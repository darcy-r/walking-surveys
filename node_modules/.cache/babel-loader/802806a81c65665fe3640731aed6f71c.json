{"ast":null,"code":"import { array, isArray, stringValue } from 'vega-util';\nimport { COLOR, OPACITY } from '../../channel';\nimport { hasConditionalValueDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { FILL_STROKE_CONFIG } from '../../mark';\nimport { getFirstDefined, isEmpty, varName } from '../../util';\nimport { applyMarkConfig, signalOrValueRef } from '../common';\nimport { formatCustomType, isCustomFormatType } from '../format';\nimport * as mixins from '../mark/encode';\nimport { STORE } from '../selection';\nexport const legendEncodeRules = {\n  symbols,\n  gradient,\n  labels,\n  entries\n};\nexport function symbols(symbolsSpec, _ref) {\n  let {\n    fieldOrDatumDef,\n    model,\n    channel,\n    legendCmpt,\n    legendType\n  } = _ref;\n\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n\n  if (legendType !== 'symbol') {\n    return undefined;\n  }\n\n  const {\n    markDef,\n    encoding,\n    config,\n    mark\n  } = model;\n  const filled = markDef.filled && mark !== 'trail';\n  let out = Object.assign(Object.assign({}, applyMarkConfig({}, model, FILL_STROKE_CONFIG)), mixins.color(model, {\n    filled\n  })); // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n\n  const symbolOpacity = (_a = legendCmpt.get('symbolOpacity')) !== null && _a !== void 0 ? _a : config.legend.symbolOpacity;\n  const symbolFillColor = (_b = legendCmpt.get('symbolFillColor')) !== null && _b !== void 0 ? _b : config.legend.symbolFillColor;\n  const symbolStrokeColor = (_c = legendCmpt.get('symbolStrokeColor')) !== null && _c !== void 0 ? _c : config.legend.symbolStrokeColor;\n  const opacity = symbolOpacity === undefined ? (_d = getMaxValue(encoding.opacity)) !== null && _d !== void 0 ? _d : markDef.opacity : undefined;\n\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || filled && channel === COLOR) {\n      delete out.fill;\n    } else {\n      if (out.fill['field']) {\n        // For others, set fill to some opaque value (or nothing if a color is already set)\n        if (symbolFillColor) {\n          delete out.fill;\n        } else {\n          out.fill = signalOrValueRef((_e = config.legend.symbolBaseFillColor) !== null && _e !== void 0 ? _e : 'black');\n          out.fillOpacity = signalOrValueRef(opacity !== null && opacity !== void 0 ? opacity : 1);\n        }\n      } else if (isArray(out.fill)) {\n        const fill = (_h = (_g = getFirstConditionValue((_f = encoding.fill) !== null && _f !== void 0 ? _f : encoding.color)) !== null && _g !== void 0 ? _g : markDef.fill) !== null && _h !== void 0 ? _h : filled && markDef.color;\n\n        if (fill) {\n          out.fill = signalOrValueRef(fill);\n        }\n      }\n    }\n  }\n\n  if (out.stroke) {\n    if (channel === 'stroke' || !filled && channel === COLOR) {\n      delete out.stroke;\n    } else {\n      if (out.stroke['field'] || symbolStrokeColor) {\n        // For others, remove stroke field\n        delete out.stroke;\n      } else if (isArray(out.stroke)) {\n        const stroke = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled ? markDef.color : undefined);\n\n        if (stroke) {\n          out.stroke = {\n            value: stroke\n          };\n        }\n      }\n    }\n  }\n\n  if (channel !== OPACITY) {\n    const condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);\n\n    if (condition) {\n      out.opacity = [Object.assign({\n        test: condition\n      }, signalOrValueRef(opacity !== null && opacity !== void 0 ? opacity : 1)), signalOrValueRef(config.legend.unselectedOpacity)];\n    } else if (opacity) {\n      out.opacity = signalOrValueRef(opacity);\n    }\n  }\n\n  out = Object.assign(Object.assign({}, out), symbolsSpec);\n  return isEmpty(out) ? undefined : out;\n}\nexport function gradient(gradientSpec, _ref2) {\n  let {\n    model,\n    legendType,\n    legendCmpt\n  } = _ref2;\n\n  var _a;\n\n  if (legendType !== 'gradient') {\n    return undefined;\n  }\n\n  const {\n    config,\n    markDef,\n    encoding\n  } = model;\n  let out = {};\n  const gradientOpacity = (_a = legendCmpt.get('gradientOpacity')) !== null && _a !== void 0 ? _a : config.legend.gradientOpacity;\n  const opacity = gradientOpacity === undefined ? getMaxValue(encoding.opacity) || markDef.opacity : undefined;\n\n  if (opacity) {\n    // only apply opacity if it is neither zero or undefined\n    out.opacity = signalOrValueRef(opacity);\n  }\n\n  out = Object.assign(Object.assign({}, out), gradientSpec);\n  return isEmpty(out) ? undefined : out;\n}\nexport function labels(specifiedlabelsSpec, _ref3) {\n  let {\n    fieldOrDatumDef,\n    model,\n    channel,\n    legendCmpt\n  } = _ref3;\n  const legend = model.legend(channel) || {};\n  const config = model.config;\n  const condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : undefined;\n  const opacity = condition ? [{\n    test: condition,\n    value: 1\n  }, {\n    value: config.legend.unselectedOpacity\n  }] : undefined;\n  const {\n    format,\n    formatType\n  } = legend;\n  const text = isCustomFormatType(formatType) ? formatCustomType({\n    fieldOrDatumDef,\n    field: 'datum.value',\n    format,\n    formatType,\n    config\n  }) : undefined;\n  const labelsSpec = Object.assign(Object.assign(Object.assign({}, opacity ? {\n    opacity\n  } : {}), text ? {\n    text\n  } : {}), specifiedlabelsSpec);\n  return isEmpty(labelsSpec) ? undefined : labelsSpec;\n}\nexport function entries(entriesSpec, _ref4) {\n  let {\n    legendCmpt\n  } = _ref4;\n  const selections = legendCmpt.get('selections');\n  return (selections === null || selections === void 0 ? void 0 : selections.length) ? Object.assign(Object.assign({}, entriesSpec), {\n    fill: {\n      value: 'transparent'\n    }\n  }) : entriesSpec;\n}\n\nfunction getMaxValue(channelDef) {\n  return getConditionValue(channelDef, (v, conditionalDef) => Math.max(v, conditionalDef.value));\n}\n\nexport function getFirstConditionValue(channelDef) {\n  return getConditionValue(channelDef, (v, conditionalDef) => {\n    return getFirstDefined(v, conditionalDef.value);\n  });\n}\n\nfunction getConditionValue(channelDef, reducer) {\n  if (hasConditionalValueDef(channelDef)) {\n    return array(channelDef.condition).reduce(reducer, channelDef.value);\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value;\n  }\n\n  return undefined;\n}\n\nfunction selectedCondition(model, legendCmpt, fieldDef) {\n  const selections = legendCmpt.get('selections');\n  if (!(selections === null || selections === void 0 ? void 0 : selections.length)) return undefined;\n  const field = stringValue(fieldDef.field);\n  return selections.map(name => {\n    const store = stringValue(varName(name) + STORE);\n    return `(!length(data(${store})) || (${name}[${field}] && indexof(${name}[${field}], datum.value) >= 0))`;\n  }).join(' || ');\n}","map":{"version":3,"mappings":"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","names":["array","isArray","stringValue","COLOR","OPACITY","hasConditionalValueDef","isFieldDef","isValueDef","FILL_STROKE_CONFIG","getFirstDefined","isEmpty","varName","applyMarkConfig","signalOrValueRef","formatCustomType","isCustomFormatType","mixins","STORE","legendEncodeRules","symbols","gradient","labels","entries","symbolsSpec","fieldOrDatumDef","model","channel","legendCmpt","legendType","undefined","markDef","encoding","config","mark","filled","out","Object","color","symbolOpacity","get","_a","legend","symbolFillColor","_b","symbolStrokeColor","_c","opacity","_d","fill","symbolBaseFillColor","_e","fillOpacity","_f","_g","_h","stroke","getFirstConditionValue","value","condition","selectedCondition","test","unselectedOpacity","gradientSpec","gradientOpacity","getMaxValue","specifiedlabelsSpec","format","formatType","text","field","labelsSpec","entriesSpec","selections","length","channelDef","getConditionValue","v","conditionalDef","Math","max","reducer","reduce","fieldDef","map","name","store","join"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/legend/encode.ts"],"sourcesContent":["import {ColorValueRef, EncodeEntry, Gradient, LegendEncode, LegendType, SignalRef, SymbolEncodeEntry} from 'vega';\nimport {array, isArray, stringValue} from 'vega-util';\nimport {COLOR, NonPositionScaleChannel, OPACITY} from '../../channel';\nimport {\n  Conditional,\n  DatumDef,\n  hasConditionalValueDef,\n  isFieldDef,\n  isValueDef,\n  TypedFieldDef,\n  Value,\n  ValueDef\n} from '../../channeldef';\nimport {Encoding} from '../../encoding';\nimport {FILL_STROKE_CONFIG} from '../../mark';\nimport {getFirstDefined, isEmpty, varName} from '../../util';\nimport {applyMarkConfig, signalOrValueRef} from '../common';\nimport {formatCustomType, isCustomFormatType} from '../format';\nimport * as mixins from '../mark/encode';\nimport {STORE} from '../selection';\nimport {UnitModel} from '../unit';\nimport {LegendComponent} from './component';\n\nexport interface LegendEncodeParams {\n  fieldOrDatumDef: TypedFieldDef<string> | DatumDef;\n  model: UnitModel;\n  channel: NonPositionScaleChannel;\n  legendCmpt: LegendComponent;\n  legendType: LegendType;\n}\n\nexport const legendEncodeRules: {\n  [part in keyof LegendEncode]?: (spec: EncodeEntry, params: LegendEncodeParams) => EncodeEntry;\n} = {\n  symbols,\n  gradient,\n  labels,\n  entries\n};\n\nexport function symbols(\n  symbolsSpec: any,\n  {fieldOrDatumDef, model, channel, legendCmpt, legendType}: LegendEncodeParams\n): SymbolEncodeEntry {\n  if (legendType !== 'symbol') {\n    return undefined;\n  }\n\n  const {markDef, encoding, config, mark} = model;\n  const filled = markDef.filled && mark !== 'trail';\n\n  let out = {\n    ...applyMarkConfig({}, model, FILL_STROKE_CONFIG),\n    ...mixins.color(model, {filled})\n  } as SymbolEncodeEntry; // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n\n  const symbolOpacity = legendCmpt.get('symbolOpacity') ?? config.legend.symbolOpacity;\n  const symbolFillColor = legendCmpt.get('symbolFillColor') ?? config.legend.symbolFillColor;\n  const symbolStrokeColor = legendCmpt.get('symbolStrokeColor') ?? config.legend.symbolStrokeColor;\n\n  const opacity = symbolOpacity === undefined ? getMaxValue(encoding.opacity) ?? markDef.opacity : undefined;\n\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || (filled && channel === COLOR)) {\n      delete out.fill;\n    } else {\n      if (out.fill['field']) {\n        // For others, set fill to some opaque value (or nothing if a color is already set)\n        if (symbolFillColor) {\n          delete out.fill;\n        } else {\n          out.fill = signalOrValueRef(config.legend.symbolBaseFillColor ?? 'black');\n          out.fillOpacity = signalOrValueRef(opacity ?? 1);\n        }\n      } else if (isArray(out.fill)) {\n        const fill =\n          getFirstConditionValue(encoding.fill ?? encoding.color) ?? markDef.fill ?? (filled && markDef.color);\n        if (fill) {\n          out.fill = signalOrValueRef(fill) as ColorValueRef;\n        }\n      }\n    }\n  }\n\n  if (out.stroke) {\n    if (channel === 'stroke' || (!filled && channel === COLOR)) {\n      delete out.stroke;\n    } else {\n      if (out.stroke['field'] || symbolStrokeColor) {\n        // For others, remove stroke field\n        delete out.stroke;\n      } else if (isArray(out.stroke)) {\n        const stroke = getFirstDefined<string | Gradient | SignalRef>(\n          getFirstConditionValue<string | Gradient>(encoding.stroke || encoding.color),\n          markDef.stroke,\n          filled ? markDef.color : undefined\n        );\n        if (stroke) {\n          out.stroke = {value: stroke} as ColorValueRef;\n        }\n      }\n    }\n  }\n\n  if (channel !== OPACITY) {\n    const condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);\n\n    if (condition) {\n      out.opacity = [\n        {test: condition, ...signalOrValueRef(opacity ?? 1)},\n        signalOrValueRef(config.legend.unselectedOpacity)\n      ];\n    } else if (opacity) {\n      out.opacity = signalOrValueRef(opacity);\n    }\n  }\n\n  out = {...out, ...symbolsSpec};\n\n  return isEmpty(out) ? undefined : out;\n}\n\nexport function gradient(gradientSpec: any, {model, legendType, legendCmpt}: LegendEncodeParams) {\n  if (legendType !== 'gradient') {\n    return undefined;\n  }\n\n  const {config, markDef, encoding} = model;\n\n  let out: SymbolEncodeEntry = {};\n\n  const gradientOpacity = legendCmpt.get('gradientOpacity') ?? config.legend.gradientOpacity;\n  const opacity = gradientOpacity === undefined ? getMaxValue(encoding.opacity) || markDef.opacity : undefined;\n  if (opacity) {\n    // only apply opacity if it is neither zero or undefined\n    out.opacity = signalOrValueRef(opacity);\n  }\n\n  out = {...out, ...gradientSpec};\n  return isEmpty(out) ? undefined : out;\n}\n\nexport function labels(specifiedlabelsSpec: any, {fieldOrDatumDef, model, channel, legendCmpt}: LegendEncodeParams) {\n  const legend = model.legend(channel) || {};\n  const config = model.config;\n\n  const condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : undefined;\n  const opacity = condition ? [{test: condition, value: 1}, {value: config.legend.unselectedOpacity}] : undefined;\n\n  const {format, formatType} = legend;\n\n  const text = isCustomFormatType(formatType)\n    ? formatCustomType({\n        fieldOrDatumDef,\n        field: 'datum.value',\n        format,\n        formatType,\n        config\n      })\n    : undefined;\n\n  const labelsSpec = {\n    ...(opacity ? {opacity} : {}),\n    ...(text ? {text} : {}),\n    ...specifiedlabelsSpec\n  };\n\n  return isEmpty(labelsSpec) ? undefined : labelsSpec;\n}\n\nexport function entries(entriesSpec: any, {legendCmpt}: LegendEncodeParams) {\n  const selections = legendCmpt.get('selections');\n  return selections?.length ? {...entriesSpec, fill: {value: 'transparent'}} : entriesSpec;\n}\n\nfunction getMaxValue(channelDef: Encoding<string>['opacity']) {\n  return getConditionValue<number>(channelDef, (v: number, conditionalDef) => Math.max(v, conditionalDef.value as any));\n}\n\nexport function getFirstConditionValue<V extends Value | Gradient>(\n  channelDef: Encoding<string>['fill' | 'stroke' | 'shape']\n): V {\n  return getConditionValue<V>(channelDef, (v: V, conditionalDef: Conditional<ValueDef<V>>) => {\n    return getFirstDefined<V>(v, conditionalDef.value);\n  });\n}\n\nfunction getConditionValue<V extends Value | Gradient>(\n  channelDef: Encoding<string>['fill' | 'stroke' | 'shape' | 'opacity'],\n  reducer: (val: V, conditionalDef: Conditional<ValueDef<V>>) => V\n): V {\n  if (hasConditionalValueDef(channelDef)) {\n    return array(channelDef.condition).reduce(reducer, channelDef.value as any);\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value as any;\n  }\n  return undefined;\n}\n\nfunction selectedCondition(model: UnitModel, legendCmpt: LegendComponent, fieldDef: TypedFieldDef<string>) {\n  const selections = legendCmpt.get('selections');\n  if (!selections?.length) return undefined;\n\n  const field = stringValue(fieldDef.field);\n  return selections\n    .map(name => {\n      const store = stringValue(varName(name) + STORE);\n      return `(!length(data(${store})) || (${name}[${field}] && indexof(${name}[${field}], datum.value) >= 0))`;\n    })\n    .join(' || ');\n}\n"]},"metadata":{},"sourceType":"module"}