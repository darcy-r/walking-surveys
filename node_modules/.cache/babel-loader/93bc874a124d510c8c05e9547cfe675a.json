{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { TUPLE, unitName } from '.';\nimport { vals } from '../../util';\nimport { BRUSH } from './interval';\nimport { TUPLE_FIELDS } from './project';\nconst point = {\n  defined: selCmpt => selCmpt.type === 'point',\n  signals: (model, selCmpt, signals) => {\n    var _a;\n\n    const name = selCmpt.name;\n    const fieldsSg = name + TUPLE_FIELDS;\n    const project = selCmpt.project;\n    const datum = '(item().isVoronoi ? datum.datum : datum)';\n    const values = project.items.map(p => {\n      const fieldDef = model.fieldDef(p.channel); // Binned fields should capture extents, for a range test against the raw field.\n\n      return (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) ? `[${datum}[${stringValue(model.vgField(p.channel, {}))}], ` + `${datum}[${stringValue(model.vgField(p.channel, {\n        binSuffix: 'end'\n      }))}]]` : `${datum}[${stringValue(p.field)}]`;\n    }).join(', '); // Only add a discrete selection to the store if a datum is present _and_\n    // the interaction isn't occurring on a group mark. This guards against\n    // polluting interactive state with invalid values in faceted displays\n    // as the group marks are also data-driven. We force the update to account\n    // for constant null states but varying toggles (e.g., shift-click in\n    // whitespace followed by a click in whitespace; the store should only\n    // be cleared on the second click).\n\n    const update = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;\n    const events = selCmpt.events;\n    const brushes = vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {}).reduce((acc, cmpt) => {\n      return cmpt.type === 'interval' ? acc.concat(cmpt.name + BRUSH) : acc;\n    }, []).map(b => `indexof(item().mark.name, '${b}') < 0`).join(' && ');\n    const test = `datum && item().mark.marktype !== 'group'${brushes ? ` && ${brushes}` : ''}`;\n    return signals.concat([{\n      name: name + TUPLE,\n      on: events ? [{\n        events,\n        update: `${test} ? {${update}: [${values}]} : null`,\n        force: true\n      }] : []\n    }]);\n  }\n};\nexport default point;","map":{"version":3,"mappings":"AACA,SAAQA,WAAR,QAA0B,WAA1B;AACA,SAA2BC,KAA3B,EAAkCC,QAAlC,QAAiD,GAAjD;AACA,SAAQC,IAAR,QAAmB,YAAnB;AACA,SAAQC,KAAR,QAAoB,YAApB;AACA,SAAQC,YAAR,QAA2B,WAA3B;AAEA,MAAMC,KAAK,GAA+B;EACxCC,OAAO,EAAEC,OAAO,IAAIA,OAAO,CAACC,IAAR,KAAiB,OADG;EAGxCC,OAAO,EAAE,CAACC,KAAD,EAAQH,OAAR,EAAiBE,OAAjB,KAA4B;;;IACnC,MAAME,IAAI,GAAGJ,OAAO,CAACI,IAArB;IACA,MAAMC,QAAQ,GAAGD,IAAI,GAAGP,YAAxB;IACA,MAAMS,OAAO,GAAGN,OAAO,CAACM,OAAxB;IACA,MAAMC,KAAK,GAAG,0CAAd;IACA,MAAMC,MAAM,GAAGF,OAAO,CAACG,KAAR,CACZC,GADY,CACRC,CAAC,IAAG;MACP,MAAMC,QAAQ,GAAGT,KAAK,CAACS,QAAN,CAAeD,CAAC,CAACE,OAAjB,CAAjB,CADO,CAEP;;MACA,OAAO,SAAQ,SAAR,YAAQ,WAAR,GAAQ,MAAR,WAAQ,CAAEC,GAAV,IACH,IAAIP,KAAK,IAAIf,WAAW,CAACW,KAAK,CAACY,OAAN,CAAcJ,CAAC,CAACE,OAAhB,EAAyB,EAAzB,CAAD,CAA8B,KAAtD,GACE,GAAGN,KAAK,IAAIf,WAAW,CAACW,KAAK,CAACY,OAAN,CAAcJ,CAAC,CAACE,OAAhB,EAAyB;QAACG,SAAS,EAAE;MAAZ,CAAzB,CAAD,CAA8C,IAFpE,GAGH,GAAGT,KAAK,IAAIf,WAAW,CAACmB,CAAC,CAACM,KAAH,CAAS,GAHpC;IAID,CARY,EASZC,IATY,CASP,IATO,CAAf,CALmC,CAgBnC;IACA;IACA;IACA;IACA;IACA;IACA;;IACA,MAAMC,MAAM,GAAG,SAASzB,QAAQ,CAACS,KAAD,CAAO,aAAaE,QAAQ,UAA5D;IAEA,MAAMe,MAAM,GAAapB,OAAO,CAACoB,MAAjC;IAEA,MAAMC,OAAO,GAAG1B,IAAI,CAAC,WAAK,CAAC2B,SAAN,CAAgBC,SAAhB,MAAyB,IAAzB,IAAyBC,aAAzB,GAAyBA,EAAzB,GAA6B,EAA9B,CAAJ,CACbC,MADa,CACN,CAACC,GAAD,EAAMC,IAAN,KAAc;MACpB,OAAOA,IAAI,CAAC1B,IAAL,KAAc,UAAd,GAA2ByB,GAAG,CAACE,MAAJ,CAAWD,IAAI,CAACvB,IAAL,GAAYR,KAAvB,CAA3B,GAA2D8B,GAAlE;IACD,CAHa,EAGX,EAHW,EAIbhB,GAJa,CAITmB,CAAC,IAAI,8BAA8BA,CAAC,QAJ3B,EAKbX,IALa,CAKR,MALQ,CAAhB;IAOA,MAAMY,IAAI,GAAG,4CAA4CT,OAAO,GAAG,OAAOA,OAAO,EAAjB,GAAsB,EAAE,EAAxF;IAEA,OAAOnB,OAAO,CAAC0B,MAAR,CAAe,CACpB;MACExB,IAAI,EAAEA,IAAI,GAAGX,KADf;MAEEsC,EAAE,EAAEX,MAAM,GACN,CACE;QACEA,MADF;QAEED,MAAM,EAAE,GAAGW,IAAI,OAAOX,MAAM,MAAMX,MAAM,WAF1C;QAGEwB,KAAK,EAAE;MAHT,CADF,CADM,GAQN;IAVN,CADoB,CAAf,CAAP;EAcD;AArDuC,CAA1C;AAwDA,eAAelC,KAAf","names":["stringValue","TUPLE","unitName","vals","BRUSH","TUPLE_FIELDS","point","defined","selCmpt","type","signals","model","name","fieldsSg","project","datum","values","items","map","p","fieldDef","channel","bin","vgField","binSuffix","field","join","update","events","brushes","component","selection","_a","reduce","acc","cmpt","concat","b","test","on","force"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/selection/point.ts"],"sourcesContent":["import {Stream} from 'vega';\nimport {stringValue} from 'vega-util';\nimport {SelectionCompiler, TUPLE, unitName} from '.';\nimport {vals} from '../../util';\nimport {BRUSH} from './interval';\nimport {TUPLE_FIELDS} from './project';\n\nconst point: SelectionCompiler<'point'> = {\n  defined: selCmpt => selCmpt.type === 'point',\n\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const fieldsSg = name + TUPLE_FIELDS;\n    const project = selCmpt.project;\n    const datum = '(item().isVoronoi ? datum.datum : datum)';\n    const values = project.items\n      .map(p => {\n        const fieldDef = model.fieldDef(p.channel);\n        // Binned fields should capture extents, for a range test against the raw field.\n        return fieldDef?.bin\n          ? `[${datum}[${stringValue(model.vgField(p.channel, {}))}], ` +\n              `${datum}[${stringValue(model.vgField(p.channel, {binSuffix: 'end'}))}]]`\n          : `${datum}[${stringValue(p.field)}]`;\n      })\n      .join(', ');\n\n    // Only add a discrete selection to the store if a datum is present _and_\n    // the interaction isn't occurring on a group mark. This guards against\n    // polluting interactive state with invalid values in faceted displays\n    // as the group marks are also data-driven. We force the update to account\n    // for constant null states but varying toggles (e.g., shift-click in\n    // whitespace followed by a click in whitespace; the store should only\n    // be cleared on the second click).\n    const update = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;\n\n    const events: Stream[] = selCmpt.events;\n\n    const brushes = vals(model.component.selection ?? {})\n      .reduce((acc, cmpt) => {\n        return cmpt.type === 'interval' ? acc.concat(cmpt.name + BRUSH) : acc;\n      }, [])\n      .map(b => `indexof(item().mark.name, '${b}') < 0`)\n      .join(' && ');\n\n    const test = `datum && item().mark.marktype !== 'group'${brushes ? ` && ${brushes}` : ''}`;\n\n    return signals.concat([\n      {\n        name: name + TUPLE,\n        on: events\n          ? [\n              {\n                events,\n                update: `${test} ? {${update}: [${values}]} : null`,\n                force: true\n              }\n            ]\n          : []\n      }\n    ]);\n  }\n};\n\nexport default point;\n"]},"metadata":{},"sourceType":"module"}