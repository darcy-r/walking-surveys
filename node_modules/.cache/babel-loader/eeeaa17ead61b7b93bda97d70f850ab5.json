{"ast":null,"code":"import * as log from '../../log';\nimport * as optimizers from './optimizers';\nimport { moveFacetDown } from './subtree';\nexport const FACET_SCALE_PREFIX = 'scale_';\nexport const MAX_OPTIMIZATION_RUNS = 5;\n/**\n * Iterates over a dataflow graph and checks whether all links are consistent.\n */\n\nexport function checkLinks(nodes) {\n  for (const node of nodes) {\n    for (const child of node.children) {\n      if (child.parent !== node) {\n        // log.error('Dataflow graph is inconsistent.', node, child);\n        return false;\n      }\n    }\n\n    if (!checkLinks(node.children)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Run the specified optimizer on the provided nodes.\n *\n * @param optimizer The optimizer instance to run.\n * @param nodes A set of nodes to optimize.\n */\n\nfunction runOptimizer(optimizer, nodes) {\n  let modified = false;\n\n  for (const node of nodes) {\n    modified = optimizer.optimize(node) || modified;\n  }\n\n  return modified;\n}\n\nfunction optimizationDataflowHelper(dataComponent, model, firstPass) {\n  let roots = dataComponent.sources;\n  let modified = false;\n  modified = runOptimizer(new optimizers.RemoveUnnecessaryOutputNodes(), roots) || modified;\n  modified = runOptimizer(new optimizers.RemoveUnnecessaryIdentifierNodes(model), roots) || modified; // remove source nodes that don't have any children because they also don't have output nodes\n\n  roots = roots.filter(r => r.numChildren() > 0);\n  modified = runOptimizer(new optimizers.RemoveUnusedSubtrees(), roots) || modified;\n  roots = roots.filter(r => r.numChildren() > 0);\n\n  if (!firstPass) {\n    // Only run these optimizations after the optimizer has moved down the facet node.\n    // With this change, we can be more aggressive in the optimizations.\n    modified = runOptimizer(new optimizers.MoveParseUp(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeBins(model), roots) || modified;\n    modified = runOptimizer(new optimizers.RemoveDuplicateTimeUnits(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeParse(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeAggregates(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeTimeUnits(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeIdenticalNodes(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeOutputs(), roots) || modified;\n  }\n\n  dataComponent.sources = roots;\n  return modified;\n}\n/**\n * Optimizes the dataflow of the passed in data component.\n */\n\n\nexport function optimizeDataflow(data, model) {\n  // check before optimizations\n  checkLinks(data.sources);\n  let firstPassCounter = 0;\n  let secondPassCounter = 0;\n\n  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n    if (!optimizationDataflowHelper(data, model, true)) {\n      break;\n    }\n\n    firstPassCounter++;\n  } // move facets down and make a copy of the subtree so that we can have scales at the top level\n\n\n  data.sources.map(moveFacetDown);\n\n  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n    if (!optimizationDataflowHelper(data, model, false)) {\n      break;\n    }\n\n    secondPassCounter++;\n  } // check after optimizations\n\n\n  checkLinks(data.sources);\n\n  if (Math.max(firstPassCounter, secondPassCounter) === MAX_OPTIMIZATION_RUNS) {\n    log.warn(`Maximum optimization runs(${MAX_OPTIMIZATION_RUNS}) reached.`);\n  }\n}","map":{"version":3,"mappings":"AACA,OAAO,KAAKA,GAAZ,MAAqB,WAArB;AAIA,OAAO,KAAKC,UAAZ,MAA4B,cAA5B;AACA,SAAQC,aAAR,QAA4B,WAA5B;AAEA,OAAO,MAAMC,kBAAkB,GAAG,QAA3B;AACP,OAAO,MAAMC,qBAAqB,GAAG,CAA9B;AAEP;;;;AAGA,OAAM,SAAUC,UAAV,CAAqBC,KAArB,EAAmD;EACvD,KAAK,MAAMC,IAAX,IAAmBD,KAAnB,EAA0B;IACxB,KAAK,MAAME,KAAX,IAAoBD,IAAI,CAACE,QAAzB,EAAmC;MACjC,IAAID,KAAK,CAACE,MAAN,KAAiBH,IAArB,EAA2B;QACzB;QACA,OAAO,KAAP;MACD;IACF;;IAED,IAAI,CAACF,UAAU,CAACE,IAAI,CAACE,QAAN,CAAf,EAAgC;MAC9B,OAAO,KAAP;IACD;EACF;;EAED,OAAO,IAAP;AACD;AAED;;;;;;;AAMA,SAASE,YAAT,CAAsBC,SAAtB,EAA4CN,KAA5C,EAAiE;EAC/D,IAAIO,QAAQ,GAAG,KAAf;;EAEA,KAAK,MAAMN,IAAX,IAAmBD,KAAnB,EAA0B;IACxBO,QAAQ,GAAGD,SAAS,CAACE,QAAV,CAAmBP,IAAnB,KAA4BM,QAAvC;EACD;;EAED,OAAOA,QAAP;AACD;;AAED,SAASE,0BAAT,CAAoCC,aAApC,EAAkEC,KAAlE,EAAgFC,SAAhF,EAAkG;EAChG,IAAIC,KAAK,GAAGH,aAAa,CAACI,OAA1B;EACA,IAAIP,QAAQ,GAAG,KAAf;EAEAA,QAAQ,GAAGF,YAAY,CAAC,IAAIV,UAAU,CAACoB,4BAAf,EAAD,EAAgDF,KAAhD,CAAZ,IAAsEN,QAAjF;EACAA,QAAQ,GAAGF,YAAY,CAAC,IAAIV,UAAU,CAACqB,gCAAf,CAAgDL,KAAhD,CAAD,EAAyDE,KAAzD,CAAZ,IAA+EN,QAA1F,CALgG,CAOhG;;EACAM,KAAK,GAAGA,KAAK,CAACI,MAAN,CAAaC,CAAC,IAAIA,CAAC,CAACC,WAAF,KAAkB,CAApC,CAAR;EAEAZ,QAAQ,GAAGF,YAAY,CAAC,IAAIV,UAAU,CAACyB,oBAAf,EAAD,EAAwCP,KAAxC,CAAZ,IAA8DN,QAAzE;EAEAM,KAAK,GAAGA,KAAK,CAACI,MAAN,CAAaC,CAAC,IAAIA,CAAC,CAACC,WAAF,KAAkB,CAApC,CAAR;;EAEA,IAAI,CAACP,SAAL,EAAgB;IACd;IACA;IACAL,QAAQ,GAAGF,YAAY,CAAC,IAAIV,UAAU,CAAC0B,WAAf,EAAD,EAA+BR,KAA/B,CAAZ,IAAqDN,QAAhE;IACAA,QAAQ,GAAGF,YAAY,CAAC,IAAIV,UAAU,CAAC2B,SAAf,CAAyBX,KAAzB,CAAD,EAAkCE,KAAlC,CAAZ,IAAwDN,QAAnE;IACAA,QAAQ,GAAGF,YAAY,CAAC,IAAIV,UAAU,CAAC4B,wBAAf,EAAD,EAA4CV,KAA5C,CAAZ,IAAkEN,QAA7E;IACAA,QAAQ,GAAGF,YAAY,CAAC,IAAIV,UAAU,CAAC6B,UAAf,EAAD,EAA8BX,KAA9B,CAAZ,IAAoDN,QAA/D;IACAA,QAAQ,GAAGF,YAAY,CAAC,IAAIV,UAAU,CAAC8B,eAAf,EAAD,EAAmCZ,KAAnC,CAAZ,IAAyDN,QAApE;IACAA,QAAQ,GAAGF,YAAY,CAAC,IAAIV,UAAU,CAAC+B,cAAf,EAAD,EAAkCb,KAAlC,CAAZ,IAAwDN,QAAnE;IACAA,QAAQ,GAAGF,YAAY,CAAC,IAAIV,UAAU,CAACgC,mBAAf,EAAD,EAAuCd,KAAvC,CAAZ,IAA6DN,QAAxE;IACAA,QAAQ,GAAGF,YAAY,CAAC,IAAIV,UAAU,CAACiC,YAAf,EAAD,EAAgCf,KAAhC,CAAZ,IAAsDN,QAAjE;EACD;;EAEDG,aAAa,CAACI,OAAd,GAAwBD,KAAxB;EAEA,OAAON,QAAP;AACD;AAED;;;;;AAGA,OAAM,SAAUsB,gBAAV,CAA2BC,IAA3B,EAAgDnB,KAAhD,EAA4D;EAChE;EACAZ,UAAU,CAAC+B,IAAI,CAAChB,OAAN,CAAV;EAEA,IAAIiB,gBAAgB,GAAG,CAAvB;EACA,IAAIC,iBAAiB,GAAG,CAAxB;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnC,qBAApB,EAA2CmC,CAAC,EAA5C,EAAgD;IAC9C,IAAI,CAACxB,0BAA0B,CAACqB,IAAD,EAAOnB,KAAP,EAAc,IAAd,CAA/B,EAAoD;MAClD;IACD;;IACDoB,gBAAgB;EACjB,CAZ+D,CAchE;;;EACAD,IAAI,CAAChB,OAAL,CAAaoB,GAAb,CAAiBtC,aAAjB;;EAEA,KAAK,IAAIqC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnC,qBAApB,EAA2CmC,CAAC,EAA5C,EAAgD;IAC9C,IAAI,CAACxB,0BAA0B,CAACqB,IAAD,EAAOnB,KAAP,EAAc,KAAd,CAA/B,EAAqD;MACnD;IACD;;IACDqB,iBAAiB;EAClB,CAtB+D,CAwBhE;;;EACAjC,UAAU,CAAC+B,IAAI,CAAChB,OAAN,CAAV;;EAEA,IAAIqB,IAAI,CAACC,GAAL,CAASL,gBAAT,EAA2BC,iBAA3B,MAAkDlC,qBAAtD,EAA6E;IAC3EJ,GAAG,CAAC2C,IAAJ,CAAS,6BAA6BvC,qBAAqB,YAA3D;EACD;AACF","names":["log","optimizers","moveFacetDown","FACET_SCALE_PREFIX","MAX_OPTIMIZATION_RUNS","checkLinks","nodes","node","child","children","parent","runOptimizer","optimizer","modified","optimize","optimizationDataflowHelper","dataComponent","model","firstPass","roots","sources","RemoveUnnecessaryOutputNodes","RemoveUnnecessaryIdentifierNodes","filter","r","numChildren","RemoveUnusedSubtrees","MoveParseUp","MergeBins","RemoveDuplicateTimeUnits","MergeParse","MergeAggregates","MergeTimeUnits","MergeIdenticalNodes","MergeOutputs","optimizeDataflow","data","firstPassCounter","secondPassCounter","i","map","Math","max","warn"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/data/optimize.ts"],"sourcesContent":["import {DataComponent} from '.';\nimport * as log from '../../log';\nimport {Model} from '../model';\nimport {DataFlowNode} from './dataflow';\nimport {Optimizer} from './optimizer';\nimport * as optimizers from './optimizers';\nimport {moveFacetDown} from './subtree';\n\nexport const FACET_SCALE_PREFIX = 'scale_';\nexport const MAX_OPTIMIZATION_RUNS = 5;\n\n/**\n * Iterates over a dataflow graph and checks whether all links are consistent.\n */\nexport function checkLinks(nodes: readonly DataFlowNode[]): boolean {\n  for (const node of nodes) {\n    for (const child of node.children) {\n      if (child.parent !== node) {\n        // log.error('Dataflow graph is inconsistent.', node, child);\n        return false;\n      }\n    }\n\n    if (!checkLinks(node.children)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Run the specified optimizer on the provided nodes.\n *\n * @param optimizer The optimizer instance to run.\n * @param nodes A set of nodes to optimize.\n */\nfunction runOptimizer(optimizer: Optimizer, nodes: DataFlowNode[]): boolean {\n  let modified = false;\n\n  for (const node of nodes) {\n    modified = optimizer.optimize(node) || modified;\n  }\n\n  return modified;\n}\n\nfunction optimizationDataflowHelper(dataComponent: DataComponent, model: Model, firstPass: boolean) {\n  let roots = dataComponent.sources;\n  let modified = false;\n\n  modified = runOptimizer(new optimizers.RemoveUnnecessaryOutputNodes(), roots) || modified;\n  modified = runOptimizer(new optimizers.RemoveUnnecessaryIdentifierNodes(model), roots) || modified;\n\n  // remove source nodes that don't have any children because they also don't have output nodes\n  roots = roots.filter(r => r.numChildren() > 0);\n\n  modified = runOptimizer(new optimizers.RemoveUnusedSubtrees(), roots) || modified;\n\n  roots = roots.filter(r => r.numChildren() > 0);\n\n  if (!firstPass) {\n    // Only run these optimizations after the optimizer has moved down the facet node.\n    // With this change, we can be more aggressive in the optimizations.\n    modified = runOptimizer(new optimizers.MoveParseUp(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeBins(model), roots) || modified;\n    modified = runOptimizer(new optimizers.RemoveDuplicateTimeUnits(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeParse(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeAggregates(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeTimeUnits(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeIdenticalNodes(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeOutputs(), roots) || modified;\n  }\n\n  dataComponent.sources = roots;\n\n  return modified;\n}\n\n/**\n * Optimizes the dataflow of the passed in data component.\n */\nexport function optimizeDataflow(data: DataComponent, model: Model) {\n  // check before optimizations\n  checkLinks(data.sources);\n\n  let firstPassCounter = 0;\n  let secondPassCounter = 0;\n\n  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n    if (!optimizationDataflowHelper(data, model, true)) {\n      break;\n    }\n    firstPassCounter++;\n  }\n\n  // move facets down and make a copy of the subtree so that we can have scales at the top level\n  data.sources.map(moveFacetDown);\n\n  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n    if (!optimizationDataflowHelper(data, model, false)) {\n      break;\n    }\n    secondPassCounter++;\n  }\n\n  // check after optimizations\n  checkLinks(data.sources);\n\n  if (Math.max(firstPassCounter, secondPassCounter) === MAX_OPTIMIZATION_RUNS) {\n    log.warn(`Maximum optimization runs(${MAX_OPTIMIZATION_RUNS}) reached.`);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}