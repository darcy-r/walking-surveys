{"ast":null,"code":"import { regressionLoess, sampleCurve, regressionLinear, regressionLog, regressionExp, regressionPow, regressionQuad, regressionPoly } from 'vega-statistics';\nimport { Transform, ingest } from 'vega-dataflow';\nimport { inherits, accessorName, hasOwnProperty, error, extent } from 'vega-util';\n\nfunction partition(data, groupby) {\n  var groups = [],\n      get = function (f) {\n    return f(t);\n  },\n      map,\n      i,\n      n,\n      t,\n      k,\n      g; // partition data points into stack groups\n\n\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n\n      if (!g) {\n        map[k] = g = [];\n        g.dims = k;\n        groups.push(g);\n      }\n\n      g.push(t);\n    }\n  }\n\n  return groups;\n}\n/**\n * Compute locally-weighted regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\n */\n\n\nfunction Loess(params) {\n  Transform.call(this, null, params);\n}\n\nLoess.Definition = {\n  'type': 'Loess',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'default': 0.3\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Loess, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition(source, _.groupby),\n            names = (_.groupby || []).map(accessorName),\n            m = names.length,\n            as = _.as || [accessorName(_.x), accessorName(_.y)],\n            values = [];\n      groups.forEach(g => {\n        regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {\n          const t = {};\n\n          for (let i = 0; i < m; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n\n          t[as[0]] = p[0];\n          t[as[1]] = p[1];\n          values.push(ingest(t));\n        });\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n\n});\nconst Methods = {\n  linear: regressionLinear,\n  log: regressionLog,\n  exp: regressionExp,\n  pow: regressionPow,\n  quad: regressionQuad,\n  poly: regressionPoly\n};\n\nconst degreesOfFreedom = (method, order) => method === 'poly' ? order : method === 'quad' ? 2 : 1;\n/**\n * Compute regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {string} [params.method='linear'] - The regression method to apply.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.\n * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.\n */\n\n\nfunction Regression(params) {\n  Transform.call(this, null, params);\n}\n\nRegression.Definition = {\n  'type': 'Regression',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'method',\n    'type': 'string',\n    'default': 'linear',\n    'values': Object.keys(Methods)\n  }, {\n    'name': 'order',\n    'type': 'number',\n    'default': 3\n  }, {\n    'name': 'extent',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'params',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Regression, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition(source, _.groupby),\n            names = (_.groupby || []).map(accessorName),\n            method = _.method || 'linear',\n            order = _.order || 3,\n            dof = degreesOfFreedom(method, order),\n            as = _.as || [accessorName(_.x), accessorName(_.y)],\n            fit = Methods[method],\n            values = [];\n      let domain = _.extent;\n\n      if (!hasOwnProperty(Methods, method)) {\n        error('Invalid regression method: ' + method);\n      }\n\n      if (domain != null) {\n        if (method === 'log' && domain[0] <= 0) {\n          pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');\n          domain = null;\n        }\n      }\n\n      groups.forEach(g => {\n        const n = g.length;\n\n        if (n <= dof) {\n          pulse.dataflow.warn('Skipping regression with more parameters than data points.');\n          return;\n        }\n\n        const model = fit(g, _.x, _.y, order);\n\n        if (_.params) {\n          // if parameter vectors requested return those\n          values.push(ingest({\n            keys: g.dims,\n            coef: model.coef,\n            rSquared: model.rSquared\n          }));\n          return;\n        }\n\n        const dom = domain || extent(g, _.x),\n              add = p => {\n          const t = {};\n\n          for (let i = 0; i < names.length; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n\n          t[as[0]] = p[0];\n          t[as[1]] = p[1];\n          values.push(ingest(t));\n        };\n\n        if (method === 'linear') {\n          // for linear regression we only need the end points\n          dom.forEach(x => add([x, model.predict(x)]));\n        } else {\n          // otherwise return trend line sample points\n          sampleCurve(model.predict, dom, 25, 200).forEach(add);\n        }\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n\n});\nexport { Loess as loess, Regression as regression };","map":{"version":3,"names":["regressionLoess","sampleCurve","regressionLinear","regressionLog","regressionExp","regressionPow","regressionQuad","regressionPoly","Transform","ingest","inherits","accessorName","hasOwnProperty","error","extent","partition","data","groupby","groups","get","f","t","map","i","n","k","g","push","length","dims","Loess","params","call","Definition","transform","_","pulse","out","fork","NO_SOURCE","NO_FIELDS","value","changed","modified","source","materialize","SOURCE","names","m","as","x","y","values","forEach","bandwidth","p","rem","add","Methods","linear","log","exp","pow","quad","poly","degreesOfFreedom","method","order","Regression","Object","keys","dof","fit","domain","dataflow","warn","model","coef","rSquared","dom","predict","loess","regression"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-regression/build/vega-regression.module.js"],"sourcesContent":["import { regressionLoess, sampleCurve, regressionLinear, regressionLog, regressionExp, regressionPow, regressionQuad, regressionPoly } from 'vega-statistics';\nimport { Transform, ingest } from 'vega-dataflow';\nimport { inherits, accessorName, hasOwnProperty, error, extent } from 'vega-util';\n\nfunction partition (data, groupby) {\n  var groups = [],\n      get = function (f) {\n    return f(t);\n  },\n      map,\n      i,\n      n,\n      t,\n      k,\n      g; // partition data points into stack groups\n\n\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n\n      if (!g) {\n        map[k] = g = [];\n        g.dims = k;\n        groups.push(g);\n      }\n\n      g.push(t);\n    }\n  }\n\n  return groups;\n}\n\n/**\n * Compute locally-weighted regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\n */\n\nfunction Loess(params) {\n  Transform.call(this, null, params);\n}\nLoess.Definition = {\n  'type': 'Loess',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'default': 0.3\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Loess, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition(source, _.groupby),\n            names = (_.groupby || []).map(accessorName),\n            m = names.length,\n            as = _.as || [accessorName(_.x), accessorName(_.y)],\n            values = [];\n      groups.forEach(g => {\n        regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {\n          const t = {};\n\n          for (let i = 0; i < m; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n\n          t[as[0]] = p[0];\n          t[as[1]] = p[1];\n          values.push(ingest(t));\n        });\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n\n});\n\nconst Methods = {\n  linear: regressionLinear,\n  log: regressionLog,\n  exp: regressionExp,\n  pow: regressionPow,\n  quad: regressionQuad,\n  poly: regressionPoly\n};\n\nconst degreesOfFreedom = (method, order) => method === 'poly' ? order : method === 'quad' ? 2 : 1;\n/**\n * Compute regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {string} [params.method='linear'] - The regression method to apply.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.\n * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.\n */\n\n\nfunction Regression(params) {\n  Transform.call(this, null, params);\n}\nRegression.Definition = {\n  'type': 'Regression',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'method',\n    'type': 'string',\n    'default': 'linear',\n    'values': Object.keys(Methods)\n  }, {\n    'name': 'order',\n    'type': 'number',\n    'default': 3\n  }, {\n    'name': 'extent',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'params',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Regression, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition(source, _.groupby),\n            names = (_.groupby || []).map(accessorName),\n            method = _.method || 'linear',\n            order = _.order || 3,\n            dof = degreesOfFreedom(method, order),\n            as = _.as || [accessorName(_.x), accessorName(_.y)],\n            fit = Methods[method],\n            values = [];\n      let domain = _.extent;\n\n      if (!hasOwnProperty(Methods, method)) {\n        error('Invalid regression method: ' + method);\n      }\n\n      if (domain != null) {\n        if (method === 'log' && domain[0] <= 0) {\n          pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');\n          domain = null;\n        }\n      }\n\n      groups.forEach(g => {\n        const n = g.length;\n\n        if (n <= dof) {\n          pulse.dataflow.warn('Skipping regression with more parameters than data points.');\n          return;\n        }\n\n        const model = fit(g, _.x, _.y, order);\n\n        if (_.params) {\n          // if parameter vectors requested return those\n          values.push(ingest({\n            keys: g.dims,\n            coef: model.coef,\n            rSquared: model.rSquared\n          }));\n          return;\n        }\n\n        const dom = domain || extent(g, _.x),\n              add = p => {\n          const t = {};\n\n          for (let i = 0; i < names.length; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n\n          t[as[0]] = p[0];\n          t[as[1]] = p[1];\n          values.push(ingest(t));\n        };\n\n        if (method === 'linear') {\n          // for linear regression we only need the end points\n          dom.forEach(x => add([x, model.predict(x)]));\n        } else {\n          // otherwise return trend line sample points\n          sampleCurve(model.predict, dom, 25, 200).forEach(add);\n        }\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n\n});\n\nexport { Loess as loess, Regression as regression };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}