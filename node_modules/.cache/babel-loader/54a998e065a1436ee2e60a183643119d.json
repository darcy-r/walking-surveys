{"ast":null,"code":"import { getMainChannelFromOffsetChannel, isXorYOffset, SCALE_CHANNELS, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { channelHasNestedOffsetScale } from '../../encoding';\nimport * as log from '../../log';\nimport { GEOSHAPE } from '../../mark';\nimport { NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES, scaleCompatible, scaleTypePrecedence } from '../../scale';\nimport { GEOJSON } from '../../type';\nimport { keys } from '../../util';\nimport { isUnitModel } from '../model';\nimport { defaultScaleResolve } from '../resolve';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { ScaleComponent } from './component';\nimport { parseScaleDomain } from './domain';\nimport { parseScaleProperty, parseScaleRange } from './properties';\nimport { scaleType } from './type';\nexport function parseScales(model) {\n  let {\n    ignoreRange\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  parseScaleCore(model);\n  parseScaleDomain(model);\n\n  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {\n    parseScaleProperty(model, prop);\n  }\n\n  if (!ignoreRange) {\n    // range depends on zero\n    parseScaleRange(model);\n  }\n}\nexport function parseScaleCore(model) {\n  if (isUnitModel(model)) {\n    model.component.scales = parseUnitScaleCore(model);\n  } else {\n    model.component.scales = parseNonUnitScaleCore(model);\n  }\n}\n/**\n * Parse scales for all channels of a model.\n */\n\nfunction parseUnitScaleCore(model) {\n  const {\n    encoding,\n    mark,\n    markDef\n  } = model;\n  const scaleComponents = {};\n\n  for (const channel of SCALE_CHANNELS) {\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]); // must be typed def to have scale\n    // Don't generate scale for shape of geoshape\n\n    if (fieldOrDatumDef && mark === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {\n      continue;\n    }\n\n    let specifiedScale = fieldOrDatumDef && fieldOrDatumDef['scale'];\n\n    if (isXorYOffset(channel)) {\n      const mainChannel = getMainChannelFromOffsetChannel(channel);\n\n      if (!channelHasNestedOffsetScale(encoding, mainChannel)) {\n        // Don't generate scale when the offset encoding shouldn't yield a nested scale\n        if (specifiedScale) {\n          log.warn(log.message.offsetEncodingScaleIgnored(channel));\n        }\n\n        continue;\n      }\n    }\n\n    if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {\n      specifiedScale !== null && specifiedScale !== void 0 ? specifiedScale : specifiedScale = {};\n      const hasNestedOffsetScale = channelHasNestedOffsetScale(encoding, channel);\n      const sType = scaleType(specifiedScale, channel, fieldOrDatumDef, markDef, hasNestedOffsetScale);\n      scaleComponents[channel] = new ScaleComponent(model.scaleName(`${channel}`, true), {\n        value: sType,\n        explicit: specifiedScale.type === sType\n      });\n    }\n  }\n\n  return scaleComponents;\n}\n\nconst scaleTypeTieBreaker = tieBreakByComparing((st1, st2) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2));\n\nfunction parseNonUnitScaleCore(model) {\n  var _a;\n\n  var _b;\n\n  const scaleComponents = model.component.scales = {};\n  const scaleTypeWithExplicitIndex = {};\n  const resolve = model.component.resolve; // Parse each child scale and determine if a particular channel can be merged.\n\n  for (const child of model.children) {\n    parseScaleCore(child); // Instead of always merging right away -- check if it is compatible to merge first!\n\n    for (const channel of keys(child.component.scales)) {\n      // if resolve is undefined, set default first\n      (_a = (_b = resolve.scale)[channel]) !== null && _a !== void 0 ? _a : _b[channel] = defaultScaleResolve(channel, model);\n\n      if (resolve.scale[channel] === 'shared') {\n        const explicitScaleType = scaleTypeWithExplicitIndex[channel];\n        const childScaleType = child.component.scales[channel].getWithExplicit('type');\n\n        if (explicitScaleType) {\n          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n            // merge scale component if type are compatible\n            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, 'type', 'scale', scaleTypeTieBreaker);\n          } else {\n            // Otherwise, update conflicting channel to be independent\n            resolve.scale[channel] = 'independent'; // Remove from the index so they don't get merged\n\n            delete scaleTypeWithExplicitIndex[channel];\n          }\n        } else {\n          scaleTypeWithExplicitIndex[channel] = childScaleType;\n        }\n      }\n    }\n  } // Merge each channel listed in the index\n\n\n  for (const channel of keys(scaleTypeWithExplicitIndex)) {\n    // Create new merged scale component\n    const name = model.scaleName(channel, true);\n    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n    scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit); // rename each child and mark them as merged\n\n    for (const child of model.children) {\n      const childScale = child.component.scales[channel];\n\n      if (childScale) {\n        child.renameScale(childScale.get('name'), name);\n        childScale.merged = true;\n      }\n    }\n  }\n\n  return scaleComponents;\n}","map":{"version":3,"mappings":"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","names":["getMainChannelFromOffsetChannel","isXorYOffset","SCALE_CHANNELS","SHAPE","getFieldOrDatumDef","channelHasNestedOffsetScale","log","GEOSHAPE","NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES","scaleCompatible","scaleTypePrecedence","GEOJSON","keys","isUnitModel","defaultScaleResolve","mergeValuesWithExplicit","tieBreakByComparing","ScaleComponent","parseScaleDomain","parseScaleProperty","parseScaleRange","scaleType","parseScales","model","ignoreRange","parseScaleCore","prop","component","scales","parseUnitScaleCore","parseNonUnitScaleCore","encoding","mark","markDef","scaleComponents","channel","fieldOrDatumDef","type","specifiedScale","mainChannel","warn","message","offsetEncodingScaleIgnored","hasNestedOffsetScale","sType","scaleName","value","explicit","scaleTypeTieBreaker","st1","st2","scaleTypeWithExplicitIndex","resolve","child","children","scale","_a","_b","explicitScaleType","childScaleType","getWithExplicit","name","typeWithExplicit","childScale","renameScale","get","merged"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/scale/parse.ts"],"sourcesContent":["import {getMainChannelFromOffsetChannel, isXorYOffset, ScaleChannel, SCALE_CHANNELS, SHAPE} from '../../channel';\nimport {getFieldOrDatumDef, ScaleDatumDef, TypedFieldDef} from '../../channeldef';\nimport {channelHasNestedOffsetScale} from '../../encoding';\nimport * as log from '../../log';\nimport {GEOSHAPE} from '../../mark';\nimport {\n  NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES,\n  scaleCompatible,\n  ScaleType,\n  scaleTypePrecedence\n} from '../../scale';\nimport {GEOJSON} from '../../type';\nimport {keys} from '../../util';\nimport {VgScale} from '../../vega.schema';\nimport {isUnitModel, Model} from '../model';\nimport {defaultScaleResolve} from '../resolve';\nimport {Explicit, mergeValuesWithExplicit, tieBreakByComparing} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponent, ScaleComponentIndex} from './component';\nimport {parseScaleDomain} from './domain';\nimport {parseScaleProperty, parseScaleRange} from './properties';\nimport {scaleType} from './type';\n\nexport function parseScales(model: Model, {ignoreRange}: {ignoreRange?: boolean} = {}) {\n  parseScaleCore(model);\n  parseScaleDomain(model);\n  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {\n    parseScaleProperty(model, prop);\n  }\n  if (!ignoreRange) {\n    // range depends on zero\n    parseScaleRange(model);\n  }\n}\n\nexport function parseScaleCore(model: Model) {\n  if (isUnitModel(model)) {\n    model.component.scales = parseUnitScaleCore(model);\n  } else {\n    model.component.scales = parseNonUnitScaleCore(model);\n  }\n}\n\n/**\n * Parse scales for all channels of a model.\n */\nfunction parseUnitScaleCore(model: UnitModel): ScaleComponentIndex {\n  const {encoding, mark, markDef} = model;\n  const scaleComponents: ScaleComponentIndex = {};\n  for (const channel of SCALE_CHANNELS) {\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) as TypedFieldDef<string> | ScaleDatumDef; // must be typed def to have scale\n\n    // Don't generate scale for shape of geoshape\n    if (fieldOrDatumDef && mark === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {\n      continue;\n    }\n\n    let specifiedScale = fieldOrDatumDef && fieldOrDatumDef['scale'];\n    if (isXorYOffset(channel)) {\n      const mainChannel = getMainChannelFromOffsetChannel(channel);\n      if (!channelHasNestedOffsetScale(encoding, mainChannel)) {\n        // Don't generate scale when the offset encoding shouldn't yield a nested scale\n        if (specifiedScale) {\n          log.warn(log.message.offsetEncodingScaleIgnored(channel));\n        }\n        continue;\n      }\n    }\n\n    if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {\n      specifiedScale ??= {};\n      const hasNestedOffsetScale = channelHasNestedOffsetScale(encoding, channel);\n\n      const sType = scaleType(specifiedScale, channel, fieldOrDatumDef, markDef, hasNestedOffsetScale);\n      scaleComponents[channel] = new ScaleComponent(model.scaleName(`${channel}`, true), {\n        value: sType,\n        explicit: specifiedScale.type === sType\n      });\n    }\n  }\n  return scaleComponents;\n}\n\nconst scaleTypeTieBreaker = tieBreakByComparing(\n  (st1: ScaleType, st2: ScaleType) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2)\n);\n\nfunction parseNonUnitScaleCore(model: Model) {\n  const scaleComponents: ScaleComponentIndex = (model.component.scales = {});\n\n  const scaleTypeWithExplicitIndex: Partial<Record<ScaleChannel, Explicit<ScaleType>>> = {};\n  const resolve = model.component.resolve;\n\n  // Parse each child scale and determine if a particular channel can be merged.\n  for (const child of model.children) {\n    parseScaleCore(child);\n\n    // Instead of always merging right away -- check if it is compatible to merge first!\n    for (const channel of keys(child.component.scales)) {\n      // if resolve is undefined, set default first\n      resolve.scale[channel] ??= defaultScaleResolve(channel, model);\n\n      if (resolve.scale[channel] === 'shared') {\n        const explicitScaleType = scaleTypeWithExplicitIndex[channel];\n        const childScaleType = child.component.scales[channel].getWithExplicit('type');\n\n        if (explicitScaleType) {\n          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n            // merge scale component if type are compatible\n            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit<VgScale, ScaleType>(\n              explicitScaleType,\n              childScaleType,\n              'type',\n              'scale',\n              scaleTypeTieBreaker\n            );\n          } else {\n            // Otherwise, update conflicting channel to be independent\n            resolve.scale[channel] = 'independent';\n            // Remove from the index so they don't get merged\n            delete scaleTypeWithExplicitIndex[channel];\n          }\n        } else {\n          scaleTypeWithExplicitIndex[channel] = childScaleType;\n        }\n      }\n    }\n  }\n\n  // Merge each channel listed in the index\n  for (const channel of keys(scaleTypeWithExplicitIndex)) {\n    // Create new merged scale component\n    const name = model.scaleName(channel, true);\n    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n    scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit);\n\n    // rename each child and mark them as merged\n    for (const child of model.children) {\n      const childScale = child.component.scales[channel];\n      if (childScale) {\n        child.renameScale(childScale.get('name'), name);\n        childScale.merged = true;\n      }\n    }\n  }\n\n  return scaleComponents;\n}\n"]},"metadata":{},"sourceType":"module"}