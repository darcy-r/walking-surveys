{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { array, stringValue } from 'vega-util';\nimport { STORE, TUPLE, unitName } from '.';\nimport { X, Y } from '../../channel';\nimport { warn } from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { keys } from '../../util';\nimport { assembleInit } from './assemble';\nimport { TUPLE_FIELDS } from './project';\nimport scales from './scales';\nexport const BRUSH = '_brush';\nexport const SCALE_TRIGGER = '_scale_trigger';\nconst interval = {\n  defined: selCmpt => selCmpt.type === 'interval',\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const fieldsSg = name + TUPLE_FIELDS;\n    const hasScales = scales.defined(selCmpt);\n    const init = selCmpt.init ? selCmpt.init[0] : null;\n    const dataSignals = [];\n    const scaleTriggers = [];\n\n    if (selCmpt.translate && !hasScales) {\n      const filterExpr = `!event.item || event.item.mark.name !== ${stringValue(name + BRUSH)}`;\n      events(selCmpt, (on, evt) => {\n        var _a;\n\n        var _b;\n\n        const filters = array((_a = (_b = evt.between[0]).filter) !== null && _a !== void 0 ? _a : _b.filter = []);\n\n        if (!filters.includes(filterExpr)) {\n          filters.push(filterExpr);\n        }\n\n        return on;\n      });\n    }\n\n    selCmpt.project.items.forEach((proj, i) => {\n      const channel = proj.channel;\n\n      if (channel !== X && channel !== Y) {\n        warn('Interval selections only support x and y encoding channels.');\n        return;\n      }\n\n      const val = init ? init[i] : null;\n      const cs = channelSignals(model, selCmpt, proj, val);\n      const dname = proj.signals.data;\n      const vname = proj.signals.visual;\n      const scaleName = stringValue(model.scaleName(channel));\n      const scaleType = model.getScaleComponent(channel).get('type');\n      const toNum = hasContinuousDomain(scaleType) ? '+' : '';\n      signals.push(...cs);\n      dataSignals.push(dname);\n      scaleTriggers.push({\n        scaleName: model.scaleName(channel),\n        expr: `(!isArray(${dname}) || ` + `(${toNum}invert(${scaleName}, ${vname})[0] === ${toNum}${dname}[0] && ` + `${toNum}invert(${scaleName}, ${vname})[1] === ${toNum}${dname}[1]))`\n      });\n    }); // Proxy scale reactions to ensure that an infinite loop doesn't occur\n    // when an interval selection filter touches the scale.\n\n    if (!hasScales && scaleTriggers.length) {\n      signals.push({\n        name: name + SCALE_TRIGGER,\n        value: {},\n        on: [{\n          events: scaleTriggers.map(t => ({\n            scale: t.scaleName\n          })),\n          update: `${scaleTriggers.map(t => t.expr).join(' && ')} ? ${name + SCALE_TRIGGER} : {}`\n        }]\n      });\n    } // Only add an interval to the store if it has valid data extents. Data extents\n    // are set to null if pixel extents are equal to account for intervals over\n    // ordinal/nominal domains which, when inverted, will still produce a valid datum.\n\n\n    const update = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;\n    return signals.concat(Object.assign(Object.assign({\n      name: name + TUPLE\n    }, init ? {\n      init: `{${update}: ${assembleInit(init)}}`\n    } : {}), dataSignals.length ? {\n      on: [{\n        events: [{\n          signal: dataSignals.join(' || ')\n        }],\n        update: `${dataSignals.join(' && ')} ? {${update}: [${dataSignals}]} : null`\n      }]\n    } : {}));\n  },\n  marks: (model, selCmpt, marks) => {\n    const name = selCmpt.name;\n    const {\n      x,\n      y\n    } = selCmpt.project.hasChannel;\n    const xvname = x === null || x === void 0 ? void 0 : x.signals.visual;\n    const yvname = y === null || y === void 0 ? void 0 : y.signals.visual;\n    const store = `data(${stringValue(selCmpt.name + STORE)})`; // Do not add a brush if we're binding to scales\n    // or we don't have a valid interval projection\n\n    if (scales.defined(selCmpt) || !x && !y) {\n      return marks;\n    }\n\n    const update = {\n      x: x !== undefined ? {\n        signal: `${xvname}[0]`\n      } : {\n        value: 0\n      },\n      y: y !== undefined ? {\n        signal: `${yvname}[0]`\n      } : {\n        value: 0\n      },\n      x2: x !== undefined ? {\n        signal: `${xvname}[1]`\n      } : {\n        field: {\n          group: 'width'\n        }\n      },\n      y2: y !== undefined ? {\n        signal: `${yvname}[1]`\n      } : {\n        field: {\n          group: 'height'\n        }\n      }\n    }; // If the selection is resolved to global, only a single interval is in\n    // the store. Wrap brush mark's encodings with a production rule to test\n    // this based on the `unit` property. Hide the brush mark if it corresponds\n    // to a unit different from the one in the store.\n\n    if (selCmpt.resolve === 'global') {\n      for (const key of keys(update)) {\n        update[key] = [Object.assign({\n          test: `${store}.length && ${store}[0].unit === ${unitName(model)}`\n        }, update[key]), {\n          value: 0\n        }];\n      }\n    } // Two brush marks ensure that fill colors and other aesthetic choices do\n    // not interefere with the core marks, but that the brushed region can still\n    // be interacted with (e.g., dragging it around).\n\n\n    const _a = selCmpt.mark,\n          {\n      fill,\n      fillOpacity,\n      cursor\n    } = _a,\n          stroke = __rest(_a, [\"fill\", \"fillOpacity\", \"cursor\"]);\n\n    const vgStroke = keys(stroke).reduce((def, k) => {\n      def[k] = [{\n        test: [x !== undefined && `${xvname}[0] !== ${xvname}[1]`, y !== undefined && `${yvname}[0] !== ${yvname}[1]`].filter(t => t).join(' && '),\n        value: stroke[k]\n      }, {\n        value: null\n      }];\n      return def;\n    }, {});\n    return [{\n      name: `${name + BRUSH}_bg`,\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: {\n          fill: {\n            value: fill\n          },\n          fillOpacity: {\n            value: fillOpacity\n          }\n        },\n        update\n      }\n    }, ...marks, {\n      name: name + BRUSH,\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: Object.assign(Object.assign({}, cursor ? {\n          cursor: {\n            value: cursor\n          }\n        } : {}), {\n          fill: {\n            value: 'transparent'\n          }\n        }),\n        update: Object.assign(Object.assign({}, update), vgStroke)\n      }\n    }];\n  }\n};\nexport default interval;\n/**\n * Returns the visual and data signals for an interval selection.\n */\n\nfunction channelSignals(model, selCmpt, proj, init) {\n  const channel = proj.channel;\n  const vname = proj.signals.visual;\n  const dname = proj.signals.data;\n  const hasScales = scales.defined(selCmpt);\n  const scaleName = stringValue(model.scaleName(channel));\n  const scale = model.getScaleComponent(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n\n  const scaled = str => `scale(${scaleName}, ${str})`;\n\n  const size = model.getSizeSignalRef(channel === X ? 'width' : 'height').signal;\n  const coord = `${channel}(unit)`;\n  const on = events(selCmpt, (def, evt) => {\n    return [...def, {\n      events: evt.between[0],\n      update: `[${coord}, ${coord}]`\n    }, {\n      events: evt,\n      update: `[${vname}[0], clamp(${coord}, 0, ${size})]`\n    } // Brush End\n    ];\n  }); // React to pan/zooms of continuous scales. Non-continuous scales\n  // (band, point) cannot be pan/zoomed and any other changes\n  // to their domains (e.g., filtering) should clear the brushes.\n\n  on.push({\n    events: {\n      signal: selCmpt.name + SCALE_TRIGGER\n    },\n    update: hasContinuousDomain(scaleType) ? `[${scaled(`${dname}[0]`)}, ${scaled(`${dname}[1]`)}]` : `[0, 0]`\n  });\n  return hasScales ? [{\n    name: dname,\n    on: []\n  }] : [Object.assign(Object.assign({\n    name: vname\n  }, init ? {\n    init: assembleInit(init, true, scaled)\n  } : {\n    value: []\n  }), {\n    on\n  }), Object.assign(Object.assign({\n    name: dname\n  }, init ? {\n    init: assembleInit(init)\n  } : {}), {\n    on: [{\n      events: {\n        signal: vname\n      },\n      update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`\n    }]\n  })];\n}\n\nfunction events(selCmpt, cb) {\n  return selCmpt.events.reduce((on, evt) => {\n    if (!evt.between) {\n      warn(`${evt} is not an ordered event stream for interval selections.`);\n      return on;\n    }\n\n    return cb(on, evt);\n  }, []);\n}","map":{"version":3,"mappings":"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","names":["array","stringValue","STORE","TUPLE","unitName","X","Y","warn","hasContinuousDomain","keys","assembleInit","TUPLE_FIELDS","scales","BRUSH","SCALE_TRIGGER","interval","defined","selCmpt","type","signals","model","name","fieldsSg","hasScales","init","dataSignals","scaleTriggers","translate","filterExpr","events","on","evt","filters","between","filter","_a","_b","includes","push","project","items","forEach","proj","i","channel","val","cs","channelSignals","dname","data","vname","visual","scaleName","scaleType","getScaleComponent","get","toNum","expr","length","value","map","t","scale","update","join","concat","Object","signal","marks","x","y","hasChannel","xvname","yvname","store","undefined","x2","field","group","y2","resolve","key","test","mark","fill","fillOpacity","cursor","stroke","vgStroke","reduce","def","k","clip","encode","enter","scaled","str","size","getSizeSignalRef","coord","cb"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/selection/interval.ts"],"sourcesContent":["import {NewSignal, OnEvent, Stream} from 'vega';\nimport {array, stringValue} from 'vega-util';\nimport {SelectionCompiler, SelectionComponent, STORE, TUPLE, unitName} from '.';\nimport {ScaleChannel, X, Y} from '../../channel';\nimport {warn} from '../../log';\nimport {hasContinuousDomain} from '../../scale';\nimport {SelectionInitInterval} from '../../selection';\nimport {keys} from '../../util';\nimport {UnitModel} from '../unit';\nimport {assembleInit} from './assemble';\nimport {SelectionProjection, TUPLE_FIELDS} from './project';\nimport scales from './scales';\n\nexport const BRUSH = '_brush';\nexport const SCALE_TRIGGER = '_scale_trigger';\n\nconst interval: SelectionCompiler<'interval'> = {\n  defined: selCmpt => selCmpt.type === 'interval',\n\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const fieldsSg = name + TUPLE_FIELDS;\n    const hasScales = scales.defined(selCmpt);\n    const init = selCmpt.init ? selCmpt.init[0] : null;\n    const dataSignals: string[] = [];\n    const scaleTriggers: {\n      scaleName: string;\n      expr: string;\n    }[] = [];\n\n    if (selCmpt.translate && !hasScales) {\n      const filterExpr = `!event.item || event.item.mark.name !== ${stringValue(name + BRUSH)}`;\n      events(selCmpt, (on: OnEvent[], evt: Stream) => {\n        const filters = array((evt.between[0].filter ??= []));\n        if (!filters.includes(filterExpr)) {\n          filters.push(filterExpr);\n        }\n        return on;\n      });\n    }\n\n    selCmpt.project.items.forEach((proj, i) => {\n      const channel = proj.channel;\n      if (channel !== X && channel !== Y) {\n        warn('Interval selections only support x and y encoding channels.');\n        return;\n      }\n\n      const val = init ? init[i] : null;\n      const cs = channelSignals(model, selCmpt, proj, val);\n      const dname = proj.signals.data;\n      const vname = proj.signals.visual;\n      const scaleName = stringValue(model.scaleName(channel));\n      const scaleType = model.getScaleComponent(channel).get('type');\n      const toNum = hasContinuousDomain(scaleType) ? '+' : '';\n\n      signals.push(...cs);\n      dataSignals.push(dname);\n\n      scaleTriggers.push({\n        scaleName: model.scaleName(channel),\n        expr:\n          `(!isArray(${dname}) || ` +\n          `(${toNum}invert(${scaleName}, ${vname})[0] === ${toNum}${dname}[0] && ` +\n          `${toNum}invert(${scaleName}, ${vname})[1] === ${toNum}${dname}[1]))`\n      });\n    });\n\n    // Proxy scale reactions to ensure that an infinite loop doesn't occur\n    // when an interval selection filter touches the scale.\n    if (!hasScales && scaleTriggers.length) {\n      signals.push({\n        name: name + SCALE_TRIGGER,\n        value: {},\n        on: [\n          {\n            events: scaleTriggers.map(t => ({scale: t.scaleName})),\n            update: `${scaleTriggers.map(t => t.expr).join(' && ')} ? ${name + SCALE_TRIGGER} : {}`\n          }\n        ]\n      });\n    }\n\n    // Only add an interval to the store if it has valid data extents. Data extents\n    // are set to null if pixel extents are equal to account for intervals over\n    // ordinal/nominal domains which, when inverted, will still produce a valid datum.\n    const update = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;\n    return signals.concat({\n      name: name + TUPLE,\n      ...(init ? {init: `{${update}: ${assembleInit(init)}}`} : {}),\n      ...(dataSignals.length\n        ? {\n            on: [\n              {\n                events: [{signal: dataSignals.join(' || ')}], // Prevents double invocation, see https://github.com/vega/vega#1672.\n                update: `${dataSignals.join(' && ')} ? {${update}: [${dataSignals}]} : null`\n              }\n            ]\n          }\n        : {})\n    });\n  },\n\n  marks: (model, selCmpt, marks) => {\n    const name = selCmpt.name;\n    const {x, y} = selCmpt.project.hasChannel;\n    const xvname = x?.signals.visual;\n    const yvname = y?.signals.visual;\n    const store = `data(${stringValue(selCmpt.name + STORE)})`;\n\n    // Do not add a brush if we're binding to scales\n    // or we don't have a valid interval projection\n    if (scales.defined(selCmpt) || (!x && !y)) {\n      return marks;\n    }\n\n    const update: any = {\n      x: x !== undefined ? {signal: `${xvname}[0]`} : {value: 0},\n      y: y !== undefined ? {signal: `${yvname}[0]`} : {value: 0},\n      x2: x !== undefined ? {signal: `${xvname}[1]`} : {field: {group: 'width'}},\n      y2: y !== undefined ? {signal: `${yvname}[1]`} : {field: {group: 'height'}}\n    };\n\n    // If the selection is resolved to global, only a single interval is in\n    // the store. Wrap brush mark's encodings with a production rule to test\n    // this based on the `unit` property. Hide the brush mark if it corresponds\n    // to a unit different from the one in the store.\n    if (selCmpt.resolve === 'global') {\n      for (const key of keys(update)) {\n        update[key] = [\n          {\n            test: `${store}.length && ${store}[0].unit === ${unitName(model)}`,\n            ...update[key]\n          },\n          {value: 0}\n        ];\n      }\n    }\n\n    // Two brush marks ensure that fill colors and other aesthetic choices do\n    // not interefere with the core marks, but that the brushed region can still\n    // be interacted with (e.g., dragging it around).\n    const {fill, fillOpacity, cursor, ...stroke} = selCmpt.mark;\n    const vgStroke = keys(stroke).reduce((def, k) => {\n      def[k] = [\n        {\n          test: [x !== undefined && `${xvname}[0] !== ${xvname}[1]`, y !== undefined && `${yvname}[0] !== ${yvname}[1]`]\n            .filter(t => t)\n            .join(' && '),\n          value: stroke[k]\n        },\n        {value: null}\n      ];\n      return def;\n    }, {});\n\n    return [\n      {\n        name: `${name + BRUSH}_bg`,\n        type: 'rect',\n        clip: true,\n        encode: {\n          enter: {\n            fill: {value: fill},\n            fillOpacity: {value: fillOpacity}\n          },\n          update\n        }\n      },\n      ...marks,\n      {\n        name: name + BRUSH,\n        type: 'rect',\n        clip: true,\n        encode: {\n          enter: {\n            ...(cursor ? {cursor: {value: cursor}} : {}),\n            fill: {value: 'transparent'}\n          },\n          update: {...update, ...vgStroke}\n        }\n      }\n    ];\n  }\n};\nexport default interval;\n\n/**\n * Returns the visual and data signals for an interval selection.\n */\nfunction channelSignals(\n  model: UnitModel,\n  selCmpt: SelectionComponent<'interval'>,\n  proj: SelectionProjection,\n  init?: SelectionInitInterval\n): NewSignal[] {\n  const channel = proj.channel;\n  const vname = proj.signals.visual;\n  const dname = proj.signals.data;\n  const hasScales = scales.defined(selCmpt);\n  const scaleName = stringValue(model.scaleName(channel));\n  const scale = model.getScaleComponent(channel as ScaleChannel);\n  const scaleType = scale ? scale.get('type') : undefined;\n  const scaled = (str: string) => `scale(${scaleName}, ${str})`;\n  const size = model.getSizeSignalRef(channel === X ? 'width' : 'height').signal;\n  const coord = `${channel}(unit)`;\n\n  const on = events(selCmpt, (def: OnEvent[], evt: Stream) => {\n    return [\n      ...def,\n      {events: evt.between[0], update: `[${coord}, ${coord}]`}, // Brush Start\n      {events: evt, update: `[${vname}[0], clamp(${coord}, 0, ${size})]`} // Brush End\n    ];\n  });\n\n  // React to pan/zooms of continuous scales. Non-continuous scales\n  // (band, point) cannot be pan/zoomed and any other changes\n  // to their domains (e.g., filtering) should clear the brushes.\n  on.push({\n    events: {signal: selCmpt.name + SCALE_TRIGGER},\n    update: hasContinuousDomain(scaleType) ? `[${scaled(`${dname}[0]`)}, ${scaled(`${dname}[1]`)}]` : `[0, 0]`\n  });\n\n  return hasScales\n    ? [{name: dname, on: []}]\n    : [\n        {\n          name: vname,\n          ...(init ? {init: assembleInit(init, true, scaled)} : {value: []}),\n          on\n        },\n        {\n          name: dname,\n          ...(init ? {init: assembleInit(init)} : {}), // Cannot be `value` as `init` may require datetime exprs.\n          on: [\n            {\n              events: {signal: vname},\n              update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`\n            }\n          ]\n        }\n      ];\n}\n\nfunction events(selCmpt: SelectionComponent<'interval'>, cb: (def: OnEvent[], evt: Stream) => OnEvent[]): OnEvent[] {\n  return selCmpt.events.reduce((on, evt) => {\n    if (!evt.between) {\n      warn(`${evt} is not an ordered event stream for interval selections.`);\n      return on;\n    }\n    return cb(on, evt);\n  }, [] as OnEvent[]);\n}\n"]},"metadata":{},"sourceType":"module"}