{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as log from '../log';\nimport { isConcatSpec, isHConcatSpec, isVConcatSpec } from './concat';\nimport { isFacetSpec } from './facet';\nimport { isLayerSpec } from './layer';\nimport { isRepeatSpec } from './repeat';\nimport { isUnitSpec } from './unit';\nexport class SpecMapper {\n  map(spec, params) {\n    if (isFacetSpec(spec)) {\n      return this.mapFacet(spec, params);\n    } else if (isRepeatSpec(spec)) {\n      return this.mapRepeat(spec, params);\n    } else if (isHConcatSpec(spec)) {\n      return this.mapHConcat(spec, params);\n    } else if (isVConcatSpec(spec)) {\n      return this.mapVConcat(spec, params);\n    } else if (isConcatSpec(spec)) {\n      return this.mapConcat(spec, params);\n    } else {\n      return this.mapLayerOrUnit(spec, params);\n    }\n  }\n\n  mapLayerOrUnit(spec, params) {\n    if (isLayerSpec(spec)) {\n      return this.mapLayer(spec, params);\n    } else if (isUnitSpec(spec)) {\n      return this.mapUnit(spec, params);\n    }\n\n    throw new Error(log.message.invalidSpec(spec));\n  }\n\n  mapLayer(spec, params) {\n    return Object.assign(Object.assign({}, spec), {\n      layer: spec.layer.map(subspec => this.mapLayerOrUnit(subspec, params))\n    });\n  }\n\n  mapHConcat(spec, params) {\n    return Object.assign(Object.assign({}, spec), {\n      hconcat: spec.hconcat.map(subspec => this.map(subspec, params))\n    });\n  }\n\n  mapVConcat(spec, params) {\n    return Object.assign(Object.assign({}, spec), {\n      vconcat: spec.vconcat.map(subspec => this.map(subspec, params))\n    });\n  }\n\n  mapConcat(spec, params) {\n    const {\n      concat\n    } = spec,\n          rest = __rest(spec, [\"concat\"]);\n\n    return Object.assign(Object.assign({}, rest), {\n      concat: concat.map(subspec => this.map(subspec, params))\n    });\n  }\n\n  mapFacet(spec, params) {\n    return Object.assign(Object.assign({}, spec), {\n      // TODO: remove \"any\" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760\n      spec: this.map(spec.spec, params)\n    });\n  }\n\n  mapRepeat(spec, params) {\n    return Object.assign(Object.assign({}, spec), {\n      // as any is required here since TS cannot infer that the output type satisfies the input type\n      spec: this.map(spec.spec, params)\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["log","isConcatSpec","isHConcatSpec","isVConcatSpec","isFacetSpec","isLayerSpec","isRepeatSpec","isUnitSpec","SpecMapper","map","spec","params","mapFacet","mapRepeat","mapHConcat","mapVConcat","mapConcat","mapLayerOrUnit","mapLayer","mapUnit","Error","message","invalidSpec","layer","subspec","hconcat","vconcat","concat","rest"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/spec/map.ts"],"sourcesContent":["import {GenericSpec} from '.';\nimport * as log from '../log';\nimport {Field, FieldName} from '../channeldef';\nimport {\n  GenericConcatSpec,\n  GenericHConcatSpec,\n  GenericVConcatSpec,\n  isConcatSpec,\n  isHConcatSpec,\n  isVConcatSpec\n} from './concat';\nimport {GenericFacetSpec, isFacetSpec} from './facet';\nimport {GenericLayerSpec, isLayerSpec} from './layer';\nimport {isRepeatSpec, RepeatSpec} from './repeat';\nimport {GenericUnitSpec, isUnitSpec, NormalizedUnitSpec} from './unit';\n\nexport abstract class SpecMapper<\n  P,\n  UI extends GenericUnitSpec<any, any>,\n  LI extends GenericLayerSpec<any> = GenericLayerSpec<UI>,\n  UO extends GenericUnitSpec<any, any> = NormalizedUnitSpec,\n  RO extends RepeatSpec = never,\n  FO extends Field = FieldName\n> {\n  public map(spec: GenericSpec<UI, LI, RepeatSpec, Field>, params: P): GenericSpec<UO, GenericLayerSpec<UO>, RO, FO> {\n    if (isFacetSpec(spec)) {\n      return this.mapFacet(spec, params);\n    } else if (isRepeatSpec(spec)) {\n      return this.mapRepeat(spec, params);\n    } else if (isHConcatSpec(spec)) {\n      return this.mapHConcat(spec, params);\n    } else if (isVConcatSpec(spec)) {\n      return this.mapVConcat(spec, params);\n    } else if (isConcatSpec(spec)) {\n      return this.mapConcat(spec, params);\n    } else {\n      return this.mapLayerOrUnit(spec, params);\n    }\n  }\n\n  public mapLayerOrUnit(spec: UI | LI, params: P): UO | GenericLayerSpec<UO> {\n    if (isLayerSpec(spec)) {\n      return this.mapLayer(spec, params);\n    } else if (isUnitSpec(spec)) {\n      return this.mapUnit(spec, params);\n    }\n    throw new Error(log.message.invalidSpec(spec));\n  }\n\n  public abstract mapUnit(spec: UI, params: P): UO | GenericLayerSpec<UO>;\n\n  protected mapLayer(spec: LI, params: P): GenericLayerSpec<UO> {\n    return {\n      ...spec,\n      layer: spec.layer.map(subspec => this.mapLayerOrUnit(subspec, params))\n    };\n  }\n\n  protected mapHConcat(\n    spec: GenericHConcatSpec<GenericSpec<UI, LI, RepeatSpec, Field>>,\n    params: P\n  ): GenericHConcatSpec<GenericSpec<UO, GenericLayerSpec<UO>, RO, FO>> {\n    return {\n      ...spec,\n      hconcat: spec.hconcat.map(subspec => this.map(subspec, params))\n    };\n  }\n\n  protected mapVConcat(\n    spec: GenericVConcatSpec<GenericSpec<UI, LI, RepeatSpec, Field>>,\n    params: P\n  ): GenericVConcatSpec<GenericSpec<UO, GenericLayerSpec<UO>, RO, FO>> {\n    return {\n      ...spec,\n      vconcat: spec.vconcat.map(subspec => this.map(subspec, params))\n    };\n  }\n\n  protected mapConcat(\n    spec: GenericConcatSpec<GenericSpec<UI, LI, RepeatSpec, Field>>,\n    params: P\n  ): GenericConcatSpec<GenericSpec<UO, GenericLayerSpec<UO>, RO, FO>> {\n    const {concat, ...rest} = spec;\n\n    return {\n      ...rest,\n      concat: concat.map(subspec => this.map(subspec, params))\n    };\n  }\n\n  protected mapFacet(spec: GenericFacetSpec<UI, LI, Field>, params: P): GenericFacetSpec<UO, GenericLayerSpec<UO>, FO> {\n    return {\n      // as any is required here since TS cannot infer that FO may only be FieldName or Field, but not RepeatRef\n      ...(spec as any),\n      // TODO: remove \"any\" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760\n      spec: this.map(spec.spec, params) as any\n    };\n  }\n\n  protected mapRepeat(spec: RepeatSpec, params: P): GenericSpec<UO, any, RO, FO> {\n    return {\n      ...spec,\n      // as any is required here since TS cannot infer that the output type satisfies the input type\n      spec: this.map(spec.spec as any, params)\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}