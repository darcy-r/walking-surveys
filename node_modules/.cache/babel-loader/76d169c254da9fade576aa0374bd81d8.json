{"ast":null,"code":"import { isBinning } from '../../bin';\nimport { getSizeChannel, isColorChannel, isScaleChannel, isXorY, isXorYOffset, rangeType } from '../../channel';\nimport { isFieldDef, isPositionFieldOrDatumDef } from '../../channeldef';\nimport * as log from '../../log';\nimport { isRelativeBandSize } from '../../mark';\nimport { channelSupportScaleType, scaleTypeSupportDataType } from '../../scale';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport * as util from '../../util';\nimport { POLAR_POSITION_SCALE_CHANNEL_INDEX } from './../../channel';\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\n// NOTE: CompassQL uses this method.\n\nexport function scaleType(specifiedScale, channel, fieldDef, mark) {\n  let hasNestedOffsetScale = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  const defaultScaleType = defaultType(channel, fieldDef, mark, hasNestedOffsetScale);\n  const {\n    type\n  } = specifiedScale;\n\n  if (!isScaleChannel(channel)) {\n    // There is no scale for these channels\n    return null;\n  }\n\n  if (type !== undefined) {\n    // Check if explicitly specified scale type is supported by the channel\n    if (!channelSupportScaleType(channel, type)) {\n      log.warn(log.message.scaleTypeNotWorkWithChannel(channel, type, defaultScaleType));\n      return defaultScaleType;\n    } // Check if explicitly specified scale type is supported by the data type\n\n\n    if (isFieldDef(fieldDef) && !scaleTypeSupportDataType(type, fieldDef.type)) {\n      log.warn(log.message.scaleTypeNotWorkWithFieldDef(type, defaultScaleType));\n      return defaultScaleType;\n    }\n\n    return type;\n  }\n\n  return defaultScaleType;\n}\n/**\n * Determine appropriate default scale type.\n */\n// NOTE: Voyager uses this method.\n\nfunction defaultType(channel, fieldDef, mark, hasNestedOffsetScale) {\n  var _a;\n\n  switch (fieldDef.type) {\n    case 'nominal':\n    case 'ordinal':\n      {\n        if (isColorChannel(channel) || rangeType(channel) === 'discrete') {\n          if (channel === 'shape' && fieldDef.type === 'ordinal') {\n            log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n          }\n\n          return 'ordinal';\n        }\n\n        if (isXorY(channel) || isXorYOffset(channel)) {\n          if (util.contains(['rect', 'bar', 'image', 'rule'], mark.type)) {\n            // The rect/bar mark should fit into a band.\n            // For rule, using band scale to make rule align with axis ticks better https://github.com/vega/vega-lite/issues/3429\n            return 'band';\n          }\n\n          if (hasNestedOffsetScale) {\n            // If there is a nested offset scale, then there is a \"band\" for the span of the nested scale.\n            return 'band';\n          }\n        } else if (mark.type === 'arc' && channel in POLAR_POSITION_SCALE_CHANNEL_INDEX) {\n          return 'band';\n        }\n\n        const dimensionSize = mark[getSizeChannel(channel)];\n\n        if (isRelativeBandSize(dimensionSize)) {\n          return 'band';\n        }\n\n        if (isPositionFieldOrDatumDef(fieldDef) && ((_a = fieldDef.axis) === null || _a === void 0 ? void 0 : _a.tickBand)) {\n          return 'band';\n        } // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n\n\n        return 'point';\n      }\n\n    case 'temporal':\n      if (isColorChannel(channel)) {\n        return 'time';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal')); // TODO: consider using quantize (equivalent to binning) once we have it\n\n        return 'ordinal';\n      } else if (isFieldDef(fieldDef) && fieldDef.timeUnit && normalizeTimeUnit(fieldDef.timeUnit).utc) {\n        return 'utc';\n      }\n\n      return 'time';\n\n    case 'quantitative':\n      if (isColorChannel(channel)) {\n        if (isFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n          return 'bin-ordinal';\n        }\n\n        return 'linear';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative')); // TODO: consider using quantize (equivalent to binning) once we have it\n\n        return 'ordinal';\n      }\n\n      return 'linear';\n\n    case 'geojson':\n      return undefined;\n  }\n  /* istanbul ignore next: should never reach this */\n\n\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}","map":{"version":3,"mappings":"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","names":["isBinning","getSizeChannel","isColorChannel","isScaleChannel","isXorY","isXorYOffset","rangeType","isFieldDef","isPositionFieldOrDatumDef","log","isRelativeBandSize","channelSupportScaleType","scaleTypeSupportDataType","normalizeTimeUnit","util","POLAR_POSITION_SCALE_CHANNEL_INDEX","scaleType","specifiedScale","channel","fieldDef","mark","hasNestedOffsetScale","defaultScaleType","defaultType","type","undefined","warn","message","scaleTypeNotWorkWithChannel","scaleTypeNotWorkWithFieldDef","discreteChannelCannotEncode","contains","dimensionSize","axis","_a","tickBand","timeUnit","utc","bin","Error","invalidFieldType"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/scale/type.ts"],"sourcesContent":["import {isBinning} from '../../bin';\nimport {\n  getSizeChannel,\n  isColorChannel,\n  isScaleChannel,\n  isXorY,\n  isXorYOffset,\n  rangeType,\n  ScaleChannel\n} from '../../channel';\nimport {DatumDef, isFieldDef, isPositionFieldOrDatumDef, ScaleDatumDef, TypedFieldDef} from '../../channeldef';\nimport * as log from '../../log';\nimport {isRelativeBandSize, MarkDef} from '../../mark';\nimport {channelSupportScaleType, Scale, ScaleType, scaleTypeSupportDataType} from '../../scale';\nimport {normalizeTimeUnit} from '../../timeunit';\nimport * as util from '../../util';\nimport {POLAR_POSITION_SCALE_CHANNEL_INDEX} from './../../channel';\n\nexport type RangeType = 'continuous' | 'discrete' | 'flexible' | undefined;\n\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\n// NOTE: CompassQL uses this method.\nexport function scaleType(\n  specifiedScale: Scale,\n  channel: ScaleChannel,\n  fieldDef: TypedFieldDef<string> | DatumDef,\n  mark: MarkDef,\n  hasNestedOffsetScale = false\n): ScaleType {\n  const defaultScaleType = defaultType(channel, fieldDef, mark, hasNestedOffsetScale);\n  const {type} = specifiedScale;\n\n  if (!isScaleChannel(channel)) {\n    // There is no scale for these channels\n    return null;\n  }\n  if (type !== undefined) {\n    // Check if explicitly specified scale type is supported by the channel\n    if (!channelSupportScaleType(channel, type)) {\n      log.warn(log.message.scaleTypeNotWorkWithChannel(channel, type, defaultScaleType));\n      return defaultScaleType;\n    }\n\n    // Check if explicitly specified scale type is supported by the data type\n    if (isFieldDef(fieldDef) && !scaleTypeSupportDataType(type, fieldDef.type)) {\n      log.warn(log.message.scaleTypeNotWorkWithFieldDef(type, defaultScaleType));\n      return defaultScaleType;\n    }\n\n    return type;\n  }\n\n  return defaultScaleType;\n}\n\n/**\n * Determine appropriate default scale type.\n */\n// NOTE: Voyager uses this method.\nfunction defaultType(\n  channel: ScaleChannel,\n  fieldDef: TypedFieldDef<string> | ScaleDatumDef,\n  mark: MarkDef,\n  hasNestedOffsetScale: boolean\n): ScaleType {\n  switch (fieldDef.type) {\n    case 'nominal':\n    case 'ordinal': {\n      if (isColorChannel(channel) || rangeType(channel) === 'discrete') {\n        if (channel === 'shape' && fieldDef.type === 'ordinal') {\n          log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n        }\n        return 'ordinal';\n      }\n\n      if (isXorY(channel) || isXorYOffset(channel)) {\n        if (util.contains(['rect', 'bar', 'image', 'rule'], mark.type)) {\n          // The rect/bar mark should fit into a band.\n          // For rule, using band scale to make rule align with axis ticks better https://github.com/vega/vega-lite/issues/3429\n          return 'band';\n        }\n        if (hasNestedOffsetScale) {\n          // If there is a nested offset scale, then there is a \"band\" for the span of the nested scale.\n          return 'band';\n        }\n      } else if (mark.type === 'arc' && channel in POLAR_POSITION_SCALE_CHANNEL_INDEX) {\n        return 'band';\n      }\n\n      const dimensionSize = mark[getSizeChannel(channel)];\n      if (isRelativeBandSize(dimensionSize)) {\n        return 'band';\n      }\n\n      if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis?.tickBand) {\n        return 'band';\n      }\n      // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n      return 'point';\n    }\n\n    case 'temporal':\n      if (isColorChannel(channel)) {\n        return 'time';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      } else if (isFieldDef(fieldDef) && fieldDef.timeUnit && normalizeTimeUnit(fieldDef.timeUnit).utc) {\n        return 'utc';\n      }\n      return 'time';\n\n    case 'quantitative':\n      if (isColorChannel(channel)) {\n        if (isFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n          return 'bin-ordinal';\n        }\n\n        return 'linear';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      }\n\n      return 'linear';\n\n    case 'geojson':\n      return undefined;\n  }\n\n  /* istanbul ignore next: should never reach this */\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\n"]},"metadata":{},"sourceType":"module"}