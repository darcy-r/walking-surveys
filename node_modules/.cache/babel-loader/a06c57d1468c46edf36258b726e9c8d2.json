{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isObject } from 'vega-util';\nimport { isXorY } from '../../channel';\nimport { keys } from '../../util';\nimport { isDataRefDomain, isVgRangeStep } from '../../vega.schema';\nimport { isConcatModel, isLayerModel } from '../model';\nimport { assembleSelectionScaleDomain } from '../selection/assemble';\nimport { assembleDomain } from './domain';\nexport function assembleScales(model) {\n  if (isLayerModel(model) || isConcatModel(model)) {\n    // For concat and layer, include scales of children too\n    return model.children.reduce((scales, child) => {\n      return scales.concat(assembleScales(child));\n    }, assembleScalesForModel(model));\n  } else {\n    // For facet, child scales would not be included in the parent's scope.\n    // For unit, there is no child.\n    return assembleScalesForModel(model);\n  }\n}\nexport function assembleScalesForModel(model) {\n  return keys(model.component.scales).reduce((scales, channel) => {\n    const scaleComponent = model.component.scales[channel];\n\n    if (scaleComponent.merged) {\n      // Skipped merged scales\n      return scales;\n    }\n\n    const scale = scaleComponent.combine();\n\n    const {\n      name,\n      type,\n      selectionExtent,\n      domains: _d,\n      range: _r,\n      reverse\n    } = scale,\n          otherScaleProps = __rest(scale, [\"name\", \"type\", \"selectionExtent\", \"domains\", \"range\", \"reverse\"]);\n\n    const range = assembleScaleRange(scale.range, name, channel, model);\n    const domain = assembleDomain(model, channel);\n    const domainRaw = selectionExtent ? assembleSelectionScaleDomain(model, selectionExtent, scaleComponent, domain) : null;\n    scales.push(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n      name,\n      type\n    }, domain ? {\n      domain\n    } : {}), domainRaw ? {\n      domainRaw\n    } : {}), {\n      range\n    }), reverse !== undefined ? {\n      reverse: reverse\n    } : {}), otherScaleProps));\n    return scales;\n  }, []);\n}\nexport function assembleScaleRange(scaleRange, scaleName, channel, model) {\n  // add signals to x/y range\n  if (isXorY(channel)) {\n    if (isVgRangeStep(scaleRange)) {\n      // For width/height step, use a signal created in layout assemble instead of a constant step.\n      return {\n        step: {\n          signal: `${scaleName}_step`\n        }\n      };\n    }\n  } else if (isObject(scaleRange) && isDataRefDomain(scaleRange)) {\n    return Object.assign(Object.assign({}, scaleRange), {\n      data: model.lookupDataSource(scaleRange.data)\n    });\n  }\n\n  return scaleRange;\n}","map":{"version":3,"mappings":"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","names":["isObject","isXorY","keys","isDataRefDomain","isVgRangeStep","isConcatModel","isLayerModel","assembleSelectionScaleDomain","assembleDomain","assembleScales","model","children","reduce","scales","child","concat","assembleScalesForModel","component","channel","scaleComponent","merged","scale","combine","name","type","selectionExtent","domains","_d","range","_r","reverse","otherScaleProps","assembleScaleRange","domain","domainRaw","push","Object","undefined","scaleRange","scaleName","step","signal","data","lookupDataSource"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/scale/assemble.ts"],"sourcesContent":["import {isObject} from 'vega-util';\nimport {isXorY, ScaleChannel} from '../../channel';\nimport {keys} from '../../util';\nimport {isDataRefDomain, isVgRangeStep, VgRange, VgScale} from '../../vega.schema';\nimport {isConcatModel, isLayerModel, Model} from '../model';\nimport {assembleSelectionScaleDomain} from '../selection/assemble';\nimport {assembleDomain} from './domain';\n\nexport function assembleScales(model: Model): VgScale[] {\n  if (isLayerModel(model) || isConcatModel(model)) {\n    // For concat and layer, include scales of children too\n    return model.children.reduce((scales, child) => {\n      return scales.concat(assembleScales(child));\n    }, assembleScalesForModel(model));\n  } else {\n    // For facet, child scales would not be included in the parent's scope.\n    // For unit, there is no child.\n    return assembleScalesForModel(model);\n  }\n}\n\nexport function assembleScalesForModel(model: Model): VgScale[] {\n  return keys(model.component.scales).reduce((scales: VgScale[], channel: ScaleChannel) => {\n    const scaleComponent = model.component.scales[channel];\n    if (scaleComponent.merged) {\n      // Skipped merged scales\n      return scales;\n    }\n\n    const scale = scaleComponent.combine();\n    const {name, type, selectionExtent, domains: _d, range: _r, reverse, ...otherScaleProps} = scale;\n    const range = assembleScaleRange(scale.range, name, channel, model);\n\n    const domain = assembleDomain(model, channel);\n    const domainRaw = selectionExtent\n      ? assembleSelectionScaleDomain(model, selectionExtent, scaleComponent, domain)\n      : null;\n\n    scales.push({\n      name,\n      type,\n      ...(domain ? {domain} : {}),\n      ...(domainRaw ? {domainRaw} : {}),\n      range,\n      ...(reverse !== undefined ? {reverse: reverse as any} : {}),\n      ...otherScaleProps\n    });\n\n    return scales;\n  }, [] as VgScale[]);\n}\n\nexport function assembleScaleRange(\n  scaleRange: VgRange,\n  scaleName: string,\n  channel: ScaleChannel,\n  model?: Model\n): VgRange {\n  // add signals to x/y range\n  if (isXorY(channel)) {\n    if (isVgRangeStep(scaleRange)) {\n      // For width/height step, use a signal created in layout assemble instead of a constant step.\n      return {\n        step: {signal: `${scaleName}_step`}\n      };\n    }\n  } else if (isObject(scaleRange) && isDataRefDomain(scaleRange)) {\n    return {\n      ...scaleRange,\n      data: model.lookupDataSource(scaleRange.data)\n    };\n  }\n  return scaleRange;\n}\n"]},"metadata":{},"sourceType":"module"}