{"ast":null,"code":"import { AncestorParse } from '.';\nimport { isGenerator, isGraticuleGenerator, isInlineData, isNamedData, isSequenceGenerator, isUrlData, DataSourceType } from '../../data';\nimport * as log from '../../log';\nimport { isAggregate, isBin, isCalculate, isDensity, isFilter, isFlatten, isFold, isImpute, isJoinAggregate, isLoess, isLookup, isPivot, isQuantile, isRegression, isSample, isStack, isTimeUnit, isWindow } from '../../transform';\nimport { deepEqual, mergeDeep } from '../../util';\nimport { isFacetModel, isLayerModel, isUnitModel } from '../model';\nimport { requiresSelectionId } from '../selection';\nimport { materializeSelections } from '../selection/parse';\nimport { AggregateNode } from './aggregate';\nimport { BinNode } from './bin';\nimport { CalculateNode } from './calculate';\nimport { OutputNode } from './dataflow';\nimport { DensityTransformNode } from './density';\nimport { FacetNode } from './facet';\nimport { FilterNode } from './filter';\nimport { FilterInvalidNode } from './filterinvalid';\nimport { FlattenTransformNode } from './flatten';\nimport { FoldTransformNode } from './fold';\nimport { getImplicitFromEncoding, getImplicitFromFilterTransform, getImplicitFromSelection, ParseNode } from './formatparse';\nimport { GeoJSONNode } from './geojson';\nimport { GeoPointNode } from './geopoint';\nimport { GraticuleNode } from './graticule';\nimport { IdentifierNode } from './identifier';\nimport { ImputeNode } from './impute';\nimport { JoinAggregateTransformNode } from './joinaggregate';\nimport { makeJoinAggregateFromFacet } from './joinaggregatefacet';\nimport { LoessTransformNode } from './loess';\nimport { LookupNode } from './lookup';\nimport { PivotTransformNode } from './pivot';\nimport { QuantileTransformNode } from './quantile';\nimport { RegressionTransformNode } from './regression';\nimport { SampleTransformNode } from './sample';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\nimport { StackNode } from './stack';\nimport { TimeUnitNode } from './timeunit';\nimport { WindowTransformNode } from './window';\nexport function findSource(data, sources) {\n  var _a, _b, _c, _d;\n\n  for (const other of sources) {\n    const otherData = other.data; // if both datasets have a name defined, we cannot merge\n\n    if (data.name && other.hasName() && data.name !== other.dataName) {\n      continue;\n    }\n\n    const formatMesh = (_a = data['format']) === null || _a === void 0 ? void 0 : _a.mesh;\n    const otherFeature = (_b = otherData.format) === null || _b === void 0 ? void 0 : _b.feature; // feature and mesh are mutually exclusive\n\n    if (formatMesh && otherFeature) {\n      continue;\n    } // we have to extract the same feature or mesh\n\n\n    const formatFeature = (_c = data['format']) === null || _c === void 0 ? void 0 : _c.feature;\n\n    if ((formatFeature || otherFeature) && formatFeature !== otherFeature) {\n      continue;\n    }\n\n    const otherMesh = (_d = otherData.format) === null || _d === void 0 ? void 0 : _d.mesh;\n\n    if ((formatMesh || otherMesh) && formatMesh !== otherMesh) {\n      continue;\n    }\n\n    if (isInlineData(data) && isInlineData(otherData)) {\n      if (deepEqual(data.values, otherData.values)) {\n        return other;\n      }\n    } else if (isUrlData(data) && isUrlData(otherData)) {\n      if (data.url === otherData.url) {\n        return other;\n      }\n    } else if (isNamedData(data)) {\n      if (data.name === other.dataName) {\n        return other;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction parseRoot(model, sources) {\n  if (model.data || !model.parent) {\n    // if the model defines a data source or is the root, create a source node\n    if (model.data === null) {\n      // data: null means we should ignore the parent's data so we just create a new data source\n      const source = new SourceNode({\n        values: []\n      });\n      sources.push(source);\n      return source;\n    }\n\n    const existingSource = findSource(model.data, sources);\n\n    if (existingSource) {\n      if (!isGenerator(model.data)) {\n        existingSource.data.format = mergeDeep({}, model.data.format, existingSource.data.format);\n      } // if the new source has a name but the existing one does not, we can set it\n\n\n      if (!existingSource.hasName() && model.data.name) {\n        existingSource.dataName = model.data.name;\n      }\n\n      return existingSource;\n    } else {\n      const source = new SourceNode(model.data);\n      sources.push(source);\n      return source;\n    }\n  } else {\n    // If we don't have a source defined (overriding parent's data), use the parent's facet root or main.\n    return model.parent.component.data.facetRoot ? model.parent.component.data.facetRoot : model.parent.component.data.main;\n  }\n}\n/**\n * Parses a transform array into a chain of connected dataflow nodes.\n */\n\n\nexport function parseTransformArray(head, model, ancestorParse) {\n  var _a, _b;\n\n  let lookupCounter = 0;\n\n  for (const t of model.transforms) {\n    let derivedType = undefined;\n    let transformNode;\n\n    if (isCalculate(t)) {\n      transformNode = head = new CalculateNode(head, t);\n      derivedType = 'derived';\n    } else if (isFilter(t)) {\n      const implicit = getImplicitFromFilterTransform(t);\n      transformNode = head = (_a = ParseNode.makeWithAncestors(head, {}, implicit, ancestorParse)) !== null && _a !== void 0 ? _a : head;\n      head = new FilterNode(head, model, t.filter);\n    } else if (isBin(t)) {\n      transformNode = head = BinNode.makeFromTransform(head, t, model);\n      derivedType = 'number';\n    } else if (isTimeUnit(t)) {\n      derivedType = 'date';\n      const parsedAs = ancestorParse.getWithExplicit(t.field); // Create parse node because the input to time unit is always date.\n\n      if (parsedAs.value === undefined) {\n        head = new ParseNode(head, {\n          [t.field]: derivedType\n        });\n        ancestorParse.set(t.field, derivedType, false);\n      }\n\n      transformNode = head = TimeUnitNode.makeFromTransform(head, t);\n    } else if (isAggregate(t)) {\n      transformNode = head = AggregateNode.makeFromTransform(head, t);\n      derivedType = 'number';\n\n      if (requiresSelectionId(model)) {\n        head = new IdentifierNode(head);\n      }\n    } else if (isLookup(t)) {\n      transformNode = head = LookupNode.make(head, model, t, lookupCounter++);\n      derivedType = 'derived';\n    } else if (isWindow(t)) {\n      transformNode = head = new WindowTransformNode(head, t);\n      derivedType = 'number';\n    } else if (isJoinAggregate(t)) {\n      transformNode = head = new JoinAggregateTransformNode(head, t);\n      derivedType = 'number';\n    } else if (isStack(t)) {\n      transformNode = head = StackNode.makeFromTransform(head, t);\n      derivedType = 'derived';\n    } else if (isFold(t)) {\n      transformNode = head = new FoldTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isFlatten(t)) {\n      transformNode = head = new FlattenTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isPivot(t)) {\n      transformNode = head = new PivotTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isSample(t)) {\n      head = new SampleTransformNode(head, t);\n    } else if (isImpute(t)) {\n      transformNode = head = ImputeNode.makeFromTransform(head, t);\n      derivedType = 'derived';\n    } else if (isDensity(t)) {\n      transformNode = head = new DensityTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isQuantile(t)) {\n      transformNode = head = new QuantileTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isRegression(t)) {\n      transformNode = head = new RegressionTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isLoess(t)) {\n      transformNode = head = new LoessTransformNode(head, t);\n      derivedType = 'derived';\n    } else {\n      log.warn(log.message.invalidTransformIgnored(t));\n      continue;\n    }\n\n    if (transformNode && derivedType !== undefined) {\n      for (const field of (_b = transformNode.producedFields()) !== null && _b !== void 0 ? _b : []) {\n        ancestorParse.set(field, derivedType, false);\n      }\n    }\n  }\n\n  return head;\n}\n/*\nDescription of the dataflow (http://asciiflow.com/):\n     +--------+\n     | Source |\n     +---+----+\n         |\n         v\n     FormatParse\n     (explicit)\n         |\n         v\n     Transforms\n(Filter, Calculate, Binning, TimeUnit, Aggregate, Window, ...)\n         |\n         v\n     FormatParse\n     (implicit)\n         |\n         v\n Binning (in `encoding`)\n         |\n         v\n Timeunit (in `encoding`)\n         |\n         v\nFormula From Sort Array\n         |\n         v\n      +--+--+\n      | Raw |\n      +-----+\n         |\n         v\n  Aggregate (in `encoding`)\n         |\n         v\n  Stack (in `encoding`)\n         |\n         v\n  Invalid Filter\n         |\n         v\n   +----------+\n   |   Main   |\n   +----------+\n         |\n         v\n     +-------+\n     | Facet |----> \"column\", \"column-layout\", and \"row\"\n     +-------+\n         |\n         v\n  ...Child data...\n*/\n\nexport function parseData(model) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n\n  let head = parseRoot(model, model.component.data.sources);\n  const {\n    outputNodes,\n    outputNodeRefCounts\n  } = model.component.data;\n  const data = model.data;\n  const newData = data && (isGenerator(data) || isUrlData(data) || isInlineData(data));\n  const ancestorParse = !newData && model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();\n\n  if (isGenerator(data)) {\n    // insert generator transform\n    if (isSequenceGenerator(data)) {\n      head = new SequenceNode(head, data.sequence);\n    } else if (isGraticuleGenerator(data)) {\n      head = new GraticuleNode(head, data.graticule);\n    } // no parsing necessary for generator\n\n\n    ancestorParse.parseNothing = true;\n  } else if (((_a = data === null || data === void 0 ? void 0 : data.format) === null || _a === void 0 ? void 0 : _a.parse) === null) {\n    // format.parse: null means disable parsing\n    ancestorParse.parseNothing = true;\n  }\n\n  head = (_b = ParseNode.makeExplicit(head, model, ancestorParse)) !== null && _b !== void 0 ? _b : head; // Default discrete selections require an identifer transform to\n  // uniquely identify data points. Add this transform at the head of\n  // the pipeline such that the identifier field is available for all\n  // subsequent datasets. During optimization, we will remove this\n  // transform if it proves to be unnecessary. Additional identifier\n  // transforms will be necessary when new tuples are constructed\n  // (e.g., post-aggregation).\n\n  head = new IdentifierNode(head); // HACK: This is equivalent for merging bin extent for union scale.\n  // FIXME(https://github.com/vega/vega-lite/issues/2270): Correctly merge extent / bin node for shared bin scale\n\n  const parentIsLayer = model.parent && isLayerModel(model.parent);\n\n  if (isUnitModel(model) || isFacetModel(model)) {\n    if (parentIsLayer) {\n      head = (_c = BinNode.makeFromEncoding(head, model)) !== null && _c !== void 0 ? _c : head;\n    }\n  }\n\n  if (model.transforms.length > 0) {\n    head = parseTransformArray(head, model, ancestorParse);\n  } // create parse nodes for fields that need to be parsed (or flattened) implicitly\n\n\n  const implicitSelection = getImplicitFromSelection(model);\n  const implicitEncoding = getImplicitFromEncoding(model);\n  head = (_d = ParseNode.makeWithAncestors(head, {}, Object.assign(Object.assign({}, implicitSelection), implicitEncoding), ancestorParse)) !== null && _d !== void 0 ? _d : head;\n\n  if (isUnitModel(model)) {\n    head = GeoJSONNode.parseAll(head, model);\n    head = GeoPointNode.parseAll(head, model);\n  }\n\n  if (isUnitModel(model) || isFacetModel(model)) {\n    if (!parentIsLayer) {\n      head = (_e = BinNode.makeFromEncoding(head, model)) !== null && _e !== void 0 ? _e : head;\n    }\n\n    head = (_f = TimeUnitNode.makeFromEncoding(head, model)) !== null && _f !== void 0 ? _f : head;\n    head = CalculateNode.parseAllForSortIndex(head, model);\n  } // add an output node pre aggregation\n\n\n  const rawName = model.getDataName(DataSourceType.Raw);\n  const raw = new OutputNode(head, rawName, DataSourceType.Raw, outputNodeRefCounts);\n  outputNodes[rawName] = raw;\n  head = raw;\n\n  if (isUnitModel(model)) {\n    const agg = AggregateNode.makeFromEncoding(head, model);\n\n    if (agg) {\n      head = agg;\n\n      if (requiresSelectionId(model)) {\n        head = new IdentifierNode(head);\n      }\n    }\n\n    head = (_g = ImputeNode.makeFromEncoding(head, model)) !== null && _g !== void 0 ? _g : head;\n    head = (_h = StackNode.makeFromEncoding(head, model)) !== null && _h !== void 0 ? _h : head;\n  }\n\n  if (isUnitModel(model)) {\n    head = (_j = FilterInvalidNode.make(head, model)) !== null && _j !== void 0 ? _j : head;\n  } // output node for marks\n\n\n  const mainName = model.getDataName(DataSourceType.Main);\n  const main = new OutputNode(head, mainName, DataSourceType.Main, outputNodeRefCounts);\n  outputNodes[mainName] = main;\n  head = main;\n\n  if (isUnitModel(model)) {\n    materializeSelections(model, main);\n  } // add facet marker\n\n\n  let facetRoot = null;\n\n  if (isFacetModel(model)) {\n    const facetName = model.getName('facet'); // Derive new aggregate for facet's sort field\n    // augment data source with new fields for crossed facet\n\n    head = (_k = makeJoinAggregateFromFacet(head, model.facet)) !== null && _k !== void 0 ? _k : head;\n    facetRoot = new FacetNode(head, model, facetName, main.getSource());\n    outputNodes[facetName] = facetRoot;\n  }\n\n  return Object.assign(Object.assign({}, model.component.data), {\n    outputNodes,\n    outputNodeRefCounts,\n    raw,\n    main,\n    facetRoot,\n    ancestorParse\n  });\n}","map":{"version":3,"mappings":"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","names":["AncestorParse","isGenerator","isGraticuleGenerator","isInlineData","isNamedData","isSequenceGenerator","isUrlData","DataSourceType","log","isAggregate","isBin","isCalculate","isDensity","isFilter","isFlatten","isFold","isImpute","isJoinAggregate","isLoess","isLookup","isPivot","isQuantile","isRegression","isSample","isStack","isTimeUnit","isWindow","deepEqual","mergeDeep","isFacetModel","isLayerModel","isUnitModel","requiresSelectionId","materializeSelections","AggregateNode","BinNode","CalculateNode","OutputNode","DensityTransformNode","FacetNode","FilterNode","FilterInvalidNode","FlattenTransformNode","FoldTransformNode","getImplicitFromEncoding","getImplicitFromFilterTransform","getImplicitFromSelection","ParseNode","GeoJSONNode","GeoPointNode","GraticuleNode","IdentifierNode","ImputeNode","JoinAggregateTransformNode","makeJoinAggregateFromFacet","LoessTransformNode","LookupNode","PivotTransformNode","QuantileTransformNode","RegressionTransformNode","SampleTransformNode","SequenceNode","SourceNode","StackNode","TimeUnitNode","WindowTransformNode","findSource","data","sources","other","otherData","name","hasName","dataName","formatMesh","_a","mesh","otherFeature","format","_b","feature","formatFeature","_c","otherMesh","_d","values","url","parseRoot","model","parent","source","push","existingSource","component","facetRoot","main","parseTransformArray","head","ancestorParse","lookupCounter","t","transforms","derivedType","undefined","transformNode","implicit","makeWithAncestors","filter","makeFromTransform","parsedAs","getWithExplicit","field","value","set","make","warn","message","invalidTransformIgnored","producedFields","parseData","outputNodes","outputNodeRefCounts","newData","clone","sequence","graticule","parseNothing","parse","makeExplicit","parentIsLayer","makeFromEncoding","length","implicitSelection","implicitEncoding","Object","parseAll","_e","_f","parseAllForSortIndex","rawName","getDataName","Raw","raw","agg","_g","_h","_j","mainName","Main","facetName","getName","facet","_k","getSource"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/data/parse.ts"],"sourcesContent":["import {AncestorParse, DataComponent} from '.';\nimport {\n  Data,\n  isGenerator,\n  isGraticuleGenerator,\n  isInlineData,\n  isNamedData,\n  isSequenceGenerator,\n  isUrlData,\n  DataSourceType,\n  ParseValue\n} from '../../data';\nimport * as log from '../../log';\nimport {\n  isAggregate,\n  isBin,\n  isCalculate,\n  isDensity,\n  isFilter,\n  isFlatten,\n  isFold,\n  isImpute,\n  isJoinAggregate,\n  isLoess,\n  isLookup,\n  isPivot,\n  isQuantile,\n  isRegression,\n  isSample,\n  isStack,\n  isTimeUnit,\n  isWindow\n} from '../../transform';\nimport {deepEqual, mergeDeep} from '../../util';\nimport {isFacetModel, isLayerModel, isUnitModel, Model} from '../model';\nimport {requiresSelectionId} from '../selection';\nimport {materializeSelections} from '../selection/parse';\nimport {AggregateNode} from './aggregate';\nimport {BinNode} from './bin';\nimport {CalculateNode} from './calculate';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {DensityTransformNode} from './density';\nimport {FacetNode} from './facet';\nimport {FilterNode} from './filter';\nimport {FilterInvalidNode} from './filterinvalid';\nimport {FlattenTransformNode} from './flatten';\nimport {FoldTransformNode} from './fold';\nimport {\n  getImplicitFromEncoding,\n  getImplicitFromFilterTransform,\n  getImplicitFromSelection,\n  ParseNode\n} from './formatparse';\nimport {GeoJSONNode} from './geojson';\nimport {GeoPointNode} from './geopoint';\nimport {GraticuleNode} from './graticule';\nimport {IdentifierNode} from './identifier';\nimport {ImputeNode} from './impute';\nimport {JoinAggregateTransformNode} from './joinaggregate';\nimport {makeJoinAggregateFromFacet} from './joinaggregatefacet';\nimport {LoessTransformNode} from './loess';\nimport {LookupNode} from './lookup';\nimport {PivotTransformNode} from './pivot';\nimport {QuantileTransformNode} from './quantile';\nimport {RegressionTransformNode} from './regression';\nimport {SampleTransformNode} from './sample';\nimport {SequenceNode} from './sequence';\nimport {SourceNode} from './source';\nimport {StackNode} from './stack';\nimport {TimeUnitNode} from './timeunit';\nimport {WindowTransformNode} from './window';\n\nexport function findSource(data: Data, sources: SourceNode[]) {\n  for (const other of sources) {\n    const otherData = other.data;\n\n    // if both datasets have a name defined, we cannot merge\n    if (data.name && other.hasName() && data.name !== other.dataName) {\n      continue;\n    }\n\n    const formatMesh = data['format']?.mesh;\n    const otherFeature = otherData.format?.feature;\n\n    // feature and mesh are mutually exclusive\n    if (formatMesh && otherFeature) {\n      continue;\n    }\n\n    // we have to extract the same feature or mesh\n    const formatFeature = data['format']?.feature;\n    if ((formatFeature || otherFeature) && formatFeature !== otherFeature) {\n      continue;\n    }\n\n    const otherMesh = otherData.format?.mesh;\n    if ((formatMesh || otherMesh) && formatMesh !== otherMesh) {\n      continue;\n    }\n\n    if (isInlineData(data) && isInlineData(otherData)) {\n      if (deepEqual(data.values, otherData.values)) {\n        return other;\n      }\n    } else if (isUrlData(data) && isUrlData(otherData)) {\n      if (data.url === otherData.url) {\n        return other;\n      }\n    } else if (isNamedData(data)) {\n      if (data.name === other.dataName) {\n        return other;\n      }\n    }\n  }\n  return null;\n}\n\nfunction parseRoot(model: Model, sources: SourceNode[]): DataFlowNode {\n  if (model.data || !model.parent) {\n    // if the model defines a data source or is the root, create a source node\n\n    if (model.data === null) {\n      // data: null means we should ignore the parent's data so we just create a new data source\n      const source = new SourceNode({values: []});\n      sources.push(source);\n      return source;\n    }\n\n    const existingSource = findSource(model.data, sources);\n\n    if (existingSource) {\n      if (!isGenerator(model.data)) {\n        existingSource.data.format = mergeDeep({}, model.data.format, existingSource.data.format);\n      }\n\n      // if the new source has a name but the existing one does not, we can set it\n      if (!existingSource.hasName() && model.data.name) {\n        existingSource.dataName = model.data.name;\n      }\n\n      return existingSource;\n    } else {\n      const source = new SourceNode(model.data);\n      sources.push(source);\n      return source;\n    }\n  } else {\n    // If we don't have a source defined (overriding parent's data), use the parent's facet root or main.\n    return model.parent.component.data.facetRoot\n      ? model.parent.component.data.facetRoot\n      : model.parent.component.data.main;\n  }\n}\n\n/**\n * Parses a transform array into a chain of connected dataflow nodes.\n */\nexport function parseTransformArray(head: DataFlowNode, model: Model, ancestorParse: AncestorParse): DataFlowNode {\n  let lookupCounter = 0;\n\n  for (const t of model.transforms) {\n    let derivedType: ParseValue = undefined;\n    let transformNode: DataFlowNode;\n\n    if (isCalculate(t)) {\n      transformNode = head = new CalculateNode(head, t);\n      derivedType = 'derived';\n    } else if (isFilter(t)) {\n      const implicit = getImplicitFromFilterTransform(t);\n      transformNode = head = ParseNode.makeWithAncestors(head, {}, implicit, ancestorParse) ?? head;\n\n      head = new FilterNode(head, model, t.filter);\n    } else if (isBin(t)) {\n      transformNode = head = BinNode.makeFromTransform(head, t, model);\n      derivedType = 'number';\n    } else if (isTimeUnit(t)) {\n      derivedType = 'date';\n      const parsedAs = ancestorParse.getWithExplicit(t.field);\n      // Create parse node because the input to time unit is always date.\n      if (parsedAs.value === undefined) {\n        head = new ParseNode(head, {[t.field]: derivedType});\n        ancestorParse.set(t.field, derivedType, false);\n      }\n      transformNode = head = TimeUnitNode.makeFromTransform(head, t);\n    } else if (isAggregate(t)) {\n      transformNode = head = AggregateNode.makeFromTransform(head, t);\n      derivedType = 'number';\n      if (requiresSelectionId(model)) {\n        head = new IdentifierNode(head);\n      }\n    } else if (isLookup(t)) {\n      transformNode = head = LookupNode.make(head, model, t, lookupCounter++);\n      derivedType = 'derived';\n    } else if (isWindow(t)) {\n      transformNode = head = new WindowTransformNode(head, t);\n      derivedType = 'number';\n    } else if (isJoinAggregate(t)) {\n      transformNode = head = new JoinAggregateTransformNode(head, t);\n      derivedType = 'number';\n    } else if (isStack(t)) {\n      transformNode = head = StackNode.makeFromTransform(head, t);\n      derivedType = 'derived';\n    } else if (isFold(t)) {\n      transformNode = head = new FoldTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isFlatten(t)) {\n      transformNode = head = new FlattenTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isPivot(t)) {\n      transformNode = head = new PivotTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isSample(t)) {\n      head = new SampleTransformNode(head, t);\n    } else if (isImpute(t)) {\n      transformNode = head = ImputeNode.makeFromTransform(head, t);\n      derivedType = 'derived';\n    } else if (isDensity(t)) {\n      transformNode = head = new DensityTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isQuantile(t)) {\n      transformNode = head = new QuantileTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isRegression(t)) {\n      transformNode = head = new RegressionTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isLoess(t)) {\n      transformNode = head = new LoessTransformNode(head, t);\n      derivedType = 'derived';\n    } else {\n      log.warn(log.message.invalidTransformIgnored(t));\n      continue;\n    }\n\n    if (transformNode && derivedType !== undefined) {\n      for (const field of transformNode.producedFields() ?? []) {\n        ancestorParse.set(field, derivedType, false);\n      }\n    }\n  }\n\n  return head;\n}\n\n/*\nDescription of the dataflow (http://asciiflow.com/):\n     +--------+\n     | Source |\n     +---+----+\n         |\n         v\n     FormatParse\n     (explicit)\n         |\n         v\n     Transforms\n(Filter, Calculate, Binning, TimeUnit, Aggregate, Window, ...)\n         |\n         v\n     FormatParse\n     (implicit)\n         |\n         v\n Binning (in `encoding`)\n         |\n         v\n Timeunit (in `encoding`)\n         |\n         v\nFormula From Sort Array\n         |\n         v\n      +--+--+\n      | Raw |\n      +-----+\n         |\n         v\n  Aggregate (in `encoding`)\n         |\n         v\n  Stack (in `encoding`)\n         |\n         v\n  Invalid Filter\n         |\n         v\n   +----------+\n   |   Main   |\n   +----------+\n         |\n         v\n     +-------+\n     | Facet |----> \"column\", \"column-layout\", and \"row\"\n     +-------+\n         |\n         v\n  ...Child data...\n*/\n\nexport function parseData(model: Model): DataComponent {\n  let head = parseRoot(model, model.component.data.sources);\n\n  const {outputNodes, outputNodeRefCounts} = model.component.data;\n  const data = model.data;\n\n  const newData = data && (isGenerator(data) || isUrlData(data) || isInlineData(data));\n  const ancestorParse =\n    !newData && model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();\n\n  if (isGenerator(data)) {\n    // insert generator transform\n    if (isSequenceGenerator(data)) {\n      head = new SequenceNode(head, data.sequence);\n    } else if (isGraticuleGenerator(data)) {\n      head = new GraticuleNode(head, data.graticule);\n    }\n    // no parsing necessary for generator\n    ancestorParse.parseNothing = true;\n  } else if (data?.format?.parse === null) {\n    // format.parse: null means disable parsing\n    ancestorParse.parseNothing = true;\n  }\n\n  head = ParseNode.makeExplicit(head, model, ancestorParse) ?? head;\n\n  // Default discrete selections require an identifer transform to\n  // uniquely identify data points. Add this transform at the head of\n  // the pipeline such that the identifier field is available for all\n  // subsequent datasets. During optimization, we will remove this\n  // transform if it proves to be unnecessary. Additional identifier\n  // transforms will be necessary when new tuples are constructed\n  // (e.g., post-aggregation).\n  head = new IdentifierNode(head);\n\n  // HACK: This is equivalent for merging bin extent for union scale.\n  // FIXME(https://github.com/vega/vega-lite/issues/2270): Correctly merge extent / bin node for shared bin scale\n  const parentIsLayer = model.parent && isLayerModel(model.parent);\n  if (isUnitModel(model) || isFacetModel(model)) {\n    if (parentIsLayer) {\n      head = BinNode.makeFromEncoding(head, model) ?? head;\n    }\n  }\n\n  if (model.transforms.length > 0) {\n    head = parseTransformArray(head, model, ancestorParse);\n  }\n\n  // create parse nodes for fields that need to be parsed (or flattened) implicitly\n  const implicitSelection = getImplicitFromSelection(model);\n  const implicitEncoding = getImplicitFromEncoding(model);\n  head = ParseNode.makeWithAncestors(head, {}, {...implicitSelection, ...implicitEncoding}, ancestorParse) ?? head;\n\n  if (isUnitModel(model)) {\n    head = GeoJSONNode.parseAll(head, model);\n    head = GeoPointNode.parseAll(head, model);\n  }\n\n  if (isUnitModel(model) || isFacetModel(model)) {\n    if (!parentIsLayer) {\n      head = BinNode.makeFromEncoding(head, model) ?? head;\n    }\n\n    head = TimeUnitNode.makeFromEncoding(head, model) ?? head;\n    head = CalculateNode.parseAllForSortIndex(head, model);\n  }\n\n  // add an output node pre aggregation\n  const rawName = model.getDataName(DataSourceType.Raw);\n  const raw = new OutputNode(head, rawName, DataSourceType.Raw, outputNodeRefCounts);\n  outputNodes[rawName] = raw;\n  head = raw;\n\n  if (isUnitModel(model)) {\n    const agg = AggregateNode.makeFromEncoding(head, model);\n    if (agg) {\n      head = agg;\n\n      if (requiresSelectionId(model)) {\n        head = new IdentifierNode(head);\n      }\n    }\n    head = ImputeNode.makeFromEncoding(head, model) ?? head;\n    head = StackNode.makeFromEncoding(head, model) ?? head;\n  }\n\n  if (isUnitModel(model)) {\n    head = FilterInvalidNode.make(head, model) ?? head;\n  }\n\n  // output node for marks\n  const mainName = model.getDataName(DataSourceType.Main);\n  const main = new OutputNode(head, mainName, DataSourceType.Main, outputNodeRefCounts);\n  outputNodes[mainName] = main;\n  head = main;\n\n  if (isUnitModel(model)) {\n    materializeSelections(model, main);\n  }\n\n  // add facet marker\n  let facetRoot = null;\n  if (isFacetModel(model)) {\n    const facetName = model.getName('facet');\n\n    // Derive new aggregate for facet's sort field\n    // augment data source with new fields for crossed facet\n    head = makeJoinAggregateFromFacet(head, model.facet) ?? head;\n\n    facetRoot = new FacetNode(head, model, facetName, main.getSource());\n    outputNodes[facetName] = facetRoot;\n  }\n\n  return {\n    ...model.component.data,\n    outputNodes,\n    outputNodeRefCounts,\n    raw,\n    main,\n    facetRoot,\n    ancestorParse\n  };\n}\n"]},"metadata":{},"sourceType":"module"}