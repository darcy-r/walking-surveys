{"ast":null,"code":"import * as log from '../../log';\nimport { uniqueId } from '../../util';\n/**\n * A node in the dataflow tree.\n */\n\nexport class DataFlowNode {\n  constructor(parent, debugName) {\n    this.debugName = debugName;\n    this._children = [];\n    this._parent = null;\n\n    if (parent) {\n      this.parent = parent;\n    }\n  }\n  /**\n   * Clone this node with a deep copy but don't clone links to children or parents.\n   */\n\n\n  clone() {\n    throw new Error('Cannot clone node');\n  }\n\n  get parent() {\n    return this._parent;\n  }\n  /**\n   * Set the parent of the node and also add this node to the parent's children.\n   */\n\n\n  set parent(parent) {\n    this._parent = parent;\n\n    if (parent) {\n      parent.addChild(this);\n    }\n  }\n\n  get children() {\n    return this._children;\n  }\n\n  numChildren() {\n    return this._children.length;\n  }\n\n  addChild(child, loc) {\n    // do not add the same child twice\n    if (this._children.includes(child)) {\n      log.warn(log.message.ADD_SAME_CHILD_TWICE);\n      return;\n    }\n\n    if (loc !== undefined) {\n      this._children.splice(loc, 0, child);\n    } else {\n      this._children.push(child);\n    }\n  }\n\n  removeChild(oldChild) {\n    const loc = this._children.indexOf(oldChild);\n\n    this._children.splice(loc, 1);\n\n    return loc;\n  }\n  /**\n   * Remove node from the dataflow.\n   */\n\n\n  remove() {\n    let loc = this._parent.removeChild(this);\n\n    for (const child of this._children) {\n      // do not use the set method because we want to insert at a particular location\n      child._parent = this._parent;\n\n      this._parent.addChild(child, loc++);\n    }\n  }\n  /**\n   * Insert another node as a parent of this node.\n   */\n\n\n  insertAsParentOf(other) {\n    const parent = other.parent;\n    parent.removeChild(this);\n    this.parent = parent;\n    other.parent = this;\n  }\n\n  swapWithParent() {\n    const parent = this._parent;\n    const newParent = parent.parent; // reconnect the children\n\n    for (const child of this._children) {\n      child.parent = parent;\n    } // remove old links\n\n\n    this._children = []; // equivalent to removing every child link one by one\n\n    parent.removeChild(this);\n    parent.parent.removeChild(parent); // swap two nodes\n\n    this.parent = newParent;\n    parent.parent = this;\n  }\n\n}\nexport class OutputNode extends DataFlowNode {\n  /**\n   * @param source The name of the source. Will change in assemble.\n   * @param type The type of the output node.\n   * @param refCounts A global ref counter map.\n   */\n  constructor(parent, source, type, refCounts) {\n    super(parent, source);\n    this.type = type;\n    this.refCounts = refCounts;\n    this._source = this._name = source;\n\n    if (this.refCounts && !(this._name in this.refCounts)) {\n      this.refCounts[this._name] = 0;\n    }\n  }\n\n  clone() {\n    const cloneObj = new this.constructor();\n    cloneObj.debugName = `clone_${this.debugName}`;\n    cloneObj._source = this._source;\n    cloneObj._name = `clone_${this._name}`;\n    cloneObj.type = this.type;\n    cloneObj.refCounts = this.refCounts;\n    cloneObj.refCounts[cloneObj._name] = 0;\n    return cloneObj;\n  }\n\n  dependentFields() {\n    return new Set();\n  }\n\n  producedFields() {\n    return new Set();\n  }\n\n  hash() {\n    if (this._hash === undefined) {\n      this._hash = `Output ${uniqueId()}`;\n    }\n\n    return this._hash;\n  }\n  /**\n   * Request the datasource name and increase the ref counter.\n   *\n   * During the parsing phase, this will return the simple name such as 'main' or 'raw'.\n   * It is crucial to request the name from an output node to mark it as a required node.\n   * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.\n   *\n   * In the assemble phase, this will return the correct name.\n   */\n\n\n  getSource() {\n    this.refCounts[this._name]++;\n    return this._source;\n  }\n\n  isRequired() {\n    return !!this.refCounts[this._name];\n  }\n\n  setSource(source) {\n    this._source = source;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["log","uniqueId","DataFlowNode","constructor","parent","debugName","clone","Error","_parent","addChild","children","_children","numChildren","length","child","loc","includes","warn","message","ADD_SAME_CHILD_TWICE","undefined","splice","push","removeChild","oldChild","indexOf","remove","insertAsParentOf","other","swapWithParent","newParent","OutputNode","source","type","refCounts","_source","_name","cloneObj","dependentFields","Set","producedFields","hash","_hash","getSource","isRequired","setSource"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/data/dataflow.ts"],"sourcesContent":["import {DataSourceType} from '../../data';\nimport * as log from '../../log';\nimport {Dict, uniqueId} from '../../util';\n\n/**\n * A node in the dataflow tree.\n */\nexport abstract class DataFlowNode {\n  private _children: DataFlowNode[] = [];\n\n  private _parent: DataFlowNode = null;\n\n  protected _hash: string | number;\n\n  constructor(parent: DataFlowNode, public readonly debugName?: string) {\n    if (parent) {\n      this.parent = parent;\n    }\n  }\n\n  /**\n   * Clone this node with a deep copy but don't clone links to children or parents.\n   */\n  public clone(): DataFlowNode {\n    throw new Error('Cannot clone node');\n  }\n\n  /**\n   * Return a hash of the node.\n   */\n  public abstract hash(): string | number;\n\n  /**\n   * Set of fields that this node depends on.\n   */\n  public abstract dependentFields(): Set<string>;\n\n  /**\n   * Set of fields that are being created by this node.\n   */\n  public abstract producedFields(): Set<string>;\n\n  get parent() {\n    return this._parent;\n  }\n\n  /**\n   * Set the parent of the node and also add this node to the parent's children.\n   */\n  set parent(parent: DataFlowNode) {\n    this._parent = parent;\n    if (parent) {\n      parent.addChild(this);\n    }\n  }\n\n  get children() {\n    return this._children;\n  }\n\n  public numChildren() {\n    return this._children.length;\n  }\n\n  public addChild(child: DataFlowNode, loc?: number) {\n    // do not add the same child twice\n    if (this._children.includes(child)) {\n      log.warn(log.message.ADD_SAME_CHILD_TWICE);\n      return;\n    }\n\n    if (loc !== undefined) {\n      this._children.splice(loc, 0, child);\n    } else {\n      this._children.push(child);\n    }\n  }\n\n  public removeChild(oldChild: DataFlowNode) {\n    const loc = this._children.indexOf(oldChild);\n    this._children.splice(loc, 1);\n    return loc;\n  }\n\n  /**\n   * Remove node from the dataflow.\n   */\n  public remove() {\n    let loc = this._parent.removeChild(this);\n    for (const child of this._children) {\n      // do not use the set method because we want to insert at a particular location\n      child._parent = this._parent;\n      this._parent.addChild(child, loc++);\n    }\n  }\n\n  /**\n   * Insert another node as a parent of this node.\n   */\n  public insertAsParentOf(other: DataFlowNode) {\n    const parent = other.parent;\n    parent.removeChild(this);\n    this.parent = parent;\n    other.parent = this;\n  }\n\n  public swapWithParent() {\n    const parent = this._parent;\n    const newParent = parent.parent;\n\n    // reconnect the children\n    for (const child of this._children) {\n      child.parent = parent;\n    }\n\n    // remove old links\n    this._children = []; // equivalent to removing every child link one by one\n    parent.removeChild(this);\n    parent.parent.removeChild(parent);\n\n    // swap two nodes\n    this.parent = newParent;\n    parent.parent = this;\n  }\n}\n\nexport class OutputNode extends DataFlowNode {\n  private _source: string;\n\n  private _name: string;\n\n  public clone(): this {\n    const cloneObj = new (this.constructor as any)();\n    cloneObj.debugName = `clone_${this.debugName}`;\n    cloneObj._source = this._source;\n    cloneObj._name = `clone_${this._name}`;\n    cloneObj.type = this.type;\n    cloneObj.refCounts = this.refCounts;\n    cloneObj.refCounts[cloneObj._name] = 0;\n    return cloneObj;\n  }\n\n  /**\n   * @param source The name of the source. Will change in assemble.\n   * @param type The type of the output node.\n   * @param refCounts A global ref counter map.\n   */\n  constructor(\n    parent: DataFlowNode,\n    source: string,\n    public readonly type: DataSourceType,\n    private readonly refCounts: Dict<number>\n  ) {\n    super(parent, source);\n\n    this._source = this._name = source;\n\n    if (this.refCounts && !(this._name in this.refCounts)) {\n      this.refCounts[this._name] = 0;\n    }\n  }\n\n  public dependentFields() {\n    return new Set<string>();\n  }\n\n  public producedFields() {\n    return new Set<string>();\n  }\n\n  public hash() {\n    if (this._hash === undefined) {\n      this._hash = `Output ${uniqueId()}`;\n    }\n    return this._hash;\n  }\n\n  /**\n   * Request the datasource name and increase the ref counter.\n   *\n   * During the parsing phase, this will return the simple name such as 'main' or 'raw'.\n   * It is crucial to request the name from an output node to mark it as a required node.\n   * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.\n   *\n   * In the assemble phase, this will return the correct name.\n   */\n  public getSource() {\n    this.refCounts[this._name]++;\n    return this._source;\n  }\n\n  public isRequired(): boolean {\n    return !!this.refCounts[this._name];\n  }\n\n  public setSource(source: string) {\n    this._source = source;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}