{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { hasOwnProperty, isArray } from 'vega-util';\nimport { hasConditionalFieldOrDatumDef, isConditionalDef, isFieldDef, isFieldOrDatumDef, isRepeatRef, isSortableFieldDef } from '../channeldef';\nimport * as log from '../log';\nimport { isSortField } from '../sort';\nimport { isFacetMapping } from '../spec/facet';\nexport function replaceRepeaterInFacet(facet, repeater) {\n  if (!repeater) {\n    return facet;\n  }\n\n  if (isFacetMapping(facet)) {\n    return replaceRepeaterInMapping(facet, repeater);\n  }\n\n  return replaceRepeaterInFieldDef(facet, repeater);\n}\nexport function replaceRepeaterInEncoding(encoding, repeater) {\n  if (!repeater) {\n    return encoding;\n  }\n\n  return replaceRepeaterInMapping(encoding, repeater);\n}\n/**\n * Replaces repeated value and returns if the repeated value is valid.\n */\n\nfunction replaceRepeatInProp(prop, o, repeater) {\n  const val = o[prop];\n\n  if (isRepeatRef(val)) {\n    if (val.repeat in repeater) {\n      return Object.assign(Object.assign({}, o), {\n        [prop]: repeater[val.repeat]\n      });\n    } else {\n      log.warn(log.message.noSuchRepeatedValue(val.repeat));\n      return undefined;\n    }\n  }\n\n  return o;\n}\n/**\n * Replace repeater values in a field def with the concrete field name.\n */\n\n\nfunction replaceRepeaterInFieldDef(fieldDef, repeater) {\n  fieldDef = replaceRepeatInProp('field', fieldDef, repeater);\n\n  if (fieldDef === undefined) {\n    // the field def should be ignored\n    return undefined;\n  } else if (fieldDef === null) {\n    return null;\n  }\n\n  if (isSortableFieldDef(fieldDef) && isSortField(fieldDef.sort)) {\n    const sort = replaceRepeatInProp('field', fieldDef.sort, repeater);\n    fieldDef = Object.assign(Object.assign({}, fieldDef), sort ? {\n      sort\n    } : {});\n  }\n\n  return fieldDef;\n}\n\nfunction replaceRepeaterInFieldOrDatumDef(def, repeater) {\n  if (isFieldDef(def)) {\n    return replaceRepeaterInFieldDef(def, repeater);\n  } else {\n    const datumDef = replaceRepeatInProp('datum', def, repeater);\n\n    if (datumDef !== def && !datumDef.type) {\n      datumDef.type = 'nominal';\n    }\n\n    return datumDef;\n  }\n}\n\nfunction replaceRepeaterInChannelDef(channelDef, repeater) {\n  if (isFieldOrDatumDef(channelDef)) {\n    const fd = replaceRepeaterInFieldOrDatumDef(channelDef, repeater);\n\n    if (fd) {\n      return fd;\n    } else if (isConditionalDef(channelDef)) {\n      return {\n        condition: channelDef.condition\n      };\n    }\n  } else {\n    if (hasConditionalFieldOrDatumDef(channelDef)) {\n      const fd = replaceRepeaterInFieldOrDatumDef(channelDef.condition, repeater);\n\n      if (fd) {\n        return Object.assign(Object.assign({}, channelDef), {\n          condition: fd\n        });\n      } else {\n        const {\n          condition\n        } = channelDef,\n              channelDefWithoutCondition = __rest(channelDef, [\"condition\"]);\n\n        return channelDefWithoutCondition;\n      }\n    }\n\n    return channelDef;\n  }\n\n  return undefined;\n}\n\nfunction replaceRepeaterInMapping(mapping, repeater) {\n  const out = {};\n\n  for (const channel in mapping) {\n    if (hasOwnProperty(mapping, channel)) {\n      const channelDef = mapping[channel];\n\n      if (isArray(channelDef)) {\n        // array cannot have condition\n        out[channel] = channelDef // somehow we need to cast it here\n        .map(cd => replaceRepeaterInChannelDef(cd, repeater)).filter(cd => cd);\n      } else {\n        const cd = replaceRepeaterInChannelDef(channelDef, repeater);\n\n        if (cd !== undefined) {\n          out[channel] = cd;\n        }\n      }\n    }\n  }\n\n  return out;\n}","map":{"version":3,"mappings":"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","names":["hasOwnProperty","isArray","hasConditionalFieldOrDatumDef","isConditionalDef","isFieldDef","isFieldOrDatumDef","isRepeatRef","isSortableFieldDef","log","isSortField","isFacetMapping","replaceRepeaterInFacet","facet","repeater","replaceRepeaterInMapping","replaceRepeaterInFieldDef","replaceRepeaterInEncoding","encoding","replaceRepeatInProp","prop","o","val","repeat","warn","message","noSuchRepeatedValue","undefined","fieldDef","sort","replaceRepeaterInFieldOrDatumDef","def","datumDef","type","replaceRepeaterInChannelDef","channelDef","fd","condition","Object","channelDefWithoutCondition","mapping","out","channel","map","cd","filter"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/normalize/repeater.ts"],"sourcesContent":["import {hasOwnProperty, isArray} from 'vega-util';\nimport {\n  ChannelDef,\n  DatumDef,\n  Field,\n  FieldDef,\n  FieldName,\n  hasConditionalFieldOrDatumDef,\n  isConditionalDef,\n  isFieldDef,\n  isFieldOrDatumDef,\n  isRepeatRef,\n  isSortableFieldDef,\n  ScaleFieldDef,\n  ValueDef\n} from '../channeldef';\nimport {Encoding} from '../encoding';\nimport * as log from '../log';\nimport {isSortField} from '../sort';\nimport {FacetFieldDef, FacetMapping, isFacetMapping} from '../spec/facet';\n\nexport interface RepeaterValue {\n  row?: string;\n  column?: string;\n\n  repeat?: string;\n\n  layer?: string;\n}\n\nexport function replaceRepeaterInFacet(\n  facet: FacetFieldDef<Field> | FacetMapping<Field>,\n  repeater: RepeaterValue\n): FacetFieldDef<FieldName> | FacetMapping<FieldName> {\n  if (!repeater) {\n    return facet as FacetFieldDef<FieldName>;\n  }\n\n  if (isFacetMapping(facet)) {\n    return replaceRepeaterInMapping(facet, repeater) as FacetMapping<FieldName>;\n  }\n  return replaceRepeaterInFieldDef(facet, repeater) as FacetFieldDef<FieldName>;\n}\n\nexport function replaceRepeaterInEncoding<E extends Encoding<Field>>(\n  encoding: E,\n  repeater: RepeaterValue\n): Encoding<FieldName> {\n  if (!repeater) {\n    return encoding as Encoding<FieldName>;\n  }\n\n  return replaceRepeaterInMapping(encoding, repeater) as Encoding<FieldName>;\n}\n\n/**\n * Replaces repeated value and returns if the repeated value is valid.\n */\nfunction replaceRepeatInProp<T>(prop: keyof T, o: T, repeater: RepeaterValue): T {\n  const val = o[prop];\n  if (isRepeatRef(val)) {\n    if (val.repeat in repeater) {\n      return {...o, [prop]: repeater[val.repeat]};\n    } else {\n      log.warn(log.message.noSuchRepeatedValue(val.repeat));\n      return undefined;\n    }\n  }\n  return o;\n}\n\n/**\n * Replace repeater values in a field def with the concrete field name.\n */\n\nfunction replaceRepeaterInFieldDef(fieldDef: FieldDef<Field>, repeater: RepeaterValue) {\n  fieldDef = replaceRepeatInProp('field', fieldDef, repeater);\n\n  if (fieldDef === undefined) {\n    // the field def should be ignored\n    return undefined;\n  } else if (fieldDef === null) {\n    return null;\n  }\n\n  if (isSortableFieldDef(fieldDef) && isSortField(fieldDef.sort)) {\n    const sort = replaceRepeatInProp('field', fieldDef.sort, repeater);\n    fieldDef = {\n      ...fieldDef,\n      ...(sort ? {sort} : {})\n    };\n  }\n\n  return fieldDef as ScaleFieldDef<FieldName>;\n}\n\nfunction replaceRepeaterInFieldOrDatumDef(def: FieldDef<Field> | DatumDef<Field>, repeater: RepeaterValue) {\n  if (isFieldDef(def)) {\n    return replaceRepeaterInFieldDef(def, repeater);\n  } else {\n    const datumDef = replaceRepeatInProp('datum', def, repeater);\n    if (datumDef !== def && !datumDef.type) {\n      datumDef.type = 'nominal';\n    }\n    return datumDef;\n  }\n}\n\nfunction replaceRepeaterInChannelDef(channelDef: ChannelDef<Field>, repeater: RepeaterValue) {\n  if (isFieldOrDatumDef(channelDef)) {\n    const fd = replaceRepeaterInFieldOrDatumDef(channelDef, repeater);\n    if (fd) {\n      return fd;\n    } else if (isConditionalDef<ChannelDef<Field>>(channelDef)) {\n      return {condition: channelDef.condition};\n    }\n  } else {\n    if (hasConditionalFieldOrDatumDef(channelDef)) {\n      const fd = replaceRepeaterInFieldOrDatumDef(channelDef.condition, repeater);\n      if (fd) {\n        return {\n          ...channelDef,\n          condition: fd\n        } as ChannelDef;\n      } else {\n        const {condition, ...channelDefWithoutCondition} = channelDef;\n        return channelDefWithoutCondition as ChannelDef;\n      }\n    }\n    return channelDef as ValueDef;\n  }\n  return undefined;\n}\n\ntype EncodingOrFacet<F extends Field> = Encoding<F> | FacetMapping<F>;\n\nfunction replaceRepeaterInMapping(\n  mapping: EncodingOrFacet<Field>,\n  repeater: RepeaterValue\n): EncodingOrFacet<FieldName> {\n  const out: EncodingOrFacet<FieldName> = {};\n  for (const channel in mapping) {\n    if (hasOwnProperty(mapping, channel)) {\n      const channelDef: ChannelDef<Field> | ChannelDef<Field>[] = mapping[channel];\n\n      if (isArray(channelDef)) {\n        // array cannot have condition\n        out[channel] = (channelDef as ChannelDef<Field>[]) // somehow we need to cast it here\n          .map(cd => replaceRepeaterInChannelDef(cd, repeater))\n          .filter(cd => cd);\n      } else {\n        const cd = replaceRepeaterInChannelDef(channelDef, repeater);\n        if (cd !== undefined) {\n          out[channel] = cd;\n        }\n      }\n    }\n  }\n  return out;\n}\n"]},"metadata":{},"sourceType":"module"}