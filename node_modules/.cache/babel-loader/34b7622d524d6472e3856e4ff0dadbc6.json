{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isSelectionParameter } from './selection';\nexport function assembleParameterSignals(params) {\n  const signals = [];\n\n  for (const param of params || []) {\n    // Selection parameters are handled separately via assembleSelectionTopLevelSignals\n    // and assembleSignals methods registered on the Model.\n    if (isSelectionParameter(param)) continue;\n\n    const {\n      expr,\n      bind\n    } = param,\n          rest = __rest(param, [\"expr\", \"bind\"]);\n\n    if (bind && expr) {\n      // Vega's InitSignal -- apply expr to \"init\"\n      const signal = Object.assign(Object.assign({}, rest), {\n        bind,\n        init: expr\n      });\n      signals.push(signal);\n    } else {\n      const signal = Object.assign(Object.assign(Object.assign({}, rest), expr ? {\n        update: expr\n      } : {}), bind ? {\n        bind\n      } : {});\n      signals.push(signal);\n    }\n  }\n\n  return signals;\n}","map":{"version":3,"mappings":";;;;;;;;;;;AACA,SAAQA,oBAAR,QAA+D,aAA/D;AA4BA,OAAM,SAAUC,wBAAV,CAAmCC,MAAnC,EAA6F;EACjG,MAAMC,OAAO,GAA+B,EAA5C;;EACA,KAAK,MAAMC,KAAX,IAAoBF,MAAM,IAAI,EAA9B,EAAkC;IAChC;IACA;IACA,IAAIF,oBAAoB,CAACI,KAAD,CAAxB,EAAiC;;IACjC,MAAM;MAACC,IAAD;MAAOC;IAAP,IAAwBF,KAA9B;IAAA,MAAsBG,IAAI,UAAIH,KAAJ,EAApB,gBAAoB,CAA1B;;IAEA,IAAIE,IAAI,IAAID,IAAZ,EAAkB;MAChB;MACA,MAAMG,MAAM,mCACPD,IADO,GACH;QACPD,IADO;QAEPG,IAAI,EAAEJ;MAFC,CADG,CAAZ;MAKAF,OAAO,CAACO,IAAR,CAAaF,MAAb;IACD,CARD,MAQO;MACL,MAAMA,MAAM,iDACPD,IADO,GAENF,IAAI,GAAG;QAACM,MAAM,EAAEN;MAAT,CAAH,GAAoB,EAFlB,GAGNC,IAAI,GAAG;QAACA;MAAD,CAAH,GAAY,EAHV,CAAZ;MAKAH,OAAO,CAACO,IAAR,CAAaF,MAAb;IACD;EACF;;EACD,OAAOL,OAAP;AACD","names":["isSelectionParameter","assembleParameterSignals","params","signals","param","expr","bind","rest","signal","init","push","update"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/parameter.ts"],"sourcesContent":["import {Binding, Expr, InitSignal, NewSignal} from 'vega';\nimport {isSelectionParameter, TopLevelSelectionParameter} from './selection';\n\nexport type ParameterName = string;\n\nexport interface VariableParameter {\n  /**\n   * A unique name for the variable parameter. Parameter names should be valid JavaScript identifiers: they should contain only alphanumeric characters (or \"$\", or \"_\") and may not start with a digit. Reserved keywords that may not be used as parameter names are \"datum\", \"event\", \"item\", and \"parent\".\n   */\n  name: ParameterName;\n\n  /**\n   * The [initial value](http://vega.github.io/vega-lite/docs/value.html) of the parameter.\n   *\n   * __Default value:__ `undefined`\n   */\n  value?: any;\n\n  /**\n   * An expression for the value of the parameter. This expression may include other parameters, in which case the parameter will automatically update in response to upstream parameter changes.\n   */\n  expr?: Expr;\n\n  /**\n   * Binds the parameter to an external input element such as a slider, selection list or radio button group.\n   */\n  bind?: Binding;\n}\n\nexport function assembleParameterSignals(params: (VariableParameter | TopLevelSelectionParameter)[]) {\n  const signals: (NewSignal | InitSignal)[] = [];\n  for (const param of params || []) {\n    // Selection parameters are handled separately via assembleSelectionTopLevelSignals\n    // and assembleSignals methods registered on the Model.\n    if (isSelectionParameter(param)) continue;\n    const {expr, bind, ...rest} = param;\n\n    if (bind && expr) {\n      // Vega's InitSignal -- apply expr to \"init\"\n      const signal: InitSignal = {\n        ...rest,\n        bind,\n        init: expr\n      };\n      signals.push(signal);\n    } else {\n      const signal: NewSignal = {\n        ...rest,\n        ...(expr ? {update: expr} : {}),\n        ...(bind ? {bind} : {})\n      };\n      signals.push(signal);\n    }\n  }\n  return signals;\n}\n"]},"metadata":{},"sourceType":"module"}