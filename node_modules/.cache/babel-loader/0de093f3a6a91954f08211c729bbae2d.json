{"ast":null,"code":"import { parseSelector } from 'vega-event-selector';\nimport { array, isObject, isString, stringValue } from 'vega-util';\nimport { selectionCompilers, STORE } from '.';\nimport { warn } from '../../log';\nimport { duplicate, entries, replacePathInField, varName } from '../../util';\nimport { OutputNode } from '../data/dataflow';\nimport { FilterNode } from '../data/filter';\nimport { DataSourceType } from '../../data';\nexport function parseUnitSelection(model, selDefs) {\n  var _a;\n\n  const selCmpts = {};\n  const selectionConfig = model.config.selection;\n  if (!selDefs || !selDefs.length) return selCmpts;\n\n  for (const def of selDefs) {\n    const name = varName(def.name);\n    const selDef = def.select;\n    const type = isString(selDef) ? selDef : selDef.type;\n    const defaults = isObject(selDef) ? duplicate(selDef) : {\n      type\n    }; // Set default values from config if a property hasn't been specified,\n    // or if it is true. E.g., \"translate\": true should use the default\n    // event handlers for translate. However, true may be a valid value for\n    // a property (e.g., \"nearest\": true).\n\n    const cfg = selectionConfig[type];\n\n    for (const key in cfg) {\n      // Project transform applies its defaults.\n      if (key === 'fields' || key === 'encodings') {\n        continue;\n      }\n\n      if (key === 'mark') {\n        defaults[key] = Object.assign(Object.assign({}, cfg[key]), defaults[key]);\n      }\n\n      if (defaults[key] === undefined || defaults[key] === true) {\n        defaults[key] = (_a = cfg[key]) !== null && _a !== void 0 ? _a : defaults[key];\n      }\n    }\n\n    const selCmpt = selCmpts[name] = Object.assign(Object.assign({}, defaults), {\n      name,\n      type,\n      init: def.value,\n      bind: def.bind,\n      events: isString(defaults.on) ? parseSelector(defaults.on, 'scope') : array(duplicate(defaults.on))\n    });\n\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.parse) {\n        c.parse(model, selCmpt, def);\n      }\n    }\n  }\n\n  return selCmpts;\n}\nexport function parseSelectionPredicate(model, pred, dfnode) {\n  let datum = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'datum';\n  const name = isString(pred) ? pred : pred.param;\n  const vname = varName(name);\n  const store = stringValue(vname + STORE);\n  let selCmpt;\n\n  try {\n    selCmpt = model.getSelectionComponent(vname, name);\n  } catch (e) {\n    // If a selection isn't found, treat as a variable parameter and coerce to boolean.\n    return `!!${vname}`;\n  }\n\n  if (selCmpt.project.timeUnit) {\n    const child = dfnode !== null && dfnode !== void 0 ? dfnode : model.component.data.raw;\n    const tunode = selCmpt.project.timeUnit.clone();\n\n    if (child.parent) {\n      tunode.insertAsParentOf(child);\n    } else {\n      child.parent = tunode;\n    }\n  }\n\n  const test = `vlSelectionTest(${store}, ${datum}${selCmpt.resolve === 'global' ? ')' : `, ${stringValue(selCmpt.resolve)})`}`;\n  const length = `length(data(${store}))`;\n  return pred.empty === false ? `${length} && ${test}` : `!${length} || ${test}`;\n}\nexport function parseSelectionExtent(model, name, extent) {\n  const vname = varName(name);\n  const encoding = extent['encoding'];\n  let field = extent['field'];\n  let selCmpt;\n\n  try {\n    selCmpt = model.getSelectionComponent(vname, name);\n  } catch (e) {\n    // If a selection isn't found, treat it as a variable parameter.\n    return vname;\n  }\n\n  if (!encoding && !field) {\n    field = selCmpt.project.items[0].field;\n\n    if (selCmpt.project.items.length > 1) {\n      warn('A \"field\" or \"encoding\" must be specified when using a selection as a scale domain. ' + `Using \"field\": ${stringValue(field)}.`);\n    }\n  } else if (encoding && !field) {\n    const encodings = selCmpt.project.items.filter(p => p.channel === encoding);\n\n    if (!encodings.length || encodings.length > 1) {\n      field = selCmpt.project.items[0].field;\n      warn((!encodings.length ? 'No ' : 'Multiple ') + `matching ${stringValue(encoding)} encoding found for selection ${stringValue(extent.param)}. ` + `Using \"field\": ${stringValue(field)}.`);\n    } else {\n      field = encodings[0].field;\n    }\n  }\n\n  return `${selCmpt.name}[${stringValue(replacePathInField(field))}]`;\n}\nexport function materializeSelections(model, main) {\n  var _a;\n\n  for (const [selection, selCmpt] of entries((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n    const lookupName = model.getName(`lookup_${selection}`);\n    model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(new FilterNode(main, model, {\n      param: selection\n    }), lookupName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);\n  }\n}","map":{"version":3,"mappings":"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","names":["parseSelector","array","isObject","isString","stringValue","selectionCompilers","STORE","warn","duplicate","entries","replacePathInField","varName","OutputNode","FilterNode","DataSourceType","parseUnitSelection","model","selDefs","selCmpts","selectionConfig","config","selection","length","def","name","selDef","select","type","defaults","cfg","key","Object","undefined","_a","selCmpt","init","value","bind","events","on","c","defined","parse","parseSelectionPredicate","pred","dfnode","datum","param","vname","store","getSelectionComponent","e","project","timeUnit","child","component","data","raw","tunode","clone","parent","insertAsParentOf","test","resolve","empty","parseSelectionExtent","extent","encoding","field","items","encodings","filter","p","channel","materializeSelections","main","lookupName","getName","outputNodes","materialized","Lookup","outputNodeRefCounts"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/selection/parse.ts"],"sourcesContent":["import {parseSelector} from 'vega-event-selector';\nimport {array, isObject, isString, stringValue} from 'vega-util';\nimport {selectionCompilers, SelectionComponent, STORE} from '.';\nimport {warn} from '../../log';\nimport {BaseSelectionConfig, SelectionParameter, ParameterExtent} from '../../selection';\nimport {Dict, duplicate, entries, replacePathInField, varName} from '../../util';\nimport {DataFlowNode, OutputNode} from '../data/dataflow';\nimport {FilterNode} from '../data/filter';\nimport {Model} from '../model';\nimport {UnitModel} from '../unit';\nimport {DataSourceType} from '../../data';\nimport {ParameterPredicate} from '../../predicate';\n\nexport function parseUnitSelection(model: UnitModel, selDefs: SelectionParameter[]) {\n  const selCmpts: Dict<SelectionComponent<any /* this has to be \"any\" so typing won't fail in test files*/>> = {};\n  const selectionConfig = model.config.selection;\n\n  if (!selDefs || !selDefs.length) return selCmpts;\n\n  for (const def of selDefs) {\n    const name = varName(def.name);\n    const selDef = def.select;\n    const type = isString(selDef) ? selDef : selDef.type;\n    const defaults: BaseSelectionConfig = isObject(selDef) ? duplicate(selDef) : {type};\n\n    // Set default values from config if a property hasn't been specified,\n    // or if it is true. E.g., \"translate\": true should use the default\n    // event handlers for translate. However, true may be a valid value for\n    // a property (e.g., \"nearest\": true).\n    const cfg = selectionConfig[type];\n    for (const key in cfg) {\n      // Project transform applies its defaults.\n      if (key === 'fields' || key === 'encodings') {\n        continue;\n      }\n\n      if (key === 'mark') {\n        defaults[key] = {...cfg[key], ...defaults[key]};\n      }\n\n      if (defaults[key] === undefined || defaults[key] === true) {\n        defaults[key] = cfg[key] ?? defaults[key];\n      }\n    }\n\n    const selCmpt: SelectionComponent<any> = (selCmpts[name] = {\n      ...defaults,\n      name,\n      type,\n      init: def.value,\n      bind: def.bind,\n      events: isString(defaults.on) ? parseSelector(defaults.on, 'scope') : array(duplicate(defaults.on))\n    } as any);\n\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.parse) {\n        c.parse(model, selCmpt, def);\n      }\n    }\n  }\n\n  return selCmpts;\n}\n\nexport function parseSelectionPredicate(\n  model: Model,\n  pred: ParameterPredicate,\n  dfnode?: DataFlowNode,\n  datum = 'datum'\n): string {\n  const name = isString(pred) ? pred : pred.param;\n  const vname = varName(name);\n  const store = stringValue(vname + STORE);\n  let selCmpt;\n\n  try {\n    selCmpt = model.getSelectionComponent(vname, name);\n  } catch (e) {\n    // If a selection isn't found, treat as a variable parameter and coerce to boolean.\n    return `!!${vname}`;\n  }\n\n  if (selCmpt.project.timeUnit) {\n    const child = dfnode ?? model.component.data.raw;\n    const tunode = selCmpt.project.timeUnit.clone();\n    if (child.parent) {\n      tunode.insertAsParentOf(child);\n    } else {\n      child.parent = tunode;\n    }\n  }\n\n  const test = `vlSelectionTest(${store}, ${datum}${\n    selCmpt.resolve === 'global' ? ')' : `, ${stringValue(selCmpt.resolve)})`\n  }`;\n  const length = `length(data(${store}))`;\n\n  return pred.empty === false ? `${length} && ${test}` : `!${length} || ${test}`;\n}\n\nexport function parseSelectionExtent(model: Model, name: string, extent: ParameterExtent) {\n  const vname = varName(name);\n  const encoding = extent['encoding'];\n  let field = extent['field'];\n  let selCmpt;\n\n  try {\n    selCmpt = model.getSelectionComponent(vname, name);\n  } catch (e) {\n    // If a selection isn't found, treat it as a variable parameter.\n    return vname;\n  }\n\n  if (!encoding && !field) {\n    field = selCmpt.project.items[0].field;\n    if (selCmpt.project.items.length > 1) {\n      warn(\n        'A \"field\" or \"encoding\" must be specified when using a selection as a scale domain. ' +\n          `Using \"field\": ${stringValue(field)}.`\n      );\n    }\n  } else if (encoding && !field) {\n    const encodings = selCmpt.project.items.filter(p => p.channel === encoding);\n    if (!encodings.length || encodings.length > 1) {\n      field = selCmpt.project.items[0].field;\n      warn(\n        (!encodings.length ? 'No ' : 'Multiple ') +\n          `matching ${stringValue(encoding)} encoding found for selection ${stringValue(extent.param)}. ` +\n          `Using \"field\": ${stringValue(field)}.`\n      );\n    } else {\n      field = encodings[0].field;\n    }\n  }\n\n  return `${selCmpt.name}[${stringValue(replacePathInField(field))}]`;\n}\n\nexport function materializeSelections(model: UnitModel, main: OutputNode) {\n  for (const [selection, selCmpt] of entries(model.component.selection ?? {})) {\n    const lookupName = model.getName(`lookup_${selection}`);\n    model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(\n      new FilterNode(main, model, {param: selection}),\n      lookupName,\n      DataSourceType.Lookup,\n      model.component.data.outputNodeRefCounts\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}