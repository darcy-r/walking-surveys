{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { parseSelector } from 'vega-event-selector';\nimport { identity, isArray, stringValue } from 'vega-util';\nimport { MODIFY, STORE, unitName, VL_SELECTION_RESOLVE, TUPLE, selectionCompilers } from '.';\nimport { dateTimeToExpr, isDateTime, dateTimeToTimestamp } from '../../datetime';\nimport { hasContinuousDomain } from '../../scale';\nimport { keys, stringify, vals } from '../../util';\nimport { isUnitModel } from '../model';\nimport { parseSelectionExtent } from './parse';\nexport function assembleInit(init) {\n  let isExpr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let wrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n\n  if (isArray(init)) {\n    const assembled = init.map(v => assembleInit(v, isExpr, wrap));\n    return isExpr ? `[${assembled.join(', ')}]` : assembled;\n  } else if (isDateTime(init)) {\n    if (isExpr) {\n      return wrap(dateTimeToExpr(init));\n    } else {\n      return wrap(dateTimeToTimestamp(init));\n    }\n  }\n\n  return isExpr ? wrap(stringify(init)) : init;\n}\nexport function assembleUnitSelectionSignals(model, signals) {\n  var _a;\n\n  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n    const name = selCmpt.name;\n    let modifyExpr = `${name}${TUPLE}, ${selCmpt.resolve === 'global' ? 'true' : `{unit: ${unitName(model)}}`}`;\n\n    for (const c of selectionCompilers) {\n      if (!c.defined(selCmpt)) continue;\n      if (c.signals) signals = c.signals(model, selCmpt, signals);\n      if (c.modifyExpr) modifyExpr = c.modifyExpr(model, selCmpt, modifyExpr);\n    }\n\n    signals.push({\n      name: name + MODIFY,\n      on: [{\n        events: {\n          signal: selCmpt.name + TUPLE\n        },\n        update: `modify(${stringValue(selCmpt.name + STORE)}, ${modifyExpr})`\n      }]\n    });\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleFacetSignals(model, signals) {\n  if (model.component.selection && keys(model.component.selection).length) {\n    const name = stringValue(model.getName('cell'));\n    signals.unshift({\n      name: 'facet',\n      value: {},\n      on: [{\n        events: parseSelector('mousemove', 'scope'),\n        update: `isTuple(facet) ? facet : group(${name}).datum`\n      }]\n    });\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleTopLevelSignals(model, signals) {\n  var _a;\n\n  let hasSelections = false;\n\n  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n    const name = selCmpt.name;\n    const store = stringValue(name + STORE);\n    const hasSg = signals.filter(s => s.name === name);\n\n    if (hasSg.length === 0) {\n      const resolve = selCmpt.resolve === 'global' ? 'union' : selCmpt.resolve;\n      const isPoint = selCmpt.type === 'point' ? ', true, true)' : ')';\n      signals.push({\n        name: selCmpt.name,\n        update: `${VL_SELECTION_RESOLVE}(${store}, ${stringValue(resolve)}${isPoint}`\n      });\n    }\n\n    hasSelections = true;\n\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.topLevelSignals) {\n        signals = c.topLevelSignals(model, selCmpt, signals);\n      }\n    }\n  }\n\n  if (hasSelections) {\n    const hasUnit = signals.filter(s => s.name === 'unit');\n\n    if (hasUnit.length === 0) {\n      signals.unshift({\n        name: 'unit',\n        value: {},\n        on: [{\n          events: 'mousemove',\n          update: 'isTuple(group()) ? group() : unit'\n        }]\n      });\n    }\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleUnitSelectionData(model, data) {\n  var _a;\n\n  const dataCopy = [...data];\n\n  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n    const init = {\n      name: selCmpt.name + STORE\n    };\n\n    if (selCmpt.init) {\n      const fields = selCmpt.project.items.map(proj => {\n        const {\n          signals\n        } = proj,\n              rest = __rest(proj, [\"signals\"]);\n\n        return rest;\n      });\n      init.values = selCmpt.init.map(i => ({\n        unit: unitName(model, {\n          escape: false\n        }),\n        fields,\n        values: assembleInit(i, false)\n      }));\n    }\n\n    const contains = dataCopy.filter(d => d.name === selCmpt.name + STORE);\n\n    if (!contains.length) {\n      dataCopy.push(init);\n    }\n  }\n\n  return dataCopy;\n}\nexport function assembleUnitSelectionMarks(model, marks) {\n  var _a;\n\n  for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.marks) {\n        marks = c.marks(model, selCmpt, marks);\n      }\n    }\n  }\n\n  return marks;\n}\nexport function assembleLayerSelectionMarks(model, marks) {\n  for (const child of model.children) {\n    if (isUnitModel(child)) {\n      marks = assembleUnitSelectionMarks(child, marks);\n    }\n  }\n\n  return marks;\n}\nexport function assembleSelectionScaleDomain(model, extent, scaleCmpt, domain) {\n  const parsedExtent = parseSelectionExtent(model, extent.param, extent);\n  return {\n    signal: hasContinuousDomain(scaleCmpt.get('type')) && isArray(domain) && domain[0] > domain[1] ? `isValid(${parsedExtent}) && reverse(${parsedExtent})` : parsedExtent\n  };\n}\n\nfunction cleanupEmptyOnArray(signals) {\n  return signals.map(s => {\n    if (s.on && !s.on.length) delete s.on;\n    return s;\n  });\n}","map":{"version":3,"mappings":"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","names":["parseSelector","identity","isArray","stringValue","MODIFY","STORE","unitName","VL_SELECTION_RESOLVE","TUPLE","selectionCompilers","dateTimeToExpr","isDateTime","dateTimeToTimestamp","hasContinuousDomain","keys","stringify","vals","isUnitModel","parseSelectionExtent","assembleInit","init","isExpr","wrap","assembled","map","v","join","assembleUnitSelectionSignals","model","signals","selCmpt","component","selection","_a","name","modifyExpr","resolve","c","defined","push","on","events","signal","update","cleanupEmptyOnArray","assembleFacetSignals","length","getName","unshift","value","assembleTopLevelSignals","hasSelections","store","hasSg","filter","s","isPoint","type","topLevelSignals","hasUnit","assembleUnitSelectionData","data","dataCopy","fields","project","items","proj","rest","values","i","unit","escape","contains","d","assembleUnitSelectionMarks","marks","assembleLayerSelectionMarks","child","children","assembleSelectionScaleDomain","extent","scaleCmpt","domain","parsedExtent","param","get"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/selection/assemble.ts"],"sourcesContent":["import {Signal, SignalRef} from 'vega';\nimport {parseSelector} from 'vega-event-selector';\nimport {identity, isArray, stringValue} from 'vega-util';\nimport {MODIFY, STORE, unitName, VL_SELECTION_RESOLVE, TUPLE, selectionCompilers} from '.';\nimport {dateTimeToExpr, isDateTime, dateTimeToTimestamp} from '../../datetime';\nimport {hasContinuousDomain} from '../../scale';\nimport {SelectionInit, SelectionInitInterval, ParameterExtent} from '../../selection';\nimport {keys, stringify, vals} from '../../util';\nimport {VgData, VgDomain} from '../../vega.schema';\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {isUnitModel, Model} from '../model';\nimport {ScaleComponent} from '../scale/component';\nimport {UnitModel} from '../unit';\nimport {parseSelectionExtent} from './parse';\n\nexport function assembleInit(\n  init: readonly (SelectionInit | readonly SelectionInit[] | SelectionInitInterval)[] | SelectionInit,\n  isExpr = true,\n  wrap: (str: string | number) => string | number = identity\n): any {\n  if (isArray(init)) {\n    const assembled = init.map(v => assembleInit(v, isExpr, wrap));\n    return isExpr ? `[${assembled.join(', ')}]` : assembled;\n  } else if (isDateTime(init)) {\n    if (isExpr) {\n      return wrap(dateTimeToExpr(init));\n    } else {\n      return wrap(dateTimeToTimestamp(init));\n    }\n  }\n  return isExpr ? wrap(stringify(init)) : init;\n}\n\nexport function assembleUnitSelectionSignals(model: UnitModel, signals: Signal[]) {\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    const name = selCmpt.name;\n    let modifyExpr = `${name}${TUPLE}, ${selCmpt.resolve === 'global' ? 'true' : `{unit: ${unitName(model)}}`}`;\n\n    for (const c of selectionCompilers) {\n      if (!c.defined(selCmpt)) continue;\n      if (c.signals) signals = c.signals(model, selCmpt, signals);\n      if (c.modifyExpr) modifyExpr = c.modifyExpr(model, selCmpt, modifyExpr);\n    }\n\n    signals.push({\n      name: name + MODIFY,\n      on: [\n        {\n          events: {signal: selCmpt.name + TUPLE},\n          update: `modify(${stringValue(selCmpt.name + STORE)}, ${modifyExpr})`\n        }\n      ]\n    });\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\n\nexport function assembleFacetSignals(model: FacetModel, signals: Signal[]) {\n  if (model.component.selection && keys(model.component.selection).length) {\n    const name = stringValue(model.getName('cell'));\n    signals.unshift({\n      name: 'facet',\n      value: {},\n      on: [\n        {\n          events: parseSelector('mousemove', 'scope'),\n          update: `isTuple(facet) ? facet : group(${name}).datum`\n        }\n      ]\n    });\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\n\nexport function assembleTopLevelSignals(model: UnitModel, signals: Signal[]) {\n  let hasSelections = false;\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    const name = selCmpt.name;\n    const store = stringValue(name + STORE);\n    const hasSg = signals.filter(s => s.name === name);\n    if (hasSg.length === 0) {\n      const resolve = selCmpt.resolve === 'global' ? 'union' : selCmpt.resolve;\n      const isPoint = selCmpt.type === 'point' ? ', true, true)' : ')';\n      signals.push({\n        name: selCmpt.name,\n        update: `${VL_SELECTION_RESOLVE}(${store}, ${stringValue(resolve)}${isPoint}`\n      });\n    }\n    hasSelections = true;\n\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.topLevelSignals) {\n        signals = c.topLevelSignals(model, selCmpt, signals);\n      }\n    }\n  }\n\n  if (hasSelections) {\n    const hasUnit = signals.filter(s => s.name === 'unit');\n    if (hasUnit.length === 0) {\n      signals.unshift({\n        name: 'unit',\n        value: {},\n        on: [{events: 'mousemove', update: 'isTuple(group()) ? group() : unit'}]\n      });\n    }\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\n\nexport function assembleUnitSelectionData(model: UnitModel, data: readonly VgData[]): VgData[] {\n  const dataCopy = [...data];\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    const init: VgData = {name: selCmpt.name + STORE};\n    if (selCmpt.init) {\n      const fields = selCmpt.project.items.map(proj => {\n        const {signals, ...rest} = proj;\n        return rest;\n      });\n\n      init.values = selCmpt.init.map(i => ({\n        unit: unitName(model, {escape: false}),\n        fields,\n        values: assembleInit(i, false)\n      }));\n    }\n    const contains = dataCopy.filter(d => d.name === selCmpt.name + STORE);\n    if (!contains.length) {\n      dataCopy.push(init);\n    }\n  }\n\n  return dataCopy;\n}\n\nexport function assembleUnitSelectionMarks(model: UnitModel, marks: any[]): any[] {\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.marks) {\n        marks = c.marks(model, selCmpt, marks);\n      }\n    }\n  }\n\n  return marks;\n}\n\nexport function assembleLayerSelectionMarks(model: LayerModel, marks: any[]): any[] {\n  for (const child of model.children) {\n    if (isUnitModel(child)) {\n      marks = assembleUnitSelectionMarks(child, marks);\n    }\n  }\n\n  return marks;\n}\n\nexport function assembleSelectionScaleDomain(\n  model: Model,\n  extent: ParameterExtent,\n  scaleCmpt: ScaleComponent,\n  domain: VgDomain\n): SignalRef {\n  const parsedExtent = parseSelectionExtent(model, extent.param, extent);\n\n  return {\n    signal:\n      hasContinuousDomain(scaleCmpt.get('type')) && isArray(domain) && domain[0] > domain[1]\n        ? `isValid(${parsedExtent}) && reverse(${parsedExtent})`\n        : parsedExtent\n  };\n}\n\nfunction cleanupEmptyOnArray(signals: Signal[]) {\n  return signals.map(s => {\n    if (s.on && !s.on.length) delete s.on;\n    return s;\n  });\n}\n"]},"metadata":{},"sourceType":"module"}