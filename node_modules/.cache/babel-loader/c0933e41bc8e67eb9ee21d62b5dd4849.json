{"ast":null,"code":"import { hasOwnProperty, isFunction, inherits, truthy, lruCache, isArray, error, toSet, array, peek, extend, isNumber, isObject } from 'vega-util';\nimport { curveBasis, curveBasisClosed, curveBasisOpen, curveBundle, curveCardinal, curveCardinalOpen, curveCardinalClosed, curveCatmullRom, curveCatmullRomClosed, curveCatmullRomOpen, curveLinear, curveLinearClosed, curveMonotoneY, curveMonotoneX, curveNatural, curveStep, curveStepAfter, curveStepBefore, arc as arc$2, area as area$2, line as line$2, symbol as symbol$2 } from 'd3-shape';\nimport { path as path$3 } from 'd3-path';\nexport { path } from 'd3-path';\nimport { image as image$1, canvas } from 'vega-canvas';\nimport { loader } from 'vega-loader';\nimport { isDiscrete, domainCaption } from 'vega-scale';\nlet gradient_id = 0;\n\nfunction resetSVGGradientId() {\n  gradient_id = 0;\n}\n\nconst patternPrefix = 'p_';\n\nfunction isGradient(value) {\n  return value && value.gradient;\n}\n\nfunction gradientRef(g, defs, base) {\n  const type = g.gradient;\n  let id = g.id,\n      prefix = type === 'radial' ? patternPrefix : ''; // check id, assign default values as needed\n\n  if (!id) {\n    id = g.id = 'gradient_' + gradient_id++;\n\n    if (type === 'radial') {\n      g.x1 = get(g.x1, 0.5);\n      g.y1 = get(g.y1, 0.5);\n      g.r1 = get(g.r1, 0);\n      g.x2 = get(g.x2, 0.5);\n      g.y2 = get(g.y2, 0.5);\n      g.r2 = get(g.r2, 0.5);\n      prefix = patternPrefix;\n    } else {\n      g.x1 = get(g.x1, 0);\n      g.y1 = get(g.y1, 0);\n      g.x2 = get(g.x2, 1);\n      g.y2 = get(g.y2, 0);\n    }\n  } // register definition\n\n\n  defs[id] = g; // return url reference\n\n  return 'url(' + (base || '') + '#' + prefix + id + ')';\n}\n\nfunction get(val, def) {\n  return val != null ? val : def;\n}\n\nfunction Gradient(p0, p1) {\n  var stops = [],\n      gradient;\n  return gradient = {\n    gradient: 'linear',\n    x1: p0 ? p0[0] : 0,\n    y1: p0 ? p0[1] : 0,\n    x2: p1 ? p1[0] : 1,\n    y2: p1 ? p1[1] : 0,\n    stops: stops,\n    stop: function (offset, color) {\n      stops.push({\n        offset: offset,\n        color: color\n      });\n      return gradient;\n    }\n  };\n}\n\nconst lookup = {\n  'basis': {\n    curve: curveBasis\n  },\n  'basis-closed': {\n    curve: curveBasisClosed\n  },\n  'basis-open': {\n    curve: curveBasisOpen\n  },\n  'bundle': {\n    curve: curveBundle,\n    tension: 'beta',\n    value: 0.85\n  },\n  'cardinal': {\n    curve: curveCardinal,\n    tension: 'tension',\n    value: 0\n  },\n  'cardinal-open': {\n    curve: curveCardinalOpen,\n    tension: 'tension',\n    value: 0\n  },\n  'cardinal-closed': {\n    curve: curveCardinalClosed,\n    tension: 'tension',\n    value: 0\n  },\n  'catmull-rom': {\n    curve: curveCatmullRom,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'catmull-rom-closed': {\n    curve: curveCatmullRomClosed,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'catmull-rom-open': {\n    curve: curveCatmullRomOpen,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'linear': {\n    curve: curveLinear\n  },\n  'linear-closed': {\n    curve: curveLinearClosed\n  },\n  'monotone': {\n    horizontal: curveMonotoneY,\n    vertical: curveMonotoneX\n  },\n  'natural': {\n    curve: curveNatural\n  },\n  'step': {\n    curve: curveStep\n  },\n  'step-after': {\n    curve: curveStepAfter\n  },\n  'step-before': {\n    curve: curveStepBefore\n  }\n};\n\nfunction curves(type, orientation, tension) {\n  var entry = hasOwnProperty(lookup, type) && lookup[type],\n      curve = null;\n\n  if (entry) {\n    curve = entry.curve || entry[orientation || 'vertical'];\n\n    if (entry.tension && tension != null) {\n      curve = curve[entry.tension](tension);\n    }\n  }\n\n  return curve;\n}\n\nconst paramCounts = {\n  m: 2,\n  l: 2,\n  h: 1,\n  v: 1,\n  z: 0,\n  c: 6,\n  s: 4,\n  q: 4,\n  t: 2,\n  a: 7\n};\nconst commandPattern = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi;\nconst numberPattern = /^[+-]?(([0-9]*\\.[0-9]+)|([0-9]+\\.)|([0-9]+))([eE][+-]?[0-9]+)?/;\nconst spacePattern = /^((\\s+,?\\s*)|(,\\s*))/;\nconst flagPattern = /^[01]/;\n\nfunction parse(path) {\n  const commands = [];\n  const matches = path.match(commandPattern) || [];\n  matches.forEach(str => {\n    let cmd = str[0];\n    const type = cmd.toLowerCase(); // parse parameters\n\n    const paramCount = paramCounts[type];\n    const params = parseParams(type, paramCount, str.slice(1).trim());\n    const count = params.length; // error checking based on parameter count\n\n    if (count < paramCount || count && count % paramCount !== 0) {\n      throw Error('Invalid SVG path, incorrect parameter count');\n    } // register the command\n\n\n    commands.push([cmd, ...params.slice(0, paramCount)]); // exit now if we're done, also handles zero-param 'z'\n\n    if (count === paramCount) {\n      return;\n    } // handle implicit line-to\n\n\n    if (type === 'm') {\n      cmd = cmd === 'M' ? 'L' : 'l';\n    } // repeat command when given extended param list\n\n\n    for (let i = paramCount; i < count; i += paramCount) {\n      commands.push([cmd, ...params.slice(i, i + paramCount)]);\n    }\n  });\n  return commands;\n}\n\nfunction parseParams(type, paramCount, segment) {\n  const params = [];\n\n  for (let index = 0; paramCount && index < segment.length;) {\n    for (let i = 0; i < paramCount; ++i) {\n      const pattern = type === 'a' && (i === 3 || i === 4) ? flagPattern : numberPattern;\n      const match = segment.slice(index).match(pattern);\n\n      if (match === null) {\n        throw Error('Invalid SVG path, incorrect parameter type');\n      }\n\n      index += match[0].length;\n      params.push(+match[0]);\n      const ws = segment.slice(index).match(spacePattern);\n\n      if (ws !== null) {\n        index += ws[0].length;\n      }\n    }\n  }\n\n  return params;\n}\n\nconst DegToRad = Math.PI / 180;\nconst Epsilon = 1e-14;\nconst HalfPi = Math.PI / 2;\nconst Tau = Math.PI * 2;\nconst HalfSqrt3 = Math.sqrt(3) / 2;\nvar segmentCache = {};\nvar bezierCache = {};\nvar join = [].join; // Copied from Inkscape svgtopdf, thanks!\n\nfunction segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  const key = join.call(arguments);\n\n  if (segmentCache[key]) {\n    return segmentCache[key];\n  }\n\n  const th = rotateX * DegToRad;\n  const sin_th = Math.sin(th);\n  const cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  const py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  let pl = px * px / (rx * rx) + py * py / (ry * ry);\n\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  const a00 = cos_th / rx;\n  const a01 = sin_th / rx;\n  const a10 = -sin_th / ry;\n  const a11 = cos_th / ry;\n  const x0 = a00 * ox + a01 * oy;\n  const y0 = a10 * ox + a11 * oy;\n  const x1 = a00 * x + a01 * y;\n  const y1 = a10 * x + a11 * y;\n  const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);\n  let sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  let sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);\n  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);\n  const th0 = Math.atan2(y0 - yc, x0 - xc);\n  const th1 = Math.atan2(y1 - yc, x1 - xc);\n  let th_arc = th1 - th0;\n\n  if (th_arc < 0 && sweep === 1) {\n    th_arc += Tau;\n  } else if (th_arc > 0 && sweep === 0) {\n    th_arc -= Tau;\n  }\n\n  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 0.001)));\n  const result = [];\n\n  for (let i = 0; i < segs; ++i) {\n    const th2 = th0 + i * th_arc / segs;\n    const th3 = th0 + (i + 1) * th_arc / segs;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return segmentCache[key] = result;\n}\n\nfunction bezier(params) {\n  const key = join.call(params);\n\n  if (bezierCache[key]) {\n    return bezierCache[key];\n  }\n\n  var cx = params[0],\n      cy = params[1],\n      th0 = params[2],\n      th1 = params[3],\n      rx = params[4],\n      ry = params[5],\n      sin_th = params[6],\n      cos_th = params[7];\n  const a00 = cos_th * rx;\n  const a01 = -sin_th * ry;\n  const a10 = sin_th * rx;\n  const a11 = cos_th * ry;\n  const cos_th0 = Math.cos(th0);\n  const sin_th0 = Math.sin(th0);\n  const cos_th1 = Math.cos(th1);\n  const sin_th1 = Math.sin(th1);\n  const th_half = 0.5 * (th1 - th0);\n  const sin_th_h2 = Math.sin(th_half * 0.5);\n  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  const x1 = cx + cos_th0 - t * sin_th0;\n  const y1 = cy + sin_th0 + t * cos_th0;\n  const x3 = cx + cos_th1;\n  const y3 = cy + sin_th1;\n  const x2 = x3 + t * sin_th1;\n  const y2 = y3 - t * cos_th1;\n  return bezierCache[key] = [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];\n}\n\nconst temp = ['l', 0, 0, 0, 0, 0, 0, 0];\n\nfunction scale$1(current, sX, sY) {\n  const c = temp[0] = current[0];\n\n  if (c === 'a' || c === 'A') {\n    temp[1] = sX * current[1];\n    temp[2] = sY * current[2];\n    temp[3] = current[3];\n    temp[4] = current[4];\n    temp[5] = current[5];\n    temp[6] = sX * current[6];\n    temp[7] = sY * current[7];\n  } else if (c === 'h' || c === 'H') {\n    temp[1] = sX * current[1];\n  } else if (c === 'v' || c === 'V') {\n    temp[1] = sY * current[1];\n  } else {\n    for (var i = 1, n = current.length; i < n; ++i) {\n      temp[i] = (i % 2 == 1 ? sX : sY) * current[i];\n    }\n  }\n\n  return temp;\n}\n\nfunction pathRender(context, path, l, t, sX, sY) {\n  var current,\n      // current instruction\n  previous = null,\n      x = 0,\n      // current x\n  y = 0,\n      // current y\n  controlX = 0,\n      // current control point x\n  controlY = 0,\n      // current control point y\n  tempX,\n      tempY,\n      tempControlX,\n      tempControlY,\n      anchorX = 0,\n      anchorY = 0;\n  if (l == null) l = 0;\n  if (t == null) t = 0;\n  if (sX == null) sX = 1;\n  if (sY == null) sY = sX;\n  if (context.beginPath) context.beginPath();\n\n  for (var i = 0, len = path.length; i < len; ++i) {\n    current = path[i];\n\n    if (sX !== 1 || sY !== 1) {\n      current = scale$1(current, sX, sY);\n    }\n\n    switch (current[0]) {\n      // first letter\n      case 'l':\n        // lineto, relative\n        x += current[1];\n        y += current[2];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'L':\n        // lineto, absolute\n        x = current[1];\n        y = current[2];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'h':\n        // horizontal lineto, relative\n        x += current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'H':\n        // horizontal lineto, absolute\n        x = current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'v':\n        // vertical lineto, relative\n        y += current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'V':\n        // verical lineto, absolute\n        y = current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'm':\n        // moveTo, relative\n        x += current[1];\n        y += current[2];\n        anchorX = x;\n        anchorY = y;\n        context.moveTo(x + l, y + t);\n        break;\n\n      case 'M':\n        // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        anchorX = x;\n        anchorY = y;\n        context.moveTo(x + l, y + t);\n        break;\n\n      case 'c':\n        // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        context.bezierCurveTo(x + current[1] + l, // x1\n        y + current[2] + t, // y1\n        controlX + l, // x2\n        controlY + t, // y2\n        tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C':\n        // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        context.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);\n        break;\n\n      case 's':\n        // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4]; // calculate reflection of previous control points\n\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t); // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S':\n        // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4]; // calculate reflection of previous control points\n\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY; // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n\n        controlX = current[1];\n        controlY = current[2];\n        break;\n\n      case 'q':\n        // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        controlX = x + current[1];\n        controlY = y + current[2];\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'Q':\n        // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        context.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        break;\n\n      case 't':\n        // shorthand quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        } else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        } else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2]; // calculate reflection of previous control points\n\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'a':\n        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        x = anchorX;\n        y = anchorY;\n        context.closePath();\n        break;\n    }\n\n    previous = current;\n  }\n}\n\nfunction drawArc(context, x, y, coords) {\n  const seg = segments(coords[5], // end x\n  coords[6], // end y\n  coords[0], // radius x\n  coords[1], // radius y\n  coords[3], // large flag\n  coords[4], // sweep flag\n  coords[2], // rotation\n  x, y);\n\n  for (let i = 0; i < seg.length; ++i) {\n    const bez = bezier(seg[i]);\n    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);\n  }\n}\n\nconst Tan30 = 0.5773502691896257;\nconst builtins = {\n  'circle': {\n    draw: function (context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(r, 0);\n      context.arc(0, 0, r, 0, Tau);\n    }\n  },\n  'cross': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          s = r / 2.5;\n      context.moveTo(-r, -s);\n      context.lineTo(-r, s);\n      context.lineTo(-s, s);\n      context.lineTo(-s, r);\n      context.lineTo(s, r);\n      context.lineTo(s, s);\n      context.lineTo(r, s);\n      context.lineTo(r, -s);\n      context.lineTo(s, -s);\n      context.lineTo(s, -r);\n      context.lineTo(-s, -r);\n      context.lineTo(-s, -s);\n      context.closePath();\n    }\n  },\n  'diamond': {\n    draw: function (context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(-r, 0);\n      context.lineTo(0, -r);\n      context.lineTo(r, 0);\n      context.lineTo(0, r);\n      context.closePath();\n    }\n  },\n  'square': {\n    draw: function (context, size) {\n      var w = Math.sqrt(size),\n          x = -w / 2;\n      context.rect(x, x, w, w);\n    }\n  },\n  'arrow': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          s = r / 7,\n          t = r / 2.5,\n          v = r / 8;\n      context.moveTo(-s, r);\n      context.lineTo(s, r);\n      context.lineTo(s, -v);\n      context.lineTo(t, -v);\n      context.lineTo(0, -r);\n      context.lineTo(-t, -v);\n      context.lineTo(-s, -v);\n      context.closePath();\n    }\n  },\n  'wedge': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r,\n          o = h - r * Tan30,\n          b = r / 4;\n      context.moveTo(0, -h - o);\n      context.lineTo(-b, h - o);\n      context.lineTo(b, h - o);\n      context.closePath();\n    }\n  },\n  'triangle': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r,\n          o = h - r * Tan30;\n      context.moveTo(0, -h - o);\n      context.lineTo(-r, h - o);\n      context.lineTo(r, h - o);\n      context.closePath();\n    }\n  },\n  'triangle-up': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(0, -h);\n      context.lineTo(-r, h);\n      context.lineTo(r, h);\n      context.closePath();\n    }\n  },\n  'triangle-down': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(0, h);\n      context.lineTo(-r, -h);\n      context.lineTo(r, -h);\n      context.closePath();\n    }\n  },\n  'triangle-right': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(h, 0);\n      context.lineTo(-h, -r);\n      context.lineTo(-h, r);\n      context.closePath();\n    }\n  },\n  'triangle-left': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(-h, 0);\n      context.lineTo(h, -r);\n      context.lineTo(h, r);\n      context.closePath();\n    }\n  },\n  'stroke': {\n    draw: function (context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(-r, 0);\n      context.lineTo(r, 0);\n    }\n  }\n};\n\nfunction symbols(_) {\n  return hasOwnProperty(builtins, _) ? builtins[_] : customSymbol(_);\n}\n\nvar custom = {};\n\nfunction customSymbol(path) {\n  if (!hasOwnProperty(custom, path)) {\n    const parsed = parse(path);\n    custom[path] = {\n      draw: function (context, size) {\n        pathRender(context, parsed, 0, 0, Math.sqrt(size) / 2);\n      }\n    };\n  }\n\n  return custom[path];\n}\n\nconst C = 0.448084975506; // C = 1 - c\n\nfunction rectangleX(d) {\n  return d.x;\n}\n\nfunction rectangleY(d) {\n  return d.y;\n}\n\nfunction rectangleWidth(d) {\n  return d.width;\n}\n\nfunction rectangleHeight(d) {\n  return d.height;\n}\n\nfunction number(_) {\n  return typeof _ === 'function' ? _ : () => +_;\n}\n\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n}\n\nfunction vg_rect() {\n  var x = rectangleX,\n      y = rectangleY,\n      width = rectangleWidth,\n      height = rectangleHeight,\n      crTL = number(0),\n      crTR = crTL,\n      crBL = crTL,\n      crBR = crTL,\n      context = null;\n\n  function rectangle(_, x0, y0) {\n    var buffer,\n        x1 = x0 != null ? x0 : +x.call(this, _),\n        y1 = y0 != null ? y0 : +y.call(this, _),\n        w = +width.call(this, _),\n        h = +height.call(this, _),\n        s = Math.min(w, h) / 2,\n        tl = clamp(+crTL.call(this, _), 0, s),\n        tr = clamp(+crTR.call(this, _), 0, s),\n        bl = clamp(+crBL.call(this, _), 0, s),\n        br = clamp(+crBR.call(this, _), 0, s);\n    if (!context) context = buffer = path$3();\n\n    if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {\n      context.rect(x1, y1, w, h);\n    } else {\n      var x2 = x1 + w,\n          y2 = y1 + h;\n      context.moveTo(x1 + tl, y1);\n      context.lineTo(x2 - tr, y1);\n      context.bezierCurveTo(x2 - C * tr, y1, x2, y1 + C * tr, x2, y1 + tr);\n      context.lineTo(x2, y2 - br);\n      context.bezierCurveTo(x2, y2 - C * br, x2 - C * br, y2, x2 - br, y2);\n      context.lineTo(x1 + bl, y2);\n      context.bezierCurveTo(x1 + C * bl, y2, x1, y2 - C * bl, x1, y2 - bl);\n      context.lineTo(x1, y1 + tl);\n      context.bezierCurveTo(x1, y1 + C * tl, x1 + C * tl, y1, x1 + tl, y1);\n      context.closePath();\n    }\n\n    if (buffer) {\n      context = null;\n      return buffer + '' || null;\n    }\n  }\n\n  rectangle.x = function (_) {\n    if (arguments.length) {\n      x = number(_);\n      return rectangle;\n    } else {\n      return x;\n    }\n  };\n\n  rectangle.y = function (_) {\n    if (arguments.length) {\n      y = number(_);\n      return rectangle;\n    } else {\n      return y;\n    }\n  };\n\n  rectangle.width = function (_) {\n    if (arguments.length) {\n      width = number(_);\n      return rectangle;\n    } else {\n      return width;\n    }\n  };\n\n  rectangle.height = function (_) {\n    if (arguments.length) {\n      height = number(_);\n      return rectangle;\n    } else {\n      return height;\n    }\n  };\n\n  rectangle.cornerRadius = function (tl, tr, br, bl) {\n    if (arguments.length) {\n      crTL = number(tl);\n      crTR = tr != null ? number(tr) : crTL;\n      crBR = br != null ? number(br) : crTL;\n      crBL = bl != null ? number(bl) : crTR;\n      return rectangle;\n    } else {\n      return crTL;\n    }\n  };\n\n  rectangle.context = function (_) {\n    if (arguments.length) {\n      context = _ == null ? null : _;\n      return rectangle;\n    } else {\n      return context;\n    }\n  };\n\n  return rectangle;\n}\n\nfunction vg_trail() {\n  var x,\n      y,\n      size,\n      defined,\n      context = null,\n      ready,\n      x1,\n      y1,\n      r1;\n\n  function point(x2, y2, w2) {\n    const r2 = w2 / 2;\n\n    if (ready) {\n      var ux = y1 - y2,\n          uy = x2 - x1;\n\n      if (ux || uy) {\n        // get normal vector\n        var ud = Math.sqrt(ux * ux + uy * uy),\n            rx = (ux /= ud) * r1,\n            ry = (uy /= ud) * r1,\n            t = Math.atan2(uy, ux); // draw segment\n\n        context.moveTo(x1 - rx, y1 - ry);\n        context.lineTo(x2 - ux * r2, y2 - uy * r2);\n        context.arc(x2, y2, r2, t - Math.PI, t);\n        context.lineTo(x1 + rx, y1 + ry);\n        context.arc(x1, y1, r1, t, t + Math.PI);\n      } else {\n        context.arc(x2, y2, r2, 0, Tau);\n      }\n\n      context.closePath();\n    } else {\n      ready = 1;\n    }\n\n    x1 = x2;\n    y1 = y2;\n    r1 = r2;\n  }\n\n  function trail(data) {\n    var i,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer;\n    if (context == null) context = buffer = path$3();\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) ready = 0;\n      }\n\n      if (defined0) point(+x(d, i, data), +y(d, i, data), +size(d, i, data));\n    }\n\n    if (buffer) {\n      context = null;\n      return buffer + '' || null;\n    }\n  }\n\n  trail.x = function (_) {\n    if (arguments.length) {\n      x = _;\n      return trail;\n    } else {\n      return x;\n    }\n  };\n\n  trail.y = function (_) {\n    if (arguments.length) {\n      y = _;\n      return trail;\n    } else {\n      return y;\n    }\n  };\n\n  trail.size = function (_) {\n    if (arguments.length) {\n      size = _;\n      return trail;\n    } else {\n      return size;\n    }\n  };\n\n  trail.defined = function (_) {\n    if (arguments.length) {\n      defined = _;\n      return trail;\n    } else {\n      return defined;\n    }\n  };\n\n  trail.context = function (_) {\n    if (arguments.length) {\n      if (_ == null) {\n        context = null;\n      } else {\n        context = _;\n      }\n\n      return trail;\n    } else {\n      return context;\n    }\n  };\n\n  return trail;\n}\n\nfunction value$1(a, b) {\n  return a != null ? a : b;\n}\n\nconst x = item => item.x || 0,\n      y = item => item.y || 0,\n      w = item => item.width || 0,\n      h = item => item.height || 0,\n      xw = item => (item.x || 0) + (item.width || 0),\n      yh = item => (item.y || 0) + (item.height || 0),\n      sa = item => item.startAngle || 0,\n      ea = item => item.endAngle || 0,\n      pa = item => item.padAngle || 0,\n      ir = item => item.innerRadius || 0,\n      or = item => item.outerRadius || 0,\n      cr = item => item.cornerRadius || 0,\n      tl = item => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0,\n      tr = item => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0,\n      br = item => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0,\n      bl = item => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0,\n      sz = item => value$1(item.size, 64),\n      ts = item => item.size || 1,\n      def = item => !(item.defined === false),\n      type = item => symbols(item.shape || 'circle');\n\nconst arcShape = arc$2().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr),\n      areavShape = area$2().x(x).y1(y).y0(yh).defined(def),\n      areahShape = area$2().y(y).x1(x).x0(xw).defined(def),\n      lineShape = line$2().x(x).y(y).defined(def),\n      rectShape = vg_rect().x(x).y(y).width(w).height(h).cornerRadius(tl, tr, br, bl),\n      symbolShape = symbol$2().type(type).size(sz),\n      trailShape = vg_trail().x(x).y(y).defined(def).size(ts);\n\nfunction hasCornerRadius(item) {\n  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;\n}\n\nfunction arc$1(context, item) {\n  return arcShape.context(context)(item);\n}\n\nfunction area$1(context, items) {\n  const item = items[0],\n        interp = item.interpolate || 'linear';\n  return (item.orient === 'horizontal' ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context)(items);\n}\n\nfunction line$1(context, items) {\n  const item = items[0],\n        interp = item.interpolate || 'linear';\n  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context)(items);\n}\n\nfunction rectangle(context, item, x, y) {\n  return rectShape.context(context)(item, x, y);\n}\n\nfunction shape$1(context, item) {\n  return (item.mark.shape || item.shape).context(context)(item);\n}\n\nfunction symbol$1(context, item) {\n  return symbolShape.context(context)(item);\n}\n\nfunction trail$1(context, items) {\n  return trailShape.context(context)(items);\n}\n\nvar clip_id = 1;\n\nfunction resetSVGClipId() {\n  clip_id = 1;\n}\n\nfunction clip$1(renderer, item, size) {\n  var clip = item.clip,\n      defs = renderer._defs,\n      id = item.clip_id || (item.clip_id = 'clip' + clip_id++),\n      c = defs.clipping[id] || (defs.clipping[id] = {\n    id: id\n  });\n\n  if (isFunction(clip)) {\n    c.path = clip(null);\n  } else if (hasCornerRadius(size)) {\n    c.path = rectangle(null, size, 0, 0);\n  } else {\n    c.width = size.width || 0;\n    c.height = size.height || 0;\n  }\n\n  return 'url(#' + id + ')';\n}\n\nfunction Bounds(b) {\n  this.clear();\n  if (b) this.union(b);\n}\n\nBounds.prototype = {\n  clone() {\n    return new Bounds(this);\n  },\n\n  clear() {\n    this.x1 = +Number.MAX_VALUE;\n    this.y1 = +Number.MAX_VALUE;\n    this.x2 = -Number.MAX_VALUE;\n    this.y2 = -Number.MAX_VALUE;\n    return this;\n  },\n\n  empty() {\n    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;\n  },\n\n  equals(b) {\n    return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;\n  },\n\n  set(x1, y1, x2, y2) {\n    if (x2 < x1) {\n      this.x2 = x1;\n      this.x1 = x2;\n    } else {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    if (y2 < y1) {\n      this.y2 = y1;\n      this.y1 = y2;\n    } else {\n      this.y1 = y1;\n      this.y2 = y2;\n    }\n\n    return this;\n  },\n\n  add(x, y) {\n    if (x < this.x1) this.x1 = x;\n    if (y < this.y1) this.y1 = y;\n    if (x > this.x2) this.x2 = x;\n    if (y > this.y2) this.y2 = y;\n    return this;\n  },\n\n  expand(d) {\n    this.x1 -= d;\n    this.y1 -= d;\n    this.x2 += d;\n    this.y2 += d;\n    return this;\n  },\n\n  round() {\n    this.x1 = Math.floor(this.x1);\n    this.y1 = Math.floor(this.y1);\n    this.x2 = Math.ceil(this.x2);\n    this.y2 = Math.ceil(this.y2);\n    return this;\n  },\n\n  scale(s) {\n    this.x1 *= s;\n    this.y1 *= s;\n    this.x2 *= s;\n    this.y2 *= s;\n    return this;\n  },\n\n  translate(dx, dy) {\n    this.x1 += dx;\n    this.x2 += dx;\n    this.y1 += dy;\n    this.y2 += dy;\n    return this;\n  },\n\n  rotate(angle, x, y) {\n    const p = this.rotatedPoints(angle, x, y);\n    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);\n  },\n\n  rotatedPoints(angle, x, y) {\n    var {\n      x1,\n      y1,\n      x2,\n      y2\n    } = this,\n        cos = Math.cos(angle),\n        sin = Math.sin(angle),\n        cx = x - x * cos + y * sin,\n        cy = y - x * sin - y * cos;\n    return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];\n  },\n\n  union(b) {\n    if (b.x1 < this.x1) this.x1 = b.x1;\n    if (b.y1 < this.y1) this.y1 = b.y1;\n    if (b.x2 > this.x2) this.x2 = b.x2;\n    if (b.y2 > this.y2) this.y2 = b.y2;\n    return this;\n  },\n\n  intersect(b) {\n    if (b.x1 > this.x1) this.x1 = b.x1;\n    if (b.y1 > this.y1) this.y1 = b.y1;\n    if (b.x2 < this.x2) this.x2 = b.x2;\n    if (b.y2 < this.y2) this.y2 = b.y2;\n    return this;\n  },\n\n  encloses(b) {\n    return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;\n  },\n\n  alignsWith(b) {\n    return b && (this.x1 == b.x1 || this.x2 == b.x2 || this.y1 == b.y1 || this.y2 == b.y2);\n  },\n\n  intersects(b) {\n    return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);\n  },\n\n  contains(x, y) {\n    return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);\n  },\n\n  width() {\n    return this.x2 - this.x1;\n  },\n\n  height() {\n    return this.y2 - this.y1;\n  }\n\n};\n\nfunction Item(mark) {\n  this.mark = mark;\n  this.bounds = this.bounds || new Bounds();\n}\n\nfunction GroupItem(mark) {\n  Item.call(this, mark);\n  this.items = this.items || [];\n}\n\ninherits(GroupItem, Item);\n\nfunction ResourceLoader(customLoader) {\n  this._pending = 0;\n  this._loader = customLoader || loader();\n}\n\nfunction increment(loader) {\n  loader._pending += 1;\n}\n\nfunction decrement(loader) {\n  loader._pending -= 1;\n}\n\nResourceLoader.prototype = {\n  pending() {\n    return this._pending;\n  },\n\n  sanitizeURL(uri) {\n    const loader = this;\n    increment(loader);\n    return loader._loader.sanitize(uri, {\n      context: 'href'\n    }).then(opt => {\n      decrement(loader);\n      return opt;\n    }).catch(() => {\n      decrement(loader);\n      return null;\n    });\n  },\n\n  loadImage(uri) {\n    const loader = this,\n          Image = image$1();\n    increment(loader);\n    return loader._loader.sanitize(uri, {\n      context: 'image'\n    }).then(opt => {\n      const url = opt.href;\n      if (!url || !Image) throw {\n        url: url\n      };\n      const img = new Image(); // set crossOrigin only if cors is defined; empty string sets anonymous mode\n      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/crossOrigin\n\n      const cors = hasOwnProperty(opt, 'crossOrigin') ? opt.crossOrigin : 'anonymous';\n      if (cors != null) img.crossOrigin = cors; // attempt to load image resource\n\n      img.onload = () => decrement(loader);\n\n      img.onerror = () => decrement(loader);\n\n      img.src = url;\n      return img;\n    }).catch(e => {\n      decrement(loader);\n      return {\n        complete: false,\n        width: 0,\n        height: 0,\n        src: e && e.url || ''\n      };\n    });\n  },\n\n  ready() {\n    const loader = this;\n    return new Promise(accept => {\n      function poll(value) {\n        if (!loader.pending()) accept(value);else setTimeout(() => {\n          poll(true);\n        }, 10);\n      }\n\n      poll(false);\n    });\n  }\n\n};\n\nfunction boundStroke(bounds, item, miter) {\n  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {\n    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;\n    bounds.expand(sw + (miter ? miterAdjustment(item, sw) : 0));\n  }\n\n  return bounds;\n}\n\nfunction miterAdjustment(item, strokeWidth) {\n  // TODO: more sophisticated adjustment? Or miter support in boundContext?\n  return item.strokeJoin && item.strokeJoin !== 'miter' ? 0 : strokeWidth;\n}\n\nconst circleThreshold = Tau - 1e-8;\nlet bounds, lx, ly, rot, ma, mb, mc, md;\n\nconst add = (x, y) => bounds.add(x, y);\n\nconst addL = (x, y) => add(lx = x, ly = y);\n\nconst addX = x => add(x, bounds.y1);\n\nconst addY = y => add(bounds.x1, y);\n\nconst px = (x, y) => ma * x + mc * y;\n\nconst py = (x, y) => mb * x + md * y;\n\nconst addp = (x, y) => add(px(x, y), py(x, y));\n\nconst addpL = (x, y) => addL(px(x, y), py(x, y));\n\nfunction boundContext(_, deg) {\n  bounds = _;\n\n  if (deg) {\n    rot = deg * DegToRad;\n    ma = md = Math.cos(rot);\n    mb = Math.sin(rot);\n    mc = -mb;\n  } else {\n    ma = md = 1;\n    rot = mb = mc = 0;\n  }\n\n  return context$1;\n}\n\nconst context$1 = {\n  beginPath() {},\n\n  closePath() {},\n\n  moveTo: addpL,\n  lineTo: addpL,\n\n  rect(x, y, w, h) {\n    if (rot) {\n      addp(x + w, y);\n      addp(x + w, y + h);\n      addp(x, y + h);\n      addpL(x, y);\n    } else {\n      add(x + w, y + h);\n      addL(x, y);\n    }\n  },\n\n  quadraticCurveTo(x1, y1, x2, y2) {\n    const px1 = px(x1, y1),\n          py1 = py(x1, y1),\n          px2 = px(x2, y2),\n          py2 = py(x2, y2);\n    quadExtrema(lx, px1, px2, addX);\n    quadExtrema(ly, py1, py2, addY);\n    addL(px2, py2);\n  },\n\n  bezierCurveTo(x1, y1, x2, y2, x3, y3) {\n    const px1 = px(x1, y1),\n          py1 = py(x1, y1),\n          px2 = px(x2, y2),\n          py2 = py(x2, y2),\n          px3 = px(x3, y3),\n          py3 = py(x3, y3);\n    cubicExtrema(lx, px1, px2, px3, addX);\n    cubicExtrema(ly, py1, py2, py3, addY);\n    addL(px3, py3);\n  },\n\n  arc(cx, cy, r, sa, ea, ccw) {\n    sa += rot;\n    ea += rot; // store last point on path\n\n    lx = r * Math.cos(ea) + cx;\n    ly = r * Math.sin(ea) + cy;\n\n    if (Math.abs(ea - sa) > circleThreshold) {\n      // treat as full circle\n      add(cx - r, cy - r);\n      add(cx + r, cy + r);\n    } else {\n      const update = a => add(r * Math.cos(a) + cx, r * Math.sin(a) + cy);\n\n      let s, i; // sample end points\n\n      update(sa);\n      update(ea); // sample interior points aligned with 90 degrees\n\n      if (ea !== sa) {\n        sa = sa % Tau;\n        if (sa < 0) sa += Tau;\n        ea = ea % Tau;\n        if (ea < 0) ea += Tau;\n\n        if (ea < sa) {\n          ccw = !ccw; // flip direction\n\n          s = sa;\n          sa = ea;\n          ea = s; // swap end-points\n        }\n\n        if (ccw) {\n          ea -= Tau;\n          s = sa - sa % HalfPi;\n\n          for (i = 0; i < 4 && s > ea; ++i, s -= HalfPi) update(s);\n        } else {\n          s = sa - sa % HalfPi + HalfPi;\n\n          for (i = 0; i < 4 && s < ea; ++i, s = s + HalfPi) update(s);\n        }\n      }\n    }\n  }\n\n};\n\nfunction quadExtrema(x0, x1, x2, cb) {\n  const t = (x0 - x1) / (x0 + x2 - 2 * x1);\n  if (0 < t && t < 1) cb(x0 + (x1 - x0) * t);\n}\n\nfunction cubicExtrema(x0, x1, x2, x3, cb) {\n  const a = x3 - x0 + 3 * x1 - 3 * x2,\n        b = x0 + x2 - 2 * x1,\n        c = x0 - x1;\n  let t0 = 0,\n      t1 = 0,\n      r; // solve for parameter t\n\n  if (Math.abs(a) > Epsilon) {\n    // quadratic equation\n    r = b * b + c * a;\n\n    if (r >= 0) {\n      r = Math.sqrt(r);\n      t0 = (-b + r) / a;\n      t1 = (-b - r) / a;\n    }\n  } else {\n    // linear equation\n    t0 = 0.5 * c / b;\n  } // calculate position\n\n\n  if (0 < t0 && t0 < 1) cb(cubic(t0, x0, x1, x2, x3));\n  if (0 < t1 && t1 < 1) cb(cubic(t1, x0, x1, x2, x3));\n}\n\nfunction cubic(t, x0, x1, x2, x3) {\n  const s = 1 - t,\n        s2 = s * s,\n        t2 = t * t;\n  return s2 * s * x0 + 3 * s2 * t * x1 + 3 * s * t2 * x2 + t2 * t * x3;\n}\n\nvar context = (context = canvas(1, 1)) ? context.getContext('2d') : null;\nconst b = new Bounds();\n\nfunction intersectPath(draw) {\n  return function (item, brush) {\n    // rely on (inaccurate) bounds intersection if no context\n    if (!context) return true; // add path to offscreen graphics context\n\n    draw(context, item); // get bounds intersection region\n\n    b.clear().union(item.bounds).intersect(brush).round();\n    const {\n      x1,\n      y1,\n      x2,\n      y2\n    } = b; // iterate over intersection region\n    // perform fine grained inclusion test\n\n    for (let y = y1; y <= y2; ++y) {\n      for (let x = x1; x <= x2; ++x) {\n        if (context.isPointInPath(x, y)) {\n          return true;\n        }\n      }\n    } // false if no hits in intersection region\n\n\n    return false;\n  };\n}\n\nfunction intersectPoint(item, box) {\n  return box.contains(item.x || 0, item.y || 0);\n}\n\nfunction intersectRect(item, box) {\n  const x = item.x || 0,\n        y = item.y || 0,\n        w = item.width || 0,\n        h = item.height || 0;\n  return box.intersects(b.set(x, y, x + w, y + h));\n}\n\nfunction intersectRule(item, box) {\n  const x = item.x || 0,\n        y = item.y || 0,\n        x2 = item.x2 != null ? item.x2 : x,\n        y2 = item.y2 != null ? item.y2 : y;\n  return intersectBoxLine(box, x, y, x2, y2);\n}\n\nfunction intersectBoxLine(box, x, y, u, v) {\n  const {\n    x1,\n    y1,\n    x2,\n    y2\n  } = box,\n        dx = u - x,\n        dy = v - y;\n  let t0 = 0,\n      t1 = 1,\n      p,\n      q,\n      r,\n      e;\n\n  for (e = 0; e < 4; ++e) {\n    if (e === 0) {\n      p = -dx;\n      q = -(x1 - x);\n    }\n\n    if (e === 1) {\n      p = dx;\n      q = x2 - x;\n    }\n\n    if (e === 2) {\n      p = -dy;\n      q = -(y1 - y);\n    }\n\n    if (e === 3) {\n      p = dy;\n      q = y2 - y;\n    }\n\n    if (Math.abs(p) < 1e-10 && q < 0) return false;\n    r = q / p;\n\n    if (p < 0) {\n      if (r > t1) return false;else if (r > t0) t0 = r;\n    } else if (p > 0) {\n      if (r < t0) return false;else if (r < t1) t1 = r;\n    }\n  }\n\n  return true;\n}\n\nfunction blend(context, item) {\n  context.globalCompositeOperation = item.blend || 'source-over';\n}\n\nfunction value(value, dflt) {\n  return value == null ? dflt : value;\n}\n\nfunction addStops(gradient, stops) {\n  const n = stops.length;\n\n  for (let i = 0; i < n; ++i) {\n    gradient.addColorStop(stops[i].offset, stops[i].color);\n  }\n\n  return gradient;\n}\n\nfunction gradient(context, spec, bounds) {\n  const w = bounds.width(),\n        h = bounds.height();\n  let gradient;\n\n  if (spec.gradient === 'radial') {\n    gradient = context.createRadialGradient(bounds.x1 + value(spec.x1, 0.5) * w, bounds.y1 + value(spec.y1, 0.5) * h, Math.max(w, h) * value(spec.r1, 0), bounds.x1 + value(spec.x2, 0.5) * w, bounds.y1 + value(spec.y2, 0.5) * h, Math.max(w, h) * value(spec.r2, 0.5));\n  } else {\n    // linear gradient\n    const x1 = value(spec.x1, 0),\n          y1 = value(spec.y1, 0),\n          x2 = value(spec.x2, 1),\n          y2 = value(spec.y2, 0);\n\n    if (x1 === x2 || y1 === y2 || w === h) {\n      // axis aligned: use normal gradient\n      gradient = context.createLinearGradient(bounds.x1 + x1 * w, bounds.y1 + y1 * h, bounds.x1 + x2 * w, bounds.y1 + y2 * h);\n    } else {\n      // not axis aligned: render gradient into a pattern (#2365)\n      // this allows us to use normalized bounding box coordinates\n      const image = canvas(Math.ceil(w), Math.ceil(h)),\n            ictx = image.getContext('2d');\n      ictx.scale(w, h);\n      ictx.fillStyle = addStops(ictx.createLinearGradient(x1, y1, x2, y2), spec.stops);\n      ictx.fillRect(0, 0, w, h);\n      return context.createPattern(image, 'no-repeat');\n    }\n  }\n\n  return addStops(gradient, spec.stops);\n}\n\nfunction color(context, item, value) {\n  return isGradient(value) ? gradient(context, value, item.bounds) : value;\n}\n\nfunction fill(context, item, opacity) {\n  opacity *= item.fillOpacity == null ? 1 : item.fillOpacity;\n\n  if (opacity > 0) {\n    context.globalAlpha = opacity;\n    context.fillStyle = color(context, item, item.fill);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvar Empty = [];\n\nfunction stroke(context, item, opacity) {\n  var lw = (lw = item.strokeWidth) != null ? lw : 1;\n  if (lw <= 0) return false;\n  opacity *= item.strokeOpacity == null ? 1 : item.strokeOpacity;\n\n  if (opacity > 0) {\n    context.globalAlpha = opacity;\n    context.strokeStyle = color(context, item, item.stroke);\n    context.lineWidth = lw;\n    context.lineCap = item.strokeCap || 'butt';\n    context.lineJoin = item.strokeJoin || 'miter';\n    context.miterLimit = item.strokeMiterLimit || 10;\n\n    if (context.setLineDash) {\n      context.setLineDash(item.strokeDash || Empty);\n      context.lineDashOffset = item.strokeDashOffset || 0;\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction compare(a, b) {\n  return a.zindex - b.zindex || a.index - b.index;\n}\n\nfunction zorder(scene) {\n  if (!scene.zdirty) return scene.zitems;\n  var items = scene.items,\n      output = [],\n      item,\n      i,\n      n;\n\n  for (i = 0, n = items.length; i < n; ++i) {\n    item = items[i];\n    item.index = i;\n    if (item.zindex) output.push(item);\n  }\n\n  scene.zdirty = false;\n  return scene.zitems = output.sort(compare);\n}\n\nfunction visit(scene, visitor) {\n  var items = scene.items,\n      i,\n      n;\n  if (!items || !items.length) return;\n  const zitems = zorder(scene);\n\n  if (zitems && zitems.length) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      if (!items[i].zindex) visitor(items[i]);\n    }\n\n    items = zitems;\n  }\n\n  for (i = 0, n = items.length; i < n; ++i) {\n    visitor(items[i]);\n  }\n}\n\nfunction pickVisit(scene, visitor) {\n  var items = scene.items,\n      hit,\n      i;\n  if (!items || !items.length) return null;\n  const zitems = zorder(scene);\n  if (zitems && zitems.length) items = zitems;\n\n  for (i = items.length; --i >= 0;) {\n    if (hit = visitor(items[i])) return hit;\n  }\n\n  if (items === zitems) {\n    for (items = scene.items, i = items.length; --i >= 0;) {\n      if (!items[i].zindex) {\n        if (hit = visitor(items[i])) return hit;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction drawAll(path) {\n  return function (context, scene, bounds) {\n    visit(scene, item => {\n      if (!bounds || bounds.intersects(item.bounds)) {\n        drawPath(path, context, item, item);\n      }\n    });\n  };\n}\n\nfunction drawOne(path) {\n  return function (context, scene, bounds) {\n    if (scene.items.length && (!bounds || bounds.intersects(scene.bounds))) {\n      drawPath(path, context, scene.items[0], scene.items);\n    }\n  };\n}\n\nfunction drawPath(path, context, item, items) {\n  var opacity = item.opacity == null ? 1 : item.opacity;\n  if (opacity === 0) return;\n  if (path(context, items)) return;\n  blend(context, item);\n\n  if (item.fill && fill(context, item, opacity)) {\n    context.fill();\n  }\n\n  if (item.stroke && stroke(context, item, opacity)) {\n    context.stroke();\n  }\n}\n\nfunction pick$1(test) {\n  test = test || truthy;\n  return function (context, scene, x, y, gx, gy) {\n    x *= context.pixelRatio;\n    y *= context.pixelRatio;\n    return pickVisit(scene, item => {\n      const b = item.bounds; // first hit test against bounding box\n\n      if (b && !b.contains(gx, gy) || !b) return; // if in bounding box, perform more careful test\n\n      if (test(context, item, x, y, gx, gy)) return item;\n    });\n  };\n}\n\nfunction hitPath(path, filled) {\n  return function (context, o, x, y) {\n    var item = Array.isArray(o) ? o[0] : o,\n        fill = filled == null ? item.fill : filled,\n        stroke = item.stroke && context.isPointInStroke,\n        lw,\n        lc;\n\n    if (stroke) {\n      lw = item.strokeWidth;\n      lc = item.strokeCap;\n      context.lineWidth = lw != null ? lw : 1;\n      context.lineCap = lc != null ? lc : 'butt';\n    }\n\n    return path(context, o) ? false : fill && context.isPointInPath(x, y) || stroke && context.isPointInStroke(x, y);\n  };\n}\n\nfunction pickPath(path) {\n  return pick$1(hitPath(path));\n}\n\nfunction translate(x, y) {\n  return 'translate(' + x + ',' + y + ')';\n}\n\nfunction rotate(a) {\n  return 'rotate(' + a + ')';\n}\n\nfunction scale(scaleX, scaleY) {\n  return 'scale(' + scaleX + ',' + scaleY + ')';\n}\n\nfunction translateItem(item) {\n  return translate(item.x || 0, item.y || 0);\n}\n\nfunction rotateItem(item) {\n  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '');\n}\n\nfunction transformItem(item) {\n  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '') + (item.scaleX || item.scaleY ? ' ' + scale(item.scaleX || 1, item.scaleY || 1) : '');\n}\n\nfunction markItemPath(type, shape, isect) {\n  function attr(emit, item) {\n    emit('transform', rotateItem(item));\n    emit('d', shape(null, item));\n  }\n\n  function bound(bounds, item) {\n    shape(boundContext(bounds, item.angle), item);\n    return boundStroke(bounds, item).translate(item.x || 0, item.y || 0);\n  }\n\n  function draw(context, item) {\n    var x = item.x || 0,\n        y = item.y || 0,\n        a = item.angle || 0;\n    context.translate(x, y);\n    if (a) context.rotate(a *= DegToRad);\n    context.beginPath();\n    shape(context, item);\n    if (a) context.rotate(-a);\n    context.translate(-x, -y);\n  }\n\n  return {\n    type: type,\n    tag: 'path',\n    nested: false,\n    attr: attr,\n    bound: bound,\n    draw: drawAll(draw),\n    pick: pickPath(draw),\n    isect: isect || intersectPath(draw)\n  };\n}\n\nvar arc = markItemPath('arc', arc$1);\n\nfunction pickArea(a, p) {\n  var v = a[0].orient === 'horizontal' ? p[1] : p[0],\n      z = a[0].orient === 'horizontal' ? 'y' : 'x',\n      i = a.length,\n      min = +Infinity,\n      hit,\n      d;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    d = Math.abs(a[i][z] - v);\n\n    if (d < min) {\n      min = d;\n      hit = a[i];\n    }\n  }\n\n  return hit;\n}\n\nfunction pickLine(a, p) {\n  var t = Math.pow(a[0].strokeWidth || 1, 2),\n      i = a.length,\n      dx,\n      dy,\n      dd;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    dx = a[i].x - p[0];\n    dy = a[i].y - p[1];\n    dd = dx * dx + dy * dy;\n    if (dd < t) return a[i];\n  }\n\n  return null;\n}\n\nfunction pickTrail(a, p) {\n  var i = a.length,\n      dx,\n      dy,\n      dd;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    dx = a[i].x - p[0];\n    dy = a[i].y - p[1];\n    dd = dx * dx + dy * dy;\n    dx = a[i].size || 1;\n    if (dd < dx * dx) return a[i];\n  }\n\n  return null;\n}\n\nfunction markMultiItemPath(type, shape, tip) {\n  function attr(emit, item) {\n    var items = item.mark.items;\n    if (items.length) emit('d', shape(null, items));\n  }\n\n  function bound(bounds, mark) {\n    var items = mark.items;\n\n    if (items.length === 0) {\n      return bounds;\n    } else {\n      shape(boundContext(bounds), items);\n      return boundStroke(bounds, items[0]);\n    }\n  }\n\n  function draw(context, items) {\n    context.beginPath();\n    shape(context, items);\n  }\n\n  const hit = hitPath(draw);\n\n  function pick(context, scene, x, y, gx, gy) {\n    var items = scene.items,\n        b = scene.bounds;\n\n    if (!items || !items.length || b && !b.contains(gx, gy)) {\n      return null;\n    }\n\n    x *= context.pixelRatio;\n    y *= context.pixelRatio;\n    return hit(context, items, x, y) ? items[0] : null;\n  }\n\n  return {\n    type: type,\n    tag: 'path',\n    nested: true,\n    attr: attr,\n    bound: bound,\n    draw: drawOne(draw),\n    pick: pick,\n    isect: intersectPoint,\n    tip: tip\n  };\n}\n\nvar area = markMultiItemPath('area', area$1, pickArea);\n\nfunction clip(context, scene) {\n  var clip = scene.clip;\n  context.save();\n\n  if (isFunction(clip)) {\n    context.beginPath();\n    clip(context);\n    context.clip();\n  } else {\n    clipGroup(context, scene.group);\n  }\n}\n\nfunction clipGroup(context, group) {\n  context.beginPath();\n  hasCornerRadius(group) ? rectangle(context, group, 0, 0) : context.rect(0, 0, group.width || 0, group.height || 0);\n  context.clip();\n}\n\nfunction offset$1(item) {\n  const sw = value(item.strokeWidth, 1);\n  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;\n}\n\nfunction attr$5(emit, item) {\n  emit('transform', translateItem(item));\n}\n\nfunction emitRectangle(emit, item) {\n  const off = offset$1(item);\n  emit('d', rectangle(null, item, off, off));\n}\n\nfunction background(emit, item) {\n  emit('class', 'background');\n  emit('aria-hidden', true);\n  emitRectangle(emit, item);\n}\n\nfunction foreground(emit, item) {\n  emit('class', 'foreground');\n  emit('aria-hidden', true);\n\n  if (item.strokeForeground) {\n    emitRectangle(emit, item);\n  } else {\n    emit('d', '');\n  }\n}\n\nfunction content(emit, item, renderer) {\n  const url = item.clip ? clip$1(renderer, item, item) : null;\n  emit('clip-path', url);\n}\n\nfunction bound$5(bounds, group) {\n  if (!group.clip && group.items) {\n    const items = group.items,\n          m = items.length;\n\n    for (let j = 0; j < m; ++j) {\n      bounds.union(items[j].bounds);\n    }\n  }\n\n  if ((group.clip || group.width || group.height) && !group.noBound) {\n    bounds.add(0, 0).add(group.width || 0, group.height || 0);\n  }\n\n  boundStroke(bounds, group);\n  return bounds.translate(group.x || 0, group.y || 0);\n}\n\nfunction rectanglePath(context, group, x, y) {\n  const off = offset$1(group);\n  context.beginPath();\n  rectangle(context, group, (x || 0) + off, (y || 0) + off);\n}\n\nconst hitBackground = hitPath(rectanglePath);\nconst hitForeground = hitPath(rectanglePath, false);\nconst hitCorner = hitPath(rectanglePath, true);\n\nfunction draw$4(context, scene, bounds) {\n  visit(scene, group => {\n    const gx = group.x || 0,\n          gy = group.y || 0,\n          fore = group.strokeForeground,\n          opacity = group.opacity == null ? 1 : group.opacity; // draw group background\n\n    if ((group.stroke || group.fill) && opacity) {\n      rectanglePath(context, group, gx, gy);\n      blend(context, group);\n\n      if (group.fill && fill(context, group, opacity)) {\n        context.fill();\n      }\n\n      if (group.stroke && !fore && stroke(context, group, opacity)) {\n        context.stroke();\n      }\n    } // setup graphics context, set clip and bounds\n\n\n    context.save();\n    context.translate(gx, gy);\n    if (group.clip) clipGroup(context, group);\n    if (bounds) bounds.translate(-gx, -gy); // draw group contents\n\n    visit(group, item => {\n      this.draw(context, item, bounds);\n    }); // restore graphics context\n\n    if (bounds) bounds.translate(gx, gy);\n    context.restore(); // draw group foreground\n\n    if (fore && group.stroke && opacity) {\n      rectanglePath(context, group, gx, gy);\n      blend(context, group);\n\n      if (stroke(context, group, opacity)) {\n        context.stroke();\n      }\n    }\n  });\n}\n\nfunction pick(context, scene, x, y, gx, gy) {\n  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {\n    return null;\n  }\n\n  const cx = x * context.pixelRatio,\n        cy = y * context.pixelRatio;\n  return pickVisit(scene, group => {\n    let hit, dx, dy; // first hit test bounding box\n\n    const b = group.bounds;\n    if (b && !b.contains(gx, gy)) return; // passed bounds check, test rectangular clip\n\n    dx = group.x || 0;\n    dy = group.y || 0;\n    const dw = dx + (group.width || 0),\n          dh = dy + (group.height || 0),\n          c = group.clip;\n    if (c && (gx < dx || gx > dw || gy < dy || gy > dh)) return; // adjust coordinate system\n\n    context.save();\n    context.translate(dx, dy);\n    dx = gx - dx;\n    dy = gy - dy; // test background for rounded corner clip\n\n    if (c && hasCornerRadius(group) && !hitCorner(context, group, cx, cy)) {\n      context.restore();\n      return null;\n    }\n\n    const fore = group.strokeForeground,\n          ix = scene.interactive !== false; // hit test against group foreground\n\n    if (ix && fore && group.stroke && hitForeground(context, group, cx, cy)) {\n      context.restore();\n      return group;\n    } // hit test against contained marks\n\n\n    hit = pickVisit(group, mark => pickMark(mark, dx, dy) ? this.pick(mark, x, y, dx, dy) : null); // hit test against group background\n\n    if (!hit && ix && (group.fill || !fore && group.stroke) && hitBackground(context, group, cx, cy)) {\n      hit = group;\n    } // restore state and return\n\n\n    context.restore();\n    return hit || null;\n  });\n}\n\nfunction pickMark(mark, x, y) {\n  return (mark.interactive !== false || mark.marktype === 'group') && mark.bounds && mark.bounds.contains(x, y);\n}\n\nvar group = {\n  type: 'group',\n  tag: 'g',\n  nested: false,\n  attr: attr$5,\n  bound: bound$5,\n  draw: draw$4,\n  pick: pick,\n  isect: intersectRect,\n  content: content,\n  background: background,\n  foreground: foreground\n};\nvar metadata = {\n  'xmlns': 'http://www.w3.org/2000/svg',\n  'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n  'version': '1.1'\n};\n\nfunction getImage(item, renderer) {\n  var image = item.image;\n\n  if (!image || item.url && item.url !== image.url) {\n    image = {\n      complete: false,\n      width: 0,\n      height: 0\n    };\n    renderer.loadImage(item.url).then(image => {\n      item.image = image;\n      item.image.url = item.url;\n    });\n  }\n\n  return image;\n}\n\nfunction imageWidth(item, image) {\n  return item.width != null ? item.width : !image || !image.width ? 0 : item.aspect !== false && item.height ? item.height * image.width / image.height : image.width;\n}\n\nfunction imageHeight(item, image) {\n  return item.height != null ? item.height : !image || !image.height ? 0 : item.aspect !== false && item.width ? item.width * image.height / image.width : image.height;\n}\n\nfunction imageXOffset(align, w) {\n  return align === 'center' ? w / 2 : align === 'right' ? w : 0;\n}\n\nfunction imageYOffset(baseline, h) {\n  return baseline === 'middle' ? h / 2 : baseline === 'bottom' ? h : 0;\n}\n\nfunction attr$4(emit, item, renderer) {\n  const img = getImage(item, renderer),\n        w = imageWidth(item, img),\n        h = imageHeight(item, img),\n        x = (item.x || 0) - imageXOffset(item.align, w),\n        y = (item.y || 0) - imageYOffset(item.baseline, h),\n        i = !img.src && img.toDataURL ? img.toDataURL() : img.src || '';\n  emit('href', i, metadata['xmlns:xlink'], 'xlink:href');\n  emit('transform', translate(x, y));\n  emit('width', w);\n  emit('height', h);\n  emit('preserveAspectRatio', item.aspect === false ? 'none' : 'xMidYMid');\n}\n\nfunction bound$4(bounds, item) {\n  const img = item.image,\n        w = imageWidth(item, img),\n        h = imageHeight(item, img),\n        x = (item.x || 0) - imageXOffset(item.align, w),\n        y = (item.y || 0) - imageYOffset(item.baseline, h);\n  return bounds.set(x, y, x + w, y + h);\n}\n\nfunction draw$3(context, scene, bounds) {\n  visit(scene, item => {\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n\n    const img = getImage(item, this);\n    let w = imageWidth(item, img);\n    let h = imageHeight(item, img);\n    if (w === 0 || h === 0) return; // early exit\n\n    let x = (item.x || 0) - imageXOffset(item.align, w),\n        y = (item.y || 0) - imageYOffset(item.baseline, h),\n        opacity,\n        ar0,\n        ar1,\n        t;\n\n    if (item.aspect !== false) {\n      ar0 = img.width / img.height;\n      ar1 = item.width / item.height;\n\n      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {\n        if (ar1 < ar0) {\n          t = w / ar0;\n          y += (h - t) / 2;\n          h = t;\n        } else {\n          t = h * ar0;\n          x += (w - t) / 2;\n          w = t;\n        }\n      }\n    }\n\n    if (img.complete || img.toDataURL) {\n      blend(context, item);\n      context.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;\n      context.imageSmoothingEnabled = item.smooth !== false;\n      context.drawImage(img, x, y, w, h);\n    }\n  });\n}\n\nvar image = {\n  type: 'image',\n  tag: 'image',\n  nested: false,\n  attr: attr$4,\n  bound: bound$4,\n  draw: draw$3,\n  pick: pick$1(),\n  isect: truthy,\n  // bounds check is sufficient\n  get: getImage,\n  xOffset: imageXOffset,\n  yOffset: imageYOffset\n};\nvar line = markMultiItemPath('line', line$1, pickLine);\n\nfunction attr$3(emit, item) {\n  var sx = item.scaleX || 1,\n      sy = item.scaleY || 1;\n\n  if (sx !== 1 || sy !== 1) {\n    emit('vector-effect', 'non-scaling-stroke');\n  }\n\n  emit('transform', transformItem(item));\n  emit('d', item.path);\n}\n\nfunction path$1(context, item) {\n  var path = item.path;\n  if (path == null) return true;\n  var x = item.x || 0,\n      y = item.y || 0,\n      sx = item.scaleX || 1,\n      sy = item.scaleY || 1,\n      a = (item.angle || 0) * DegToRad,\n      cache = item.pathCache;\n\n  if (!cache || cache.path !== path) {\n    (item.pathCache = cache = parse(path)).path = path;\n  }\n\n  if (a && context.rotate && context.translate) {\n    context.translate(x, y);\n    context.rotate(a);\n    pathRender(context, cache, 0, 0, sx, sy);\n    context.rotate(-a);\n    context.translate(-x, -y);\n  } else {\n    pathRender(context, cache, x, y, sx, sy);\n  }\n}\n\nfunction bound$3(bounds, item) {\n  return path$1(boundContext(bounds, item.angle), item) ? bounds.set(0, 0, 0, 0) : boundStroke(bounds, item, true);\n}\n\nvar path$2 = {\n  type: 'path',\n  tag: 'path',\n  nested: false,\n  attr: attr$3,\n  bound: bound$3,\n  draw: drawAll(path$1),\n  pick: pickPath(path$1),\n  isect: intersectPath(path$1)\n};\n\nfunction attr$2(emit, item) {\n  emit('d', rectangle(null, item));\n}\n\nfunction bound$2(bounds, item) {\n  var x, y;\n  return boundStroke(bounds.set(x = item.x || 0, y = item.y || 0, x + item.width || 0, y + item.height || 0), item);\n}\n\nfunction draw$2(context, item) {\n  context.beginPath();\n  rectangle(context, item);\n}\n\nvar rect = {\n  type: 'rect',\n  tag: 'path',\n  nested: false,\n  attr: attr$2,\n  bound: bound$2,\n  draw: drawAll(draw$2),\n  pick: pickPath(draw$2),\n  isect: intersectRect\n};\n\nfunction attr$1(emit, item) {\n  emit('transform', translateItem(item));\n  emit('x2', item.x2 != null ? item.x2 - (item.x || 0) : 0);\n  emit('y2', item.y2 != null ? item.y2 - (item.y || 0) : 0);\n}\n\nfunction bound$1(bounds, item) {\n  var x1, y1;\n  return boundStroke(bounds.set(x1 = item.x || 0, y1 = item.y || 0, item.x2 != null ? item.x2 : x1, item.y2 != null ? item.y2 : y1), item);\n}\n\nfunction path(context, item, opacity) {\n  var x1, y1, x2, y2;\n\n  if (item.stroke && stroke(context, item, opacity)) {\n    x1 = item.x || 0;\n    y1 = item.y || 0;\n    x2 = item.x2 != null ? item.x2 : x1;\n    y2 = item.y2 != null ? item.y2 : y1;\n    context.beginPath();\n    context.moveTo(x1, y1);\n    context.lineTo(x2, y2);\n    return true;\n  }\n\n  return false;\n}\n\nfunction draw$1(context, scene, bounds) {\n  visit(scene, item => {\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n\n    var opacity = item.opacity == null ? 1 : item.opacity;\n\n    if (opacity && path(context, item, opacity)) {\n      blend(context, item);\n      context.stroke();\n    }\n  });\n}\n\nfunction hit$1(context, item, x, y) {\n  if (!context.isPointInStroke) return false;\n  return path(context, item, 1) && context.isPointInStroke(x, y);\n}\n\nvar rule = {\n  type: 'rule',\n  tag: 'line',\n  nested: false,\n  attr: attr$1,\n  bound: bound$1,\n  draw: draw$1,\n  pick: pick$1(hit$1),\n  isect: intersectRule\n};\nvar shape = markItemPath('shape', shape$1);\nvar symbol = markItemPath('symbol', symbol$1, intersectPoint);\nconst widthCache = lruCache();\nvar textMetrics = {\n  height: fontSize,\n  measureWidth: measureWidth,\n  estimateWidth: estimateWidth,\n  width: estimateWidth,\n  canvas: useCanvas\n};\nuseCanvas(true);\n\nfunction useCanvas(use) {\n  textMetrics.width = use && context ? measureWidth : estimateWidth;\n} // make simple estimate if no canvas is available\n\n\nfunction estimateWidth(item, text) {\n  return _estimateWidth(textValue(item, text), fontSize(item));\n}\n\nfunction _estimateWidth(text, currentFontHeight) {\n  return ~~(0.8 * text.length * currentFontHeight);\n} // measure text width if canvas is available\n\n\nfunction measureWidth(item, text) {\n  return fontSize(item) <= 0 || !(text = textValue(item, text)) ? 0 : _measureWidth(text, font(item));\n}\n\nfunction _measureWidth(text, currentFont) {\n  const key = \"(\".concat(currentFont, \") \").concat(text);\n  let width = widthCache.get(key);\n\n  if (width === undefined) {\n    context.font = currentFont;\n    width = context.measureText(text).width;\n    widthCache.set(key, width);\n  }\n\n  return width;\n}\n\nfunction fontSize(item) {\n  return item.fontSize != null ? +item.fontSize || 0 : 11;\n}\n\nfunction lineHeight(item) {\n  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;\n}\n\nfunction lineArray(_) {\n  return isArray(_) ? _.length > 1 ? _ : _[0] : _;\n}\n\nfunction textLines(item) {\n  return lineArray(item.lineBreak && item.text && !isArray(item.text) ? item.text.split(item.lineBreak) : item.text);\n}\n\nfunction multiLineOffset(item) {\n  const tl = textLines(item);\n  return (isArray(tl) ? tl.length - 1 : 0) * lineHeight(item);\n}\n\nfunction textValue(item, line) {\n  const text = line == null ? '' : (line + '').trim();\n  return item.limit > 0 && text.length ? truncate(item, text) : text;\n}\n\nfunction widthGetter(item) {\n  if (textMetrics.width === measureWidth) {\n    // we are using canvas\n    const currentFont = font(item);\n    return text => _measureWidth(text, currentFont);\n  } else {\n    // we are relying on estimates\n    const currentFontHeight = fontSize(item);\n    return text => _estimateWidth(text, currentFontHeight);\n  }\n}\n\nfunction truncate(item, text) {\n  var limit = +item.limit,\n      width = widthGetter(item);\n  if (width(text) < limit) return text;\n  var ellipsis = item.ellipsis || '\\u2026',\n      rtl = item.dir === 'rtl',\n      lo = 0,\n      hi = text.length,\n      mid;\n  limit -= width(ellipsis);\n\n  if (rtl) {\n    while (lo < hi) {\n      mid = lo + hi >>> 1;\n      if (width(text.slice(mid)) > limit) lo = mid + 1;else hi = mid;\n    }\n\n    return ellipsis + text.slice(lo);\n  } else {\n    while (lo < hi) {\n      mid = 1 + (lo + hi >>> 1);\n      if (width(text.slice(0, mid)) < limit) lo = mid;else hi = mid - 1;\n    }\n\n    return text.slice(0, lo) + ellipsis;\n  }\n}\n\nfunction fontFamily(item, quote) {\n  var font = item.font;\n  return (quote && font ? String(font).replace(/\"/g, '\\'') : font) || 'sans-serif';\n}\n\nfunction font(item, quote) {\n  return '' + (item.fontStyle ? item.fontStyle + ' ' : '') + (item.fontVariant ? item.fontVariant + ' ' : '') + (item.fontWeight ? item.fontWeight + ' ' : '') + fontSize(item) + 'px ' + fontFamily(item, quote);\n}\n\nfunction offset(item) {\n  // perform our own font baseline calculation\n  // why? not all browsers support SVG 1.1 'alignment-baseline' :(\n  // this also ensures consistent layout across renderers\n  var baseline = item.baseline,\n      h = fontSize(item);\n  return Math.round(baseline === 'top' ? 0.79 * h : baseline === 'middle' ? 0.30 * h : baseline === 'bottom' ? -0.21 * h : baseline === 'line-top' ? 0.29 * h + 0.5 * lineHeight(item) : baseline === 'line-bottom' ? 0.29 * h - 0.5 * lineHeight(item) : 0);\n}\n\nconst textAlign = {\n  'left': 'start',\n  'center': 'middle',\n  'right': 'end'\n};\nconst tempBounds = new Bounds();\n\nfunction anchorPoint(item) {\n  var x = item.x || 0,\n      y = item.y || 0,\n      r = item.radius || 0,\n      t;\n\n  if (r) {\n    t = (item.theta || 0) - HalfPi;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  tempBounds.x1 = x;\n  tempBounds.y1 = y;\n  return tempBounds;\n}\n\nfunction attr(emit, item) {\n  var dx = item.dx || 0,\n      dy = (item.dy || 0) + offset(item),\n      p = anchorPoint(item),\n      x = p.x1,\n      y = p.y1,\n      a = item.angle || 0,\n      t;\n  emit('text-anchor', textAlign[item.align] || 'start');\n\n  if (a) {\n    t = translate(x, y) + ' ' + rotate(a);\n    if (dx || dy) t += ' ' + translate(dx, dy);\n  } else {\n    t = translate(x + dx, y + dy);\n  }\n\n  emit('transform', t);\n}\n\nfunction bound(bounds, item, mode) {\n  var h = textMetrics.height(item),\n      a = item.align,\n      p = anchorPoint(item),\n      x = p.x1,\n      y = p.y1,\n      dx = item.dx || 0,\n      dy = (item.dy || 0) + offset(item) - Math.round(0.8 * h),\n      // use 4/5 offset\n  tl = textLines(item),\n      w; // get dimensions\n\n  if (isArray(tl)) {\n    // multi-line text\n    h += lineHeight(item) * (tl.length - 1);\n    w = tl.reduce((w, t) => Math.max(w, textMetrics.width(item, t)), 0);\n  } else {\n    // single-line text\n    w = textMetrics.width(item, tl);\n  } // horizontal alignment\n\n\n  if (a === 'center') {\n    dx -= w / 2;\n  } else if (a === 'right') {\n    dx -= w;\n  } else ;\n\n  bounds.set(dx += x, dy += y, dx + w, dy + h);\n\n  if (item.angle && !mode) {\n    bounds.rotate(item.angle * DegToRad, x, y);\n  } else if (mode === 2) {\n    return bounds.rotatedPoints(item.angle * DegToRad, x, y);\n  }\n\n  return bounds;\n}\n\nfunction draw(context, scene, bounds) {\n  visit(scene, item => {\n    var opacity = item.opacity == null ? 1 : item.opacity,\n        p,\n        x,\n        y,\n        i,\n        lh,\n        tl,\n        str;\n    if (bounds && !bounds.intersects(item.bounds) || // bounds check\n    opacity === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0) return;\n    context.font = font(item);\n    context.textAlign = item.align || 'left';\n    p = anchorPoint(item);\n    x = p.x1, y = p.y1;\n\n    if (item.angle) {\n      context.save();\n      context.translate(x, y);\n      context.rotate(item.angle * DegToRad);\n      x = y = 0; // reset x, y\n    }\n\n    x += item.dx || 0;\n    y += (item.dy || 0) + offset(item);\n    tl = textLines(item);\n    blend(context, item);\n\n    if (isArray(tl)) {\n      lh = lineHeight(item);\n\n      for (i = 0; i < tl.length; ++i) {\n        str = textValue(item, tl[i]);\n\n        if (item.fill && fill(context, item, opacity)) {\n          context.fillText(str, x, y);\n        }\n\n        if (item.stroke && stroke(context, item, opacity)) {\n          context.strokeText(str, x, y);\n        }\n\n        y += lh;\n      }\n    } else {\n      str = textValue(item, tl);\n\n      if (item.fill && fill(context, item, opacity)) {\n        context.fillText(str, x, y);\n      }\n\n      if (item.stroke && stroke(context, item, opacity)) {\n        context.strokeText(str, x, y);\n      }\n    }\n\n    if (item.angle) context.restore();\n  });\n}\n\nfunction hit(context, item, x, y, gx, gy) {\n  if (item.fontSize <= 0) return false;\n  if (!item.angle) return true; // bounds sufficient if no rotation\n  // project point into space of unrotated bounds\n\n  var p = anchorPoint(item),\n      ax = p.x1,\n      ay = p.y1,\n      b = bound(tempBounds, item, 1),\n      a = -item.angle * DegToRad,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      px = cos * gx - sin * gy + (ax - cos * ax + sin * ay),\n      py = sin * gx + cos * gy + (ay - sin * ax - cos * ay);\n  return b.contains(px, py);\n}\n\nfunction intersectText(item, box) {\n  const p = bound(tempBounds, item, 2);\n  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);\n}\n\nvar text = {\n  type: 'text',\n  tag: 'text',\n  nested: false,\n  attr: attr,\n  bound: bound,\n  draw: draw,\n  pick: pick$1(hit),\n  isect: intersectText\n};\nvar trail = markMultiItemPath('trail', trail$1, pickTrail);\nvar Marks = {\n  arc: arc,\n  area: area,\n  group: group,\n  image: image,\n  line: line,\n  path: path$2,\n  rect: rect,\n  rule: rule,\n  shape: shape,\n  symbol: symbol,\n  text: text,\n  trail: trail\n};\n\nfunction boundItem(item, func, opt) {\n  var type = Marks[item.mark.marktype],\n      bound = func || type.bound;\n  if (type.nested) item = item.mark;\n  return bound(item.bounds || (item.bounds = new Bounds()), item, opt);\n}\n\nvar DUMMY = {\n  mark: null\n};\n\nfunction boundMark(mark, bounds, opt) {\n  var type = Marks[mark.marktype],\n      bound = type.bound,\n      items = mark.items,\n      hasItems = items && items.length,\n      i,\n      n,\n      item,\n      b;\n\n  if (type.nested) {\n    if (hasItems) {\n      item = items[0];\n    } else {\n      // no items, fake it\n      DUMMY.mark = mark;\n      item = DUMMY;\n    }\n\n    b = boundItem(item, bound, opt);\n    bounds = bounds && bounds.union(b) || b;\n    return bounds;\n  }\n\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n\n  if (hasItems) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      bounds.union(boundItem(items[i], bound, opt));\n    }\n  }\n\n  return mark.bounds = bounds;\n}\n\nconst keys = ['marktype', 'name', 'role', 'interactive', 'clip', 'items', 'zindex', 'x', 'y', 'width', 'height', 'align', 'baseline', // layout\n'fill', 'fillOpacity', 'opacity', 'blend', // fill\n'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap', // stroke\n'strokeDash', 'strokeDashOffset', // stroke dash\n'strokeForeground', 'strokeOffset', // group\n'startAngle', 'endAngle', 'innerRadius', 'outerRadius', // arc\n'cornerRadius', 'padAngle', // arc, rect\n'cornerRadiusTopLeft', 'cornerRadiusTopRight', // rect, group\n'cornerRadiusBottomLeft', 'cornerRadiusBottomRight', 'interpolate', 'tension', 'orient', 'defined', // area, line\n'url', 'aspect', 'smooth', // image\n'path', 'scaleX', 'scaleY', // path\n'x2', 'y2', // rule\n'size', 'shape', // symbol\n'text', 'angle', 'theta', 'radius', 'dir', 'dx', 'dy', // text\n'ellipsis', 'limit', 'lineBreak', 'lineHeight', 'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant', // font\n'description', 'aria', 'ariaRole', 'ariaRoleDescription' // aria\n];\n\nfunction sceneToJSON(scene, indent) {\n  return JSON.stringify(scene, keys, indent);\n}\n\nfunction sceneFromJSON(json) {\n  const scene = typeof json === 'string' ? JSON.parse(json) : json;\n  return initialize(scene);\n}\n\nfunction initialize(scene) {\n  var type = scene.marktype,\n      items = scene.items,\n      parent,\n      i,\n      n;\n\n  if (items) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      parent = type ? 'mark' : 'group';\n      items[i][parent] = scene;\n      if (items[i].zindex) items[i][parent].zdirty = true;\n      if ('group' === (type || parent)) initialize(items[i]);\n    }\n  }\n\n  if (type) boundMark(scene);\n  return scene;\n}\n\nfunction Scenegraph(scene) {\n  if (arguments.length) {\n    this.root = sceneFromJSON(scene);\n  } else {\n    this.root = createMark({\n      marktype: 'group',\n      name: 'root',\n      role: 'frame'\n    });\n    this.root.items = [new GroupItem(this.root)];\n  }\n}\n\nScenegraph.prototype = {\n  toJSON(indent) {\n    return sceneToJSON(this.root, indent || 0);\n  },\n\n  mark(markdef, group, index) {\n    group = group || this.root.items[0];\n    const mark = createMark(markdef, group);\n    group.items[index] = mark;\n    if (mark.zindex) mark.group.zdirty = true;\n    return mark;\n  }\n\n};\n\nfunction createMark(def, group) {\n  const mark = {\n    bounds: new Bounds(),\n    clip: !!def.clip,\n    group: group,\n    interactive: def.interactive === false ? false : true,\n    items: [],\n    marktype: def.marktype,\n    name: def.name || undefined,\n    role: def.role || undefined,\n    zindex: def.zindex || 0\n  }; // add accessibility properties if defined\n\n  if (def.aria != null) {\n    mark.aria = def.aria;\n  }\n\n  if (def.description) {\n    mark.description = def.description;\n  }\n\n  return mark;\n} // create a new DOM element\n\n\nfunction domCreate(doc, tag, ns) {\n  if (!doc && typeof document !== 'undefined' && document.createElement) {\n    doc = document;\n  }\n\n  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;\n} // find first child element with matching tag\n\n\nfunction domFind(el, tag) {\n  tag = tag.toLowerCase();\n  var nodes = el.childNodes,\n      i = 0,\n      n = nodes.length;\n\n  for (; i < n; ++i) if (nodes[i].tagName.toLowerCase() === tag) {\n    return nodes[i];\n  }\n} // retrieve child element at given index\n// create & insert if doesn't exist or if tags do not match\n\n\nfunction domChild(el, index, tag, ns) {\n  var a = el.childNodes[index],\n      b;\n\n  if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {\n    b = a || null;\n    a = domCreate(el.ownerDocument, tag, ns);\n    el.insertBefore(a, b);\n  }\n\n  return a;\n} // remove all child elements at or above the given index\n\n\nfunction domClear(el, index) {\n  var nodes = el.childNodes,\n      curr = nodes.length;\n\n  while (curr > index) el.removeChild(nodes[--curr]);\n\n  return el;\n} // generate css class name for mark\n\n\nfunction cssClass(mark) {\n  return 'mark-' + mark.marktype + (mark.role ? ' role-' + mark.role : '') + (mark.name ? ' ' + mark.name : '');\n}\n\nfunction point(event, el) {\n  const rect = el.getBoundingClientRect();\n  return [event.clientX - rect.left - (el.clientLeft || 0), event.clientY - rect.top - (el.clientTop || 0)];\n}\n\nfunction resolveItem(item, event, el, origin) {\n  var mark = item && item.mark,\n      mdef,\n      p;\n\n  if (mark && (mdef = Marks[mark.marktype]).tip) {\n    p = point(event, el);\n    p[0] -= origin[0];\n    p[1] -= origin[1];\n\n    while (item = item.mark.group) {\n      p[0] -= item.x || 0;\n      p[1] -= item.y || 0;\n    }\n\n    item = mdef.tip(mark.items, p);\n  }\n\n  return item;\n}\n/**\n * Create a new Handler instance.\n * @param {object} [customLoader] - Optional loader instance for\n *   href URL sanitization. If not specified, a standard loader\n *   instance will be generated.\n * @param {function} [customTooltip] - Optional tooltip handler\n *   function for custom tooltip display.\n * @constructor\n */\n\n\nfunction Handler(customLoader, customTooltip) {\n  this._active = null;\n  this._handlers = {};\n  this._loader = customLoader || loader();\n  this._tooltip = customTooltip || defaultTooltip;\n} // The default tooltip display handler.\n// Sets the HTML title attribute on the visualization container.\n\n\nfunction defaultTooltip(handler, event, item, value) {\n  handler.element().setAttribute('title', value || '');\n}\n\nHandler.prototype = {\n  /**\n   * Initialize a new Handler instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {object} [obj] - Optional context object that should serve as\n   *   the \"this\" context for event callbacks.\n   * @return {Handler} - This handler instance.\n   */\n  initialize(el, origin, obj) {\n    this._el = el;\n    this._obj = obj || null;\n    return this.origin(origin);\n  },\n\n  /**\n   * Returns the parent container element for a visualization.\n   * @return {DOMElement} - The containing DOM element.\n   */\n  element() {\n    return this._el;\n  },\n\n  /**\n   * Returns the scene element (e.g., canvas or SVG) of the visualization\n   * Subclasses must override if the first child is not the scene element.\n   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n   */\n  canvas() {\n    return this._el && this._el.firstChild;\n  },\n\n  /**\n   * Get / set the origin coordinates of the visualization.\n   */\n  origin(origin) {\n    if (arguments.length) {\n      this._origin = origin || [0, 0];\n      return this;\n    } else {\n      return this._origin.slice();\n    }\n  },\n\n  /**\n   * Get / set the scenegraph root.\n   */\n  scene(scene) {\n    if (!arguments.length) return this._scene;\n    this._scene = scene;\n    return this;\n  },\n\n  /**\n   * Add an event handler. Subclasses should override this method.\n   */\n  on() {},\n\n  /**\n   * Remove an event handler. Subclasses should override this method.\n   */\n  off() {},\n\n  /**\n   * Utility method for finding the array index of an event handler.\n   * @param {Array} h - An array of registered event handlers.\n   * @param {string} type - The event type.\n   * @param {function} handler - The event handler instance to find.\n   * @return {number} - The handler's array index or -1 if not registered.\n   */\n  _handlerIndex(h, type, handler) {\n    for (let i = h ? h.length : 0; --i >= 0;) {\n      if (h[i].type === type && (!handler || h[i].handler === handler)) {\n        return i;\n      }\n    }\n\n    return -1;\n  },\n\n  /**\n   * Returns an array with registered event handlers.\n   * @param {string} [type] - The event type to query. Any annotations\n   *   are ignored; for example, for the argument \"click.foo\", \".foo\" will\n   *   be ignored and the method returns all \"click\" handlers. If type is\n   *   null or unspecified, this method returns handlers for all types.\n   * @return {Array} - A new array containing all registered event handlers.\n   */\n  handlers(type) {\n    const h = this._handlers,\n          a = [];\n\n    if (type) {\n      a.push(...h[this.eventName(type)]);\n    } else {\n      for (const k in h) {\n        a.push(...h[k]);\n      }\n    }\n\n    return a;\n  },\n\n  /**\n   * Parses an event name string to return the specific event type.\n   * For example, given \"click.foo\" returns \"click\"\n   * @param {string} name - The input event type string.\n   * @return {string} - A string with the event type only.\n   */\n  eventName(name) {\n    const i = name.indexOf('.');\n    return i < 0 ? name : name.slice(0, i);\n  },\n\n  /**\n   * Handle hyperlink navigation in response to an item.href value.\n   * @param {Event} event - The event triggering hyperlink navigation.\n   * @param {Item} item - The scenegraph item.\n   * @param {string} href - The URL to navigate to.\n   */\n  handleHref(event, item, href) {\n    this._loader.sanitize(href, {\n      context: 'href'\n    }).then(opt => {\n      const e = new MouseEvent(event.type, event),\n            a = domCreate(null, 'a');\n\n      for (const name in opt) a.setAttribute(name, opt[name]);\n\n      a.dispatchEvent(e);\n    }).catch(() => {\n      /* do nothing */\n    });\n  },\n\n  /**\n   * Handle tooltip display in response to an item.tooltip value.\n   * @param {Event} event - The event triggering tooltip display.\n   * @param {Item} item - The scenegraph item.\n   * @param {boolean} show - A boolean flag indicating whether\n   *   to show or hide a tooltip for the given item.\n   */\n  handleTooltip(event, item, show) {\n    if (item && item.tooltip != null) {\n      item = resolveItem(item, event, this.canvas(), this._origin);\n      const value = show && item && item.tooltip || null;\n\n      this._tooltip.call(this._obj, this, event, item, value);\n    }\n  },\n\n  /**\n   * Returns the size of a scenegraph item and its position relative\n   * to the viewport.\n   * @param {Item} item - The scenegraph item.\n   * @return {object} - A bounding box object (compatible with the\n   *   DOMRect type) consisting of x, y, width, heigh, top, left,\n   *   right, and bottom properties.\n   */\n  getItemBoundingClientRect(item) {\n    const el = this.canvas();\n    if (!el) return;\n    const rect = el.getBoundingClientRect(),\n          origin = this._origin,\n          bounds = item.bounds,\n          width = bounds.width(),\n          height = bounds.height();\n    let x = bounds.x1 + origin[0] + rect.left,\n        y = bounds.y1 + origin[1] + rect.top; // translate coordinate for each parent group\n\n    while (item.mark && (item = item.mark.group)) {\n      x += item.x || 0;\n      y += item.y || 0;\n    } // return DOMRect-compatible bounding box\n\n\n    return {\n      x,\n      y,\n      width,\n      height,\n      left: x,\n      top: y,\n      right: x + width,\n      bottom: y + height\n    };\n  }\n\n};\n/**\n * Create a new Renderer instance.\n * @param {object} [loader] - Optional loader instance for\n *   image and href URL sanitization. If not specified, a\n *   standard loader instance will be generated.\n * @constructor\n */\n\nfunction Renderer(loader) {\n  this._el = null;\n  this._bgcolor = null;\n  this._loader = new ResourceLoader(loader);\n}\n\nRenderer.prototype = {\n  /**\n   * Initialize a new Renderer instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {number} width - The coordinate width of the display, in pixels.\n   * @param {number} height - The coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {Renderer} - This renderer instance.\n   */\n  initialize(el, width, height, origin, scaleFactor) {\n    this._el = el;\n    return this.resize(width, height, origin, scaleFactor);\n  },\n\n  /**\n   * Returns the parent container element for a visualization.\n   * @return {DOMElement} - The containing DOM element.\n   */\n  element() {\n    return this._el;\n  },\n\n  /**\n   * Returns the scene element (e.g., canvas or SVG) of the visualization\n   * Subclasses must override if the first child is not the scene element.\n   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n   */\n  canvas() {\n    return this._el && this._el.firstChild;\n  },\n\n  /**\n   * Get / set the background color.\n   */\n  background(bgcolor) {\n    if (arguments.length === 0) return this._bgcolor;\n    this._bgcolor = bgcolor;\n    return this;\n  },\n\n  /**\n   * Resize the display.\n   * @param {number} width - The new coordinate width of the display, in pixels.\n   * @param {number} height - The new coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The new origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {Renderer} - This renderer instance;\n   */\n  resize(width, height, origin, scaleFactor) {\n    this._width = width;\n    this._height = height;\n    this._origin = origin || [0, 0];\n    this._scale = scaleFactor || 1;\n    return this;\n  },\n\n  /**\n   * Report a dirty item whose bounds should be redrawn.\n   * This base class method does nothing. Subclasses that perform\n   * incremental should implement this method.\n   * @param {Item} item - The dirty item whose bounds should be redrawn.\n   */\n  dirty() {},\n\n  /**\n   * Render an input scenegraph, potentially with a set of dirty items.\n   * This method will perform an immediate rendering with available resources.\n   * The renderer may also need to perform image loading to perform a complete\n   * render. This process can lead to asynchronous re-rendering of the scene\n   * after this method returns. To receive notification when rendering is\n   * complete, use the renderAsync method instead.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @return {Renderer} - This renderer instance.\n   */\n  render(scene) {\n    const r = this; // bind arguments into a render call, and cache it\n    // this function may be subsequently called for async redraw\n\n    r._call = function () {\n      r._render(scene);\n    }; // invoke the renderer\n\n\n    r._call(); // clear the cached call for garbage collection\n    // async redraws will stash their own copy\n\n\n    r._call = null;\n    return r;\n  },\n\n  /**\n   * Internal rendering method. Renderer subclasses should override this\n   * method to actually perform rendering.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   */\n  _render() {// subclasses to override\n  },\n\n  /**\n   * Asynchronous rendering method. Similar to render, but returns a Promise\n   * that resolves when all rendering is completed. Sometimes a renderer must\n   * perform image loading to get a complete rendering. The returned\n   * Promise will not resolve until this process completes.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @return {Promise} - A Promise that resolves when rendering is complete.\n   */\n  renderAsync(scene) {\n    const r = this.render(scene);\n    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);\n  },\n\n  /**\n   * Internal method for asynchronous resource loading.\n   * Proxies method calls to the ImageLoader, and tracks loading\n   * progress to invoke a re-render once complete.\n   * @param {string} method - The method name to invoke on the ImageLoader.\n   * @param {string} uri - The URI for the requested resource.\n   * @return {Promise} - A Promise that resolves to the requested resource.\n   */\n  _load(method, uri) {\n    var r = this,\n        p = r._loader[method](uri);\n\n    if (!r._ready) {\n      // re-render the scene when loading completes\n      const call = r._call;\n      r._ready = r._loader.ready().then(redraw => {\n        if (redraw) call();\n        r._ready = null;\n      });\n    }\n\n    return p;\n  },\n\n  /**\n   * Sanitize a URL to include as a hyperlink in the rendered scene.\n   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks\n   * image loading progress and invokes a re-render once complete.\n   * @param {string} uri - The URI string to sanitize.\n   * @return {Promise} - A Promise that resolves to the sanitized URL.\n   */\n  sanitizeURL(uri) {\n    return this._load('sanitizeURL', uri);\n  },\n\n  /**\n   * Requests an image to include in the rendered scene.\n   * This method proxies a call to ImageLoader.loadImage, but also tracks\n   * image loading progress and invokes a re-render once complete.\n   * @param {string} uri - The URI string of the image.\n   * @return {Promise} - A Promise that resolves to the loaded Image.\n   */\n  loadImage(uri) {\n    return this._load('loadImage', uri);\n  }\n\n};\nconst KeyDownEvent = 'keydown';\nconst KeyPressEvent = 'keypress';\nconst KeyUpEvent = 'keyup';\nconst DragEnterEvent = 'dragenter';\nconst DragLeaveEvent = 'dragleave';\nconst DragOverEvent = 'dragover';\nconst MouseDownEvent = 'mousedown';\nconst MouseUpEvent = 'mouseup';\nconst MouseMoveEvent = 'mousemove';\nconst MouseOutEvent = 'mouseout';\nconst MouseOverEvent = 'mouseover';\nconst ClickEvent = 'click';\nconst DoubleClickEvent = 'dblclick';\nconst WheelEvent = 'wheel';\nconst MouseWheelEvent = 'mousewheel';\nconst TouchStartEvent = 'touchstart';\nconst TouchMoveEvent = 'touchmove';\nconst TouchEndEvent = 'touchend';\nconst Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];\nconst TooltipShowEvent = MouseMoveEvent;\nconst TooltipHideEvent = MouseOutEvent;\nconst HrefEvent = ClickEvent;\n\nfunction CanvasHandler(loader, tooltip) {\n  Handler.call(this, loader, tooltip);\n  this._down = null;\n  this._touch = null;\n  this._first = true;\n  this._events = {};\n}\n\nconst eventBundle = type => type === TouchStartEvent || type === TouchMoveEvent || type === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type]; // lazily add listeners to the canvas as needed\n\n\nfunction eventListenerCheck(handler, type) {\n  eventBundle(type).forEach(_ => addEventListener(handler, _));\n}\n\nfunction addEventListener(handler, type) {\n  const canvas = handler.canvas();\n\n  if (canvas && !handler._events[type]) {\n    handler._events[type] = 1;\n    canvas.addEventListener(type, handler[type] ? evt => handler[type](evt) : evt => handler.fire(type, evt));\n  }\n}\n\nfunction move(moveEvent, overEvent, outEvent) {\n  return function (evt) {\n    const a = this._active,\n          p = this.pickEvent(evt);\n\n    if (p === a) {\n      // active item and picked item are the same\n      this.fire(moveEvent, evt); // fire move\n    } else {\n      // active item and picked item are different\n      if (!a || !a.exit) {\n        // fire out for prior active item\n        // suppress if active item was removed from scene\n        this.fire(outEvent, evt);\n      }\n\n      this._active = p; // set new active item\n\n      this.fire(overEvent, evt); // fire over for new active item\n\n      this.fire(moveEvent, evt); // fire move for new active item\n    }\n  };\n}\n\nfunction inactive(type) {\n  return function (evt) {\n    this.fire(type, evt);\n    this._active = null;\n  };\n}\n\ninherits(CanvasHandler, Handler, {\n  initialize(el, origin, obj) {\n    this._canvas = el && domFind(el, 'canvas'); // add minimal events required for proper state management\n\n    [ClickEvent, MouseDownEvent, MouseMoveEvent, MouseOutEvent, DragLeaveEvent].forEach(type => eventListenerCheck(this, type));\n    return Handler.prototype.initialize.call(this, el, origin, obj);\n  },\n\n  // return the backing canvas instance\n  canvas() {\n    return this._canvas;\n  },\n\n  // retrieve the current canvas context\n  context() {\n    return this._canvas.getContext('2d');\n  },\n\n  // supported events\n  events: Events,\n\n  // to keep old versions of firefox happy\n  DOMMouseScroll(evt) {\n    this.fire(MouseWheelEvent, evt);\n  },\n\n  mousemove: move(MouseMoveEvent, MouseOverEvent, MouseOutEvent),\n  dragover: move(DragOverEvent, DragEnterEvent, DragLeaveEvent),\n  mouseout: inactive(MouseOutEvent),\n  dragleave: inactive(DragLeaveEvent),\n\n  mousedown(evt) {\n    this._down = this._active;\n    this.fire(MouseDownEvent, evt);\n  },\n\n  click(evt) {\n    if (this._down === this._active) {\n      this.fire(ClickEvent, evt);\n      this._down = null;\n    }\n  },\n\n  touchstart(evt) {\n    this._touch = this.pickEvent(evt.changedTouches[0]);\n\n    if (this._first) {\n      this._active = this._touch;\n      this._first = false;\n    }\n\n    this.fire(TouchStartEvent, evt, true);\n  },\n\n  touchmove(evt) {\n    this.fire(TouchMoveEvent, evt, true);\n  },\n\n  touchend(evt) {\n    this.fire(TouchEndEvent, evt, true);\n    this._touch = null;\n  },\n\n  // fire an event\n  fire(type, evt, touch) {\n    const a = touch ? this._touch : this._active,\n          h = this._handlers[type]; // set event type relative to scenegraph items\n\n    evt.vegaType = type; // handle hyperlinks and tooltips first\n\n    if (type === HrefEvent && a && a.href) {\n      this.handleHref(evt, a, a.href);\n    } else if (type === TooltipShowEvent || type === TooltipHideEvent) {\n      this.handleTooltip(evt, a, type !== TooltipHideEvent);\n    } // invoke all registered handlers\n\n\n    if (h) {\n      for (let i = 0, len = h.length; i < len; ++i) {\n        h[i].handler.call(this._obj, evt, a);\n      }\n    }\n  },\n\n  // add an event handler\n  on(type, handler) {\n    const name = this.eventName(type),\n          h = this._handlers,\n          i = this._handlerIndex(h[name], type, handler);\n\n    if (i < 0) {\n      eventListenerCheck(this, type);\n      (h[name] || (h[name] = [])).push({\n        type: type,\n        handler: handler\n      });\n    }\n\n    return this;\n  },\n\n  // remove an event handler\n  off(type, handler) {\n    const name = this.eventName(type),\n          h = this._handlers[name],\n          i = this._handlerIndex(h, type, handler);\n\n    if (i >= 0) {\n      h.splice(i, 1);\n    }\n\n    return this;\n  },\n\n  pickEvent(evt) {\n    const p = point(evt, this._canvas),\n          o = this._origin;\n    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);\n  },\n\n  // find the scenegraph item at the current mouse position\n  // x, y -- the absolute x, y mouse coordinates on the canvas element\n  // gx, gy -- the relative coordinates within the current group\n  pick(scene, x, y, gx, gy) {\n    const g = this.context(),\n          mark = Marks[scene.marktype];\n    return mark.pick.call(this, g, scene, x, y, gx, gy);\n  }\n\n});\n\nfunction devicePixelRatio() {\n  return typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1;\n}\n\nvar pixelRatio = devicePixelRatio();\n\nfunction resize(canvas, width, height, origin, scaleFactor, opt) {\n  const inDOM = typeof HTMLElement !== 'undefined' && canvas instanceof HTMLElement && canvas.parentNode != null,\n        context = canvas.getContext('2d'),\n        ratio = inDOM ? pixelRatio : scaleFactor;\n  canvas.width = width * ratio;\n  canvas.height = height * ratio;\n\n  for (const key in opt) {\n    context[key] = opt[key];\n  }\n\n  if (inDOM && ratio !== 1) {\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n  }\n\n  context.pixelRatio = ratio;\n  context.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);\n  return canvas;\n}\n\nfunction CanvasRenderer(loader) {\n  Renderer.call(this, loader);\n  this._options = {};\n  this._redraw = false;\n  this._dirty = new Bounds();\n  this._tempb = new Bounds();\n}\n\nconst base$1 = Renderer.prototype;\n\nconst viewBounds = (origin, width, height) => new Bounds().set(0, 0, width, height).translate(-origin[0], -origin[1]);\n\nfunction clipToBounds(g, b, origin) {\n  // expand bounds by 1 pixel, then round to pixel boundaries\n  b.expand(1).round(); // align to base pixel grid in case of non-integer scaling (#2425)\n\n  if (g.pixelRatio % 1) {\n    b.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);\n  } // to avoid artifacts translate if origin has fractional pixels\n\n\n  b.translate(-(origin[0] % 1), -(origin[1] % 1)); // set clip path\n\n  g.beginPath();\n  g.rect(b.x1, b.y1, b.width(), b.height());\n  g.clip();\n  return b;\n}\n\ninherits(CanvasRenderer, Renderer, {\n  initialize(el, width, height, origin, scaleFactor, options) {\n    this._options = options || {};\n    this._canvas = this._options.externalContext ? null : canvas(1, 1, this._options.type); // instantiate a small canvas\n\n    if (el && this._canvas) {\n      domClear(el, 0).appendChild(this._canvas);\n\n      this._canvas.setAttribute('class', 'marks');\n    } // this method will invoke resize to size the canvas appropriately\n\n\n    return base$1.initialize.call(this, el, width, height, origin, scaleFactor);\n  },\n\n  resize(width, height, origin, scaleFactor) {\n    base$1.resize.call(this, width, height, origin, scaleFactor);\n\n    if (this._canvas) {\n      // configure canvas size and transform\n      resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);\n    } else {\n      // external context needs to be scaled and positioned to origin\n      const ctx = this._options.externalContext;\n      if (!ctx) error('CanvasRenderer is missing a valid canvas or context');\n      ctx.scale(this._scale, this._scale);\n      ctx.translate(this._origin[0], this._origin[1]);\n    }\n\n    this._redraw = true;\n    return this;\n  },\n\n  canvas() {\n    return this._canvas;\n  },\n\n  context() {\n    return this._options.externalContext || (this._canvas ? this._canvas.getContext('2d') : null);\n  },\n\n  dirty(item) {\n    const b = this._tempb.clear().union(item.bounds);\n\n    let g = item.mark.group;\n\n    while (g) {\n      b.translate(g.x || 0, g.y || 0);\n      g = g.mark.group;\n    }\n\n    this._dirty.union(b);\n  },\n\n  _render(scene) {\n    const g = this.context(),\n          o = this._origin,\n          w = this._width,\n          h = this._height,\n          db = this._dirty,\n          vb = viewBounds(o, w, h); // setup\n\n    g.save();\n    const b = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);\n    this.clear(-o[0], -o[1], w, h); // render\n\n    this.draw(g, scene, b); // takedown\n\n    g.restore();\n    db.clear();\n    return this;\n  },\n\n  draw(ctx, scene, bounds) {\n    const mark = Marks[scene.marktype];\n    if (scene.clip) clip(ctx, scene);\n    mark.draw.call(this, ctx, scene, bounds);\n    if (scene.clip) ctx.restore();\n  },\n\n  clear(x, y, w, h) {\n    const opt = this._options,\n          g = this.context();\n\n    if (opt.type !== 'pdf' && !opt.externalContext) {\n      // calling clear rect voids vector output in pdf mode\n      // and could remove external context content (#2615)\n      g.clearRect(x, y, w, h);\n    }\n\n    if (this._bgcolor != null) {\n      g.fillStyle = this._bgcolor;\n      g.fillRect(x, y, w, h);\n    }\n  }\n\n});\n\nfunction SVGHandler(loader, tooltip) {\n  Handler.call(this, loader, tooltip);\n  const h = this;\n  h._hrefHandler = listener(h, (evt, item) => {\n    if (item && item.href) h.handleHref(evt, item, item.href);\n  });\n  h._tooltipHandler = listener(h, (evt, item) => {\n    h.handleTooltip(evt, item, evt.type !== TooltipHideEvent);\n  });\n} // wrap an event listener for the SVG DOM\n\n\nconst listener = (context, handler) => evt => {\n  let item = evt.target.__data__;\n  item = Array.isArray(item) ? item[0] : item;\n  evt.vegaType = evt.type;\n  handler.call(context._obj, evt, item);\n};\n\ninherits(SVGHandler, Handler, {\n  initialize(el, origin, obj) {\n    let svg = this._svg;\n\n    if (svg) {\n      svg.removeEventListener(HrefEvent, this._hrefHandler);\n      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);\n      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);\n    }\n\n    this._svg = svg = el && domFind(el, 'svg');\n\n    if (svg) {\n      svg.addEventListener(HrefEvent, this._hrefHandler);\n      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);\n      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);\n    }\n\n    return Handler.prototype.initialize.call(this, el, origin, obj);\n  },\n\n  canvas() {\n    return this._svg;\n  },\n\n  // add an event handler\n  on(type, handler) {\n    const name = this.eventName(type),\n          h = this._handlers,\n          i = this._handlerIndex(h[name], type, handler);\n\n    if (i < 0) {\n      const x = {\n        type,\n        handler,\n        listener: listener(this, handler)\n      };\n      (h[name] || (h[name] = [])).push(x);\n\n      if (this._svg) {\n        this._svg.addEventListener(name, x.listener);\n      }\n    }\n\n    return this;\n  },\n\n  // remove an event handler\n  off(type, handler) {\n    const name = this.eventName(type),\n          h = this._handlers[name],\n          i = this._handlerIndex(h, type, handler);\n\n    if (i >= 0) {\n      if (this._svg) {\n        this._svg.removeEventListener(name, h[i].listener);\n      }\n\n      h.splice(i, 1);\n    }\n\n    return this;\n  }\n\n});\nconst ARIA_HIDDEN = 'aria-hidden';\nconst ARIA_LABEL = 'aria-label';\nconst ARIA_ROLE = 'role';\nconst ARIA_ROLEDESCRIPTION = 'aria-roledescription';\nconst GRAPHICS_OBJECT = 'graphics-object';\nconst GRAPHICS_SYMBOL = 'graphics-symbol';\n\nconst bundle = (role, roledesc, label) => ({\n  [ARIA_ROLE]: role,\n  [ARIA_ROLEDESCRIPTION]: roledesc,\n  [ARIA_LABEL]: label || undefined\n}); // these roles are covered by related roles\n// we can ignore them, no need to generate attributes\n\n\nconst AriaIgnore = toSet(['axis-domain', 'axis-grid', 'axis-label', 'axis-tick', 'axis-title', 'legend-band', 'legend-entry', 'legend-gradient', 'legend-label', 'legend-title', 'legend-symbol', 'title']); // aria attribute generators for guide roles\n\nconst AriaGuides = {\n  'axis': {\n    desc: 'axis',\n    caption: axisCaption\n  },\n  'legend': {\n    desc: 'legend',\n    caption: legendCaption\n  },\n  'title-text': {\n    desc: 'title',\n    caption: item => \"Title text '\".concat(titleCaption(item), \"'\")\n  },\n  'title-subtitle': {\n    desc: 'subtitle',\n    caption: item => \"Subtitle text '\".concat(titleCaption(item), \"'\")\n  }\n}; // aria properties generated for mark item encoding channels\n\nconst AriaEncode = {\n  ariaRole: ARIA_ROLE,\n  ariaRoleDescription: ARIA_ROLEDESCRIPTION,\n  description: ARIA_LABEL\n};\n\nfunction ariaItemAttributes(emit, item) {\n  const hide = item.aria === false;\n  emit(ARIA_HIDDEN, hide || undefined);\n\n  if (hide || item.description == null) {\n    for (const prop in AriaEncode) {\n      emit(AriaEncode[prop], undefined);\n    }\n  } else {\n    const type = item.mark.marktype;\n    emit(ARIA_LABEL, item.description);\n    emit(ARIA_ROLE, item.ariaRole || (type === 'group' ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));\n    emit(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || \"\".concat(type, \" mark\"));\n  }\n}\n\nfunction ariaMarkAttributes(mark) {\n  return mark.aria === false ? {\n    [ARIA_HIDDEN]: true\n  } : AriaIgnore[mark.role] ? null : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role]) : ariaMark(mark);\n}\n\nfunction ariaMark(mark) {\n  const type = mark.marktype;\n  const recurse = type === 'group' || type === 'text' || mark.items.some(_ => _.description != null && _.aria !== false);\n  return bundle(recurse ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, \"\".concat(type, \" mark container\"), mark.description);\n}\n\nfunction ariaGuide(mark, opt) {\n  try {\n    const item = mark.items[0],\n          caption = opt.caption || (() => '');\n\n    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));\n  } catch (err) {\n    return null;\n  }\n}\n\nfunction titleCaption(item) {\n  return array(item.text).join(' ');\n}\n\nfunction axisCaption(item) {\n  const datum = item.datum,\n        orient = item.orient,\n        title = datum.title ? extractTitle(item) : null,\n        ctx = item.context,\n        scale = ctx.scales[datum.scale].value,\n        locale = ctx.dataflow.locale(),\n        type = scale.type,\n        xy = orient === 'left' || orient === 'right' ? 'Y' : 'X';\n  return \"\".concat(xy, \"-axis\") + (title ? \" titled '\".concat(title, \"'\") : '') + \" for a \".concat(isDiscrete(type) ? 'discrete' : type, \" scale\") + \" with \".concat(domainCaption(locale, scale, item));\n}\n\nfunction legendCaption(item) {\n  const datum = item.datum,\n        title = datum.title ? extractTitle(item) : null,\n        type = \"\".concat(datum.type || '', \" legend\").trim(),\n        scales = datum.scales,\n        props = Object.keys(scales),\n        ctx = item.context,\n        scale = ctx.scales[scales[props[0]]].value,\n        locale = ctx.dataflow.locale();\n  return capitalize(type) + (title ? \" titled '\".concat(title, \"'\") : '') + \" for \".concat(channelCaption(props)) + \" with \".concat(domainCaption(locale, scale, item));\n}\n\nfunction extractTitle(item) {\n  try {\n    return array(peek(item.items).items[0].text).join(' ');\n  } catch (err) {\n    return null;\n  }\n}\n\nfunction channelCaption(props) {\n  props = props.map(p => p + (p === 'fill' || p === 'stroke' ? ' color' : ''));\n  return props.length < 2 ? props[0] : props.slice(0, -1).join(', ') + ' and ' + peek(props);\n}\n\nfunction capitalize(s) {\n  return s.length ? s[0].toUpperCase() + s.slice(1) : s;\n}\n\nconst innerText = val => (val + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n\nconst attrText = val => innerText(val).replace(/\"/g, '&quot;').replace(/\\t/g, '&#x9;').replace(/\\n/g, '&#xA;').replace(/\\r/g, '&#xD;');\n\nfunction markup() {\n  let buf = '',\n      outer = '',\n      inner = '';\n\n  const stack = [],\n        clear = () => outer = inner = '',\n        push = tag => {\n    if (outer) {\n      buf += \"\".concat(outer, \">\").concat(inner);\n      clear();\n    }\n\n    stack.push(tag);\n  },\n        attr = (name, value) => {\n    if (value != null) outer += \" \".concat(name, \"=\\\"\").concat(attrText(value), \"\\\"\");\n    return m;\n  },\n        m = {\n    open(tag) {\n      push(tag);\n      outer = '<' + tag;\n\n      for (var _len = arguments.length, attrs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        attrs[_key - 1] = arguments[_key];\n      }\n\n      for (const set of attrs) {\n        for (const key in set) attr(key, set[key]);\n      }\n\n      return m;\n    },\n\n    close() {\n      const tag = stack.pop();\n\n      if (outer) {\n        buf += outer + (inner ? \">\".concat(inner, \"</\").concat(tag, \">\") : '/>');\n      } else {\n        buf += \"</\".concat(tag, \">\");\n      }\n\n      clear();\n      return m;\n    },\n\n    attr,\n    text: t => (inner += innerText(t), m),\n    toString: () => buf\n  };\n\n  return m;\n}\n\nconst serializeXML = node => _serialize(markup(), node) + '';\n\nfunction _serialize(m, node) {\n  m.open(node.tagName);\n\n  if (node.hasAttributes()) {\n    const attrs = node.attributes,\n          n = attrs.length;\n\n    for (let i = 0; i < n; ++i) {\n      m.attr(attrs[i].name, attrs[i].value);\n    }\n  }\n\n  if (node.hasChildNodes()) {\n    const children = node.childNodes;\n\n    for (const child of children) {\n      child.nodeType === 3 // text node\n      ? m.text(child.nodeValue) : _serialize(m, child);\n    }\n  }\n\n  return m.close();\n}\n\nconst stylesAttr = {\n  fill: 'fill',\n  fillOpacity: 'fill-opacity',\n  stroke: 'stroke',\n  strokeOpacity: 'stroke-opacity',\n  strokeWidth: 'stroke-width',\n  strokeCap: 'stroke-linecap',\n  strokeJoin: 'stroke-linejoin',\n  strokeDash: 'stroke-dasharray',\n  strokeDashOffset: 'stroke-dashoffset',\n  strokeMiterLimit: 'stroke-miterlimit',\n  opacity: 'opacity'\n};\nconst stylesCss = {\n  blend: 'mix-blend-mode'\n}; // ensure miter limit default is consistent with canvas (#2498)\n\nconst rootAttributes = {\n  'fill': 'none',\n  'stroke-miterlimit': 10\n};\nconst RootIndex = 0,\n      xmlns = 'http://www.w3.org/2000/xmlns/',\n      svgns = metadata.xmlns;\n\nfunction SVGRenderer(loader) {\n  Renderer.call(this, loader);\n  this._dirtyID = 0;\n  this._dirty = [];\n  this._svg = null;\n  this._root = null;\n  this._defs = null;\n}\n\nconst base = Renderer.prototype;\ninherits(SVGRenderer, Renderer, {\n  /**\n   * Initialize a new SVGRenderer instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {number} width - The coordinate width of the display, in pixels.\n   * @param {number} height - The coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {SVGRenderer} - This renderer instance.\n   */\n  initialize(el, width, height, origin, scaleFactor) {\n    // create the svg definitions cache\n    this._defs = {};\n\n    this._clearDefs();\n\n    if (el) {\n      this._svg = domChild(el, 0, 'svg', svgns);\n\n      this._svg.setAttributeNS(xmlns, 'xmlns', svgns);\n\n      this._svg.setAttributeNS(xmlns, 'xmlns:xlink', metadata['xmlns:xlink']);\n\n      this._svg.setAttribute('version', metadata['version']);\n\n      this._svg.setAttribute('class', 'marks');\n\n      domClear(el, 1); // set the svg root group\n\n      this._root = domChild(this._svg, RootIndex, 'g', svgns);\n      setAttributes(this._root, rootAttributes); // ensure no additional child elements\n\n      domClear(this._svg, RootIndex + 1);\n    } // set background color if defined\n\n\n    this.background(this._bgcolor);\n    return base.initialize.call(this, el, width, height, origin, scaleFactor);\n  },\n\n  /**\n   * Get / set the background color.\n   */\n  background(bgcolor) {\n    if (arguments.length && this._svg) {\n      this._svg.style.setProperty('background-color', bgcolor);\n    }\n\n    return base.background.apply(this, arguments);\n  },\n\n  /**\n   * Resize the display.\n   * @param {number} width - The new coordinate width of the display, in pixels.\n   * @param {number} height - The new coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The new origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {SVGRenderer} - This renderer instance;\n   */\n  resize(width, height, origin, scaleFactor) {\n    base.resize.call(this, width, height, origin, scaleFactor);\n\n    if (this._svg) {\n      setAttributes(this._svg, {\n        width: this._width * this._scale,\n        height: this._height * this._scale,\n        viewBox: \"0 0 \".concat(this._width, \" \").concat(this._height)\n      });\n\n      this._root.setAttribute('transform', \"translate(\".concat(this._origin, \")\"));\n    }\n\n    this._dirty = [];\n    return this;\n  },\n\n  /**\n   * Returns the SVG element of the visualization.\n   * @return {DOMElement} - The SVG element.\n   */\n  canvas() {\n    return this._svg;\n  },\n\n  /**\n   * Returns an SVG text string for the rendered content,\n   * or null if this renderer is currently headless.\n   */\n  svg() {\n    const svg = this._svg,\n          bg = this._bgcolor;\n    if (!svg) return null;\n    let node;\n\n    if (bg) {\n      svg.removeAttribute('style');\n      node = domChild(svg, RootIndex, 'rect', svgns);\n      setAttributes(node, {\n        width: this._width,\n        height: this._height,\n        fill: bg\n      });\n    }\n\n    const text = serializeXML(svg);\n\n    if (bg) {\n      svg.removeChild(node);\n\n      this._svg.style.setProperty('background-color', bg);\n    }\n\n    return text;\n  },\n\n  /**\n   * Internal rendering method.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   */\n  _render(scene) {\n    // perform spot updates and re-render markup\n    if (this._dirtyCheck()) {\n      if (this._dirtyAll) this._clearDefs();\n      this.mark(this._root, scene);\n      domClear(this._root, 1);\n    }\n\n    this.defs();\n    this._dirty = [];\n    ++this._dirtyID;\n    return this;\n  },\n\n  // -- Manage rendering of items marked as dirty --\n\n  /**\n   * Flag a mark item as dirty.\n   * @param {Item} item - The mark item.\n   */\n  dirty(item) {\n    if (item.dirty !== this._dirtyID) {\n      item.dirty = this._dirtyID;\n\n      this._dirty.push(item);\n    }\n  },\n\n  /**\n   * Check if a mark item is considered dirty.\n   * @param {Item} item - The mark item.\n   */\n  isDirty(item) {\n    return this._dirtyAll || !item._svg || !item._svg.ownerSVGElement || item.dirty === this._dirtyID;\n  },\n\n  /**\n   * Internal method to check dirty status and, if possible,\n   * make targetted updates without a full rendering pass.\n   */\n  _dirtyCheck() {\n    this._dirtyAll = true;\n    const items = this._dirty;\n    if (!items.length || !this._dirtyID) return true;\n    const id = ++this._dirtyID;\n    let item, mark, type, mdef, i, n, o;\n\n    for (i = 0, n = items.length; i < n; ++i) {\n      item = items[i];\n      mark = item.mark;\n\n      if (mark.marktype !== type) {\n        // memoize mark instance lookup\n        type = mark.marktype;\n        mdef = Marks[type];\n      }\n\n      if (mark.zdirty && mark.dirty !== id) {\n        this._dirtyAll = false;\n        dirtyParents(item, id);\n        mark.items.forEach(i => {\n          i.dirty = id;\n        });\n      }\n\n      if (mark.zdirty) continue; // handle in standard drawing pass\n\n      if (item.exit) {\n        // EXIT\n        if (mdef.nested && mark.items.length) {\n          // if nested mark with remaining points, update instead\n          o = mark.items[0];\n          if (o._svg) this._update(mdef, o._svg, o);\n        } else if (item._svg) {\n          // otherwise remove from DOM\n          o = item._svg.parentNode;\n          if (o) o.removeChild(item._svg);\n        }\n\n        item._svg = null;\n        continue;\n      }\n\n      item = mdef.nested ? mark.items[0] : item;\n      if (item._update === id) continue; // already visited\n\n      if (!item._svg || !item._svg.ownerSVGElement) {\n        // ENTER\n        this._dirtyAll = false;\n        dirtyParents(item, id);\n      } else {\n        // IN-PLACE UPDATE\n        this._update(mdef, item._svg, item);\n      }\n\n      item._update = id;\n    }\n\n    return !this._dirtyAll;\n  },\n\n  // -- Construct & maintain scenegraph to SVG mapping ---\n\n  /**\n   * Render a set of mark items.\n   * @param {SVGElement} el - The parent element in the SVG tree.\n   * @param {object} scene - The mark parent to render.\n   * @param {SVGElement} prev - The previous sibling in the SVG tree.\n   */\n  mark(el, scene, prev) {\n    if (!this.isDirty(scene)) {\n      return scene._svg;\n    }\n\n    const svg = this._svg,\n          mdef = Marks[scene.marktype],\n          events = scene.interactive === false ? 'none' : null,\n          isGroup = mdef.tag === 'g';\n    const parent = bind(scene, el, prev, 'g', svg);\n    parent.setAttribute('class', cssClass(scene)); // apply aria attributes to parent container element\n\n    const aria = ariaMarkAttributes(scene);\n\n    for (const key in aria) setAttribute(parent, key, aria[key]);\n\n    if (!isGroup) {\n      setAttribute(parent, 'pointer-events', events);\n    }\n\n    setAttribute(parent, 'clip-path', scene.clip ? clip$1(this, scene, scene.group) : null);\n    let sibling = null,\n        i = 0;\n\n    const process = item => {\n      const dirty = this.isDirty(item),\n            node = bind(item, parent, sibling, mdef.tag, svg);\n\n      if (dirty) {\n        this._update(mdef, node, item);\n\n        if (isGroup) recurse(this, node, item);\n      }\n\n      sibling = node;\n      ++i;\n    };\n\n    if (mdef.nested) {\n      if (scene.items.length) process(scene.items[0]);\n    } else {\n      visit(scene, process);\n    }\n\n    domClear(parent, i);\n    return parent;\n  },\n\n  /**\n   * Update the attributes of an SVG element for a mark item.\n   * @param {object} mdef - The mark definition object\n   * @param {SVGElement} el - The SVG element.\n   * @param {Item} item - The mark item.\n   */\n  _update(mdef, el, item) {\n    // set dom element and values cache\n    // provides access to emit method\n    element = el;\n    values = el.__values__; // apply aria-specific properties\n\n    ariaItemAttributes(emit, item); // apply svg attributes\n\n    mdef.attr(emit, item, this); // some marks need special treatment\n\n    const extra = mark_extras[mdef.type];\n    if (extra) extra.call(this, mdef, el, item); // apply svg style attributes\n    // note: element state may have been modified by 'extra' method\n\n    if (element) this.style(element, item);\n  },\n\n  /**\n   * Update the presentation attributes of an SVG element for a mark item.\n   * @param {SVGElement} el - The SVG element.\n   * @param {Item} item - The mark item.\n   */\n  style(el, item) {\n    if (item == null) return;\n\n    for (const prop in stylesAttr) {\n      let value = prop === 'font' ? fontFamily(item) : item[prop];\n      if (value === values[prop]) continue;\n      const name = stylesAttr[prop];\n\n      if (value == null) {\n        el.removeAttribute(name);\n      } else {\n        if (isGradient(value)) {\n          value = gradientRef(value, this._defs.gradient, href());\n        }\n\n        el.setAttribute(name, value + '');\n      }\n\n      values[prop] = value;\n    }\n\n    for (const prop in stylesCss) {\n      setStyle(el, stylesCss[prop], item[prop]);\n    }\n  },\n\n  /**\n   * Render SVG defs, as needed.\n   * Must be called *after* marks have been processed to ensure the\n   * collected state is current and accurate.\n   */\n  defs() {\n    const svg = this._svg,\n          defs = this._defs;\n    let el = defs.el,\n        index = 0;\n\n    for (const id in defs.gradient) {\n      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);\n      index = updateGradient(el, defs.gradient[id], index);\n    }\n\n    for (const id in defs.clipping) {\n      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);\n      index = updateClipping(el, defs.clipping[id], index);\n    } // clean-up\n\n\n    if (el) {\n      index === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index);\n    }\n  },\n\n  /**\n   * Clear defs caches.\n   */\n  _clearDefs() {\n    const def = this._defs;\n    def.gradient = {};\n    def.clipping = {};\n  }\n\n}); // mark ancestor chain with a dirty id\n\nfunction dirtyParents(item, id) {\n  for (; item && item.dirty !== id; item = item.mark.group) {\n    item.dirty = id;\n\n    if (item.mark && item.mark.dirty !== id) {\n      item.mark.dirty = id;\n    } else return;\n  }\n} // update gradient definitions\n\n\nfunction updateGradient(el, grad, index) {\n  let i, n, stop;\n\n  if (grad.gradient === 'radial') {\n    // SVG radial gradients automatically transform to normalized bbox\n    // coordinates, in a way that is cumbersome to replicate in canvas.\n    // We wrap the radial gradient in a pattern element, allowing us to\n    // maintain a circular gradient that matches what canvas provides.\n    let pt = domChild(el, index++, 'pattern', svgns);\n    setAttributes(pt, {\n      id: patternPrefix + grad.id,\n      viewBox: '0,0,1,1',\n      width: '100%',\n      height: '100%',\n      preserveAspectRatio: 'xMidYMid slice'\n    });\n    pt = domChild(pt, 0, 'rect', svgns);\n    setAttributes(pt, {\n      width: 1,\n      height: 1,\n      fill: \"url(\".concat(href(), \"#\").concat(grad.id, \")\")\n    });\n    el = domChild(el, index++, 'radialGradient', svgns);\n    setAttributes(el, {\n      id: grad.id,\n      fx: grad.x1,\n      fy: grad.y1,\n      fr: grad.r1,\n      cx: grad.x2,\n      cy: grad.y2,\n      r: grad.r2\n    });\n  } else {\n    el = domChild(el, index++, 'linearGradient', svgns);\n    setAttributes(el, {\n      id: grad.id,\n      x1: grad.x1,\n      x2: grad.x2,\n      y1: grad.y1,\n      y2: grad.y2\n    });\n  }\n\n  for (i = 0, n = grad.stops.length; i < n; ++i) {\n    stop = domChild(el, i, 'stop', svgns);\n    stop.setAttribute('offset', grad.stops[i].offset);\n    stop.setAttribute('stop-color', grad.stops[i].color);\n  }\n\n  domClear(el, i);\n  return index;\n} // update clipping path definitions\n\n\nfunction updateClipping(el, clip, index) {\n  let mask;\n  el = domChild(el, index, 'clipPath', svgns);\n  el.setAttribute('id', clip.id);\n\n  if (clip.path) {\n    mask = domChild(el, 0, 'path', svgns);\n    mask.setAttribute('d', clip.path);\n  } else {\n    mask = domChild(el, 0, 'rect', svgns);\n    setAttributes(mask, {\n      x: 0,\n      y: 0,\n      width: clip.width,\n      height: clip.height\n    });\n  }\n\n  domClear(el, 1);\n  return index + 1;\n} // Recursively process group contents.\n\n\nfunction recurse(renderer, el, group) {\n  // child 'g' element is second to last among children (path, g, path)\n  // other children here are foreground and background path elements\n  el = el.lastChild.previousSibling;\n  let prev,\n      idx = 0;\n  visit(group, item => {\n    prev = renderer.mark(el, item, prev);\n    ++idx;\n  }); // remove any extraneous DOM elements\n\n  domClear(el, 1 + idx);\n} // Bind a scenegraph item to an SVG DOM element.\n// Create new SVG elements as needed.\n\n\nfunction bind(item, el, sibling, tag, svg) {\n  let node = item._svg,\n      doc; // create a new dom node if needed\n\n  if (!node) {\n    doc = el.ownerDocument;\n    node = domCreate(doc, tag, svgns);\n    item._svg = node;\n\n    if (item.mark) {\n      node.__data__ = item;\n      node.__values__ = {\n        fill: 'default'\n      }; // if group, create background, content, and foreground elements\n\n      if (tag === 'g') {\n        const bg = domCreate(doc, 'path', svgns);\n        node.appendChild(bg);\n        bg.__data__ = item;\n        const cg = domCreate(doc, 'g', svgns);\n        node.appendChild(cg);\n        cg.__data__ = item;\n        const fg = domCreate(doc, 'path', svgns);\n        node.appendChild(fg);\n        fg.__data__ = item;\n        fg.__values__ = {\n          fill: 'default'\n        };\n      }\n    }\n  } // (re-)insert if (a) not contained in SVG or (b) sibling order has changed\n\n\n  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {\n    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);\n  }\n\n  return node;\n} // check if two nodes are ordered siblings\n\n\nfunction siblingCheck(node, sibling) {\n  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling; // treat null/undefined the same\n} // -- Set attributes & styles on SVG elements ---\n\n\nlet element = null,\n    // temp var for current SVG element\nvalues = null; // temp var for current values hash\n// Extra configuration for certain mark types\n\nconst mark_extras = {\n  group(mdef, el, item) {\n    const fg = element = el.childNodes[2];\n    values = fg.__values__;\n    mdef.foreground(emit, item, this);\n    values = el.__values__; // use parent's values hash\n\n    element = el.childNodes[1];\n    mdef.content(emit, item, this);\n    const bg = element = el.childNodes[0];\n    mdef.background(emit, item, this);\n    const value = item.mark.interactive === false ? 'none' : null;\n\n    if (value !== values.events) {\n      setAttribute(fg, 'pointer-events', value);\n      setAttribute(bg, 'pointer-events', value);\n      values.events = value;\n    }\n\n    if (item.strokeForeground && item.stroke) {\n      const fill = item.fill;\n      setAttribute(fg, 'display', null); // set style of background\n\n      this.style(bg, item);\n      setAttribute(bg, 'stroke', null); // set style of foreground\n\n      if (fill) item.fill = null;\n      values = fg.__values__;\n      this.style(fg, item);\n      if (fill) item.fill = fill; // leave element null to prevent downstream styling\n\n      element = null;\n    } else {\n      // ensure foreground is ignored\n      setAttribute(fg, 'display', 'none');\n    }\n  },\n\n  image(mdef, el, item) {\n    if (item.smooth === false) {\n      setStyle(el, 'image-rendering', 'optimizeSpeed');\n      setStyle(el, 'image-rendering', 'pixelated');\n    } else {\n      setStyle(el, 'image-rendering', null);\n    }\n  },\n\n  text(mdef, el, item) {\n    const tl = textLines(item);\n    let key, value, doc, lh;\n\n    if (isArray(tl)) {\n      // multi-line text\n      value = tl.map(_ => textValue(item, _));\n      key = value.join('\\n'); // content cache key\n\n      if (key !== values.text) {\n        domClear(el, 0);\n        doc = el.ownerDocument;\n        lh = lineHeight(item);\n        value.forEach((t, i) => {\n          const ts = domCreate(doc, 'tspan', svgns);\n          ts.__data__ = item; // data binding\n\n          ts.textContent = t;\n\n          if (i) {\n            ts.setAttribute('x', 0);\n            ts.setAttribute('dy', lh);\n          }\n\n          el.appendChild(ts);\n        });\n        values.text = key;\n      }\n    } else {\n      // single-line text\n      value = textValue(item, tl);\n\n      if (value !== values.text) {\n        el.textContent = value;\n        values.text = value;\n      }\n    }\n\n    setAttribute(el, 'font-family', fontFamily(item));\n    setAttribute(el, 'font-size', fontSize(item) + 'px');\n    setAttribute(el, 'font-style', item.fontStyle);\n    setAttribute(el, 'font-variant', item.fontVariant);\n    setAttribute(el, 'font-weight', item.fontWeight);\n  }\n\n};\n\nfunction emit(name, value, ns) {\n  // early exit if value is unchanged\n  if (value === values[name]) return; // use appropriate method given namespace (ns)\n\n  if (ns) {\n    setAttributeNS(element, name, value, ns);\n  } else {\n    setAttribute(element, name, value);\n  } // note current value for future comparison\n\n\n  values[name] = value;\n}\n\nfunction setStyle(el, name, value) {\n  if (value !== values[name]) {\n    if (value == null) {\n      el.style.removeProperty(name);\n    } else {\n      el.style.setProperty(name, value + '');\n    }\n\n    values[name] = value;\n  }\n}\n\nfunction setAttributes(el, attrs) {\n  for (const key in attrs) {\n    setAttribute(el, key, attrs[key]);\n  }\n}\n\nfunction setAttribute(el, name, value) {\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    el.setAttribute(name, value);\n  } else {\n    // else remove DOM attribute\n    el.removeAttribute(name);\n  }\n}\n\nfunction setAttributeNS(el, name, value, ns) {\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    el.setAttributeNS(ns, name, value);\n  } else {\n    // else remove DOM attribute\n    el.removeAttributeNS(ns, name);\n  }\n}\n\nfunction href() {\n  let loc;\n  return typeof window === 'undefined' ? '' : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;\n}\n\nfunction SVGStringRenderer(loader) {\n  Renderer.call(this, loader);\n  this._text = null;\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n}\n\ninherits(SVGStringRenderer, Renderer, {\n  /**\n   * Returns the rendered SVG text string,\n   * or null if rendering has not yet occurred.\n   */\n  svg() {\n    return this._text;\n  },\n\n  /**\n   * Internal rendering method.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   */\n  _render(scene) {\n    const m = markup(); // svg tag\n\n    m.open('svg', extend({}, metadata, {\n      class: 'marks',\n      width: this._width * this._scale,\n      height: this._height * this._scale,\n      viewBox: \"0 0 \".concat(this._width, \" \").concat(this._height)\n    })); // background, if defined\n\n    const bg = this._bgcolor;\n\n    if (bg && bg !== 'transparent' && bg !== 'none') {\n      m.open('rect', {\n        width: this._width,\n        height: this._height,\n        fill: bg\n      }).close();\n    } // root content group\n\n\n    m.open('g', rootAttributes, {\n      transform: 'translate(' + this._origin + ')'\n    });\n    this.mark(m, scene);\n    m.close(); // </g>\n    // defs\n\n    this.defs(m); // get SVG text string\n\n    this._text = m.close() + '';\n    return this;\n  },\n\n  /**\n   * Render a set of mark items.\n   * @param {object} m - The markup context.\n   * @param {object} scene - The mark parent to render.\n   */\n  mark(m, scene) {\n    const mdef = Marks[scene.marktype],\n          tag = mdef.tag,\n          attrList = [ariaItemAttributes, mdef.attr]; // render opening group tag\n\n    m.open('g', {\n      'class': cssClass(scene),\n      'clip-path': scene.clip ? clip$1(this, scene, scene.group) : null\n    }, ariaMarkAttributes(scene), {\n      'pointer-events': tag !== 'g' && scene.interactive === false ? 'none' : null\n    }); // render contained elements\n\n    const process = item => {\n      const href = this.href(item);\n      if (href) m.open('a', href);\n      m.open(tag, this.attr(scene, item, attrList, tag !== 'g' ? tag : null));\n\n      if (tag === 'text') {\n        const tl = textLines(item);\n\n        if (isArray(tl)) {\n          // multi-line text\n          const attrs = {\n            x: 0,\n            dy: lineHeight(item)\n          };\n\n          for (let i = 0; i < tl.length; ++i) {\n            m.open('tspan', i ? attrs : null).text(textValue(item, tl[i])).close();\n          }\n        } else {\n          // single-line text\n          m.text(textValue(item, tl));\n        }\n      } else if (tag === 'g') {\n        const fore = item.strokeForeground,\n              fill = item.fill,\n              stroke = item.stroke;\n\n        if (fore && stroke) {\n          item.stroke = null;\n        }\n\n        m.open('path', this.attr(scene, item, mdef.background, 'bgrect')).close(); // recurse for group content\n\n        m.open('g', this.attr(scene, item, mdef.content));\n        visit(item, scene => this.mark(m, scene));\n        m.close();\n\n        if (fore && stroke) {\n          if (fill) item.fill = null;\n          item.stroke = stroke;\n          m.open('path', this.attr(scene, item, mdef.foreground, 'bgrect')).close();\n          if (fill) item.fill = fill;\n        } else {\n          m.open('path', this.attr(scene, item, mdef.foreground, 'bgfore')).close();\n        }\n      }\n\n      m.close(); // </tag>\n\n      if (href) m.close(); // </a>\n    };\n\n    if (mdef.nested) {\n      if (scene.items && scene.items.length) process(scene.items[0]);\n    } else {\n      visit(scene, process);\n    } // render closing group tag\n\n\n    return m.close(); // </g>\n  },\n\n  /**\n   * Get href attributes for a hyperlinked mark item.\n   * @param {Item} item - The mark item.\n   */\n  href(item) {\n    const href = item.href;\n    let attr;\n\n    if (href) {\n      if (attr = this._hrefs && this._hrefs[href]) {\n        return attr;\n      } else {\n        this.sanitizeURL(href).then(attr => {\n          // rewrite to use xlink namespace\n          attr['xlink:href'] = attr.href;\n          attr.href = null;\n          (this._hrefs || (this._hrefs = {}))[href] = attr;\n        });\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Get an object of SVG attributes for a mark item.\n   * @param {object} scene - The mark parent.\n   * @param {Item} item - The mark item.\n   * @param {array|function} attrs - One or more attribute emitters.\n   * @param {string} tag - The tag being rendered.\n   */\n  attr(scene, item, attrs, tag) {\n    const object = {},\n          emit = (name, value, ns, prefixed) => {\n      object[prefixed || name] = value;\n    }; // apply mark specific attributes\n\n\n    if (Array.isArray(attrs)) {\n      attrs.forEach(fn => fn(emit, item, this));\n    } else {\n      attrs(emit, item, this);\n    } // apply style attributes\n\n\n    if (tag) {\n      style(object, item, scene, tag, this._defs);\n    }\n\n    return object;\n  },\n\n  /**\n   * Render SVG defs, as needed.\n   * Must be called *after* marks have been processed to ensure the\n   * collected state is current and accurate.\n   * @param {object} m - The markup context.\n   */\n  defs(m) {\n    const gradient = this._defs.gradient,\n          clipping = this._defs.clipping,\n          count = Object.keys(gradient).length + Object.keys(clipping).length;\n    if (count === 0) return; // nothing to do\n\n    m.open('defs');\n\n    for (const id in gradient) {\n      const def = gradient[id],\n            stops = def.stops;\n\n      if (def.gradient === 'radial') {\n        // SVG radial gradients automatically transform to normalized bbox\n        // coordinates, in a way that is cumbersome to replicate in canvas.\n        // We wrap the radial gradient in a pattern element, allowing us to\n        // maintain a circular gradient that matches what canvas provides.\n        m.open('pattern', {\n          id: patternPrefix + id,\n          viewBox: '0,0,1,1',\n          width: '100%',\n          height: '100%',\n          preserveAspectRatio: 'xMidYMid slice'\n        });\n        m.open('rect', {\n          width: '1',\n          height: '1',\n          fill: 'url(#' + id + ')'\n        }).close();\n        m.close(); // </pattern>\n\n        m.open('radialGradient', {\n          id: id,\n          fx: def.x1,\n          fy: def.y1,\n          fr: def.r1,\n          cx: def.x2,\n          cy: def.y2,\n          r: def.r2\n        });\n      } else {\n        m.open('linearGradient', {\n          id: id,\n          x1: def.x1,\n          x2: def.x2,\n          y1: def.y1,\n          y2: def.y2\n        });\n      }\n\n      for (let i = 0; i < stops.length; ++i) {\n        m.open('stop', {\n          offset: stops[i].offset,\n          'stop-color': stops[i].color\n        }).close();\n      }\n\n      m.close();\n    }\n\n    for (const id in clipping) {\n      const def = clipping[id];\n      m.open('clipPath', {\n        id: id\n      });\n\n      if (def.path) {\n        m.open('path', {\n          d: def.path\n        }).close();\n      } else {\n        m.open('rect', {\n          x: 0,\n          y: 0,\n          width: def.width,\n          height: def.height\n        }).close();\n      }\n\n      m.close();\n    }\n\n    m.close();\n  }\n\n}); // Helper function for attr for style presentation attributes\n\nfunction style(s, item, scene, tag, defs) {\n  let styleList;\n  if (item == null) return s;\n\n  if (tag === 'bgrect' && scene.interactive === false) {\n    s['pointer-events'] = 'none';\n  }\n\n  if (tag === 'bgfore') {\n    if (scene.interactive === false) {\n      s['pointer-events'] = 'none';\n    }\n\n    s.display = 'none';\n    if (item.fill !== null) return s;\n  }\n\n  if (tag === 'image' && item.smooth === false) {\n    styleList = ['image-rendering: optimizeSpeed;', 'image-rendering: pixelated;'];\n  }\n\n  if (tag === 'text') {\n    s['font-family'] = fontFamily(item);\n    s['font-size'] = fontSize(item) + 'px';\n    s['font-style'] = item.fontStyle;\n    s['font-variant'] = item.fontVariant;\n    s['font-weight'] = item.fontWeight;\n  }\n\n  for (const prop in stylesAttr) {\n    let value = item[prop];\n    const name = stylesAttr[prop];\n    if (value === 'transparent' && (name === 'fill' || name === 'stroke')) ;else if (value != null) {\n      if (isGradient(value)) {\n        value = gradientRef(value, defs.gradient, '');\n      }\n\n      s[name] = value;\n    }\n  }\n\n  for (const prop in stylesCss) {\n    const value = item[prop];\n\n    if (value != null) {\n      styleList = styleList || [];\n      styleList.push(\"\".concat(stylesCss[prop], \": \").concat(value, \";\"));\n    }\n  }\n\n  if (styleList) {\n    s.style = styleList.join(' ');\n  }\n\n  return s;\n}\n\nconst Canvas = 'canvas';\nconst PNG = 'png';\nconst SVG = 'svg';\nconst None = 'none';\nconst RenderType = {\n  Canvas: Canvas,\n  PNG: PNG,\n  SVG: SVG,\n  None: None\n};\nconst modules = {};\nmodules[Canvas] = modules[PNG] = {\n  renderer: CanvasRenderer,\n  headless: CanvasRenderer,\n  handler: CanvasHandler\n};\nmodules[SVG] = {\n  renderer: SVGRenderer,\n  headless: SVGStringRenderer,\n  handler: SVGHandler\n};\nmodules[None] = {};\n\nfunction renderModule(name, _) {\n  name = String(name || '').toLowerCase();\n\n  if (arguments.length > 1) {\n    modules[name] = _;\n    return this;\n  } else {\n    return modules[name];\n  }\n}\n\nfunction intersect(scene, bounds, filter) {\n  const hits = [],\n        // intersection results\n  box = new Bounds().union(bounds),\n        // defensive copy\n  type = scene.marktype;\n  return type ? intersectMark(scene, box, filter, hits) : type === 'group' ? intersectGroup(scene, box, filter, hits) : error('Intersect scene must be mark node or group item.');\n}\n\nfunction intersectMark(mark, box, filter, hits) {\n  if (visitMark(mark, box, filter)) {\n    const items = mark.items,\n          type = mark.marktype,\n          n = items.length;\n    let i = 0;\n\n    if (type === 'group') {\n      for (; i < n; ++i) {\n        intersectGroup(items[i], box, filter, hits);\n      }\n    } else {\n      for (const test = Marks[type].isect; i < n; ++i) {\n        const item = items[i];\n        if (intersectItem(item, box, test)) hits.push(item);\n      }\n    }\n  }\n\n  return hits;\n}\n\nfunction visitMark(mark, box, filter) {\n  // process if bounds intersect and if\n  // (1) mark is a group mark (so we must recurse), or\n  // (2) mark is interactive and passes filter\n  return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === 'group' || mark.interactive !== false && (!filter || filter(mark)));\n}\n\nfunction intersectGroup(group, box, filter, hits) {\n  // test intersect against group\n  // skip groups by default unless filter says otherwise\n  if (filter && filter(group.mark) && intersectItem(group, box, Marks.group.isect)) {\n    hits.push(group);\n  } // recursively test children marks\n  // translate box to group coordinate space\n\n\n  const marks = group.items,\n        n = marks && marks.length;\n\n  if (n) {\n    const x = group.x || 0,\n          y = group.y || 0;\n    box.translate(-x, -y);\n\n    for (let i = 0; i < n; ++i) {\n      intersectMark(marks[i], box, filter, hits);\n    }\n\n    box.translate(x, y);\n  }\n\n  return hits;\n}\n\nfunction intersectItem(item, box, test) {\n  // test bounds enclosure, bounds intersection, then detailed test\n  const bounds = item.bounds;\n  return box.encloses(bounds) || box.intersects(bounds) && test(item, box);\n}\n\nconst clipBounds = new Bounds();\n\nfunction boundClip(mark) {\n  const clip = mark.clip;\n\n  if (isFunction(clip)) {\n    clip(boundContext(clipBounds.clear()));\n  } else if (clip) {\n    clipBounds.set(0, 0, mark.group.width, mark.group.height);\n  } else return;\n\n  mark.bounds.intersect(clipBounds);\n}\n\nconst TOLERANCE = 1e-9;\n\nfunction sceneEqual(a, b, key) {\n  return a === b ? true : key === 'path' ? pathEqual(a, b) : a instanceof Date && b instanceof Date ? +a === +b : isNumber(a) && isNumber(b) ? Math.abs(a - b) <= TOLERANCE : !a || !b || !isObject(a) && !isObject(b) ? a == b : objectEqual(a, b);\n}\n\nfunction pathEqual(a, b) {\n  return sceneEqual(parse(a), parse(b));\n}\n\nfunction objectEqual(a, b) {\n  var ka = Object.keys(a),\n      kb = Object.keys(b),\n      key,\n      i;\n  if (ka.length !== kb.length) return false;\n  ka.sort();\n  kb.sort();\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i]) return false;\n  }\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!sceneEqual(a[key], b[key], key)) return false;\n  }\n\n  return typeof a === typeof b;\n}\n\nfunction resetSVGDefIds() {\n  resetSVGClipId();\n  resetSVGGradientId();\n}\n\nexport { Bounds, CanvasHandler, CanvasRenderer, Gradient, GroupItem, Handler, Item, Marks, RenderType, Renderer, ResourceLoader, SVGHandler, SVGRenderer, SVGStringRenderer, Scenegraph, boundClip, boundContext, boundItem, boundMark, boundStroke, domChild, domClear, domCreate, domFind, font, fontFamily, fontSize, intersect, intersectBoxLine, intersectPath, intersectPoint, intersectRule, lineHeight, markup, multiLineOffset, curves as pathCurves, pathEqual, parse as pathParse, vg_rect as pathRectangle, pathRender, symbols as pathSymbols, vg_trail as pathTrail, point, renderModule, resetSVGClipId, resetSVGDefIds, sceneEqual, sceneFromJSON, pickVisit as scenePickVisit, sceneToJSON, visit as sceneVisit, zorder as sceneZOrder, serializeXML, textMetrics };","map":{"version":3,"names":["hasOwnProperty","isFunction","inherits","truthy","lruCache","isArray","error","toSet","array","peek","extend","isNumber","isObject","curveBasis","curveBasisClosed","curveBasisOpen","curveBundle","curveCardinal","curveCardinalOpen","curveCardinalClosed","curveCatmullRom","curveCatmullRomClosed","curveCatmullRomOpen","curveLinear","curveLinearClosed","curveMonotoneY","curveMonotoneX","curveNatural","curveStep","curveStepAfter","curveStepBefore","arc","arc$2","area","area$2","line","line$2","symbol","symbol$2","path","path$3","image","image$1","canvas","loader","isDiscrete","domainCaption","gradient_id","resetSVGGradientId","patternPrefix","isGradient","value","gradient","gradientRef","g","defs","base","type","id","prefix","x1","get","y1","r1","x2","y2","r2","val","def","Gradient","p0","p1","stops","stop","offset","color","push","lookup","curve","tension","horizontal","vertical","curves","orientation","entry","paramCounts","m","l","h","v","z","c","s","q","t","a","commandPattern","numberPattern","spacePattern","flagPattern","parse","commands","matches","match","forEach","str","cmd","toLowerCase","paramCount","params","parseParams","slice","trim","count","length","Error","i","segment","index","pattern","ws","DegToRad","Math","PI","Epsilon","HalfPi","Tau","HalfSqrt3","sqrt","segmentCache","bezierCache","join","segments","x","y","rx","ry","large","sweep","rotateX","ox","oy","key","call","arguments","th","sin_th","sin","cos_th","cos","abs","px","py","pl","a00","a01","a10","a11","x0","y0","d","sfactor_sq","sfactor","xc","yc","th0","atan2","th1","th_arc","segs","ceil","result","th2","th3","bezier","cx","cy","cos_th0","sin_th0","cos_th1","sin_th1","th_half","sin_th_h2","x3","y3","temp","scale$1","current","sX","sY","n","pathRender","context","previous","controlX","controlY","tempX","tempY","tempControlX","tempControlY","anchorX","anchorY","beginPath","len","lineTo","moveTo","bezierCurveTo","quadraticCurveTo","drawArc","closePath","coords","seg","bez","Tan30","builtins","draw","size","r","w","rect","o","b","symbols","_","customSymbol","custom","parsed","C","rectangleX","rectangleY","rectangleWidth","width","rectangleHeight","height","number","clamp","min","max","vg_rect","crTL","crTR","crBL","crBR","rectangle","buffer","tl","tr","bl","br","cornerRadius","vg_trail","defined","ready","point","w2","ux","uy","ud","trail","data","defined0","value$1","item","xw","yh","sa","startAngle","ea","endAngle","pa","padAngle","ir","innerRadius","or","outerRadius","cr","cornerRadiusTopLeft","cornerRadiusTopRight","cornerRadiusBottomRight","cornerRadiusBottomLeft","sz","ts","shape","arcShape","areavShape","areahShape","lineShape","rectShape","symbolShape","trailShape","hasCornerRadius","arc$1","area$1","items","interp","interpolate","orient","line$1","shape$1","mark","symbol$1","trail$1","clip_id","resetSVGClipId","clip$1","renderer","clip","_defs","clipping","Bounds","clear","union","prototype","clone","Number","MAX_VALUE","empty","equals","set","add","expand","round","floor","scale","translate","dx","dy","rotate","angle","p","rotatedPoints","intersect","encloses","alignsWith","intersects","contains","Item","bounds","GroupItem","ResourceLoader","customLoader","_pending","_loader","increment","decrement","pending","sanitizeURL","uri","sanitize","then","opt","catch","loadImage","Image","url","href","img","cors","crossOrigin","onload","onerror","src","e","complete","Promise","accept","poll","setTimeout","boundStroke","miter","stroke","opacity","strokeOpacity","sw","strokeWidth","miterAdjustment","strokeJoin","circleThreshold","lx","ly","rot","ma","mb","mc","md","addL","addX","addY","addp","addpL","boundContext","deg","context$1","px1","py1","px2","py2","quadExtrema","px3","py3","cubicExtrema","ccw","update","cb","t0","t1","cubic","s2","t2","getContext","intersectPath","brush","isPointInPath","intersectPoint","box","intersectRect","intersectRule","intersectBoxLine","u","blend","globalCompositeOperation","dflt","addStops","addColorStop","spec","createRadialGradient","createLinearGradient","ictx","fillStyle","fillRect","createPattern","fill","fillOpacity","globalAlpha","Empty","lw","strokeStyle","lineWidth","lineCap","strokeCap","lineJoin","miterLimit","strokeMiterLimit","setLineDash","strokeDash","lineDashOffset","strokeDashOffset","compare","zindex","zorder","scene","zdirty","zitems","output","sort","visit","visitor","pickVisit","hit","drawAll","drawPath","drawOne","pick$1","test","gx","gy","pixelRatio","hitPath","filled","Array","isPointInStroke","lc","pickPath","scaleX","scaleY","translateItem","rotateItem","transformItem","markItemPath","isect","attr","emit","bound","tag","nested","pick","pickArea","Infinity","pickLine","pow","dd","pickTrail","markMultiItemPath","tip","save","clipGroup","group","offset$1","strokeOffset","attr$5","emitRectangle","off","background","foreground","strokeForeground","content","bound$5","j","noBound","rectanglePath","hitBackground","hitForeground","hitCorner","draw$4","fore","restore","dw","dh","ix","interactive","pickMark","marktype","metadata","getImage","imageWidth","aspect","imageHeight","imageXOffset","align","imageYOffset","baseline","attr$4","toDataURL","bound$4","draw$3","ar0","ar1","imageSmoothingEnabled","smooth","drawImage","xOffset","yOffset","attr$3","sx","sy","path$1","cache","pathCache","bound$3","path$2","attr$2","bound$2","draw$2","attr$1","bound$1","draw$1","hit$1","rule","widthCache","textMetrics","fontSize","measureWidth","estimateWidth","useCanvas","use","text","_estimateWidth","textValue","currentFontHeight","_measureWidth","font","currentFont","concat","undefined","measureText","lineHeight","lineArray","textLines","lineBreak","split","multiLineOffset","limit","truncate","widthGetter","ellipsis","rtl","dir","lo","hi","mid","fontFamily","quote","String","replace","fontStyle","fontVariant","fontWeight","textAlign","tempBounds","anchorPoint","radius","theta","mode","reduce","lh","fillText","strokeText","ax","ay","intersectText","Marks","boundItem","func","DUMMY","boundMark","hasItems","keys","sceneToJSON","indent","JSON","stringify","sceneFromJSON","json","initialize","parent","Scenegraph","root","createMark","name","role","toJSON","markdef","aria","description","domCreate","doc","ns","document","createElement","createElementNS","domFind","el","nodes","childNodes","tagName","domChild","ownerDocument","insertBefore","domClear","curr","removeChild","cssClass","event","getBoundingClientRect","clientX","left","clientLeft","clientY","top","clientTop","resolveItem","origin","mdef","Handler","customTooltip","_active","_handlers","_tooltip","defaultTooltip","handler","element","setAttribute","obj","_el","_obj","firstChild","_origin","_scene","on","_handlerIndex","handlers","eventName","k","indexOf","handleHref","MouseEvent","dispatchEvent","handleTooltip","show","tooltip","getItemBoundingClientRect","right","bottom","Renderer","_bgcolor","scaleFactor","resize","bgcolor","_width","_height","_scale","dirty","render","_call","_render","renderAsync","_ready","resolve","_load","method","redraw","KeyDownEvent","KeyPressEvent","KeyUpEvent","DragEnterEvent","DragLeaveEvent","DragOverEvent","MouseDownEvent","MouseUpEvent","MouseMoveEvent","MouseOutEvent","MouseOverEvent","ClickEvent","DoubleClickEvent","WheelEvent","MouseWheelEvent","TouchStartEvent","TouchMoveEvent","TouchEndEvent","Events","TooltipShowEvent","TooltipHideEvent","HrefEvent","CanvasHandler","_down","_touch","_first","_events","eventBundle","eventListenerCheck","addEventListener","evt","fire","move","moveEvent","overEvent","outEvent","pickEvent","exit","inactive","_canvas","events","DOMMouseScroll","mousemove","dragover","mouseout","dragleave","mousedown","click","touchstart","changedTouches","touchmove","touchend","touch","vegaType","splice","devicePixelRatio","window","inDOM","HTMLElement","parentNode","ratio","style","setTransform","CanvasRenderer","_options","_redraw","_dirty","_tempb","base$1","viewBounds","clipToBounds","options","externalContext","appendChild","ctx","db","vb","clearRect","SVGHandler","_hrefHandler","listener","_tooltipHandler","target","__data__","svg","_svg","removeEventListener","ARIA_HIDDEN","ARIA_LABEL","ARIA_ROLE","ARIA_ROLEDESCRIPTION","GRAPHICS_OBJECT","GRAPHICS_SYMBOL","bundle","roledesc","label","AriaIgnore","AriaGuides","desc","caption","axisCaption","legendCaption","titleCaption","AriaEncode","ariaRole","ariaRoleDescription","ariaItemAttributes","hide","prop","ariaMarkAttributes","ariaGuide","ariaMark","recurse","some","err","datum","title","extractTitle","scales","locale","dataflow","xy","props","Object","capitalize","channelCaption","map","toUpperCase","innerText","attrText","markup","buf","outer","inner","stack","open","_len","attrs","_key","close","pop","toString","serializeXML","node","_serialize","hasAttributes","attributes","hasChildNodes","children","child","nodeType","nodeValue","stylesAttr","stylesCss","rootAttributes","RootIndex","xmlns","svgns","SVGRenderer","_dirtyID","_root","_clearDefs","setAttributeNS","setAttributes","setProperty","apply","viewBox","bg","removeAttribute","_dirtyCheck","_dirtyAll","isDirty","ownerSVGElement","dirtyParents","_update","prev","isGroup","bind","sibling","process","values","__values__","extra","mark_extras","setStyle","updateGradient","updateClipping","grad","pt","preserveAspectRatio","fx","fy","fr","mask","lastChild","previousSibling","idx","cg","fg","siblingCheck","nextSibling","textContent","removeProperty","removeAttributeNS","loc","location","hash","SVGStringRenderer","_text","class","transform","attrList","_hrefs","object","prefixed","fn","styleList","display","Canvas","PNG","SVG","None","RenderType","modules","headless","renderModule","filter","hits","intersectMark","intersectGroup","visitMark","intersectItem","marks","clipBounds","boundClip","TOLERANCE","sceneEqual","pathEqual","Date","objectEqual","ka","kb","resetSVGDefIds","pathCurves","pathParse","pathRectangle","pathSymbols","pathTrail","scenePickVisit","sceneVisit","sceneZOrder"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-scenegraph/build/vega-scenegraph.module.js"],"sourcesContent":["import { hasOwnProperty, isFunction, inherits, truthy, lruCache, isArray, error, toSet, array, peek, extend, isNumber, isObject } from 'vega-util';\nimport { curveBasis, curveBasisClosed, curveBasisOpen, curveBundle, curveCardinal, curveCardinalOpen, curveCardinalClosed, curveCatmullRom, curveCatmullRomClosed, curveCatmullRomOpen, curveLinear, curveLinearClosed, curveMonotoneY, curveMonotoneX, curveNatural, curveStep, curveStepAfter, curveStepBefore, arc as arc$2, area as area$2, line as line$2, symbol as symbol$2 } from 'd3-shape';\nimport { path as path$3 } from 'd3-path';\nexport { path } from 'd3-path';\nimport { image as image$1, canvas } from 'vega-canvas';\nimport { loader } from 'vega-loader';\nimport { isDiscrete, domainCaption } from 'vega-scale';\n\nlet gradient_id = 0;\nfunction resetSVGGradientId() {\n  gradient_id = 0;\n}\nconst patternPrefix = 'p_';\nfunction isGradient(value) {\n  return value && value.gradient;\n}\nfunction gradientRef(g, defs, base) {\n  const type = g.gradient;\n  let id = g.id,\n      prefix = type === 'radial' ? patternPrefix : ''; // check id, assign default values as needed\n\n  if (!id) {\n    id = g.id = 'gradient_' + gradient_id++;\n\n    if (type === 'radial') {\n      g.x1 = get(g.x1, 0.5);\n      g.y1 = get(g.y1, 0.5);\n      g.r1 = get(g.r1, 0);\n      g.x2 = get(g.x2, 0.5);\n      g.y2 = get(g.y2, 0.5);\n      g.r2 = get(g.r2, 0.5);\n      prefix = patternPrefix;\n    } else {\n      g.x1 = get(g.x1, 0);\n      g.y1 = get(g.y1, 0);\n      g.x2 = get(g.x2, 1);\n      g.y2 = get(g.y2, 0);\n    }\n  } // register definition\n\n\n  defs[id] = g; // return url reference\n\n  return 'url(' + (base || '') + '#' + prefix + id + ')';\n}\n\nfunction get(val, def) {\n  return val != null ? val : def;\n}\n\nfunction Gradient (p0, p1) {\n  var stops = [],\n      gradient;\n  return gradient = {\n    gradient: 'linear',\n    x1: p0 ? p0[0] : 0,\n    y1: p0 ? p0[1] : 0,\n    x2: p1 ? p1[0] : 1,\n    y2: p1 ? p1[1] : 0,\n    stops: stops,\n    stop: function (offset, color) {\n      stops.push({\n        offset: offset,\n        color: color\n      });\n      return gradient;\n    }\n  };\n}\n\nconst lookup = {\n  'basis': {\n    curve: curveBasis\n  },\n  'basis-closed': {\n    curve: curveBasisClosed\n  },\n  'basis-open': {\n    curve: curveBasisOpen\n  },\n  'bundle': {\n    curve: curveBundle,\n    tension: 'beta',\n    value: 0.85\n  },\n  'cardinal': {\n    curve: curveCardinal,\n    tension: 'tension',\n    value: 0\n  },\n  'cardinal-open': {\n    curve: curveCardinalOpen,\n    tension: 'tension',\n    value: 0\n  },\n  'cardinal-closed': {\n    curve: curveCardinalClosed,\n    tension: 'tension',\n    value: 0\n  },\n  'catmull-rom': {\n    curve: curveCatmullRom,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'catmull-rom-closed': {\n    curve: curveCatmullRomClosed,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'catmull-rom-open': {\n    curve: curveCatmullRomOpen,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'linear': {\n    curve: curveLinear\n  },\n  'linear-closed': {\n    curve: curveLinearClosed\n  },\n  'monotone': {\n    horizontal: curveMonotoneY,\n    vertical: curveMonotoneX\n  },\n  'natural': {\n    curve: curveNatural\n  },\n  'step': {\n    curve: curveStep\n  },\n  'step-after': {\n    curve: curveStepAfter\n  },\n  'step-before': {\n    curve: curveStepBefore\n  }\n};\nfunction curves(type, orientation, tension) {\n  var entry = hasOwnProperty(lookup, type) && lookup[type],\n      curve = null;\n\n  if (entry) {\n    curve = entry.curve || entry[orientation || 'vertical'];\n\n    if (entry.tension && tension != null) {\n      curve = curve[entry.tension](tension);\n    }\n  }\n\n  return curve;\n}\n\nconst paramCounts = {\n  m: 2,\n  l: 2,\n  h: 1,\n  v: 1,\n  z: 0,\n  c: 6,\n  s: 4,\n  q: 4,\n  t: 2,\n  a: 7\n};\nconst commandPattern = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi;\nconst numberPattern = /^[+-]?(([0-9]*\\.[0-9]+)|([0-9]+\\.)|([0-9]+))([eE][+-]?[0-9]+)?/;\nconst spacePattern = /^((\\s+,?\\s*)|(,\\s*))/;\nconst flagPattern = /^[01]/;\nfunction parse(path) {\n  const commands = [];\n  const matches = path.match(commandPattern) || [];\n  matches.forEach(str => {\n    let cmd = str[0];\n    const type = cmd.toLowerCase(); // parse parameters\n\n    const paramCount = paramCounts[type];\n    const params = parseParams(type, paramCount, str.slice(1).trim());\n    const count = params.length; // error checking based on parameter count\n\n    if (count < paramCount || count && count % paramCount !== 0) {\n      throw Error('Invalid SVG path, incorrect parameter count');\n    } // register the command\n\n\n    commands.push([cmd, ...params.slice(0, paramCount)]); // exit now if we're done, also handles zero-param 'z'\n\n    if (count === paramCount) {\n      return;\n    } // handle implicit line-to\n\n\n    if (type === 'm') {\n      cmd = cmd === 'M' ? 'L' : 'l';\n    } // repeat command when given extended param list\n\n\n    for (let i = paramCount; i < count; i += paramCount) {\n      commands.push([cmd, ...params.slice(i, i + paramCount)]);\n    }\n  });\n  return commands;\n}\n\nfunction parseParams(type, paramCount, segment) {\n  const params = [];\n\n  for (let index = 0; paramCount && index < segment.length;) {\n    for (let i = 0; i < paramCount; ++i) {\n      const pattern = type === 'a' && (i === 3 || i === 4) ? flagPattern : numberPattern;\n      const match = segment.slice(index).match(pattern);\n\n      if (match === null) {\n        throw Error('Invalid SVG path, incorrect parameter type');\n      }\n\n      index += match[0].length;\n      params.push(+match[0]);\n      const ws = segment.slice(index).match(spacePattern);\n\n      if (ws !== null) {\n        index += ws[0].length;\n      }\n    }\n  }\n\n  return params;\n}\n\nconst DegToRad = Math.PI / 180;\nconst Epsilon = 1e-14;\nconst HalfPi = Math.PI / 2;\nconst Tau = Math.PI * 2;\nconst HalfSqrt3 = Math.sqrt(3) / 2;\n\nvar segmentCache = {};\nvar bezierCache = {};\nvar join = [].join; // Copied from Inkscape svgtopdf, thanks!\n\nfunction segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  const key = join.call(arguments);\n\n  if (segmentCache[key]) {\n    return segmentCache[key];\n  }\n\n  const th = rotateX * DegToRad;\n  const sin_th = Math.sin(th);\n  const cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  const py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  let pl = px * px / (rx * rx) + py * py / (ry * ry);\n\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  const a00 = cos_th / rx;\n  const a01 = sin_th / rx;\n  const a10 = -sin_th / ry;\n  const a11 = cos_th / ry;\n  const x0 = a00 * ox + a01 * oy;\n  const y0 = a10 * ox + a11 * oy;\n  const x1 = a00 * x + a01 * y;\n  const y1 = a10 * x + a11 * y;\n  const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);\n  let sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  let sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);\n  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);\n  const th0 = Math.atan2(y0 - yc, x0 - xc);\n  const th1 = Math.atan2(y1 - yc, x1 - xc);\n  let th_arc = th1 - th0;\n\n  if (th_arc < 0 && sweep === 1) {\n    th_arc += Tau;\n  } else if (th_arc > 0 && sweep === 0) {\n    th_arc -= Tau;\n  }\n\n  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 0.001)));\n  const result = [];\n\n  for (let i = 0; i < segs; ++i) {\n    const th2 = th0 + i * th_arc / segs;\n    const th3 = th0 + (i + 1) * th_arc / segs;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return segmentCache[key] = result;\n}\nfunction bezier(params) {\n  const key = join.call(params);\n\n  if (bezierCache[key]) {\n    return bezierCache[key];\n  }\n\n  var cx = params[0],\n      cy = params[1],\n      th0 = params[2],\n      th1 = params[3],\n      rx = params[4],\n      ry = params[5],\n      sin_th = params[6],\n      cos_th = params[7];\n  const a00 = cos_th * rx;\n  const a01 = -sin_th * ry;\n  const a10 = sin_th * rx;\n  const a11 = cos_th * ry;\n  const cos_th0 = Math.cos(th0);\n  const sin_th0 = Math.sin(th0);\n  const cos_th1 = Math.cos(th1);\n  const sin_th1 = Math.sin(th1);\n  const th_half = 0.5 * (th1 - th0);\n  const sin_th_h2 = Math.sin(th_half * 0.5);\n  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  const x1 = cx + cos_th0 - t * sin_th0;\n  const y1 = cy + sin_th0 + t * cos_th0;\n  const x3 = cx + cos_th1;\n  const y3 = cy + sin_th1;\n  const x2 = x3 + t * sin_th1;\n  const y2 = y3 - t * cos_th1;\n  return bezierCache[key] = [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];\n}\n\nconst temp = ['l', 0, 0, 0, 0, 0, 0, 0];\n\nfunction scale$1(current, sX, sY) {\n  const c = temp[0] = current[0];\n\n  if (c === 'a' || c === 'A') {\n    temp[1] = sX * current[1];\n    temp[2] = sY * current[2];\n    temp[3] = current[3];\n    temp[4] = current[4];\n    temp[5] = current[5];\n    temp[6] = sX * current[6];\n    temp[7] = sY * current[7];\n  } else if (c === 'h' || c === 'H') {\n    temp[1] = sX * current[1];\n  } else if (c === 'v' || c === 'V') {\n    temp[1] = sY * current[1];\n  } else {\n    for (var i = 1, n = current.length; i < n; ++i) {\n      temp[i] = (i % 2 == 1 ? sX : sY) * current[i];\n    }\n  }\n\n  return temp;\n}\n\nfunction pathRender (context, path, l, t, sX, sY) {\n  var current,\n      // current instruction\n  previous = null,\n      x = 0,\n      // current x\n  y = 0,\n      // current y\n  controlX = 0,\n      // current control point x\n  controlY = 0,\n      // current control point y\n  tempX,\n      tempY,\n      tempControlX,\n      tempControlY,\n      anchorX = 0,\n      anchorY = 0;\n  if (l == null) l = 0;\n  if (t == null) t = 0;\n  if (sX == null) sX = 1;\n  if (sY == null) sY = sX;\n  if (context.beginPath) context.beginPath();\n\n  for (var i = 0, len = path.length; i < len; ++i) {\n    current = path[i];\n\n    if (sX !== 1 || sY !== 1) {\n      current = scale$1(current, sX, sY);\n    }\n\n    switch (current[0]) {\n      // first letter\n      case 'l':\n        // lineto, relative\n        x += current[1];\n        y += current[2];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'L':\n        // lineto, absolute\n        x = current[1];\n        y = current[2];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'h':\n        // horizontal lineto, relative\n        x += current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'H':\n        // horizontal lineto, absolute\n        x = current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'v':\n        // vertical lineto, relative\n        y += current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'V':\n        // verical lineto, absolute\n        y = current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'm':\n        // moveTo, relative\n        x += current[1];\n        y += current[2];\n        anchorX = x;\n        anchorY = y;\n        context.moveTo(x + l, y + t);\n        break;\n\n      case 'M':\n        // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        anchorX = x;\n        anchorY = y;\n        context.moveTo(x + l, y + t);\n        break;\n\n      case 'c':\n        // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        context.bezierCurveTo(x + current[1] + l, // x1\n        y + current[2] + t, // y1\n        controlX + l, // x2\n        controlY + t, // y2\n        tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C':\n        // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        context.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);\n        break;\n\n      case 's':\n        // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4]; // calculate reflection of previous control points\n\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t); // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S':\n        // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4]; // calculate reflection of previous control points\n\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY; // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n\n        controlX = current[1];\n        controlY = current[2];\n        break;\n\n      case 'q':\n        // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        controlX = x + current[1];\n        controlY = y + current[2];\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'Q':\n        // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        context.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        break;\n\n      case 't':\n        // shorthand quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        } else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        } else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2]; // calculate reflection of previous control points\n\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'a':\n        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        x = anchorX;\n        y = anchorY;\n        context.closePath();\n        break;\n    }\n\n    previous = current;\n  }\n}\n\nfunction drawArc(context, x, y, coords) {\n  const seg = segments(coords[5], // end x\n  coords[6], // end y\n  coords[0], // radius x\n  coords[1], // radius y\n  coords[3], // large flag\n  coords[4], // sweep flag\n  coords[2], // rotation\n  x, y);\n\n  for (let i = 0; i < seg.length; ++i) {\n    const bez = bezier(seg[i]);\n    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);\n  }\n}\n\nconst Tan30 = 0.5773502691896257;\nconst builtins = {\n  'circle': {\n    draw: function (context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(r, 0);\n      context.arc(0, 0, r, 0, Tau);\n    }\n  },\n  'cross': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          s = r / 2.5;\n      context.moveTo(-r, -s);\n      context.lineTo(-r, s);\n      context.lineTo(-s, s);\n      context.lineTo(-s, r);\n      context.lineTo(s, r);\n      context.lineTo(s, s);\n      context.lineTo(r, s);\n      context.lineTo(r, -s);\n      context.lineTo(s, -s);\n      context.lineTo(s, -r);\n      context.lineTo(-s, -r);\n      context.lineTo(-s, -s);\n      context.closePath();\n    }\n  },\n  'diamond': {\n    draw: function (context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(-r, 0);\n      context.lineTo(0, -r);\n      context.lineTo(r, 0);\n      context.lineTo(0, r);\n      context.closePath();\n    }\n  },\n  'square': {\n    draw: function (context, size) {\n      var w = Math.sqrt(size),\n          x = -w / 2;\n      context.rect(x, x, w, w);\n    }\n  },\n  'arrow': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          s = r / 7,\n          t = r / 2.5,\n          v = r / 8;\n      context.moveTo(-s, r);\n      context.lineTo(s, r);\n      context.lineTo(s, -v);\n      context.lineTo(t, -v);\n      context.lineTo(0, -r);\n      context.lineTo(-t, -v);\n      context.lineTo(-s, -v);\n      context.closePath();\n    }\n  },\n  'wedge': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r,\n          o = h - r * Tan30,\n          b = r / 4;\n      context.moveTo(0, -h - o);\n      context.lineTo(-b, h - o);\n      context.lineTo(b, h - o);\n      context.closePath();\n    }\n  },\n  'triangle': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r,\n          o = h - r * Tan30;\n      context.moveTo(0, -h - o);\n      context.lineTo(-r, h - o);\n      context.lineTo(r, h - o);\n      context.closePath();\n    }\n  },\n  'triangle-up': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(0, -h);\n      context.lineTo(-r, h);\n      context.lineTo(r, h);\n      context.closePath();\n    }\n  },\n  'triangle-down': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(0, h);\n      context.lineTo(-r, -h);\n      context.lineTo(r, -h);\n      context.closePath();\n    }\n  },\n  'triangle-right': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(h, 0);\n      context.lineTo(-h, -r);\n      context.lineTo(-h, r);\n      context.closePath();\n    }\n  },\n  'triangle-left': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = HalfSqrt3 * r;\n      context.moveTo(-h, 0);\n      context.lineTo(h, -r);\n      context.lineTo(h, r);\n      context.closePath();\n    }\n  },\n  'stroke': {\n    draw: function (context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(-r, 0);\n      context.lineTo(r, 0);\n    }\n  }\n};\nfunction symbols(_) {\n  return hasOwnProperty(builtins, _) ? builtins[_] : customSymbol(_);\n}\nvar custom = {};\n\nfunction customSymbol(path) {\n  if (!hasOwnProperty(custom, path)) {\n    const parsed = parse(path);\n    custom[path] = {\n      draw: function (context, size) {\n        pathRender(context, parsed, 0, 0, Math.sqrt(size) / 2);\n      }\n    };\n  }\n\n  return custom[path];\n}\n\nconst C = 0.448084975506; // C = 1 - c\n\nfunction rectangleX(d) {\n  return d.x;\n}\n\nfunction rectangleY(d) {\n  return d.y;\n}\n\nfunction rectangleWidth(d) {\n  return d.width;\n}\n\nfunction rectangleHeight(d) {\n  return d.height;\n}\n\nfunction number(_) {\n  return typeof _ === 'function' ? _ : () => +_;\n}\n\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n}\n\nfunction vg_rect () {\n  var x = rectangleX,\n      y = rectangleY,\n      width = rectangleWidth,\n      height = rectangleHeight,\n      crTL = number(0),\n      crTR = crTL,\n      crBL = crTL,\n      crBR = crTL,\n      context = null;\n\n  function rectangle(_, x0, y0) {\n    var buffer,\n        x1 = x0 != null ? x0 : +x.call(this, _),\n        y1 = y0 != null ? y0 : +y.call(this, _),\n        w = +width.call(this, _),\n        h = +height.call(this, _),\n        s = Math.min(w, h) / 2,\n        tl = clamp(+crTL.call(this, _), 0, s),\n        tr = clamp(+crTR.call(this, _), 0, s),\n        bl = clamp(+crBL.call(this, _), 0, s),\n        br = clamp(+crBR.call(this, _), 0, s);\n    if (!context) context = buffer = path$3();\n\n    if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {\n      context.rect(x1, y1, w, h);\n    } else {\n      var x2 = x1 + w,\n          y2 = y1 + h;\n      context.moveTo(x1 + tl, y1);\n      context.lineTo(x2 - tr, y1);\n      context.bezierCurveTo(x2 - C * tr, y1, x2, y1 + C * tr, x2, y1 + tr);\n      context.lineTo(x2, y2 - br);\n      context.bezierCurveTo(x2, y2 - C * br, x2 - C * br, y2, x2 - br, y2);\n      context.lineTo(x1 + bl, y2);\n      context.bezierCurveTo(x1 + C * bl, y2, x1, y2 - C * bl, x1, y2 - bl);\n      context.lineTo(x1, y1 + tl);\n      context.bezierCurveTo(x1, y1 + C * tl, x1 + C * tl, y1, x1 + tl, y1);\n      context.closePath();\n    }\n\n    if (buffer) {\n      context = null;\n      return buffer + '' || null;\n    }\n  }\n\n  rectangle.x = function (_) {\n    if (arguments.length) {\n      x = number(_);\n      return rectangle;\n    } else {\n      return x;\n    }\n  };\n\n  rectangle.y = function (_) {\n    if (arguments.length) {\n      y = number(_);\n      return rectangle;\n    } else {\n      return y;\n    }\n  };\n\n  rectangle.width = function (_) {\n    if (arguments.length) {\n      width = number(_);\n      return rectangle;\n    } else {\n      return width;\n    }\n  };\n\n  rectangle.height = function (_) {\n    if (arguments.length) {\n      height = number(_);\n      return rectangle;\n    } else {\n      return height;\n    }\n  };\n\n  rectangle.cornerRadius = function (tl, tr, br, bl) {\n    if (arguments.length) {\n      crTL = number(tl);\n      crTR = tr != null ? number(tr) : crTL;\n      crBR = br != null ? number(br) : crTL;\n      crBL = bl != null ? number(bl) : crTR;\n      return rectangle;\n    } else {\n      return crTL;\n    }\n  };\n\n  rectangle.context = function (_) {\n    if (arguments.length) {\n      context = _ == null ? null : _;\n      return rectangle;\n    } else {\n      return context;\n    }\n  };\n\n  return rectangle;\n}\n\nfunction vg_trail () {\n  var x,\n      y,\n      size,\n      defined,\n      context = null,\n      ready,\n      x1,\n      y1,\n      r1;\n\n  function point(x2, y2, w2) {\n    const r2 = w2 / 2;\n\n    if (ready) {\n      var ux = y1 - y2,\n          uy = x2 - x1;\n\n      if (ux || uy) {\n        // get normal vector\n        var ud = Math.sqrt(ux * ux + uy * uy),\n            rx = (ux /= ud) * r1,\n            ry = (uy /= ud) * r1,\n            t = Math.atan2(uy, ux); // draw segment\n\n        context.moveTo(x1 - rx, y1 - ry);\n        context.lineTo(x2 - ux * r2, y2 - uy * r2);\n        context.arc(x2, y2, r2, t - Math.PI, t);\n        context.lineTo(x1 + rx, y1 + ry);\n        context.arc(x1, y1, r1, t, t + Math.PI);\n      } else {\n        context.arc(x2, y2, r2, 0, Tau);\n      }\n\n      context.closePath();\n    } else {\n      ready = 1;\n    }\n\n    x1 = x2;\n    y1 = y2;\n    r1 = r2;\n  }\n\n  function trail(data) {\n    var i,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer;\n    if (context == null) context = buffer = path$3();\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) ready = 0;\n      }\n\n      if (defined0) point(+x(d, i, data), +y(d, i, data), +size(d, i, data));\n    }\n\n    if (buffer) {\n      context = null;\n      return buffer + '' || null;\n    }\n  }\n\n  trail.x = function (_) {\n    if (arguments.length) {\n      x = _;\n      return trail;\n    } else {\n      return x;\n    }\n  };\n\n  trail.y = function (_) {\n    if (arguments.length) {\n      y = _;\n      return trail;\n    } else {\n      return y;\n    }\n  };\n\n  trail.size = function (_) {\n    if (arguments.length) {\n      size = _;\n      return trail;\n    } else {\n      return size;\n    }\n  };\n\n  trail.defined = function (_) {\n    if (arguments.length) {\n      defined = _;\n      return trail;\n    } else {\n      return defined;\n    }\n  };\n\n  trail.context = function (_) {\n    if (arguments.length) {\n      if (_ == null) {\n        context = null;\n      } else {\n        context = _;\n      }\n\n      return trail;\n    } else {\n      return context;\n    }\n  };\n\n  return trail;\n}\n\nfunction value$1(a, b) {\n  return a != null ? a : b;\n}\n\nconst x = item => item.x || 0,\n      y = item => item.y || 0,\n      w = item => item.width || 0,\n      h = item => item.height || 0,\n      xw = item => (item.x || 0) + (item.width || 0),\n      yh = item => (item.y || 0) + (item.height || 0),\n      sa = item => item.startAngle || 0,\n      ea = item => item.endAngle || 0,\n      pa = item => item.padAngle || 0,\n      ir = item => item.innerRadius || 0,\n      or = item => item.outerRadius || 0,\n      cr = item => item.cornerRadius || 0,\n      tl = item => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0,\n      tr = item => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0,\n      br = item => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0,\n      bl = item => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0,\n      sz = item => value$1(item.size, 64),\n      ts = item => item.size || 1,\n      def = item => !(item.defined === false),\n      type = item => symbols(item.shape || 'circle');\n\nconst arcShape = arc$2().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr),\n      areavShape = area$2().x(x).y1(y).y0(yh).defined(def),\n      areahShape = area$2().y(y).x1(x).x0(xw).defined(def),\n      lineShape = line$2().x(x).y(y).defined(def),\n      rectShape = vg_rect().x(x).y(y).width(w).height(h).cornerRadius(tl, tr, br, bl),\n      symbolShape = symbol$2().type(type).size(sz),\n      trailShape = vg_trail().x(x).y(y).defined(def).size(ts);\nfunction hasCornerRadius(item) {\n  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;\n}\nfunction arc$1(context, item) {\n  return arcShape.context(context)(item);\n}\nfunction area$1(context, items) {\n  const item = items[0],\n        interp = item.interpolate || 'linear';\n  return (item.orient === 'horizontal' ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context)(items);\n}\nfunction line$1(context, items) {\n  const item = items[0],\n        interp = item.interpolate || 'linear';\n  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context)(items);\n}\nfunction rectangle(context, item, x, y) {\n  return rectShape.context(context)(item, x, y);\n}\nfunction shape$1(context, item) {\n  return (item.mark.shape || item.shape).context(context)(item);\n}\nfunction symbol$1(context, item) {\n  return symbolShape.context(context)(item);\n}\nfunction trail$1(context, items) {\n  return trailShape.context(context)(items);\n}\n\nvar clip_id = 1;\nfunction resetSVGClipId() {\n  clip_id = 1;\n}\nfunction clip$1 (renderer, item, size) {\n  var clip = item.clip,\n      defs = renderer._defs,\n      id = item.clip_id || (item.clip_id = 'clip' + clip_id++),\n      c = defs.clipping[id] || (defs.clipping[id] = {\n    id: id\n  });\n\n  if (isFunction(clip)) {\n    c.path = clip(null);\n  } else if (hasCornerRadius(size)) {\n    c.path = rectangle(null, size, 0, 0);\n  } else {\n    c.width = size.width || 0;\n    c.height = size.height || 0;\n  }\n\n  return 'url(#' + id + ')';\n}\n\nfunction Bounds(b) {\n  this.clear();\n  if (b) this.union(b);\n}\nBounds.prototype = {\n  clone() {\n    return new Bounds(this);\n  },\n\n  clear() {\n    this.x1 = +Number.MAX_VALUE;\n    this.y1 = +Number.MAX_VALUE;\n    this.x2 = -Number.MAX_VALUE;\n    this.y2 = -Number.MAX_VALUE;\n    return this;\n  },\n\n  empty() {\n    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;\n  },\n\n  equals(b) {\n    return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;\n  },\n\n  set(x1, y1, x2, y2) {\n    if (x2 < x1) {\n      this.x2 = x1;\n      this.x1 = x2;\n    } else {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    if (y2 < y1) {\n      this.y2 = y1;\n      this.y1 = y2;\n    } else {\n      this.y1 = y1;\n      this.y2 = y2;\n    }\n\n    return this;\n  },\n\n  add(x, y) {\n    if (x < this.x1) this.x1 = x;\n    if (y < this.y1) this.y1 = y;\n    if (x > this.x2) this.x2 = x;\n    if (y > this.y2) this.y2 = y;\n    return this;\n  },\n\n  expand(d) {\n    this.x1 -= d;\n    this.y1 -= d;\n    this.x2 += d;\n    this.y2 += d;\n    return this;\n  },\n\n  round() {\n    this.x1 = Math.floor(this.x1);\n    this.y1 = Math.floor(this.y1);\n    this.x2 = Math.ceil(this.x2);\n    this.y2 = Math.ceil(this.y2);\n    return this;\n  },\n\n  scale(s) {\n    this.x1 *= s;\n    this.y1 *= s;\n    this.x2 *= s;\n    this.y2 *= s;\n    return this;\n  },\n\n  translate(dx, dy) {\n    this.x1 += dx;\n    this.x2 += dx;\n    this.y1 += dy;\n    this.y2 += dy;\n    return this;\n  },\n\n  rotate(angle, x, y) {\n    const p = this.rotatedPoints(angle, x, y);\n    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);\n  },\n\n  rotatedPoints(angle, x, y) {\n    var {\n      x1,\n      y1,\n      x2,\n      y2\n    } = this,\n        cos = Math.cos(angle),\n        sin = Math.sin(angle),\n        cx = x - x * cos + y * sin,\n        cy = y - x * sin - y * cos;\n    return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];\n  },\n\n  union(b) {\n    if (b.x1 < this.x1) this.x1 = b.x1;\n    if (b.y1 < this.y1) this.y1 = b.y1;\n    if (b.x2 > this.x2) this.x2 = b.x2;\n    if (b.y2 > this.y2) this.y2 = b.y2;\n    return this;\n  },\n\n  intersect(b) {\n    if (b.x1 > this.x1) this.x1 = b.x1;\n    if (b.y1 > this.y1) this.y1 = b.y1;\n    if (b.x2 < this.x2) this.x2 = b.x2;\n    if (b.y2 < this.y2) this.y2 = b.y2;\n    return this;\n  },\n\n  encloses(b) {\n    return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;\n  },\n\n  alignsWith(b) {\n    return b && (this.x1 == b.x1 || this.x2 == b.x2 || this.y1 == b.y1 || this.y2 == b.y2);\n  },\n\n  intersects(b) {\n    return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);\n  },\n\n  contains(x, y) {\n    return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);\n  },\n\n  width() {\n    return this.x2 - this.x1;\n  },\n\n  height() {\n    return this.y2 - this.y1;\n  }\n\n};\n\nfunction Item(mark) {\n  this.mark = mark;\n  this.bounds = this.bounds || new Bounds();\n}\n\nfunction GroupItem(mark) {\n  Item.call(this, mark);\n  this.items = this.items || [];\n}\ninherits(GroupItem, Item);\n\nfunction ResourceLoader(customLoader) {\n  this._pending = 0;\n  this._loader = customLoader || loader();\n}\n\nfunction increment(loader) {\n  loader._pending += 1;\n}\n\nfunction decrement(loader) {\n  loader._pending -= 1;\n}\n\nResourceLoader.prototype = {\n  pending() {\n    return this._pending;\n  },\n\n  sanitizeURL(uri) {\n    const loader = this;\n    increment(loader);\n    return loader._loader.sanitize(uri, {\n      context: 'href'\n    }).then(opt => {\n      decrement(loader);\n      return opt;\n    }).catch(() => {\n      decrement(loader);\n      return null;\n    });\n  },\n\n  loadImage(uri) {\n    const loader = this,\n          Image = image$1();\n    increment(loader);\n    return loader._loader.sanitize(uri, {\n      context: 'image'\n    }).then(opt => {\n      const url = opt.href;\n      if (!url || !Image) throw {\n        url: url\n      };\n      const img = new Image(); // set crossOrigin only if cors is defined; empty string sets anonymous mode\n      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/crossOrigin\n\n      const cors = hasOwnProperty(opt, 'crossOrigin') ? opt.crossOrigin : 'anonymous';\n      if (cors != null) img.crossOrigin = cors; // attempt to load image resource\n\n      img.onload = () => decrement(loader);\n\n      img.onerror = () => decrement(loader);\n\n      img.src = url;\n      return img;\n    }).catch(e => {\n      decrement(loader);\n      return {\n        complete: false,\n        width: 0,\n        height: 0,\n        src: e && e.url || ''\n      };\n    });\n  },\n\n  ready() {\n    const loader = this;\n    return new Promise(accept => {\n      function poll(value) {\n        if (!loader.pending()) accept(value);else setTimeout(() => {\n          poll(true);\n        }, 10);\n      }\n\n      poll(false);\n    });\n  }\n\n};\n\nfunction boundStroke (bounds, item, miter) {\n  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {\n    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;\n    bounds.expand(sw + (miter ? miterAdjustment(item, sw) : 0));\n  }\n\n  return bounds;\n}\n\nfunction miterAdjustment(item, strokeWidth) {\n  // TODO: more sophisticated adjustment? Or miter support in boundContext?\n  return item.strokeJoin && item.strokeJoin !== 'miter' ? 0 : strokeWidth;\n}\n\nconst circleThreshold = Tau - 1e-8;\nlet bounds, lx, ly, rot, ma, mb, mc, md;\n\nconst add = (x, y) => bounds.add(x, y);\n\nconst addL = (x, y) => add(lx = x, ly = y);\n\nconst addX = x => add(x, bounds.y1);\n\nconst addY = y => add(bounds.x1, y);\n\nconst px = (x, y) => ma * x + mc * y;\n\nconst py = (x, y) => mb * x + md * y;\n\nconst addp = (x, y) => add(px(x, y), py(x, y));\n\nconst addpL = (x, y) => addL(px(x, y), py(x, y));\n\nfunction boundContext (_, deg) {\n  bounds = _;\n\n  if (deg) {\n    rot = deg * DegToRad;\n    ma = md = Math.cos(rot);\n    mb = Math.sin(rot);\n    mc = -mb;\n  } else {\n    ma = md = 1;\n    rot = mb = mc = 0;\n  }\n\n  return context$1;\n}\nconst context$1 = {\n  beginPath() {},\n\n  closePath() {},\n\n  moveTo: addpL,\n  lineTo: addpL,\n\n  rect(x, y, w, h) {\n    if (rot) {\n      addp(x + w, y);\n      addp(x + w, y + h);\n      addp(x, y + h);\n      addpL(x, y);\n    } else {\n      add(x + w, y + h);\n      addL(x, y);\n    }\n  },\n\n  quadraticCurveTo(x1, y1, x2, y2) {\n    const px1 = px(x1, y1),\n          py1 = py(x1, y1),\n          px2 = px(x2, y2),\n          py2 = py(x2, y2);\n    quadExtrema(lx, px1, px2, addX);\n    quadExtrema(ly, py1, py2, addY);\n    addL(px2, py2);\n  },\n\n  bezierCurveTo(x1, y1, x2, y2, x3, y3) {\n    const px1 = px(x1, y1),\n          py1 = py(x1, y1),\n          px2 = px(x2, y2),\n          py2 = py(x2, y2),\n          px3 = px(x3, y3),\n          py3 = py(x3, y3);\n    cubicExtrema(lx, px1, px2, px3, addX);\n    cubicExtrema(ly, py1, py2, py3, addY);\n    addL(px3, py3);\n  },\n\n  arc(cx, cy, r, sa, ea, ccw) {\n    sa += rot;\n    ea += rot; // store last point on path\n\n    lx = r * Math.cos(ea) + cx;\n    ly = r * Math.sin(ea) + cy;\n\n    if (Math.abs(ea - sa) > circleThreshold) {\n      // treat as full circle\n      add(cx - r, cy - r);\n      add(cx + r, cy + r);\n    } else {\n      const update = a => add(r * Math.cos(a) + cx, r * Math.sin(a) + cy);\n\n      let s, i; // sample end points\n\n      update(sa);\n      update(ea); // sample interior points aligned with 90 degrees\n\n      if (ea !== sa) {\n        sa = sa % Tau;\n        if (sa < 0) sa += Tau;\n        ea = ea % Tau;\n        if (ea < 0) ea += Tau;\n\n        if (ea < sa) {\n          ccw = !ccw; // flip direction\n\n          s = sa;\n          sa = ea;\n          ea = s; // swap end-points\n        }\n\n        if (ccw) {\n          ea -= Tau;\n          s = sa - sa % HalfPi;\n\n          for (i = 0; i < 4 && s > ea; ++i, s -= HalfPi) update(s);\n        } else {\n          s = sa - sa % HalfPi + HalfPi;\n\n          for (i = 0; i < 4 && s < ea; ++i, s = s + HalfPi) update(s);\n        }\n      }\n    }\n  }\n\n};\n\nfunction quadExtrema(x0, x1, x2, cb) {\n  const t = (x0 - x1) / (x0 + x2 - 2 * x1);\n  if (0 < t && t < 1) cb(x0 + (x1 - x0) * t);\n}\n\nfunction cubicExtrema(x0, x1, x2, x3, cb) {\n  const a = x3 - x0 + 3 * x1 - 3 * x2,\n        b = x0 + x2 - 2 * x1,\n        c = x0 - x1;\n  let t0 = 0,\n      t1 = 0,\n      r; // solve for parameter t\n\n  if (Math.abs(a) > Epsilon) {\n    // quadratic equation\n    r = b * b + c * a;\n\n    if (r >= 0) {\n      r = Math.sqrt(r);\n      t0 = (-b + r) / a;\n      t1 = (-b - r) / a;\n    }\n  } else {\n    // linear equation\n    t0 = 0.5 * c / b;\n  } // calculate position\n\n\n  if (0 < t0 && t0 < 1) cb(cubic(t0, x0, x1, x2, x3));\n  if (0 < t1 && t1 < 1) cb(cubic(t1, x0, x1, x2, x3));\n}\n\nfunction cubic(t, x0, x1, x2, x3) {\n  const s = 1 - t,\n        s2 = s * s,\n        t2 = t * t;\n  return s2 * s * x0 + 3 * s2 * t * x1 + 3 * s * t2 * x2 + t2 * t * x3;\n}\n\nvar context = (context = canvas(1, 1)) ? context.getContext('2d') : null;\n\nconst b = new Bounds();\nfunction intersectPath(draw) {\n  return function (item, brush) {\n    // rely on (inaccurate) bounds intersection if no context\n    if (!context) return true; // add path to offscreen graphics context\n\n    draw(context, item); // get bounds intersection region\n\n    b.clear().union(item.bounds).intersect(brush).round();\n    const {\n      x1,\n      y1,\n      x2,\n      y2\n    } = b; // iterate over intersection region\n    // perform fine grained inclusion test\n\n    for (let y = y1; y <= y2; ++y) {\n      for (let x = x1; x <= x2; ++x) {\n        if (context.isPointInPath(x, y)) {\n          return true;\n        }\n      }\n    } // false if no hits in intersection region\n\n\n    return false;\n  };\n}\nfunction intersectPoint(item, box) {\n  return box.contains(item.x || 0, item.y || 0);\n}\nfunction intersectRect(item, box) {\n  const x = item.x || 0,\n        y = item.y || 0,\n        w = item.width || 0,\n        h = item.height || 0;\n  return box.intersects(b.set(x, y, x + w, y + h));\n}\nfunction intersectRule(item, box) {\n  const x = item.x || 0,\n        y = item.y || 0,\n        x2 = item.x2 != null ? item.x2 : x,\n        y2 = item.y2 != null ? item.y2 : y;\n  return intersectBoxLine(box, x, y, x2, y2);\n}\nfunction intersectBoxLine(box, x, y, u, v) {\n  const {\n    x1,\n    y1,\n    x2,\n    y2\n  } = box,\n        dx = u - x,\n        dy = v - y;\n  let t0 = 0,\n      t1 = 1,\n      p,\n      q,\n      r,\n      e;\n\n  for (e = 0; e < 4; ++e) {\n    if (e === 0) {\n      p = -dx;\n      q = -(x1 - x);\n    }\n\n    if (e === 1) {\n      p = dx;\n      q = x2 - x;\n    }\n\n    if (e === 2) {\n      p = -dy;\n      q = -(y1 - y);\n    }\n\n    if (e === 3) {\n      p = dy;\n      q = y2 - y;\n    }\n\n    if (Math.abs(p) < 1e-10 && q < 0) return false;\n    r = q / p;\n\n    if (p < 0) {\n      if (r > t1) return false;else if (r > t0) t0 = r;\n    } else if (p > 0) {\n      if (r < t0) return false;else if (r < t1) t1 = r;\n    }\n  }\n\n  return true;\n}\n\nfunction blend (context, item) {\n  context.globalCompositeOperation = item.blend || 'source-over';\n}\n\nfunction value (value, dflt) {\n  return value == null ? dflt : value;\n}\n\nfunction addStops(gradient, stops) {\n  const n = stops.length;\n\n  for (let i = 0; i < n; ++i) {\n    gradient.addColorStop(stops[i].offset, stops[i].color);\n  }\n\n  return gradient;\n}\n\nfunction gradient (context, spec, bounds) {\n  const w = bounds.width(),\n        h = bounds.height();\n  let gradient;\n\n  if (spec.gradient === 'radial') {\n    gradient = context.createRadialGradient(bounds.x1 + value(spec.x1, 0.5) * w, bounds.y1 + value(spec.y1, 0.5) * h, Math.max(w, h) * value(spec.r1, 0), bounds.x1 + value(spec.x2, 0.5) * w, bounds.y1 + value(spec.y2, 0.5) * h, Math.max(w, h) * value(spec.r2, 0.5));\n  } else {\n    // linear gradient\n    const x1 = value(spec.x1, 0),\n          y1 = value(spec.y1, 0),\n          x2 = value(spec.x2, 1),\n          y2 = value(spec.y2, 0);\n\n    if (x1 === x2 || y1 === y2 || w === h) {\n      // axis aligned: use normal gradient\n      gradient = context.createLinearGradient(bounds.x1 + x1 * w, bounds.y1 + y1 * h, bounds.x1 + x2 * w, bounds.y1 + y2 * h);\n    } else {\n      // not axis aligned: render gradient into a pattern (#2365)\n      // this allows us to use normalized bounding box coordinates\n      const image = canvas(Math.ceil(w), Math.ceil(h)),\n            ictx = image.getContext('2d');\n      ictx.scale(w, h);\n      ictx.fillStyle = addStops(ictx.createLinearGradient(x1, y1, x2, y2), spec.stops);\n      ictx.fillRect(0, 0, w, h);\n      return context.createPattern(image, 'no-repeat');\n    }\n  }\n\n  return addStops(gradient, spec.stops);\n}\n\nfunction color (context, item, value) {\n  return isGradient(value) ? gradient(context, value, item.bounds) : value;\n}\n\nfunction fill (context, item, opacity) {\n  opacity *= item.fillOpacity == null ? 1 : item.fillOpacity;\n\n  if (opacity > 0) {\n    context.globalAlpha = opacity;\n    context.fillStyle = color(context, item, item.fill);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvar Empty = [];\nfunction stroke (context, item, opacity) {\n  var lw = (lw = item.strokeWidth) != null ? lw : 1;\n  if (lw <= 0) return false;\n  opacity *= item.strokeOpacity == null ? 1 : item.strokeOpacity;\n\n  if (opacity > 0) {\n    context.globalAlpha = opacity;\n    context.strokeStyle = color(context, item, item.stroke);\n    context.lineWidth = lw;\n    context.lineCap = item.strokeCap || 'butt';\n    context.lineJoin = item.strokeJoin || 'miter';\n    context.miterLimit = item.strokeMiterLimit || 10;\n\n    if (context.setLineDash) {\n      context.setLineDash(item.strokeDash || Empty);\n      context.lineDashOffset = item.strokeDashOffset || 0;\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction compare(a, b) {\n  return a.zindex - b.zindex || a.index - b.index;\n}\n\nfunction zorder(scene) {\n  if (!scene.zdirty) return scene.zitems;\n  var items = scene.items,\n      output = [],\n      item,\n      i,\n      n;\n\n  for (i = 0, n = items.length; i < n; ++i) {\n    item = items[i];\n    item.index = i;\n    if (item.zindex) output.push(item);\n  }\n\n  scene.zdirty = false;\n  return scene.zitems = output.sort(compare);\n}\nfunction visit(scene, visitor) {\n  var items = scene.items,\n      i,\n      n;\n  if (!items || !items.length) return;\n  const zitems = zorder(scene);\n\n  if (zitems && zitems.length) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      if (!items[i].zindex) visitor(items[i]);\n    }\n\n    items = zitems;\n  }\n\n  for (i = 0, n = items.length; i < n; ++i) {\n    visitor(items[i]);\n  }\n}\nfunction pickVisit(scene, visitor) {\n  var items = scene.items,\n      hit,\n      i;\n  if (!items || !items.length) return null;\n  const zitems = zorder(scene);\n  if (zitems && zitems.length) items = zitems;\n\n  for (i = items.length; --i >= 0;) {\n    if (hit = visitor(items[i])) return hit;\n  }\n\n  if (items === zitems) {\n    for (items = scene.items, i = items.length; --i >= 0;) {\n      if (!items[i].zindex) {\n        if (hit = visitor(items[i])) return hit;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction drawAll(path) {\n  return function (context, scene, bounds) {\n    visit(scene, item => {\n      if (!bounds || bounds.intersects(item.bounds)) {\n        drawPath(path, context, item, item);\n      }\n    });\n  };\n}\nfunction drawOne(path) {\n  return function (context, scene, bounds) {\n    if (scene.items.length && (!bounds || bounds.intersects(scene.bounds))) {\n      drawPath(path, context, scene.items[0], scene.items);\n    }\n  };\n}\n\nfunction drawPath(path, context, item, items) {\n  var opacity = item.opacity == null ? 1 : item.opacity;\n  if (opacity === 0) return;\n  if (path(context, items)) return;\n  blend(context, item);\n\n  if (item.fill && fill(context, item, opacity)) {\n    context.fill();\n  }\n\n  if (item.stroke && stroke(context, item, opacity)) {\n    context.stroke();\n  }\n}\n\nfunction pick$1(test) {\n  test = test || truthy;\n  return function (context, scene, x, y, gx, gy) {\n    x *= context.pixelRatio;\n    y *= context.pixelRatio;\n    return pickVisit(scene, item => {\n      const b = item.bounds; // first hit test against bounding box\n\n      if (b && !b.contains(gx, gy) || !b) return; // if in bounding box, perform more careful test\n\n      if (test(context, item, x, y, gx, gy)) return item;\n    });\n  };\n}\nfunction hitPath(path, filled) {\n  return function (context, o, x, y) {\n    var item = Array.isArray(o) ? o[0] : o,\n        fill = filled == null ? item.fill : filled,\n        stroke = item.stroke && context.isPointInStroke,\n        lw,\n        lc;\n\n    if (stroke) {\n      lw = item.strokeWidth;\n      lc = item.strokeCap;\n      context.lineWidth = lw != null ? lw : 1;\n      context.lineCap = lc != null ? lc : 'butt';\n    }\n\n    return path(context, o) ? false : fill && context.isPointInPath(x, y) || stroke && context.isPointInStroke(x, y);\n  };\n}\nfunction pickPath(path) {\n  return pick$1(hitPath(path));\n}\n\nfunction translate(x, y) {\n  return 'translate(' + x + ',' + y + ')';\n}\nfunction rotate(a) {\n  return 'rotate(' + a + ')';\n}\nfunction scale(scaleX, scaleY) {\n  return 'scale(' + scaleX + ',' + scaleY + ')';\n}\nfunction translateItem(item) {\n  return translate(item.x || 0, item.y || 0);\n}\nfunction rotateItem(item) {\n  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '');\n}\nfunction transformItem(item) {\n  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '') + (item.scaleX || item.scaleY ? ' ' + scale(item.scaleX || 1, item.scaleY || 1) : '');\n}\n\nfunction markItemPath (type, shape, isect) {\n  function attr(emit, item) {\n    emit('transform', rotateItem(item));\n    emit('d', shape(null, item));\n  }\n\n  function bound(bounds, item) {\n    shape(boundContext(bounds, item.angle), item);\n    return boundStroke(bounds, item).translate(item.x || 0, item.y || 0);\n  }\n\n  function draw(context, item) {\n    var x = item.x || 0,\n        y = item.y || 0,\n        a = item.angle || 0;\n    context.translate(x, y);\n    if (a) context.rotate(a *= DegToRad);\n    context.beginPath();\n    shape(context, item);\n    if (a) context.rotate(-a);\n    context.translate(-x, -y);\n  }\n\n  return {\n    type: type,\n    tag: 'path',\n    nested: false,\n    attr: attr,\n    bound: bound,\n    draw: drawAll(draw),\n    pick: pickPath(draw),\n    isect: isect || intersectPath(draw)\n  };\n}\n\nvar arc = markItemPath('arc', arc$1);\n\nfunction pickArea(a, p) {\n  var v = a[0].orient === 'horizontal' ? p[1] : p[0],\n      z = a[0].orient === 'horizontal' ? 'y' : 'x',\n      i = a.length,\n      min = +Infinity,\n      hit,\n      d;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    d = Math.abs(a[i][z] - v);\n\n    if (d < min) {\n      min = d;\n      hit = a[i];\n    }\n  }\n\n  return hit;\n}\nfunction pickLine(a, p) {\n  var t = Math.pow(a[0].strokeWidth || 1, 2),\n      i = a.length,\n      dx,\n      dy,\n      dd;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    dx = a[i].x - p[0];\n    dy = a[i].y - p[1];\n    dd = dx * dx + dy * dy;\n    if (dd < t) return a[i];\n  }\n\n  return null;\n}\nfunction pickTrail(a, p) {\n  var i = a.length,\n      dx,\n      dy,\n      dd;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    dx = a[i].x - p[0];\n    dy = a[i].y - p[1];\n    dd = dx * dx + dy * dy;\n    dx = a[i].size || 1;\n    if (dd < dx * dx) return a[i];\n  }\n\n  return null;\n}\n\nfunction markMultiItemPath (type, shape, tip) {\n  function attr(emit, item) {\n    var items = item.mark.items;\n    if (items.length) emit('d', shape(null, items));\n  }\n\n  function bound(bounds, mark) {\n    var items = mark.items;\n\n    if (items.length === 0) {\n      return bounds;\n    } else {\n      shape(boundContext(bounds), items);\n      return boundStroke(bounds, items[0]);\n    }\n  }\n\n  function draw(context, items) {\n    context.beginPath();\n    shape(context, items);\n  }\n\n  const hit = hitPath(draw);\n\n  function pick(context, scene, x, y, gx, gy) {\n    var items = scene.items,\n        b = scene.bounds;\n\n    if (!items || !items.length || b && !b.contains(gx, gy)) {\n      return null;\n    }\n\n    x *= context.pixelRatio;\n    y *= context.pixelRatio;\n    return hit(context, items, x, y) ? items[0] : null;\n  }\n\n  return {\n    type: type,\n    tag: 'path',\n    nested: true,\n    attr: attr,\n    bound: bound,\n    draw: drawOne(draw),\n    pick: pick,\n    isect: intersectPoint,\n    tip: tip\n  };\n}\n\nvar area = markMultiItemPath('area', area$1, pickArea);\n\nfunction clip (context, scene) {\n  var clip = scene.clip;\n  context.save();\n\n  if (isFunction(clip)) {\n    context.beginPath();\n    clip(context);\n    context.clip();\n  } else {\n    clipGroup(context, scene.group);\n  }\n}\nfunction clipGroup(context, group) {\n  context.beginPath();\n  hasCornerRadius(group) ? rectangle(context, group, 0, 0) : context.rect(0, 0, group.width || 0, group.height || 0);\n  context.clip();\n}\n\nfunction offset$1(item) {\n  const sw = value(item.strokeWidth, 1);\n  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;\n}\n\nfunction attr$5(emit, item) {\n  emit('transform', translateItem(item));\n}\n\nfunction emitRectangle(emit, item) {\n  const off = offset$1(item);\n  emit('d', rectangle(null, item, off, off));\n}\n\nfunction background(emit, item) {\n  emit('class', 'background');\n  emit('aria-hidden', true);\n  emitRectangle(emit, item);\n}\n\nfunction foreground(emit, item) {\n  emit('class', 'foreground');\n  emit('aria-hidden', true);\n\n  if (item.strokeForeground) {\n    emitRectangle(emit, item);\n  } else {\n    emit('d', '');\n  }\n}\n\nfunction content(emit, item, renderer) {\n  const url = item.clip ? clip$1(renderer, item, item) : null;\n  emit('clip-path', url);\n}\n\nfunction bound$5(bounds, group) {\n  if (!group.clip && group.items) {\n    const items = group.items,\n          m = items.length;\n\n    for (let j = 0; j < m; ++j) {\n      bounds.union(items[j].bounds);\n    }\n  }\n\n  if ((group.clip || group.width || group.height) && !group.noBound) {\n    bounds.add(0, 0).add(group.width || 0, group.height || 0);\n  }\n\n  boundStroke(bounds, group);\n  return bounds.translate(group.x || 0, group.y || 0);\n}\n\nfunction rectanglePath(context, group, x, y) {\n  const off = offset$1(group);\n  context.beginPath();\n  rectangle(context, group, (x || 0) + off, (y || 0) + off);\n}\n\nconst hitBackground = hitPath(rectanglePath);\nconst hitForeground = hitPath(rectanglePath, false);\nconst hitCorner = hitPath(rectanglePath, true);\n\nfunction draw$4(context, scene, bounds) {\n  visit(scene, group => {\n    const gx = group.x || 0,\n          gy = group.y || 0,\n          fore = group.strokeForeground,\n          opacity = group.opacity == null ? 1 : group.opacity; // draw group background\n\n    if ((group.stroke || group.fill) && opacity) {\n      rectanglePath(context, group, gx, gy);\n      blend(context, group);\n\n      if (group.fill && fill(context, group, opacity)) {\n        context.fill();\n      }\n\n      if (group.stroke && !fore && stroke(context, group, opacity)) {\n        context.stroke();\n      }\n    } // setup graphics context, set clip and bounds\n\n\n    context.save();\n    context.translate(gx, gy);\n    if (group.clip) clipGroup(context, group);\n    if (bounds) bounds.translate(-gx, -gy); // draw group contents\n\n    visit(group, item => {\n      this.draw(context, item, bounds);\n    }); // restore graphics context\n\n    if (bounds) bounds.translate(gx, gy);\n    context.restore(); // draw group foreground\n\n    if (fore && group.stroke && opacity) {\n      rectanglePath(context, group, gx, gy);\n      blend(context, group);\n\n      if (stroke(context, group, opacity)) {\n        context.stroke();\n      }\n    }\n  });\n}\n\nfunction pick(context, scene, x, y, gx, gy) {\n  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {\n    return null;\n  }\n\n  const cx = x * context.pixelRatio,\n        cy = y * context.pixelRatio;\n  return pickVisit(scene, group => {\n    let hit, dx, dy; // first hit test bounding box\n\n    const b = group.bounds;\n    if (b && !b.contains(gx, gy)) return; // passed bounds check, test rectangular clip\n\n    dx = group.x || 0;\n    dy = group.y || 0;\n    const dw = dx + (group.width || 0),\n          dh = dy + (group.height || 0),\n          c = group.clip;\n    if (c && (gx < dx || gx > dw || gy < dy || gy > dh)) return; // adjust coordinate system\n\n    context.save();\n    context.translate(dx, dy);\n    dx = gx - dx;\n    dy = gy - dy; // test background for rounded corner clip\n\n    if (c && hasCornerRadius(group) && !hitCorner(context, group, cx, cy)) {\n      context.restore();\n      return null;\n    }\n\n    const fore = group.strokeForeground,\n          ix = scene.interactive !== false; // hit test against group foreground\n\n    if (ix && fore && group.stroke && hitForeground(context, group, cx, cy)) {\n      context.restore();\n      return group;\n    } // hit test against contained marks\n\n\n    hit = pickVisit(group, mark => pickMark(mark, dx, dy) ? this.pick(mark, x, y, dx, dy) : null); // hit test against group background\n\n    if (!hit && ix && (group.fill || !fore && group.stroke) && hitBackground(context, group, cx, cy)) {\n      hit = group;\n    } // restore state and return\n\n\n    context.restore();\n    return hit || null;\n  });\n}\n\nfunction pickMark(mark, x, y) {\n  return (mark.interactive !== false || mark.marktype === 'group') && mark.bounds && mark.bounds.contains(x, y);\n}\n\nvar group = {\n  type: 'group',\n  tag: 'g',\n  nested: false,\n  attr: attr$5,\n  bound: bound$5,\n  draw: draw$4,\n  pick: pick,\n  isect: intersectRect,\n  content: content,\n  background: background,\n  foreground: foreground\n};\n\nvar metadata = {\n  'xmlns': 'http://www.w3.org/2000/svg',\n  'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n  'version': '1.1'\n};\n\nfunction getImage(item, renderer) {\n  var image = item.image;\n\n  if (!image || item.url && item.url !== image.url) {\n    image = {\n      complete: false,\n      width: 0,\n      height: 0\n    };\n    renderer.loadImage(item.url).then(image => {\n      item.image = image;\n      item.image.url = item.url;\n    });\n  }\n\n  return image;\n}\n\nfunction imageWidth(item, image) {\n  return item.width != null ? item.width : !image || !image.width ? 0 : item.aspect !== false && item.height ? item.height * image.width / image.height : image.width;\n}\n\nfunction imageHeight(item, image) {\n  return item.height != null ? item.height : !image || !image.height ? 0 : item.aspect !== false && item.width ? item.width * image.height / image.width : image.height;\n}\n\nfunction imageXOffset(align, w) {\n  return align === 'center' ? w / 2 : align === 'right' ? w : 0;\n}\n\nfunction imageYOffset(baseline, h) {\n  return baseline === 'middle' ? h / 2 : baseline === 'bottom' ? h : 0;\n}\n\nfunction attr$4(emit, item, renderer) {\n  const img = getImage(item, renderer),\n        w = imageWidth(item, img),\n        h = imageHeight(item, img),\n        x = (item.x || 0) - imageXOffset(item.align, w),\n        y = (item.y || 0) - imageYOffset(item.baseline, h),\n        i = !img.src && img.toDataURL ? img.toDataURL() : img.src || '';\n  emit('href', i, metadata['xmlns:xlink'], 'xlink:href');\n  emit('transform', translate(x, y));\n  emit('width', w);\n  emit('height', h);\n  emit('preserveAspectRatio', item.aspect === false ? 'none' : 'xMidYMid');\n}\n\nfunction bound$4(bounds, item) {\n  const img = item.image,\n        w = imageWidth(item, img),\n        h = imageHeight(item, img),\n        x = (item.x || 0) - imageXOffset(item.align, w),\n        y = (item.y || 0) - imageYOffset(item.baseline, h);\n  return bounds.set(x, y, x + w, y + h);\n}\n\nfunction draw$3(context, scene, bounds) {\n  visit(scene, item => {\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n\n    const img = getImage(item, this);\n    let w = imageWidth(item, img);\n    let h = imageHeight(item, img);\n    if (w === 0 || h === 0) return; // early exit\n\n    let x = (item.x || 0) - imageXOffset(item.align, w),\n        y = (item.y || 0) - imageYOffset(item.baseline, h),\n        opacity,\n        ar0,\n        ar1,\n        t;\n\n    if (item.aspect !== false) {\n      ar0 = img.width / img.height;\n      ar1 = item.width / item.height;\n\n      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {\n        if (ar1 < ar0) {\n          t = w / ar0;\n          y += (h - t) / 2;\n          h = t;\n        } else {\n          t = h * ar0;\n          x += (w - t) / 2;\n          w = t;\n        }\n      }\n    }\n\n    if (img.complete || img.toDataURL) {\n      blend(context, item);\n      context.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;\n      context.imageSmoothingEnabled = item.smooth !== false;\n      context.drawImage(img, x, y, w, h);\n    }\n  });\n}\n\nvar image = {\n  type: 'image',\n  tag: 'image',\n  nested: false,\n  attr: attr$4,\n  bound: bound$4,\n  draw: draw$3,\n  pick: pick$1(),\n  isect: truthy,\n  // bounds check is sufficient\n  get: getImage,\n  xOffset: imageXOffset,\n  yOffset: imageYOffset\n};\n\nvar line = markMultiItemPath('line', line$1, pickLine);\n\nfunction attr$3(emit, item) {\n  var sx = item.scaleX || 1,\n      sy = item.scaleY || 1;\n\n  if (sx !== 1 || sy !== 1) {\n    emit('vector-effect', 'non-scaling-stroke');\n  }\n\n  emit('transform', transformItem(item));\n  emit('d', item.path);\n}\n\nfunction path$1(context, item) {\n  var path = item.path;\n  if (path == null) return true;\n  var x = item.x || 0,\n      y = item.y || 0,\n      sx = item.scaleX || 1,\n      sy = item.scaleY || 1,\n      a = (item.angle || 0) * DegToRad,\n      cache = item.pathCache;\n\n  if (!cache || cache.path !== path) {\n    (item.pathCache = cache = parse(path)).path = path;\n  }\n\n  if (a && context.rotate && context.translate) {\n    context.translate(x, y);\n    context.rotate(a);\n    pathRender(context, cache, 0, 0, sx, sy);\n    context.rotate(-a);\n    context.translate(-x, -y);\n  } else {\n    pathRender(context, cache, x, y, sx, sy);\n  }\n}\n\nfunction bound$3(bounds, item) {\n  return path$1(boundContext(bounds, item.angle), item) ? bounds.set(0, 0, 0, 0) : boundStroke(bounds, item, true);\n}\n\nvar path$2 = {\n  type: 'path',\n  tag: 'path',\n  nested: false,\n  attr: attr$3,\n  bound: bound$3,\n  draw: drawAll(path$1),\n  pick: pickPath(path$1),\n  isect: intersectPath(path$1)\n};\n\nfunction attr$2(emit, item) {\n  emit('d', rectangle(null, item));\n}\n\nfunction bound$2(bounds, item) {\n  var x, y;\n  return boundStroke(bounds.set(x = item.x || 0, y = item.y || 0, x + item.width || 0, y + item.height || 0), item);\n}\n\nfunction draw$2(context, item) {\n  context.beginPath();\n  rectangle(context, item);\n}\n\nvar rect = {\n  type: 'rect',\n  tag: 'path',\n  nested: false,\n  attr: attr$2,\n  bound: bound$2,\n  draw: drawAll(draw$2),\n  pick: pickPath(draw$2),\n  isect: intersectRect\n};\n\nfunction attr$1(emit, item) {\n  emit('transform', translateItem(item));\n  emit('x2', item.x2 != null ? item.x2 - (item.x || 0) : 0);\n  emit('y2', item.y2 != null ? item.y2 - (item.y || 0) : 0);\n}\n\nfunction bound$1(bounds, item) {\n  var x1, y1;\n  return boundStroke(bounds.set(x1 = item.x || 0, y1 = item.y || 0, item.x2 != null ? item.x2 : x1, item.y2 != null ? item.y2 : y1), item);\n}\n\nfunction path(context, item, opacity) {\n  var x1, y1, x2, y2;\n\n  if (item.stroke && stroke(context, item, opacity)) {\n    x1 = item.x || 0;\n    y1 = item.y || 0;\n    x2 = item.x2 != null ? item.x2 : x1;\n    y2 = item.y2 != null ? item.y2 : y1;\n    context.beginPath();\n    context.moveTo(x1, y1);\n    context.lineTo(x2, y2);\n    return true;\n  }\n\n  return false;\n}\n\nfunction draw$1(context, scene, bounds) {\n  visit(scene, item => {\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n\n    var opacity = item.opacity == null ? 1 : item.opacity;\n\n    if (opacity && path(context, item, opacity)) {\n      blend(context, item);\n      context.stroke();\n    }\n  });\n}\n\nfunction hit$1(context, item, x, y) {\n  if (!context.isPointInStroke) return false;\n  return path(context, item, 1) && context.isPointInStroke(x, y);\n}\n\nvar rule = {\n  type: 'rule',\n  tag: 'line',\n  nested: false,\n  attr: attr$1,\n  bound: bound$1,\n  draw: draw$1,\n  pick: pick$1(hit$1),\n  isect: intersectRule\n};\n\nvar shape = markItemPath('shape', shape$1);\n\nvar symbol = markItemPath('symbol', symbol$1, intersectPoint);\n\nconst widthCache = lruCache();\nvar textMetrics = {\n  height: fontSize,\n  measureWidth: measureWidth,\n  estimateWidth: estimateWidth,\n  width: estimateWidth,\n  canvas: useCanvas\n};\nuseCanvas(true);\n\nfunction useCanvas(use) {\n  textMetrics.width = use && context ? measureWidth : estimateWidth;\n} // make simple estimate if no canvas is available\n\n\nfunction estimateWidth(item, text) {\n  return _estimateWidth(textValue(item, text), fontSize(item));\n}\n\nfunction _estimateWidth(text, currentFontHeight) {\n  return ~~(0.8 * text.length * currentFontHeight);\n} // measure text width if canvas is available\n\n\nfunction measureWidth(item, text) {\n  return fontSize(item) <= 0 || !(text = textValue(item, text)) ? 0 : _measureWidth(text, font(item));\n}\n\nfunction _measureWidth(text, currentFont) {\n  const key = \"(\".concat(currentFont, \") \").concat(text);\n  let width = widthCache.get(key);\n\n  if (width === undefined) {\n    context.font = currentFont;\n    width = context.measureText(text).width;\n    widthCache.set(key, width);\n  }\n\n  return width;\n}\n\nfunction fontSize(item) {\n  return item.fontSize != null ? +item.fontSize || 0 : 11;\n}\nfunction lineHeight(item) {\n  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;\n}\n\nfunction lineArray(_) {\n  return isArray(_) ? _.length > 1 ? _ : _[0] : _;\n}\n\nfunction textLines(item) {\n  return lineArray(item.lineBreak && item.text && !isArray(item.text) ? item.text.split(item.lineBreak) : item.text);\n}\nfunction multiLineOffset(item) {\n  const tl = textLines(item);\n  return (isArray(tl) ? tl.length - 1 : 0) * lineHeight(item);\n}\nfunction textValue(item, line) {\n  const text = line == null ? '' : (line + '').trim();\n  return item.limit > 0 && text.length ? truncate(item, text) : text;\n}\n\nfunction widthGetter(item) {\n  if (textMetrics.width === measureWidth) {\n    // we are using canvas\n    const currentFont = font(item);\n    return text => _measureWidth(text, currentFont);\n  } else {\n    // we are relying on estimates\n    const currentFontHeight = fontSize(item);\n    return text => _estimateWidth(text, currentFontHeight);\n  }\n}\n\nfunction truncate(item, text) {\n  var limit = +item.limit,\n      width = widthGetter(item);\n  if (width(text) < limit) return text;\n  var ellipsis = item.ellipsis || '\\u2026',\n      rtl = item.dir === 'rtl',\n      lo = 0,\n      hi = text.length,\n      mid;\n  limit -= width(ellipsis);\n\n  if (rtl) {\n    while (lo < hi) {\n      mid = lo + hi >>> 1;\n      if (width(text.slice(mid)) > limit) lo = mid + 1;else hi = mid;\n    }\n\n    return ellipsis + text.slice(lo);\n  } else {\n    while (lo < hi) {\n      mid = 1 + (lo + hi >>> 1);\n      if (width(text.slice(0, mid)) < limit) lo = mid;else hi = mid - 1;\n    }\n\n    return text.slice(0, lo) + ellipsis;\n  }\n}\n\nfunction fontFamily(item, quote) {\n  var font = item.font;\n  return (quote && font ? String(font).replace(/\"/g, '\\'') : font) || 'sans-serif';\n}\nfunction font(item, quote) {\n  return '' + (item.fontStyle ? item.fontStyle + ' ' : '') + (item.fontVariant ? item.fontVariant + ' ' : '') + (item.fontWeight ? item.fontWeight + ' ' : '') + fontSize(item) + 'px ' + fontFamily(item, quote);\n}\nfunction offset(item) {\n  // perform our own font baseline calculation\n  // why? not all browsers support SVG 1.1 'alignment-baseline' :(\n  // this also ensures consistent layout across renderers\n  var baseline = item.baseline,\n      h = fontSize(item);\n  return Math.round(baseline === 'top' ? 0.79 * h : baseline === 'middle' ? 0.30 * h : baseline === 'bottom' ? -0.21 * h : baseline === 'line-top' ? 0.29 * h + 0.5 * lineHeight(item) : baseline === 'line-bottom' ? 0.29 * h - 0.5 * lineHeight(item) : 0);\n}\n\nconst textAlign = {\n  'left': 'start',\n  'center': 'middle',\n  'right': 'end'\n};\nconst tempBounds = new Bounds();\n\nfunction anchorPoint(item) {\n  var x = item.x || 0,\n      y = item.y || 0,\n      r = item.radius || 0,\n      t;\n\n  if (r) {\n    t = (item.theta || 0) - HalfPi;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  tempBounds.x1 = x;\n  tempBounds.y1 = y;\n  return tempBounds;\n}\n\nfunction attr(emit, item) {\n  var dx = item.dx || 0,\n      dy = (item.dy || 0) + offset(item),\n      p = anchorPoint(item),\n      x = p.x1,\n      y = p.y1,\n      a = item.angle || 0,\n      t;\n  emit('text-anchor', textAlign[item.align] || 'start');\n\n  if (a) {\n    t = translate(x, y) + ' ' + rotate(a);\n    if (dx || dy) t += ' ' + translate(dx, dy);\n  } else {\n    t = translate(x + dx, y + dy);\n  }\n\n  emit('transform', t);\n}\n\nfunction bound(bounds, item, mode) {\n  var h = textMetrics.height(item),\n      a = item.align,\n      p = anchorPoint(item),\n      x = p.x1,\n      y = p.y1,\n      dx = item.dx || 0,\n      dy = (item.dy || 0) + offset(item) - Math.round(0.8 * h),\n      // use 4/5 offset\n  tl = textLines(item),\n      w; // get dimensions\n\n  if (isArray(tl)) {\n    // multi-line text\n    h += lineHeight(item) * (tl.length - 1);\n    w = tl.reduce((w, t) => Math.max(w, textMetrics.width(item, t)), 0);\n  } else {\n    // single-line text\n    w = textMetrics.width(item, tl);\n  } // horizontal alignment\n\n\n  if (a === 'center') {\n    dx -= w / 2;\n  } else if (a === 'right') {\n    dx -= w;\n  } else ;\n\n  bounds.set(dx += x, dy += y, dx + w, dy + h);\n\n  if (item.angle && !mode) {\n    bounds.rotate(item.angle * DegToRad, x, y);\n  } else if (mode === 2) {\n    return bounds.rotatedPoints(item.angle * DegToRad, x, y);\n  }\n\n  return bounds;\n}\n\nfunction draw(context, scene, bounds) {\n  visit(scene, item => {\n    var opacity = item.opacity == null ? 1 : item.opacity,\n        p,\n        x,\n        y,\n        i,\n        lh,\n        tl,\n        str;\n    if (bounds && !bounds.intersects(item.bounds) || // bounds check\n    opacity === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0) return;\n    context.font = font(item);\n    context.textAlign = item.align || 'left';\n    p = anchorPoint(item);\n    x = p.x1, y = p.y1;\n\n    if (item.angle) {\n      context.save();\n      context.translate(x, y);\n      context.rotate(item.angle * DegToRad);\n      x = y = 0; // reset x, y\n    }\n\n    x += item.dx || 0;\n    y += (item.dy || 0) + offset(item);\n    tl = textLines(item);\n    blend(context, item);\n\n    if (isArray(tl)) {\n      lh = lineHeight(item);\n\n      for (i = 0; i < tl.length; ++i) {\n        str = textValue(item, tl[i]);\n\n        if (item.fill && fill(context, item, opacity)) {\n          context.fillText(str, x, y);\n        }\n\n        if (item.stroke && stroke(context, item, opacity)) {\n          context.strokeText(str, x, y);\n        }\n\n        y += lh;\n      }\n    } else {\n      str = textValue(item, tl);\n\n      if (item.fill && fill(context, item, opacity)) {\n        context.fillText(str, x, y);\n      }\n\n      if (item.stroke && stroke(context, item, opacity)) {\n        context.strokeText(str, x, y);\n      }\n    }\n\n    if (item.angle) context.restore();\n  });\n}\n\nfunction hit(context, item, x, y, gx, gy) {\n  if (item.fontSize <= 0) return false;\n  if (!item.angle) return true; // bounds sufficient if no rotation\n  // project point into space of unrotated bounds\n\n  var p = anchorPoint(item),\n      ax = p.x1,\n      ay = p.y1,\n      b = bound(tempBounds, item, 1),\n      a = -item.angle * DegToRad,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      px = cos * gx - sin * gy + (ax - cos * ax + sin * ay),\n      py = sin * gx + cos * gy + (ay - sin * ax - cos * ay);\n  return b.contains(px, py);\n}\n\nfunction intersectText(item, box) {\n  const p = bound(tempBounds, item, 2);\n  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);\n}\n\nvar text = {\n  type: 'text',\n  tag: 'text',\n  nested: false,\n  attr: attr,\n  bound: bound,\n  draw: draw,\n  pick: pick$1(hit),\n  isect: intersectText\n};\n\nvar trail = markMultiItemPath('trail', trail$1, pickTrail);\n\nvar Marks = {\n  arc: arc,\n  area: area,\n  group: group,\n  image: image,\n  line: line,\n  path: path$2,\n  rect: rect,\n  rule: rule,\n  shape: shape,\n  symbol: symbol,\n  text: text,\n  trail: trail\n};\n\nfunction boundItem (item, func, opt) {\n  var type = Marks[item.mark.marktype],\n      bound = func || type.bound;\n  if (type.nested) item = item.mark;\n  return bound(item.bounds || (item.bounds = new Bounds()), item, opt);\n}\n\nvar DUMMY = {\n  mark: null\n};\nfunction boundMark (mark, bounds, opt) {\n  var type = Marks[mark.marktype],\n      bound = type.bound,\n      items = mark.items,\n      hasItems = items && items.length,\n      i,\n      n,\n      item,\n      b;\n\n  if (type.nested) {\n    if (hasItems) {\n      item = items[0];\n    } else {\n      // no items, fake it\n      DUMMY.mark = mark;\n      item = DUMMY;\n    }\n\n    b = boundItem(item, bound, opt);\n    bounds = bounds && bounds.union(b) || b;\n    return bounds;\n  }\n\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n\n  if (hasItems) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      bounds.union(boundItem(items[i], bound, opt));\n    }\n  }\n\n  return mark.bounds = bounds;\n}\n\nconst keys = ['marktype', 'name', 'role', 'interactive', 'clip', 'items', 'zindex', 'x', 'y', 'width', 'height', 'align', 'baseline', // layout\n'fill', 'fillOpacity', 'opacity', 'blend', // fill\n'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap', // stroke\n'strokeDash', 'strokeDashOffset', // stroke dash\n'strokeForeground', 'strokeOffset', // group\n'startAngle', 'endAngle', 'innerRadius', 'outerRadius', // arc\n'cornerRadius', 'padAngle', // arc, rect\n'cornerRadiusTopLeft', 'cornerRadiusTopRight', // rect, group\n'cornerRadiusBottomLeft', 'cornerRadiusBottomRight', 'interpolate', 'tension', 'orient', 'defined', // area, line\n'url', 'aspect', 'smooth', // image\n'path', 'scaleX', 'scaleY', // path\n'x2', 'y2', // rule\n'size', 'shape', // symbol\n'text', 'angle', 'theta', 'radius', 'dir', 'dx', 'dy', // text\n'ellipsis', 'limit', 'lineBreak', 'lineHeight', 'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant', // font\n'description', 'aria', 'ariaRole', 'ariaRoleDescription' // aria\n];\nfunction sceneToJSON(scene, indent) {\n  return JSON.stringify(scene, keys, indent);\n}\nfunction sceneFromJSON(json) {\n  const scene = typeof json === 'string' ? JSON.parse(json) : json;\n  return initialize(scene);\n}\n\nfunction initialize(scene) {\n  var type = scene.marktype,\n      items = scene.items,\n      parent,\n      i,\n      n;\n\n  if (items) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      parent = type ? 'mark' : 'group';\n      items[i][parent] = scene;\n      if (items[i].zindex) items[i][parent].zdirty = true;\n      if ('group' === (type || parent)) initialize(items[i]);\n    }\n  }\n\n  if (type) boundMark(scene);\n  return scene;\n}\n\nfunction Scenegraph(scene) {\n  if (arguments.length) {\n    this.root = sceneFromJSON(scene);\n  } else {\n    this.root = createMark({\n      marktype: 'group',\n      name: 'root',\n      role: 'frame'\n    });\n    this.root.items = [new GroupItem(this.root)];\n  }\n}\nScenegraph.prototype = {\n  toJSON(indent) {\n    return sceneToJSON(this.root, indent || 0);\n  },\n\n  mark(markdef, group, index) {\n    group = group || this.root.items[0];\n    const mark = createMark(markdef, group);\n    group.items[index] = mark;\n    if (mark.zindex) mark.group.zdirty = true;\n    return mark;\n  }\n\n};\n\nfunction createMark(def, group) {\n  const mark = {\n    bounds: new Bounds(),\n    clip: !!def.clip,\n    group: group,\n    interactive: def.interactive === false ? false : true,\n    items: [],\n    marktype: def.marktype,\n    name: def.name || undefined,\n    role: def.role || undefined,\n    zindex: def.zindex || 0\n  }; // add accessibility properties if defined\n\n  if (def.aria != null) {\n    mark.aria = def.aria;\n  }\n\n  if (def.description) {\n    mark.description = def.description;\n  }\n\n  return mark;\n}\n\n// create a new DOM element\nfunction domCreate(doc, tag, ns) {\n  if (!doc && typeof document !== 'undefined' && document.createElement) {\n    doc = document;\n  }\n\n  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;\n} // find first child element with matching tag\n\nfunction domFind(el, tag) {\n  tag = tag.toLowerCase();\n  var nodes = el.childNodes,\n      i = 0,\n      n = nodes.length;\n\n  for (; i < n; ++i) if (nodes[i].tagName.toLowerCase() === tag) {\n    return nodes[i];\n  }\n} // retrieve child element at given index\n// create & insert if doesn't exist or if tags do not match\n\nfunction domChild(el, index, tag, ns) {\n  var a = el.childNodes[index],\n      b;\n\n  if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {\n    b = a || null;\n    a = domCreate(el.ownerDocument, tag, ns);\n    el.insertBefore(a, b);\n  }\n\n  return a;\n} // remove all child elements at or above the given index\n\nfunction domClear(el, index) {\n  var nodes = el.childNodes,\n      curr = nodes.length;\n\n  while (curr > index) el.removeChild(nodes[--curr]);\n\n  return el;\n} // generate css class name for mark\n\nfunction cssClass(mark) {\n  return 'mark-' + mark.marktype + (mark.role ? ' role-' + mark.role : '') + (mark.name ? ' ' + mark.name : '');\n}\n\nfunction point (event, el) {\n  const rect = el.getBoundingClientRect();\n  return [event.clientX - rect.left - (el.clientLeft || 0), event.clientY - rect.top - (el.clientTop || 0)];\n}\n\nfunction resolveItem (item, event, el, origin) {\n  var mark = item && item.mark,\n      mdef,\n      p;\n\n  if (mark && (mdef = Marks[mark.marktype]).tip) {\n    p = point(event, el);\n    p[0] -= origin[0];\n    p[1] -= origin[1];\n\n    while (item = item.mark.group) {\n      p[0] -= item.x || 0;\n      p[1] -= item.y || 0;\n    }\n\n    item = mdef.tip(mark.items, p);\n  }\n\n  return item;\n}\n\n/**\n * Create a new Handler instance.\n * @param {object} [customLoader] - Optional loader instance for\n *   href URL sanitization. If not specified, a standard loader\n *   instance will be generated.\n * @param {function} [customTooltip] - Optional tooltip handler\n *   function for custom tooltip display.\n * @constructor\n */\n\nfunction Handler(customLoader, customTooltip) {\n  this._active = null;\n  this._handlers = {};\n  this._loader = customLoader || loader();\n  this._tooltip = customTooltip || defaultTooltip;\n} // The default tooltip display handler.\n// Sets the HTML title attribute on the visualization container.\n\nfunction defaultTooltip(handler, event, item, value) {\n  handler.element().setAttribute('title', value || '');\n}\n\nHandler.prototype = {\n  /**\n   * Initialize a new Handler instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {object} [obj] - Optional context object that should serve as\n   *   the \"this\" context for event callbacks.\n   * @return {Handler} - This handler instance.\n   */\n  initialize(el, origin, obj) {\n    this._el = el;\n    this._obj = obj || null;\n    return this.origin(origin);\n  },\n\n  /**\n   * Returns the parent container element for a visualization.\n   * @return {DOMElement} - The containing DOM element.\n   */\n  element() {\n    return this._el;\n  },\n\n  /**\n   * Returns the scene element (e.g., canvas or SVG) of the visualization\n   * Subclasses must override if the first child is not the scene element.\n   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n   */\n  canvas() {\n    return this._el && this._el.firstChild;\n  },\n\n  /**\n   * Get / set the origin coordinates of the visualization.\n   */\n  origin(origin) {\n    if (arguments.length) {\n      this._origin = origin || [0, 0];\n      return this;\n    } else {\n      return this._origin.slice();\n    }\n  },\n\n  /**\n   * Get / set the scenegraph root.\n   */\n  scene(scene) {\n    if (!arguments.length) return this._scene;\n    this._scene = scene;\n    return this;\n  },\n\n  /**\n   * Add an event handler. Subclasses should override this method.\n   */\n  on() {},\n\n  /**\n   * Remove an event handler. Subclasses should override this method.\n   */\n  off() {},\n\n  /**\n   * Utility method for finding the array index of an event handler.\n   * @param {Array} h - An array of registered event handlers.\n   * @param {string} type - The event type.\n   * @param {function} handler - The event handler instance to find.\n   * @return {number} - The handler's array index or -1 if not registered.\n   */\n  _handlerIndex(h, type, handler) {\n    for (let i = h ? h.length : 0; --i >= 0;) {\n      if (h[i].type === type && (!handler || h[i].handler === handler)) {\n        return i;\n      }\n    }\n\n    return -1;\n  },\n\n  /**\n   * Returns an array with registered event handlers.\n   * @param {string} [type] - The event type to query. Any annotations\n   *   are ignored; for example, for the argument \"click.foo\", \".foo\" will\n   *   be ignored and the method returns all \"click\" handlers. If type is\n   *   null or unspecified, this method returns handlers for all types.\n   * @return {Array} - A new array containing all registered event handlers.\n   */\n  handlers(type) {\n    const h = this._handlers,\n          a = [];\n\n    if (type) {\n      a.push(...h[this.eventName(type)]);\n    } else {\n      for (const k in h) {\n        a.push(...h[k]);\n      }\n    }\n\n    return a;\n  },\n\n  /**\n   * Parses an event name string to return the specific event type.\n   * For example, given \"click.foo\" returns \"click\"\n   * @param {string} name - The input event type string.\n   * @return {string} - A string with the event type only.\n   */\n  eventName(name) {\n    const i = name.indexOf('.');\n    return i < 0 ? name : name.slice(0, i);\n  },\n\n  /**\n   * Handle hyperlink navigation in response to an item.href value.\n   * @param {Event} event - The event triggering hyperlink navigation.\n   * @param {Item} item - The scenegraph item.\n   * @param {string} href - The URL to navigate to.\n   */\n  handleHref(event, item, href) {\n    this._loader.sanitize(href, {\n      context: 'href'\n    }).then(opt => {\n      const e = new MouseEvent(event.type, event),\n            a = domCreate(null, 'a');\n\n      for (const name in opt) a.setAttribute(name, opt[name]);\n\n      a.dispatchEvent(e);\n    }).catch(() => {\n      /* do nothing */\n    });\n  },\n\n  /**\n   * Handle tooltip display in response to an item.tooltip value.\n   * @param {Event} event - The event triggering tooltip display.\n   * @param {Item} item - The scenegraph item.\n   * @param {boolean} show - A boolean flag indicating whether\n   *   to show or hide a tooltip for the given item.\n   */\n  handleTooltip(event, item, show) {\n    if (item && item.tooltip != null) {\n      item = resolveItem(item, event, this.canvas(), this._origin);\n      const value = show && item && item.tooltip || null;\n\n      this._tooltip.call(this._obj, this, event, item, value);\n    }\n  },\n\n  /**\n   * Returns the size of a scenegraph item and its position relative\n   * to the viewport.\n   * @param {Item} item - The scenegraph item.\n   * @return {object} - A bounding box object (compatible with the\n   *   DOMRect type) consisting of x, y, width, heigh, top, left,\n   *   right, and bottom properties.\n   */\n  getItemBoundingClientRect(item) {\n    const el = this.canvas();\n    if (!el) return;\n    const rect = el.getBoundingClientRect(),\n          origin = this._origin,\n          bounds = item.bounds,\n          width = bounds.width(),\n          height = bounds.height();\n    let x = bounds.x1 + origin[0] + rect.left,\n        y = bounds.y1 + origin[1] + rect.top; // translate coordinate for each parent group\n\n    while (item.mark && (item = item.mark.group)) {\n      x += item.x || 0;\n      y += item.y || 0;\n    } // return DOMRect-compatible bounding box\n\n\n    return {\n      x,\n      y,\n      width,\n      height,\n      left: x,\n      top: y,\n      right: x + width,\n      bottom: y + height\n    };\n  }\n\n};\n\n/**\n * Create a new Renderer instance.\n * @param {object} [loader] - Optional loader instance for\n *   image and href URL sanitization. If not specified, a\n *   standard loader instance will be generated.\n * @constructor\n */\n\nfunction Renderer(loader) {\n  this._el = null;\n  this._bgcolor = null;\n  this._loader = new ResourceLoader(loader);\n}\nRenderer.prototype = {\n  /**\n   * Initialize a new Renderer instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {number} width - The coordinate width of the display, in pixels.\n   * @param {number} height - The coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {Renderer} - This renderer instance.\n   */\n  initialize(el, width, height, origin, scaleFactor) {\n    this._el = el;\n    return this.resize(width, height, origin, scaleFactor);\n  },\n\n  /**\n   * Returns the parent container element for a visualization.\n   * @return {DOMElement} - The containing DOM element.\n   */\n  element() {\n    return this._el;\n  },\n\n  /**\n   * Returns the scene element (e.g., canvas or SVG) of the visualization\n   * Subclasses must override if the first child is not the scene element.\n   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n   */\n  canvas() {\n    return this._el && this._el.firstChild;\n  },\n\n  /**\n   * Get / set the background color.\n   */\n  background(bgcolor) {\n    if (arguments.length === 0) return this._bgcolor;\n    this._bgcolor = bgcolor;\n    return this;\n  },\n\n  /**\n   * Resize the display.\n   * @param {number} width - The new coordinate width of the display, in pixels.\n   * @param {number} height - The new coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The new origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {Renderer} - This renderer instance;\n   */\n  resize(width, height, origin, scaleFactor) {\n    this._width = width;\n    this._height = height;\n    this._origin = origin || [0, 0];\n    this._scale = scaleFactor || 1;\n    return this;\n  },\n\n  /**\n   * Report a dirty item whose bounds should be redrawn.\n   * This base class method does nothing. Subclasses that perform\n   * incremental should implement this method.\n   * @param {Item} item - The dirty item whose bounds should be redrawn.\n   */\n  dirty() {},\n\n  /**\n   * Render an input scenegraph, potentially with a set of dirty items.\n   * This method will perform an immediate rendering with available resources.\n   * The renderer may also need to perform image loading to perform a complete\n   * render. This process can lead to asynchronous re-rendering of the scene\n   * after this method returns. To receive notification when rendering is\n   * complete, use the renderAsync method instead.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @return {Renderer} - This renderer instance.\n   */\n  render(scene) {\n    const r = this; // bind arguments into a render call, and cache it\n    // this function may be subsequently called for async redraw\n\n    r._call = function () {\n      r._render(scene);\n    }; // invoke the renderer\n\n\n    r._call(); // clear the cached call for garbage collection\n    // async redraws will stash their own copy\n\n\n    r._call = null;\n    return r;\n  },\n\n  /**\n   * Internal rendering method. Renderer subclasses should override this\n   * method to actually perform rendering.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   */\n  _render() {// subclasses to override\n  },\n\n  /**\n   * Asynchronous rendering method. Similar to render, but returns a Promise\n   * that resolves when all rendering is completed. Sometimes a renderer must\n   * perform image loading to get a complete rendering. The returned\n   * Promise will not resolve until this process completes.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @return {Promise} - A Promise that resolves when rendering is complete.\n   */\n  renderAsync(scene) {\n    const r = this.render(scene);\n    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);\n  },\n\n  /**\n   * Internal method for asynchronous resource loading.\n   * Proxies method calls to the ImageLoader, and tracks loading\n   * progress to invoke a re-render once complete.\n   * @param {string} method - The method name to invoke on the ImageLoader.\n   * @param {string} uri - The URI for the requested resource.\n   * @return {Promise} - A Promise that resolves to the requested resource.\n   */\n  _load(method, uri) {\n    var r = this,\n        p = r._loader[method](uri);\n\n    if (!r._ready) {\n      // re-render the scene when loading completes\n      const call = r._call;\n      r._ready = r._loader.ready().then(redraw => {\n        if (redraw) call();\n        r._ready = null;\n      });\n    }\n\n    return p;\n  },\n\n  /**\n   * Sanitize a URL to include as a hyperlink in the rendered scene.\n   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks\n   * image loading progress and invokes a re-render once complete.\n   * @param {string} uri - The URI string to sanitize.\n   * @return {Promise} - A Promise that resolves to the sanitized URL.\n   */\n  sanitizeURL(uri) {\n    return this._load('sanitizeURL', uri);\n  },\n\n  /**\n   * Requests an image to include in the rendered scene.\n   * This method proxies a call to ImageLoader.loadImage, but also tracks\n   * image loading progress and invokes a re-render once complete.\n   * @param {string} uri - The URI string of the image.\n   * @return {Promise} - A Promise that resolves to the loaded Image.\n   */\n  loadImage(uri) {\n    return this._load('loadImage', uri);\n  }\n\n};\n\nconst KeyDownEvent = 'keydown';\nconst KeyPressEvent = 'keypress';\nconst KeyUpEvent = 'keyup';\nconst DragEnterEvent = 'dragenter';\nconst DragLeaveEvent = 'dragleave';\nconst DragOverEvent = 'dragover';\nconst MouseDownEvent = 'mousedown';\nconst MouseUpEvent = 'mouseup';\nconst MouseMoveEvent = 'mousemove';\nconst MouseOutEvent = 'mouseout';\nconst MouseOverEvent = 'mouseover';\nconst ClickEvent = 'click';\nconst DoubleClickEvent = 'dblclick';\nconst WheelEvent = 'wheel';\nconst MouseWheelEvent = 'mousewheel';\nconst TouchStartEvent = 'touchstart';\nconst TouchMoveEvent = 'touchmove';\nconst TouchEndEvent = 'touchend';\nconst Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];\nconst TooltipShowEvent = MouseMoveEvent;\nconst TooltipHideEvent = MouseOutEvent;\nconst HrefEvent = ClickEvent;\n\nfunction CanvasHandler(loader, tooltip) {\n  Handler.call(this, loader, tooltip);\n  this._down = null;\n  this._touch = null;\n  this._first = true;\n  this._events = {};\n}\n\nconst eventBundle = type => type === TouchStartEvent || type === TouchMoveEvent || type === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type]; // lazily add listeners to the canvas as needed\n\n\nfunction eventListenerCheck(handler, type) {\n  eventBundle(type).forEach(_ => addEventListener(handler, _));\n}\n\nfunction addEventListener(handler, type) {\n  const canvas = handler.canvas();\n\n  if (canvas && !handler._events[type]) {\n    handler._events[type] = 1;\n    canvas.addEventListener(type, handler[type] ? evt => handler[type](evt) : evt => handler.fire(type, evt));\n  }\n}\n\nfunction move(moveEvent, overEvent, outEvent) {\n  return function (evt) {\n    const a = this._active,\n          p = this.pickEvent(evt);\n\n    if (p === a) {\n      // active item and picked item are the same\n      this.fire(moveEvent, evt); // fire move\n    } else {\n      // active item and picked item are different\n      if (!a || !a.exit) {\n        // fire out for prior active item\n        // suppress if active item was removed from scene\n        this.fire(outEvent, evt);\n      }\n\n      this._active = p; // set new active item\n\n      this.fire(overEvent, evt); // fire over for new active item\n\n      this.fire(moveEvent, evt); // fire move for new active item\n    }\n  };\n}\n\nfunction inactive(type) {\n  return function (evt) {\n    this.fire(type, evt);\n    this._active = null;\n  };\n}\n\ninherits(CanvasHandler, Handler, {\n  initialize(el, origin, obj) {\n    this._canvas = el && domFind(el, 'canvas'); // add minimal events required for proper state management\n\n    [ClickEvent, MouseDownEvent, MouseMoveEvent, MouseOutEvent, DragLeaveEvent].forEach(type => eventListenerCheck(this, type));\n    return Handler.prototype.initialize.call(this, el, origin, obj);\n  },\n\n  // return the backing canvas instance\n  canvas() {\n    return this._canvas;\n  },\n\n  // retrieve the current canvas context\n  context() {\n    return this._canvas.getContext('2d');\n  },\n\n  // supported events\n  events: Events,\n\n  // to keep old versions of firefox happy\n  DOMMouseScroll(evt) {\n    this.fire(MouseWheelEvent, evt);\n  },\n\n  mousemove: move(MouseMoveEvent, MouseOverEvent, MouseOutEvent),\n  dragover: move(DragOverEvent, DragEnterEvent, DragLeaveEvent),\n  mouseout: inactive(MouseOutEvent),\n  dragleave: inactive(DragLeaveEvent),\n\n  mousedown(evt) {\n    this._down = this._active;\n    this.fire(MouseDownEvent, evt);\n  },\n\n  click(evt) {\n    if (this._down === this._active) {\n      this.fire(ClickEvent, evt);\n      this._down = null;\n    }\n  },\n\n  touchstart(evt) {\n    this._touch = this.pickEvent(evt.changedTouches[0]);\n\n    if (this._first) {\n      this._active = this._touch;\n      this._first = false;\n    }\n\n    this.fire(TouchStartEvent, evt, true);\n  },\n\n  touchmove(evt) {\n    this.fire(TouchMoveEvent, evt, true);\n  },\n\n  touchend(evt) {\n    this.fire(TouchEndEvent, evt, true);\n    this._touch = null;\n  },\n\n  // fire an event\n  fire(type, evt, touch) {\n    const a = touch ? this._touch : this._active,\n          h = this._handlers[type]; // set event type relative to scenegraph items\n\n    evt.vegaType = type; // handle hyperlinks and tooltips first\n\n    if (type === HrefEvent && a && a.href) {\n      this.handleHref(evt, a, a.href);\n    } else if (type === TooltipShowEvent || type === TooltipHideEvent) {\n      this.handleTooltip(evt, a, type !== TooltipHideEvent);\n    } // invoke all registered handlers\n\n\n    if (h) {\n      for (let i = 0, len = h.length; i < len; ++i) {\n        h[i].handler.call(this._obj, evt, a);\n      }\n    }\n  },\n\n  // add an event handler\n  on(type, handler) {\n    const name = this.eventName(type),\n          h = this._handlers,\n          i = this._handlerIndex(h[name], type, handler);\n\n    if (i < 0) {\n      eventListenerCheck(this, type);\n      (h[name] || (h[name] = [])).push({\n        type: type,\n        handler: handler\n      });\n    }\n\n    return this;\n  },\n\n  // remove an event handler\n  off(type, handler) {\n    const name = this.eventName(type),\n          h = this._handlers[name],\n          i = this._handlerIndex(h, type, handler);\n\n    if (i >= 0) {\n      h.splice(i, 1);\n    }\n\n    return this;\n  },\n\n  pickEvent(evt) {\n    const p = point(evt, this._canvas),\n          o = this._origin;\n    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);\n  },\n\n  // find the scenegraph item at the current mouse position\n  // x, y -- the absolute x, y mouse coordinates on the canvas element\n  // gx, gy -- the relative coordinates within the current group\n  pick(scene, x, y, gx, gy) {\n    const g = this.context(),\n          mark = Marks[scene.marktype];\n    return mark.pick.call(this, g, scene, x, y, gx, gy);\n  }\n\n});\n\nfunction devicePixelRatio() {\n  return typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1;\n}\n\nvar pixelRatio = devicePixelRatio();\nfunction resize (canvas, width, height, origin, scaleFactor, opt) {\n  const inDOM = typeof HTMLElement !== 'undefined' && canvas instanceof HTMLElement && canvas.parentNode != null,\n        context = canvas.getContext('2d'),\n        ratio = inDOM ? pixelRatio : scaleFactor;\n  canvas.width = width * ratio;\n  canvas.height = height * ratio;\n\n  for (const key in opt) {\n    context[key] = opt[key];\n  }\n\n  if (inDOM && ratio !== 1) {\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n  }\n\n  context.pixelRatio = ratio;\n  context.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);\n  return canvas;\n}\n\nfunction CanvasRenderer(loader) {\n  Renderer.call(this, loader);\n  this._options = {};\n  this._redraw = false;\n  this._dirty = new Bounds();\n  this._tempb = new Bounds();\n}\nconst base$1 = Renderer.prototype;\n\nconst viewBounds = (origin, width, height) => new Bounds().set(0, 0, width, height).translate(-origin[0], -origin[1]);\n\nfunction clipToBounds(g, b, origin) {\n  // expand bounds by 1 pixel, then round to pixel boundaries\n  b.expand(1).round(); // align to base pixel grid in case of non-integer scaling (#2425)\n\n  if (g.pixelRatio % 1) {\n    b.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);\n  } // to avoid artifacts translate if origin has fractional pixels\n\n\n  b.translate(-(origin[0] % 1), -(origin[1] % 1)); // set clip path\n\n  g.beginPath();\n  g.rect(b.x1, b.y1, b.width(), b.height());\n  g.clip();\n  return b;\n}\n\ninherits(CanvasRenderer, Renderer, {\n  initialize(el, width, height, origin, scaleFactor, options) {\n    this._options = options || {};\n    this._canvas = this._options.externalContext ? null : canvas(1, 1, this._options.type); // instantiate a small canvas\n\n    if (el && this._canvas) {\n      domClear(el, 0).appendChild(this._canvas);\n\n      this._canvas.setAttribute('class', 'marks');\n    } // this method will invoke resize to size the canvas appropriately\n\n\n    return base$1.initialize.call(this, el, width, height, origin, scaleFactor);\n  },\n\n  resize(width, height, origin, scaleFactor) {\n    base$1.resize.call(this, width, height, origin, scaleFactor);\n\n    if (this._canvas) {\n      // configure canvas size and transform\n      resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);\n    } else {\n      // external context needs to be scaled and positioned to origin\n      const ctx = this._options.externalContext;\n      if (!ctx) error('CanvasRenderer is missing a valid canvas or context');\n      ctx.scale(this._scale, this._scale);\n      ctx.translate(this._origin[0], this._origin[1]);\n    }\n\n    this._redraw = true;\n    return this;\n  },\n\n  canvas() {\n    return this._canvas;\n  },\n\n  context() {\n    return this._options.externalContext || (this._canvas ? this._canvas.getContext('2d') : null);\n  },\n\n  dirty(item) {\n    const b = this._tempb.clear().union(item.bounds);\n\n    let g = item.mark.group;\n\n    while (g) {\n      b.translate(g.x || 0, g.y || 0);\n      g = g.mark.group;\n    }\n\n    this._dirty.union(b);\n  },\n\n  _render(scene) {\n    const g = this.context(),\n          o = this._origin,\n          w = this._width,\n          h = this._height,\n          db = this._dirty,\n          vb = viewBounds(o, w, h); // setup\n\n    g.save();\n    const b = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);\n    this.clear(-o[0], -o[1], w, h); // render\n\n    this.draw(g, scene, b); // takedown\n\n    g.restore();\n    db.clear();\n    return this;\n  },\n\n  draw(ctx, scene, bounds) {\n    const mark = Marks[scene.marktype];\n    if (scene.clip) clip(ctx, scene);\n    mark.draw.call(this, ctx, scene, bounds);\n    if (scene.clip) ctx.restore();\n  },\n\n  clear(x, y, w, h) {\n    const opt = this._options,\n          g = this.context();\n\n    if (opt.type !== 'pdf' && !opt.externalContext) {\n      // calling clear rect voids vector output in pdf mode\n      // and could remove external context content (#2615)\n      g.clearRect(x, y, w, h);\n    }\n\n    if (this._bgcolor != null) {\n      g.fillStyle = this._bgcolor;\n      g.fillRect(x, y, w, h);\n    }\n  }\n\n});\n\nfunction SVGHandler(loader, tooltip) {\n  Handler.call(this, loader, tooltip);\n  const h = this;\n  h._hrefHandler = listener(h, (evt, item) => {\n    if (item && item.href) h.handleHref(evt, item, item.href);\n  });\n  h._tooltipHandler = listener(h, (evt, item) => {\n    h.handleTooltip(evt, item, evt.type !== TooltipHideEvent);\n  });\n} // wrap an event listener for the SVG DOM\n\nconst listener = (context, handler) => evt => {\n  let item = evt.target.__data__;\n  item = Array.isArray(item) ? item[0] : item;\n  evt.vegaType = evt.type;\n  handler.call(context._obj, evt, item);\n};\n\ninherits(SVGHandler, Handler, {\n  initialize(el, origin, obj) {\n    let svg = this._svg;\n\n    if (svg) {\n      svg.removeEventListener(HrefEvent, this._hrefHandler);\n      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);\n      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);\n    }\n\n    this._svg = svg = el && domFind(el, 'svg');\n\n    if (svg) {\n      svg.addEventListener(HrefEvent, this._hrefHandler);\n      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);\n      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);\n    }\n\n    return Handler.prototype.initialize.call(this, el, origin, obj);\n  },\n\n  canvas() {\n    return this._svg;\n  },\n\n  // add an event handler\n  on(type, handler) {\n    const name = this.eventName(type),\n          h = this._handlers,\n          i = this._handlerIndex(h[name], type, handler);\n\n    if (i < 0) {\n      const x = {\n        type,\n        handler,\n        listener: listener(this, handler)\n      };\n      (h[name] || (h[name] = [])).push(x);\n\n      if (this._svg) {\n        this._svg.addEventListener(name, x.listener);\n      }\n    }\n\n    return this;\n  },\n\n  // remove an event handler\n  off(type, handler) {\n    const name = this.eventName(type),\n          h = this._handlers[name],\n          i = this._handlerIndex(h, type, handler);\n\n    if (i >= 0) {\n      if (this._svg) {\n        this._svg.removeEventListener(name, h[i].listener);\n      }\n\n      h.splice(i, 1);\n    }\n\n    return this;\n  }\n\n});\n\nconst ARIA_HIDDEN = 'aria-hidden';\nconst ARIA_LABEL = 'aria-label';\nconst ARIA_ROLE = 'role';\nconst ARIA_ROLEDESCRIPTION = 'aria-roledescription';\nconst GRAPHICS_OBJECT = 'graphics-object';\nconst GRAPHICS_SYMBOL = 'graphics-symbol';\n\nconst bundle = (role, roledesc, label) => ({\n  [ARIA_ROLE]: role,\n  [ARIA_ROLEDESCRIPTION]: roledesc,\n  [ARIA_LABEL]: label || undefined\n}); // these roles are covered by related roles\n// we can ignore them, no need to generate attributes\n\n\nconst AriaIgnore = toSet(['axis-domain', 'axis-grid', 'axis-label', 'axis-tick', 'axis-title', 'legend-band', 'legend-entry', 'legend-gradient', 'legend-label', 'legend-title', 'legend-symbol', 'title']); // aria attribute generators for guide roles\n\nconst AriaGuides = {\n  'axis': {\n    desc: 'axis',\n    caption: axisCaption\n  },\n  'legend': {\n    desc: 'legend',\n    caption: legendCaption\n  },\n  'title-text': {\n    desc: 'title',\n    caption: item => \"Title text '\".concat(titleCaption(item), \"'\")\n  },\n  'title-subtitle': {\n    desc: 'subtitle',\n    caption: item => \"Subtitle text '\".concat(titleCaption(item), \"'\")\n  }\n}; // aria properties generated for mark item encoding channels\n\nconst AriaEncode = {\n  ariaRole: ARIA_ROLE,\n  ariaRoleDescription: ARIA_ROLEDESCRIPTION,\n  description: ARIA_LABEL\n};\nfunction ariaItemAttributes(emit, item) {\n  const hide = item.aria === false;\n  emit(ARIA_HIDDEN, hide || undefined);\n\n  if (hide || item.description == null) {\n    for (const prop in AriaEncode) {\n      emit(AriaEncode[prop], undefined);\n    }\n  } else {\n    const type = item.mark.marktype;\n    emit(ARIA_LABEL, item.description);\n    emit(ARIA_ROLE, item.ariaRole || (type === 'group' ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));\n    emit(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || \"\".concat(type, \" mark\"));\n  }\n}\nfunction ariaMarkAttributes(mark) {\n  return mark.aria === false ? {\n    [ARIA_HIDDEN]: true\n  } : AriaIgnore[mark.role] ? null : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role]) : ariaMark(mark);\n}\n\nfunction ariaMark(mark) {\n  const type = mark.marktype;\n  const recurse = type === 'group' || type === 'text' || mark.items.some(_ => _.description != null && _.aria !== false);\n  return bundle(recurse ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, \"\".concat(type, \" mark container\"), mark.description);\n}\n\nfunction ariaGuide(mark, opt) {\n  try {\n    const item = mark.items[0],\n          caption = opt.caption || (() => '');\n\n    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));\n  } catch (err) {\n    return null;\n  }\n}\n\nfunction titleCaption(item) {\n  return array(item.text).join(' ');\n}\n\nfunction axisCaption(item) {\n  const datum = item.datum,\n        orient = item.orient,\n        title = datum.title ? extractTitle(item) : null,\n        ctx = item.context,\n        scale = ctx.scales[datum.scale].value,\n        locale = ctx.dataflow.locale(),\n        type = scale.type,\n        xy = orient === 'left' || orient === 'right' ? 'Y' : 'X';\n  return \"\".concat(xy, \"-axis\") + (title ? \" titled '\".concat(title, \"'\") : '') + \" for a \".concat(isDiscrete(type) ? 'discrete' : type, \" scale\") + \" with \".concat(domainCaption(locale, scale, item));\n}\n\nfunction legendCaption(item) {\n  const datum = item.datum,\n        title = datum.title ? extractTitle(item) : null,\n        type = \"\".concat(datum.type || '', \" legend\").trim(),\n        scales = datum.scales,\n        props = Object.keys(scales),\n        ctx = item.context,\n        scale = ctx.scales[scales[props[0]]].value,\n        locale = ctx.dataflow.locale();\n  return capitalize(type) + (title ? \" titled '\".concat(title, \"'\") : '') + \" for \".concat(channelCaption(props)) + \" with \".concat(domainCaption(locale, scale, item));\n}\n\nfunction extractTitle(item) {\n  try {\n    return array(peek(item.items).items[0].text).join(' ');\n  } catch (err) {\n    return null;\n  }\n}\n\nfunction channelCaption(props) {\n  props = props.map(p => p + (p === 'fill' || p === 'stroke' ? ' color' : ''));\n  return props.length < 2 ? props[0] : props.slice(0, -1).join(', ') + ' and ' + peek(props);\n}\n\nfunction capitalize(s) {\n  return s.length ? s[0].toUpperCase() + s.slice(1) : s;\n}\n\nconst innerText = val => (val + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n\nconst attrText = val => innerText(val).replace(/\"/g, '&quot;').replace(/\\t/g, '&#x9;').replace(/\\n/g, '&#xA;').replace(/\\r/g, '&#xD;');\n\nfunction markup() {\n  let buf = '',\n      outer = '',\n      inner = '';\n\n  const stack = [],\n        clear = () => outer = inner = '',\n        push = tag => {\n    if (outer) {\n      buf += \"\".concat(outer, \">\").concat(inner);\n      clear();\n    }\n\n    stack.push(tag);\n  },\n        attr = (name, value) => {\n    if (value != null) outer += \" \".concat(name, \"=\\\"\").concat(attrText(value), \"\\\"\");\n    return m;\n  },\n        m = {\n    open(tag) {\n      push(tag);\n      outer = '<' + tag;\n\n      for (var _len = arguments.length, attrs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        attrs[_key - 1] = arguments[_key];\n      }\n\n      for (const set of attrs) {\n        for (const key in set) attr(key, set[key]);\n      }\n\n      return m;\n    },\n\n    close() {\n      const tag = stack.pop();\n\n      if (outer) {\n        buf += outer + (inner ? \">\".concat(inner, \"</\").concat(tag, \">\") : '/>');\n      } else {\n        buf += \"</\".concat(tag, \">\");\n      }\n\n      clear();\n      return m;\n    },\n\n    attr,\n    text: t => (inner += innerText(t), m),\n    toString: () => buf\n  };\n\n  return m;\n}\nconst serializeXML = node => _serialize(markup(), node) + '';\n\nfunction _serialize(m, node) {\n  m.open(node.tagName);\n\n  if (node.hasAttributes()) {\n    const attrs = node.attributes,\n          n = attrs.length;\n\n    for (let i = 0; i < n; ++i) {\n      m.attr(attrs[i].name, attrs[i].value);\n    }\n  }\n\n  if (node.hasChildNodes()) {\n    const children = node.childNodes;\n\n    for (const child of children) {\n      child.nodeType === 3 // text node\n      ? m.text(child.nodeValue) : _serialize(m, child);\n    }\n  }\n\n  return m.close();\n}\n\nconst stylesAttr = {\n  fill: 'fill',\n  fillOpacity: 'fill-opacity',\n  stroke: 'stroke',\n  strokeOpacity: 'stroke-opacity',\n  strokeWidth: 'stroke-width',\n  strokeCap: 'stroke-linecap',\n  strokeJoin: 'stroke-linejoin',\n  strokeDash: 'stroke-dasharray',\n  strokeDashOffset: 'stroke-dashoffset',\n  strokeMiterLimit: 'stroke-miterlimit',\n  opacity: 'opacity'\n};\nconst stylesCss = {\n  blend: 'mix-blend-mode'\n}; // ensure miter limit default is consistent with canvas (#2498)\n\nconst rootAttributes = {\n  'fill': 'none',\n  'stroke-miterlimit': 10\n};\n\nconst RootIndex = 0,\n      xmlns = 'http://www.w3.org/2000/xmlns/',\n      svgns = metadata.xmlns;\nfunction SVGRenderer(loader) {\n  Renderer.call(this, loader);\n  this._dirtyID = 0;\n  this._dirty = [];\n  this._svg = null;\n  this._root = null;\n  this._defs = null;\n}\nconst base = Renderer.prototype;\ninherits(SVGRenderer, Renderer, {\n  /**\n   * Initialize a new SVGRenderer instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {number} width - The coordinate width of the display, in pixels.\n   * @param {number} height - The coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {SVGRenderer} - This renderer instance.\n   */\n  initialize(el, width, height, origin, scaleFactor) {\n    // create the svg definitions cache\n    this._defs = {};\n\n    this._clearDefs();\n\n    if (el) {\n      this._svg = domChild(el, 0, 'svg', svgns);\n\n      this._svg.setAttributeNS(xmlns, 'xmlns', svgns);\n\n      this._svg.setAttributeNS(xmlns, 'xmlns:xlink', metadata['xmlns:xlink']);\n\n      this._svg.setAttribute('version', metadata['version']);\n\n      this._svg.setAttribute('class', 'marks');\n\n      domClear(el, 1); // set the svg root group\n\n      this._root = domChild(this._svg, RootIndex, 'g', svgns);\n      setAttributes(this._root, rootAttributes); // ensure no additional child elements\n\n      domClear(this._svg, RootIndex + 1);\n    } // set background color if defined\n\n\n    this.background(this._bgcolor);\n    return base.initialize.call(this, el, width, height, origin, scaleFactor);\n  },\n\n  /**\n   * Get / set the background color.\n   */\n  background(bgcolor) {\n    if (arguments.length && this._svg) {\n      this._svg.style.setProperty('background-color', bgcolor);\n    }\n\n    return base.background.apply(this, arguments);\n  },\n\n  /**\n   * Resize the display.\n   * @param {number} width - The new coordinate width of the display, in pixels.\n   * @param {number} height - The new coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The new origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {SVGRenderer} - This renderer instance;\n   */\n  resize(width, height, origin, scaleFactor) {\n    base.resize.call(this, width, height, origin, scaleFactor);\n\n    if (this._svg) {\n      setAttributes(this._svg, {\n        width: this._width * this._scale,\n        height: this._height * this._scale,\n        viewBox: \"0 0 \".concat(this._width, \" \").concat(this._height)\n      });\n\n      this._root.setAttribute('transform', \"translate(\".concat(this._origin, \")\"));\n    }\n\n    this._dirty = [];\n    return this;\n  },\n\n  /**\n   * Returns the SVG element of the visualization.\n   * @return {DOMElement} - The SVG element.\n   */\n  canvas() {\n    return this._svg;\n  },\n\n  /**\n   * Returns an SVG text string for the rendered content,\n   * or null if this renderer is currently headless.\n   */\n  svg() {\n    const svg = this._svg,\n          bg = this._bgcolor;\n    if (!svg) return null;\n    let node;\n\n    if (bg) {\n      svg.removeAttribute('style');\n      node = domChild(svg, RootIndex, 'rect', svgns);\n      setAttributes(node, {\n        width: this._width,\n        height: this._height,\n        fill: bg\n      });\n    }\n\n    const text = serializeXML(svg);\n\n    if (bg) {\n      svg.removeChild(node);\n\n      this._svg.style.setProperty('background-color', bg);\n    }\n\n    return text;\n  },\n\n  /**\n   * Internal rendering method.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   */\n  _render(scene) {\n    // perform spot updates and re-render markup\n    if (this._dirtyCheck()) {\n      if (this._dirtyAll) this._clearDefs();\n      this.mark(this._root, scene);\n      domClear(this._root, 1);\n    }\n\n    this.defs();\n    this._dirty = [];\n    ++this._dirtyID;\n    return this;\n  },\n\n  // -- Manage rendering of items marked as dirty --\n\n  /**\n   * Flag a mark item as dirty.\n   * @param {Item} item - The mark item.\n   */\n  dirty(item) {\n    if (item.dirty !== this._dirtyID) {\n      item.dirty = this._dirtyID;\n\n      this._dirty.push(item);\n    }\n  },\n\n  /**\n   * Check if a mark item is considered dirty.\n   * @param {Item} item - The mark item.\n   */\n  isDirty(item) {\n    return this._dirtyAll || !item._svg || !item._svg.ownerSVGElement || item.dirty === this._dirtyID;\n  },\n\n  /**\n   * Internal method to check dirty status and, if possible,\n   * make targetted updates without a full rendering pass.\n   */\n  _dirtyCheck() {\n    this._dirtyAll = true;\n    const items = this._dirty;\n    if (!items.length || !this._dirtyID) return true;\n    const id = ++this._dirtyID;\n    let item, mark, type, mdef, i, n, o;\n\n    for (i = 0, n = items.length; i < n; ++i) {\n      item = items[i];\n      mark = item.mark;\n\n      if (mark.marktype !== type) {\n        // memoize mark instance lookup\n        type = mark.marktype;\n        mdef = Marks[type];\n      }\n\n      if (mark.zdirty && mark.dirty !== id) {\n        this._dirtyAll = false;\n        dirtyParents(item, id);\n        mark.items.forEach(i => {\n          i.dirty = id;\n        });\n      }\n\n      if (mark.zdirty) continue; // handle in standard drawing pass\n\n      if (item.exit) {\n        // EXIT\n        if (mdef.nested && mark.items.length) {\n          // if nested mark with remaining points, update instead\n          o = mark.items[0];\n          if (o._svg) this._update(mdef, o._svg, o);\n        } else if (item._svg) {\n          // otherwise remove from DOM\n          o = item._svg.parentNode;\n          if (o) o.removeChild(item._svg);\n        }\n\n        item._svg = null;\n        continue;\n      }\n\n      item = mdef.nested ? mark.items[0] : item;\n      if (item._update === id) continue; // already visited\n\n      if (!item._svg || !item._svg.ownerSVGElement) {\n        // ENTER\n        this._dirtyAll = false;\n        dirtyParents(item, id);\n      } else {\n        // IN-PLACE UPDATE\n        this._update(mdef, item._svg, item);\n      }\n\n      item._update = id;\n    }\n\n    return !this._dirtyAll;\n  },\n\n  // -- Construct & maintain scenegraph to SVG mapping ---\n\n  /**\n   * Render a set of mark items.\n   * @param {SVGElement} el - The parent element in the SVG tree.\n   * @param {object} scene - The mark parent to render.\n   * @param {SVGElement} prev - The previous sibling in the SVG tree.\n   */\n  mark(el, scene, prev) {\n    if (!this.isDirty(scene)) {\n      return scene._svg;\n    }\n\n    const svg = this._svg,\n          mdef = Marks[scene.marktype],\n          events = scene.interactive === false ? 'none' : null,\n          isGroup = mdef.tag === 'g';\n    const parent = bind(scene, el, prev, 'g', svg);\n    parent.setAttribute('class', cssClass(scene)); // apply aria attributes to parent container element\n\n    const aria = ariaMarkAttributes(scene);\n\n    for (const key in aria) setAttribute(parent, key, aria[key]);\n\n    if (!isGroup) {\n      setAttribute(parent, 'pointer-events', events);\n    }\n\n    setAttribute(parent, 'clip-path', scene.clip ? clip$1(this, scene, scene.group) : null);\n    let sibling = null,\n        i = 0;\n\n    const process = item => {\n      const dirty = this.isDirty(item),\n            node = bind(item, parent, sibling, mdef.tag, svg);\n\n      if (dirty) {\n        this._update(mdef, node, item);\n\n        if (isGroup) recurse(this, node, item);\n      }\n\n      sibling = node;\n      ++i;\n    };\n\n    if (mdef.nested) {\n      if (scene.items.length) process(scene.items[0]);\n    } else {\n      visit(scene, process);\n    }\n\n    domClear(parent, i);\n    return parent;\n  },\n\n  /**\n   * Update the attributes of an SVG element for a mark item.\n   * @param {object} mdef - The mark definition object\n   * @param {SVGElement} el - The SVG element.\n   * @param {Item} item - The mark item.\n   */\n  _update(mdef, el, item) {\n    // set dom element and values cache\n    // provides access to emit method\n    element = el;\n    values = el.__values__; // apply aria-specific properties\n\n    ariaItemAttributes(emit, item); // apply svg attributes\n\n    mdef.attr(emit, item, this); // some marks need special treatment\n\n    const extra = mark_extras[mdef.type];\n    if (extra) extra.call(this, mdef, el, item); // apply svg style attributes\n    // note: element state may have been modified by 'extra' method\n\n    if (element) this.style(element, item);\n  },\n\n  /**\n   * Update the presentation attributes of an SVG element for a mark item.\n   * @param {SVGElement} el - The SVG element.\n   * @param {Item} item - The mark item.\n   */\n  style(el, item) {\n    if (item == null) return;\n\n    for (const prop in stylesAttr) {\n      let value = prop === 'font' ? fontFamily(item) : item[prop];\n      if (value === values[prop]) continue;\n      const name = stylesAttr[prop];\n\n      if (value == null) {\n        el.removeAttribute(name);\n      } else {\n        if (isGradient(value)) {\n          value = gradientRef(value, this._defs.gradient, href());\n        }\n\n        el.setAttribute(name, value + '');\n      }\n\n      values[prop] = value;\n    }\n\n    for (const prop in stylesCss) {\n      setStyle(el, stylesCss[prop], item[prop]);\n    }\n  },\n\n  /**\n   * Render SVG defs, as needed.\n   * Must be called *after* marks have been processed to ensure the\n   * collected state is current and accurate.\n   */\n  defs() {\n    const svg = this._svg,\n          defs = this._defs;\n    let el = defs.el,\n        index = 0;\n\n    for (const id in defs.gradient) {\n      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);\n      index = updateGradient(el, defs.gradient[id], index);\n    }\n\n    for (const id in defs.clipping) {\n      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);\n      index = updateClipping(el, defs.clipping[id], index);\n    } // clean-up\n\n\n    if (el) {\n      index === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index);\n    }\n  },\n\n  /**\n   * Clear defs caches.\n   */\n  _clearDefs() {\n    const def = this._defs;\n    def.gradient = {};\n    def.clipping = {};\n  }\n\n}); // mark ancestor chain with a dirty id\n\nfunction dirtyParents(item, id) {\n  for (; item && item.dirty !== id; item = item.mark.group) {\n    item.dirty = id;\n\n    if (item.mark && item.mark.dirty !== id) {\n      item.mark.dirty = id;\n    } else return;\n  }\n} // update gradient definitions\n\n\nfunction updateGradient(el, grad, index) {\n  let i, n, stop;\n\n  if (grad.gradient === 'radial') {\n    // SVG radial gradients automatically transform to normalized bbox\n    // coordinates, in a way that is cumbersome to replicate in canvas.\n    // We wrap the radial gradient in a pattern element, allowing us to\n    // maintain a circular gradient that matches what canvas provides.\n    let pt = domChild(el, index++, 'pattern', svgns);\n    setAttributes(pt, {\n      id: patternPrefix + grad.id,\n      viewBox: '0,0,1,1',\n      width: '100%',\n      height: '100%',\n      preserveAspectRatio: 'xMidYMid slice'\n    });\n    pt = domChild(pt, 0, 'rect', svgns);\n    setAttributes(pt, {\n      width: 1,\n      height: 1,\n      fill: \"url(\".concat(href(), \"#\").concat(grad.id, \")\")\n    });\n    el = domChild(el, index++, 'radialGradient', svgns);\n    setAttributes(el, {\n      id: grad.id,\n      fx: grad.x1,\n      fy: grad.y1,\n      fr: grad.r1,\n      cx: grad.x2,\n      cy: grad.y2,\n      r: grad.r2\n    });\n  } else {\n    el = domChild(el, index++, 'linearGradient', svgns);\n    setAttributes(el, {\n      id: grad.id,\n      x1: grad.x1,\n      x2: grad.x2,\n      y1: grad.y1,\n      y2: grad.y2\n    });\n  }\n\n  for (i = 0, n = grad.stops.length; i < n; ++i) {\n    stop = domChild(el, i, 'stop', svgns);\n    stop.setAttribute('offset', grad.stops[i].offset);\n    stop.setAttribute('stop-color', grad.stops[i].color);\n  }\n\n  domClear(el, i);\n  return index;\n} // update clipping path definitions\n\n\nfunction updateClipping(el, clip, index) {\n  let mask;\n  el = domChild(el, index, 'clipPath', svgns);\n  el.setAttribute('id', clip.id);\n\n  if (clip.path) {\n    mask = domChild(el, 0, 'path', svgns);\n    mask.setAttribute('d', clip.path);\n  } else {\n    mask = domChild(el, 0, 'rect', svgns);\n    setAttributes(mask, {\n      x: 0,\n      y: 0,\n      width: clip.width,\n      height: clip.height\n    });\n  }\n\n  domClear(el, 1);\n  return index + 1;\n} // Recursively process group contents.\n\n\nfunction recurse(renderer, el, group) {\n  // child 'g' element is second to last among children (path, g, path)\n  // other children here are foreground and background path elements\n  el = el.lastChild.previousSibling;\n  let prev,\n      idx = 0;\n  visit(group, item => {\n    prev = renderer.mark(el, item, prev);\n    ++idx;\n  }); // remove any extraneous DOM elements\n\n  domClear(el, 1 + idx);\n} // Bind a scenegraph item to an SVG DOM element.\n// Create new SVG elements as needed.\n\n\nfunction bind(item, el, sibling, tag, svg) {\n  let node = item._svg,\n      doc; // create a new dom node if needed\n\n  if (!node) {\n    doc = el.ownerDocument;\n    node = domCreate(doc, tag, svgns);\n    item._svg = node;\n\n    if (item.mark) {\n      node.__data__ = item;\n      node.__values__ = {\n        fill: 'default'\n      }; // if group, create background, content, and foreground elements\n\n      if (tag === 'g') {\n        const bg = domCreate(doc, 'path', svgns);\n        node.appendChild(bg);\n        bg.__data__ = item;\n        const cg = domCreate(doc, 'g', svgns);\n        node.appendChild(cg);\n        cg.__data__ = item;\n        const fg = domCreate(doc, 'path', svgns);\n        node.appendChild(fg);\n        fg.__data__ = item;\n        fg.__values__ = {\n          fill: 'default'\n        };\n      }\n    }\n  } // (re-)insert if (a) not contained in SVG or (b) sibling order has changed\n\n\n  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {\n    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);\n  }\n\n  return node;\n} // check if two nodes are ordered siblings\n\n\nfunction siblingCheck(node, sibling) {\n  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling; // treat null/undefined the same\n} // -- Set attributes & styles on SVG elements ---\n\n\nlet element = null,\n    // temp var for current SVG element\nvalues = null; // temp var for current values hash\n// Extra configuration for certain mark types\n\nconst mark_extras = {\n  group(mdef, el, item) {\n    const fg = element = el.childNodes[2];\n    values = fg.__values__;\n    mdef.foreground(emit, item, this);\n    values = el.__values__; // use parent's values hash\n\n    element = el.childNodes[1];\n    mdef.content(emit, item, this);\n    const bg = element = el.childNodes[0];\n    mdef.background(emit, item, this);\n    const value = item.mark.interactive === false ? 'none' : null;\n\n    if (value !== values.events) {\n      setAttribute(fg, 'pointer-events', value);\n      setAttribute(bg, 'pointer-events', value);\n      values.events = value;\n    }\n\n    if (item.strokeForeground && item.stroke) {\n      const fill = item.fill;\n      setAttribute(fg, 'display', null); // set style of background\n\n      this.style(bg, item);\n      setAttribute(bg, 'stroke', null); // set style of foreground\n\n      if (fill) item.fill = null;\n      values = fg.__values__;\n      this.style(fg, item);\n      if (fill) item.fill = fill; // leave element null to prevent downstream styling\n\n      element = null;\n    } else {\n      // ensure foreground is ignored\n      setAttribute(fg, 'display', 'none');\n    }\n  },\n\n  image(mdef, el, item) {\n    if (item.smooth === false) {\n      setStyle(el, 'image-rendering', 'optimizeSpeed');\n      setStyle(el, 'image-rendering', 'pixelated');\n    } else {\n      setStyle(el, 'image-rendering', null);\n    }\n  },\n\n  text(mdef, el, item) {\n    const tl = textLines(item);\n    let key, value, doc, lh;\n\n    if (isArray(tl)) {\n      // multi-line text\n      value = tl.map(_ => textValue(item, _));\n      key = value.join('\\n'); // content cache key\n\n      if (key !== values.text) {\n        domClear(el, 0);\n        doc = el.ownerDocument;\n        lh = lineHeight(item);\n        value.forEach((t, i) => {\n          const ts = domCreate(doc, 'tspan', svgns);\n          ts.__data__ = item; // data binding\n\n          ts.textContent = t;\n\n          if (i) {\n            ts.setAttribute('x', 0);\n            ts.setAttribute('dy', lh);\n          }\n\n          el.appendChild(ts);\n        });\n        values.text = key;\n      }\n    } else {\n      // single-line text\n      value = textValue(item, tl);\n\n      if (value !== values.text) {\n        el.textContent = value;\n        values.text = value;\n      }\n    }\n\n    setAttribute(el, 'font-family', fontFamily(item));\n    setAttribute(el, 'font-size', fontSize(item) + 'px');\n    setAttribute(el, 'font-style', item.fontStyle);\n    setAttribute(el, 'font-variant', item.fontVariant);\n    setAttribute(el, 'font-weight', item.fontWeight);\n  }\n\n};\n\nfunction emit(name, value, ns) {\n  // early exit if value is unchanged\n  if (value === values[name]) return; // use appropriate method given namespace (ns)\n\n  if (ns) {\n    setAttributeNS(element, name, value, ns);\n  } else {\n    setAttribute(element, name, value);\n  } // note current value for future comparison\n\n\n  values[name] = value;\n}\n\nfunction setStyle(el, name, value) {\n  if (value !== values[name]) {\n    if (value == null) {\n      el.style.removeProperty(name);\n    } else {\n      el.style.setProperty(name, value + '');\n    }\n\n    values[name] = value;\n  }\n}\n\nfunction setAttributes(el, attrs) {\n  for (const key in attrs) {\n    setAttribute(el, key, attrs[key]);\n  }\n}\n\nfunction setAttribute(el, name, value) {\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    el.setAttribute(name, value);\n  } else {\n    // else remove DOM attribute\n    el.removeAttribute(name);\n  }\n}\n\nfunction setAttributeNS(el, name, value, ns) {\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    el.setAttributeNS(ns, name, value);\n  } else {\n    // else remove DOM attribute\n    el.removeAttributeNS(ns, name);\n  }\n}\n\nfunction href() {\n  let loc;\n  return typeof window === 'undefined' ? '' : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;\n}\n\nfunction SVGStringRenderer(loader) {\n  Renderer.call(this, loader);\n  this._text = null;\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n}\ninherits(SVGStringRenderer, Renderer, {\n  /**\n   * Returns the rendered SVG text string,\n   * or null if rendering has not yet occurred.\n   */\n  svg() {\n    return this._text;\n  },\n\n  /**\n   * Internal rendering method.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   */\n  _render(scene) {\n    const m = markup(); // svg tag\n\n    m.open('svg', extend({}, metadata, {\n      class: 'marks',\n      width: this._width * this._scale,\n      height: this._height * this._scale,\n      viewBox: \"0 0 \".concat(this._width, \" \").concat(this._height)\n    })); // background, if defined\n\n    const bg = this._bgcolor;\n\n    if (bg && bg !== 'transparent' && bg !== 'none') {\n      m.open('rect', {\n        width: this._width,\n        height: this._height,\n        fill: bg\n      }).close();\n    } // root content group\n\n\n    m.open('g', rootAttributes, {\n      transform: 'translate(' + this._origin + ')'\n    });\n    this.mark(m, scene);\n    m.close(); // </g>\n    // defs\n\n    this.defs(m); // get SVG text string\n\n    this._text = m.close() + '';\n    return this;\n  },\n\n  /**\n   * Render a set of mark items.\n   * @param {object} m - The markup context.\n   * @param {object} scene - The mark parent to render.\n   */\n  mark(m, scene) {\n    const mdef = Marks[scene.marktype],\n          tag = mdef.tag,\n          attrList = [ariaItemAttributes, mdef.attr]; // render opening group tag\n\n    m.open('g', {\n      'class': cssClass(scene),\n      'clip-path': scene.clip ? clip$1(this, scene, scene.group) : null\n    }, ariaMarkAttributes(scene), {\n      'pointer-events': tag !== 'g' && scene.interactive === false ? 'none' : null\n    }); // render contained elements\n\n    const process = item => {\n      const href = this.href(item);\n      if (href) m.open('a', href);\n      m.open(tag, this.attr(scene, item, attrList, tag !== 'g' ? tag : null));\n\n      if (tag === 'text') {\n        const tl = textLines(item);\n\n        if (isArray(tl)) {\n          // multi-line text\n          const attrs = {\n            x: 0,\n            dy: lineHeight(item)\n          };\n\n          for (let i = 0; i < tl.length; ++i) {\n            m.open('tspan', i ? attrs : null).text(textValue(item, tl[i])).close();\n          }\n        } else {\n          // single-line text\n          m.text(textValue(item, tl));\n        }\n      } else if (tag === 'g') {\n        const fore = item.strokeForeground,\n              fill = item.fill,\n              stroke = item.stroke;\n\n        if (fore && stroke) {\n          item.stroke = null;\n        }\n\n        m.open('path', this.attr(scene, item, mdef.background, 'bgrect')).close(); // recurse for group content\n\n        m.open('g', this.attr(scene, item, mdef.content));\n        visit(item, scene => this.mark(m, scene));\n        m.close();\n\n        if (fore && stroke) {\n          if (fill) item.fill = null;\n          item.stroke = stroke;\n          m.open('path', this.attr(scene, item, mdef.foreground, 'bgrect')).close();\n          if (fill) item.fill = fill;\n        } else {\n          m.open('path', this.attr(scene, item, mdef.foreground, 'bgfore')).close();\n        }\n      }\n\n      m.close(); // </tag>\n\n      if (href) m.close(); // </a>\n    };\n\n    if (mdef.nested) {\n      if (scene.items && scene.items.length) process(scene.items[0]);\n    } else {\n      visit(scene, process);\n    } // render closing group tag\n\n\n    return m.close(); // </g>\n  },\n\n  /**\n   * Get href attributes for a hyperlinked mark item.\n   * @param {Item} item - The mark item.\n   */\n  href(item) {\n    const href = item.href;\n    let attr;\n\n    if (href) {\n      if (attr = this._hrefs && this._hrefs[href]) {\n        return attr;\n      } else {\n        this.sanitizeURL(href).then(attr => {\n          // rewrite to use xlink namespace\n          attr['xlink:href'] = attr.href;\n          attr.href = null;\n          (this._hrefs || (this._hrefs = {}))[href] = attr;\n        });\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Get an object of SVG attributes for a mark item.\n   * @param {object} scene - The mark parent.\n   * @param {Item} item - The mark item.\n   * @param {array|function} attrs - One or more attribute emitters.\n   * @param {string} tag - The tag being rendered.\n   */\n  attr(scene, item, attrs, tag) {\n    const object = {},\n          emit = (name, value, ns, prefixed) => {\n      object[prefixed || name] = value;\n    }; // apply mark specific attributes\n\n\n    if (Array.isArray(attrs)) {\n      attrs.forEach(fn => fn(emit, item, this));\n    } else {\n      attrs(emit, item, this);\n    } // apply style attributes\n\n\n    if (tag) {\n      style(object, item, scene, tag, this._defs);\n    }\n\n    return object;\n  },\n\n  /**\n   * Render SVG defs, as needed.\n   * Must be called *after* marks have been processed to ensure the\n   * collected state is current and accurate.\n   * @param {object} m - The markup context.\n   */\n  defs(m) {\n    const gradient = this._defs.gradient,\n          clipping = this._defs.clipping,\n          count = Object.keys(gradient).length + Object.keys(clipping).length;\n    if (count === 0) return; // nothing to do\n\n    m.open('defs');\n\n    for (const id in gradient) {\n      const def = gradient[id],\n            stops = def.stops;\n\n      if (def.gradient === 'radial') {\n        // SVG radial gradients automatically transform to normalized bbox\n        // coordinates, in a way that is cumbersome to replicate in canvas.\n        // We wrap the radial gradient in a pattern element, allowing us to\n        // maintain a circular gradient that matches what canvas provides.\n        m.open('pattern', {\n          id: patternPrefix + id,\n          viewBox: '0,0,1,1',\n          width: '100%',\n          height: '100%',\n          preserveAspectRatio: 'xMidYMid slice'\n        });\n        m.open('rect', {\n          width: '1',\n          height: '1',\n          fill: 'url(#' + id + ')'\n        }).close();\n        m.close(); // </pattern>\n\n        m.open('radialGradient', {\n          id: id,\n          fx: def.x1,\n          fy: def.y1,\n          fr: def.r1,\n          cx: def.x2,\n          cy: def.y2,\n          r: def.r2\n        });\n      } else {\n        m.open('linearGradient', {\n          id: id,\n          x1: def.x1,\n          x2: def.x2,\n          y1: def.y1,\n          y2: def.y2\n        });\n      }\n\n      for (let i = 0; i < stops.length; ++i) {\n        m.open('stop', {\n          offset: stops[i].offset,\n          'stop-color': stops[i].color\n        }).close();\n      }\n\n      m.close();\n    }\n\n    for (const id in clipping) {\n      const def = clipping[id];\n      m.open('clipPath', {\n        id: id\n      });\n\n      if (def.path) {\n        m.open('path', {\n          d: def.path\n        }).close();\n      } else {\n        m.open('rect', {\n          x: 0,\n          y: 0,\n          width: def.width,\n          height: def.height\n        }).close();\n      }\n\n      m.close();\n    }\n\n    m.close();\n  }\n\n}); // Helper function for attr for style presentation attributes\n\nfunction style(s, item, scene, tag, defs) {\n  let styleList;\n  if (item == null) return s;\n\n  if (tag === 'bgrect' && scene.interactive === false) {\n    s['pointer-events'] = 'none';\n  }\n\n  if (tag === 'bgfore') {\n    if (scene.interactive === false) {\n      s['pointer-events'] = 'none';\n    }\n\n    s.display = 'none';\n    if (item.fill !== null) return s;\n  }\n\n  if (tag === 'image' && item.smooth === false) {\n    styleList = ['image-rendering: optimizeSpeed;', 'image-rendering: pixelated;'];\n  }\n\n  if (tag === 'text') {\n    s['font-family'] = fontFamily(item);\n    s['font-size'] = fontSize(item) + 'px';\n    s['font-style'] = item.fontStyle;\n    s['font-variant'] = item.fontVariant;\n    s['font-weight'] = item.fontWeight;\n  }\n\n  for (const prop in stylesAttr) {\n    let value = item[prop];\n    const name = stylesAttr[prop];\n\n    if (value === 'transparent' && (name === 'fill' || name === 'stroke')) ; else if (value != null) {\n      if (isGradient(value)) {\n        value = gradientRef(value, defs.gradient, '');\n      }\n\n      s[name] = value;\n    }\n  }\n\n  for (const prop in stylesCss) {\n    const value = item[prop];\n\n    if (value != null) {\n      styleList = styleList || [];\n      styleList.push(\"\".concat(stylesCss[prop], \": \").concat(value, \";\"));\n    }\n  }\n\n  if (styleList) {\n    s.style = styleList.join(' ');\n  }\n\n  return s;\n}\n\nconst Canvas = 'canvas';\nconst PNG = 'png';\nconst SVG = 'svg';\nconst None = 'none';\nconst RenderType = {\n  Canvas: Canvas,\n  PNG: PNG,\n  SVG: SVG,\n  None: None\n};\nconst modules = {};\nmodules[Canvas] = modules[PNG] = {\n  renderer: CanvasRenderer,\n  headless: CanvasRenderer,\n  handler: CanvasHandler\n};\nmodules[SVG] = {\n  renderer: SVGRenderer,\n  headless: SVGStringRenderer,\n  handler: SVGHandler\n};\nmodules[None] = {};\nfunction renderModule(name, _) {\n  name = String(name || '').toLowerCase();\n\n  if (arguments.length > 1) {\n    modules[name] = _;\n    return this;\n  } else {\n    return modules[name];\n  }\n}\n\nfunction intersect(scene, bounds, filter) {\n  const hits = [],\n        // intersection results\n  box = new Bounds().union(bounds),\n        // defensive copy\n  type = scene.marktype;\n  return type ? intersectMark(scene, box, filter, hits) : type === 'group' ? intersectGroup(scene, box, filter, hits) : error('Intersect scene must be mark node or group item.');\n}\n\nfunction intersectMark(mark, box, filter, hits) {\n  if (visitMark(mark, box, filter)) {\n    const items = mark.items,\n          type = mark.marktype,\n          n = items.length;\n    let i = 0;\n\n    if (type === 'group') {\n      for (; i < n; ++i) {\n        intersectGroup(items[i], box, filter, hits);\n      }\n    } else {\n      for (const test = Marks[type].isect; i < n; ++i) {\n        const item = items[i];\n        if (intersectItem(item, box, test)) hits.push(item);\n      }\n    }\n  }\n\n  return hits;\n}\n\nfunction visitMark(mark, box, filter) {\n  // process if bounds intersect and if\n  // (1) mark is a group mark (so we must recurse), or\n  // (2) mark is interactive and passes filter\n  return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === 'group' || mark.interactive !== false && (!filter || filter(mark)));\n}\n\nfunction intersectGroup(group, box, filter, hits) {\n  // test intersect against group\n  // skip groups by default unless filter says otherwise\n  if (filter && filter(group.mark) && intersectItem(group, box, Marks.group.isect)) {\n    hits.push(group);\n  } // recursively test children marks\n  // translate box to group coordinate space\n\n\n  const marks = group.items,\n        n = marks && marks.length;\n\n  if (n) {\n    const x = group.x || 0,\n          y = group.y || 0;\n    box.translate(-x, -y);\n\n    for (let i = 0; i < n; ++i) {\n      intersectMark(marks[i], box, filter, hits);\n    }\n\n    box.translate(x, y);\n  }\n\n  return hits;\n}\n\nfunction intersectItem(item, box, test) {\n  // test bounds enclosure, bounds intersection, then detailed test\n  const bounds = item.bounds;\n  return box.encloses(bounds) || box.intersects(bounds) && test(item, box);\n}\n\nconst clipBounds = new Bounds();\nfunction boundClip (mark) {\n  const clip = mark.clip;\n\n  if (isFunction(clip)) {\n    clip(boundContext(clipBounds.clear()));\n  } else if (clip) {\n    clipBounds.set(0, 0, mark.group.width, mark.group.height);\n  } else return;\n\n  mark.bounds.intersect(clipBounds);\n}\n\nconst TOLERANCE = 1e-9;\nfunction sceneEqual(a, b, key) {\n  return a === b ? true : key === 'path' ? pathEqual(a, b) : a instanceof Date && b instanceof Date ? +a === +b : isNumber(a) && isNumber(b) ? Math.abs(a - b) <= TOLERANCE : !a || !b || !isObject(a) && !isObject(b) ? a == b : objectEqual(a, b);\n}\nfunction pathEqual(a, b) {\n  return sceneEqual(parse(a), parse(b));\n}\n\nfunction objectEqual(a, b) {\n  var ka = Object.keys(a),\n      kb = Object.keys(b),\n      key,\n      i;\n  if (ka.length !== kb.length) return false;\n  ka.sort();\n  kb.sort();\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i]) return false;\n  }\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!sceneEqual(a[key], b[key], key)) return false;\n  }\n\n  return typeof a === typeof b;\n}\n\nfunction resetSVGDefIds() {\n  resetSVGClipId();\n  resetSVGGradientId();\n}\n\nexport { Bounds, CanvasHandler, CanvasRenderer, Gradient, GroupItem, Handler, Item, Marks, RenderType, Renderer, ResourceLoader, SVGHandler, SVGRenderer, SVGStringRenderer, Scenegraph, boundClip, boundContext, boundItem, boundMark, boundStroke, domChild, domClear, domCreate, domFind, font, fontFamily, fontSize, intersect, intersectBoxLine, intersectPath, intersectPoint, intersectRule, lineHeight, markup, multiLineOffset, curves as pathCurves, pathEqual, parse as pathParse, vg_rect as pathRectangle, pathRender, symbols as pathSymbols, vg_trail as pathTrail, point, renderModule, resetSVGClipId, resetSVGDefIds, sceneEqual, sceneFromJSON, pickVisit as scenePickVisit, sceneToJSON, visit as sceneVisit, zorder as sceneZOrder, serializeXML, textMetrics };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}