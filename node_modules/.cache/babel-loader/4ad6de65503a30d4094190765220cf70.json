{"ast":null,"code":"import { getPositionScaleChannel } from '../channel';\nimport { signalRefOrValue } from '../compile/common';\nexport function isFitType(autoSizeType) {\n  return autoSizeType === 'fit' || autoSizeType === 'fit-x' || autoSizeType === 'fit-y';\n}\nexport function getFitType(sizeType) {\n  return sizeType ? `fit-${getPositionScaleChannel(sizeType)}` : 'fit';\n}\nconst TOP_LEVEL_PROPERTIES = ['background', 'padding' // We do not include \"autosize\" here as it is supported by only unit and layer specs and thus need to be normalized\n];\nexport function extractTopLevelProperties(t, includeParams) {\n  const o = {};\n\n  for (const p of TOP_LEVEL_PROPERTIES) {\n    if (t && t[p] !== undefined) {\n      o[p] = signalRefOrValue(t[p]);\n    }\n  }\n\n  if (includeParams) {\n    o.params = t.params;\n  }\n\n  return o;\n}","map":{"version":3,"mappings":"AAEA,SAAQA,uBAAR,QAAsC,YAAtC;AACA,SAAQC,gBAAR,QAA+B,mBAA/B;AA4EA,OAAM,SAAUC,SAAV,CAAoBC,YAApB,EAA8C;EAClD,OAAOA,YAAY,KAAK,KAAjB,IAA0BA,YAAY,KAAK,OAA3C,IAAsDA,YAAY,KAAK,OAA9E;AACD;AAED,OAAM,SAAUC,UAAV,CAAqBC,QAArB,EAAkD;EACtD,OAAOA,QAAQ,GAAI,OAAOL,uBAAuB,CAACK,QAAD,CAAU,EAA5C,GAA6D,KAA5E;AACD;AA2BD,MAAMC,oBAAoB,GAAiC,CACzD,YADyD,EAEzD,SAFyD,CAGzD;AAHyD,CAA3D;AAMA,OAAM,SAAUC,yBAAV,CAAoCC,CAApC,EAA2DC,aAA3D,EAAiF;EACrF,MAAMC,CAAC,GAAkC,EAAzC;;EACA,KAAK,MAAMC,CAAX,IAAgBL,oBAAhB,EAAsC;IACpC,IAAIE,CAAC,IAAIA,CAAC,CAACG,CAAD,CAAD,KAASC,SAAlB,EAA6B;MAC3BF,CAAC,CAACC,CAAD,CAAD,GAAcV,gBAAgB,CAACO,CAAC,CAACG,CAAD,CAAF,CAA9B;IACD;EACF;;EACD,IAAIF,aAAJ,EAAmB;IACjBC,CAAC,CAACG,MAAF,GAAWL,CAAC,CAACK,MAAb;EACD;;EACD,OAAOH,CAAP;AACD","names":["getPositionScaleChannel","signalRefOrValue","isFitType","autoSizeType","getFitType","sizeType","TOP_LEVEL_PROPERTIES","extractTopLevelProperties","t","includeParams","o","p","undefined","params"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/spec/toplevel.ts"],"sourcesContent":["import {Color, SignalRef} from 'vega';\nimport {BaseSpec} from '.';\nimport {getPositionScaleChannel} from '../channel';\nimport {signalRefOrValue} from '../compile/common';\nimport {Config} from '../config';\nimport {InlineDataset} from '../data';\nimport {ExprRef} from '../expr';\nimport {VariableParameter} from '../parameter';\nimport {TopLevelSelectionParameter} from '../selection';\nimport {Dict} from '../util';\n\n/**\n * @minimum 0\n */\nexport type Padding = number | {top?: number; bottom?: number; left?: number; right?: number};\n\nexport type Datasets = Dict<InlineDataset>;\n\nexport type TopLevel<S extends BaseSpec> = S &\n  TopLevelProperties & {\n    /**\n     * URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.\n     * @format uri\n     */\n    $schema?: string;\n\n    /**\n     * Vega-Lite configuration object. This property can only be defined at the top-level of a specification.\n     */\n    config?: Config;\n\n    /**\n     * A global data store for named datasets. This is a mapping from names to inline datasets.\n     * This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property.\n     */\n    datasets?: Datasets;\n\n    /**\n     * Optional metadata that will be passed to Vega.\n     * This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata.\n     */\n    usermeta?: Dict<unknown>;\n  };\n\n/**\n * Shared properties between Top-Level specs and Config\n */\nexport interface TopLevelProperties<ES extends ExprRef | SignalRef = ExprRef | SignalRef> {\n  /**\n   * CSS color property to use as the background of the entire view.\n   *\n   * __Default value:__ `\"white\"`\n   */\n  background?: Color | ES;\n\n  /**\n   * The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides.\n   * If an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n   *\n   * __Default value__: `5`\n   */\n  padding?: Padding | ES;\n\n  /**\n   * How the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`.\n   * Object values can additionally specify parameters for content sizing and automatic resizing.\n   *\n   * __Default value__: `pad`\n   */\n  autosize?: AutosizeType | AutoSizeParams; // Vega actually supports signal for autosize. However, we need to check autosize at compile time to infer the rest of the spec. Thus VL's autosize won't support SignalRef for now.\n\n  /**\n   * Dynamic variables or selections that parameterize a visualization.\n   */\n  params?: (VariableParameter | TopLevelSelectionParameter)[];\n}\n\nexport type FitType = 'fit' | 'fit-x' | 'fit-y';\n\nexport function isFitType(autoSizeType: AutosizeType): autoSizeType is FitType {\n  return autoSizeType === 'fit' || autoSizeType === 'fit-x' || autoSizeType === 'fit-y';\n}\n\nexport function getFitType(sizeType?: 'width' | 'height'): FitType {\n  return sizeType ? (`fit-${getPositionScaleChannel(sizeType)}` as FitType) : 'fit';\n}\n\nexport type AutosizeType = 'pad' | 'none' | 'fit' | 'fit-x' | 'fit-y';\n\nexport interface AutoSizeParams {\n  /**\n   * The sizing format type. One of `\"pad\"`, `\"fit\"`, `\"fit-x\"`, `\"fit-y\"`,  or `\"none\"`. See the [autosize type](https://vega.github.io/vega-lite/docs/size.html#autosize) documentation for descriptions of each.\n   *\n   * __Default value__: `\"pad\"`\n   */\n  type?: AutosizeType;\n\n  /**\n   * A boolean flag indicating if autosize layout should be re-calculated on every view update.\n   *\n   * __Default value__: `false`\n   */\n  resize?: boolean;\n\n  /**\n   * Determines how size calculation should be performed, one of `\"content\"` or `\"padding\"`. The default setting (`\"content\"`) interprets the width and height settings as the data rectangle (plotting) dimensions, to which padding is then added. In contrast, the `\"padding\"` setting includes the padding within the view size calculations, such that the width and height settings indicate the **total** intended size of the view.\n   *\n   * __Default value__: `\"content\"`\n   */\n  contains?: 'content' | 'padding';\n}\n\nconst TOP_LEVEL_PROPERTIES: (keyof TopLevelProperties)[] = [\n  'background',\n  'padding'\n  // We do not include \"autosize\" here as it is supported by only unit and layer specs and thus need to be normalized\n];\n\nexport function extractTopLevelProperties(t: TopLevelProperties, includeParams: boolean) {\n  const o: TopLevelProperties<SignalRef> = {};\n  for (const p of TOP_LEVEL_PROPERTIES) {\n    if (t && t[p] !== undefined) {\n      o[p as any] = signalRefOrValue(t[p]);\n    }\n  }\n  if (includeParams) {\n    o.params = t.params;\n  }\n  return o;\n}\n"]},"metadata":{},"sourceType":"module"}