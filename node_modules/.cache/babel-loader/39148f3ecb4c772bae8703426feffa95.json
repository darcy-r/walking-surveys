{"ast":null,"code":"import { isXorY } from '../channel';\nimport * as log from '../log';\nimport { isConcatModel, isFacetModel, isLayerModel } from './model';\nexport function defaultScaleResolve(channel, model) {\n  if (isFacetModel(model)) {\n    return channel === 'theta' ? 'independent' : 'shared';\n  } else if (isLayerModel(model)) {\n    return 'shared';\n  } else if (isConcatModel(model)) {\n    return isXorY(channel) || channel === 'theta' || channel === 'radius' ? 'independent' : 'shared';\n  }\n  /* istanbul ignore next: should never reach here. */\n\n\n  throw new Error('invalid model type for resolve');\n}\nexport function parseGuideResolve(resolve, channel) {\n  const channelScaleResolve = resolve.scale[channel];\n  const guide = isXorY(channel) ? 'axis' : 'legend';\n\n  if (channelScaleResolve === 'independent') {\n    if (resolve[guide][channel] === 'shared') {\n      log.warn(log.message.independentScaleMeansIndependentGuide(channel));\n    }\n\n    return 'independent';\n  }\n\n  return resolve[guide][channel] || 'shared';\n}","map":{"version":3,"mappings":"AAAA,SAAQA,MAAR,QAAmC,YAAnC;AACA,OAAO,KAAKC,GAAZ,MAAqB,QAArB;AAEA,SAAQC,aAAR,EAAuBC,YAAvB,EAAqCC,YAArC,QAA+D,SAA/D;AAEA,OAAM,SAAUC,mBAAV,CAA8BC,OAA9B,EAAqDC,KAArD,EAAiE;EACrE,IAAIJ,YAAY,CAACI,KAAD,CAAhB,EAAyB;IACvB,OAAOD,OAAO,KAAK,OAAZ,GAAsB,aAAtB,GAAsC,QAA7C;EACD,CAFD,MAEO,IAAIF,YAAY,CAACG,KAAD,CAAhB,EAAyB;IAC9B,OAAO,QAAP;EACD,CAFM,MAEA,IAAIL,aAAa,CAACK,KAAD,CAAjB,EAA0B;IAC/B,OAAOP,MAAM,CAACM,OAAD,CAAN,IAAmBA,OAAO,KAAK,OAA/B,IAA0CA,OAAO,KAAK,QAAtD,GAAiE,aAAjE,GAAiF,QAAxF;EACD;EACD;;;EACA,MAAM,IAAIE,KAAJ,CAAU,gCAAV,CAAN;AACD;AAED,OAAM,SAAUC,iBAAV,CAA4BC,OAA5B,EAA8CJ,OAA9C,EAAmE;EACvE,MAAMK,mBAAmB,GAAGD,OAAO,CAACE,KAAR,CAAcN,OAAd,CAA5B;EACA,MAAMO,KAAK,GAAGb,MAAM,CAACM,OAAD,CAAN,GAAkB,MAAlB,GAA2B,QAAzC;;EAEA,IAAIK,mBAAmB,KAAK,aAA5B,EAA2C;IACzC,IAAID,OAAO,CAACG,KAAD,CAAP,CAAeP,OAAf,MAA4B,QAAhC,EAA0C;MACxCL,GAAG,CAACa,IAAJ,CAASb,GAAG,CAACc,OAAJ,CAAYC,qCAAZ,CAAkDV,OAAlD,CAAT;IACD;;IACD,OAAO,aAAP;EACD;;EAED,OAAOI,OAAO,CAACG,KAAD,CAAP,CAAeP,OAAf,KAA2B,QAAlC;AACD","names":["isXorY","log","isConcatModel","isFacetModel","isLayerModel","defaultScaleResolve","channel","model","Error","parseGuideResolve","resolve","channelScaleResolve","scale","guide","warn","message","independentScaleMeansIndependentGuide"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/resolve.ts"],"sourcesContent":["import {isXorY, ScaleChannel} from '../channel';\nimport * as log from '../log';\nimport {Resolve, ResolveMode} from '../resolve';\nimport {isConcatModel, isFacetModel, isLayerModel, Model} from './model';\n\nexport function defaultScaleResolve(channel: ScaleChannel, model: Model): ResolveMode {\n  if (isFacetModel(model)) {\n    return channel === 'theta' ? 'independent' : 'shared';\n  } else if (isLayerModel(model)) {\n    return 'shared';\n  } else if (isConcatModel(model)) {\n    return isXorY(channel) || channel === 'theta' || channel === 'radius' ? 'independent' : 'shared';\n  }\n  /* istanbul ignore next: should never reach here. */\n  throw new Error('invalid model type for resolve');\n}\n\nexport function parseGuideResolve(resolve: Resolve, channel: ScaleChannel): ResolveMode {\n  const channelScaleResolve = resolve.scale[channel];\n  const guide = isXorY(channel) ? 'axis' : 'legend';\n\n  if (channelScaleResolve === 'independent') {\n    if (resolve[guide][channel] === 'shared') {\n      log.warn(log.message.independentScaleMeansIndependentGuide(channel));\n    }\n    return 'independent';\n  }\n\n  return resolve[guide][channel] || 'shared';\n}\n"]},"metadata":{},"sourceType":"module"}