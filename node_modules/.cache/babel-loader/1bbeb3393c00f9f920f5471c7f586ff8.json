{"ast":null,"code":"import { isArray, isNumber } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../../bin';\nimport { getOffsetChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isPolarPositionChannel, isXorY } from '../../../channel';\nimport { getBandSize, isFieldDef, isFieldOrDatumDef, vgField } from '../../../channeldef';\nimport { getViewConfigDiscreteStep } from '../../../config';\nimport * as log from '../../../log';\nimport { isRelativeBandSize } from '../../../mark';\nimport { hasDiscreteDomain } from '../../../scale';\nimport { isSignalRef, isVgRangeStep } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrStringValue, signalOrValueRef } from '../../common';\nimport { nonPosition } from './nonposition';\nimport { positionOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPositionDefaultRef } from './position-point';\nimport { rangePosition } from './position-range';\nimport * as ref from './valueref';\nexport function rectPosition(model, channel) {\n  var _a, _b;\n\n  const {\n    config,\n    encoding,\n    markDef\n  } = model;\n  const mark = markDef.type;\n  const channel2 = getSecondaryRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n  const channelDef = encoding[channel];\n  const channelDef2 = encoding[channel2];\n  const scale = model.getScaleComponent(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n  const orient = markDef.orient;\n  const hasSizeDef = (_b = (_a = encoding[sizeChannel]) !== null && _a !== void 0 ? _a : encoding.size) !== null && _b !== void 0 ? _b : getMarkPropOrConfig('size', markDef, config, {\n    vgChannel: sizeChannel\n  });\n  const isBarBand = mark === 'bar' && (channel === 'x' ? orient === 'vertical' : orient === 'horizontal'); // x, x2, and width -- we must specify two of these in all conditions\n\n  if (isFieldDef(channelDef) && (isBinning(channelDef.bin) || isBinned(channelDef.bin) || channelDef.timeUnit && !channelDef2) && !(hasSizeDef && !isRelativeBandSize(hasSizeDef)) && !hasDiscreteDomain(scaleType)) {\n    return rectBinPosition({\n      fieldDef: channelDef,\n      fieldDef2: channelDef2,\n      channel,\n      model\n    });\n  } else if ((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType) || isBarBand) && !channelDef2) {\n    return positionAndSize(channelDef, channel, model);\n  } else {\n    return rangePosition(channel, model, {\n      defaultPos: 'zeroOrMax',\n      defaultPos2: 'zeroOrMin'\n    });\n  }\n}\n\nfunction defaultSizeRef(sizeChannel, scaleName, scale, config, bandSize) {\n  if (isRelativeBandSize(bandSize)) {\n    if (scale) {\n      const scaleType = scale.get('type');\n\n      if (scaleType === 'band') {\n        return {\n          scale: scaleName,\n          band: bandSize.band\n        };\n      } else if (bandSize.band !== 1) {\n        log.warn(log.message.cannotUseRelativeBandSizeWithNonBandScale(scaleType));\n        bandSize = undefined;\n      }\n    } else {\n      return {\n        mult: bandSize.band,\n        field: {\n          group: sizeChannel\n        }\n      };\n    }\n  } else if (isSignalRef(bandSize)) {\n    return bandSize;\n  } else if (bandSize) {\n    return {\n      value: bandSize\n    };\n  } // no valid band size\n\n\n  if (scale) {\n    const scaleRange = scale.get('range');\n\n    if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n      return {\n        value: scaleRange.step - 2\n      };\n    }\n  }\n\n  const defaultStep = getViewConfigDiscreteStep(config.view, sizeChannel);\n  return {\n    value: defaultStep - 2\n  };\n}\n/**\n * Output position encoding and its size encoding for continuous, point, and band scales.\n */\n\n\nfunction positionAndSize(fieldDef, channel, model) {\n  const {\n    markDef,\n    encoding,\n    config,\n    stack\n  } = model;\n  const orient = markDef.orient;\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n  const vgSizeChannel = getSizeChannel(channel);\n  const channel2 = getSecondaryRangeChannel(channel);\n  const offsetScaleChannel = getOffsetChannel(channel);\n  const offsetScaleName = model.scaleName(offsetScaleChannel); // use \"size\" channel for bars, if there is orient and the channel matches the right orientation\n\n  const useVlSizeChannel = orient === 'horizontal' && channel === 'y' || orient === 'vertical' && channel === 'x'; // Use size encoding / mark property / config if it exists\n\n  let sizeMixins;\n\n  if (encoding.size || markDef.size) {\n    if (useVlSizeChannel) {\n      sizeMixins = nonPosition('size', model, {\n        vgChannel: vgSizeChannel,\n        defaultRef: signalOrValueRef(markDef.size)\n      });\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(markDef.type));\n    }\n  } // Otherwise, apply default value\n\n\n  const bandSize = getBandSize({\n    channel,\n    fieldDef,\n    markDef,\n    config,\n    scaleType: scale === null || scale === void 0 ? void 0 : scale.get('type'),\n    useVlSizeChannel\n  });\n  sizeMixins = sizeMixins || {\n    [vgSizeChannel]: defaultSizeRef(vgSizeChannel, offsetScaleName || scaleName, scale, config, bandSize)\n  };\n  /*\n    Band scales with size value and all point scales, use xc/yc + band=0.5\n       Otherwise (band scales that has size based on a band ref), use x/y with position band = (1 - size_band) / 2.\n    In this case, size_band is the band specified in the x/y-encoding.\n    By default band is 1, so `(1 - band) / 2` = 0.\n    If band is 0.6, the the x/y position in such case should be `(1 - band) / 2` = 0.2\n   */\n\n  const defaultBandAlign = (scale === null || scale === void 0 ? void 0 : scale.get('type')) !== 'band' || !('band' in sizeMixins[vgSizeChannel]) ? 'middle' : 'top';\n  const vgChannel = vgAlignedPositionChannel(channel, markDef, config, defaultBandAlign);\n  const center = vgChannel === 'xc' || vgChannel === 'yc';\n  const {\n    offset,\n    offsetType\n  } = positionOffset({\n    channel,\n    markDef,\n    encoding,\n    model,\n    bandPosition: center ? 0.5 : 0\n  });\n  const posRef = ref.midPointRefWithPositionInvalidTest({\n    channel,\n    channelDef: fieldDef,\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: pointPositionDefaultRef({\n      model,\n      defaultPos: 'mid',\n      channel,\n      scaleName,\n      scale\n    }),\n    bandPosition: center ? offsetType === 'encoding' ? 0 : 0.5 : isSignalRef(bandSize) ? {\n      signal: `(1-${bandSize})/2`\n    } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0\n  });\n\n  if (vgSizeChannel) {\n    return Object.assign({\n      [vgChannel]: posRef\n    }, sizeMixins);\n  } else {\n    // otherwise, we must simulate size by setting position2 = position + size\n    // (for theta/radius since Vega doesn't have thetaWidth/radiusWidth)\n    const vgChannel2 = getVgPositionChannel(channel2);\n    const sizeRef = sizeMixins[vgSizeChannel];\n    const sizeOffset = offset ? Object.assign(Object.assign({}, sizeRef), {\n      offset\n    }) : sizeRef;\n    return {\n      [vgChannel]: posRef,\n      // posRef might be an array that wraps position invalid test\n      [vgChannel2]: isArray(posRef) ? [posRef[0], Object.assign(Object.assign({}, posRef[1]), {\n        offset: sizeOffset\n      })] : Object.assign(Object.assign({}, posRef), {\n        offset: sizeOffset\n      })\n    };\n  }\n}\n\nfunction getBinSpacing(channel, spacing, reverse, translate, offset) {\n  if (isPolarPositionChannel(channel)) {\n    return 0;\n  }\n\n  const spacingOffset = channel === 'x' || channel === 'y2' ? -spacing / 2 : spacing / 2;\n\n  if (isSignalRef(reverse) || isSignalRef(offset) || isSignalRef(translate)) {\n    const reverseExpr = signalOrStringValue(reverse);\n    const offsetExpr = signalOrStringValue(offset);\n    const translateExpr = signalOrStringValue(translate);\n    const t = translateExpr ? `${translateExpr} + ` : '';\n    const r = reverseExpr ? `(${reverseExpr} ? -1 : 1) * ` : '';\n    const o = offsetExpr ? `(${offsetExpr} + ${spacingOffset})` : spacingOffset;\n    return {\n      signal: t + r + o\n    };\n  } else {\n    offset = offset || 0;\n    return translate + (reverse ? -offset - spacingOffset : +offset + spacingOffset);\n  }\n}\n\nfunction rectBinPosition(_ref) {\n  let {\n    fieldDef,\n    fieldDef2,\n    channel,\n    model\n  } = _ref;\n\n  var _a, _b, _c;\n\n  const {\n    config,\n    markDef,\n    encoding\n  } = model;\n  const scale = model.getScaleComponent(channel);\n  const scaleName = model.scaleName(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n  const reverse = scale.get('reverse');\n  const bandSize = getBandSize({\n    channel,\n    fieldDef,\n    markDef,\n    config,\n    scaleType\n  });\n  const axis = (_a = model.component.axes[channel]) === null || _a === void 0 ? void 0 : _a[0];\n  const axisTranslate = (_b = axis === null || axis === void 0 ? void 0 : axis.get('translate')) !== null && _b !== void 0 ? _b : 0.5; // vega default is 0.5\n\n  const spacing = isXorY(channel) ? (_c = getMarkPropOrConfig('binSpacing', markDef, config)) !== null && _c !== void 0 ? _c : 0 : 0;\n  const channel2 = getSecondaryRangeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n  const vgChannel2 = getVgPositionChannel(channel2);\n  const {\n    offset\n  } = positionOffset({\n    channel,\n    markDef,\n    encoding,\n    model,\n    bandPosition: 0\n  });\n  const bandPosition = isSignalRef(bandSize) ? {\n    signal: `(1-${bandSize.signal})/2`\n  } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0.5;\n\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n    return {\n      [vgChannel2]: rectBinRef({\n        fieldDef,\n        scaleName,\n        bandPosition,\n        offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset)\n      }),\n      [vgChannel]: rectBinRef({\n        fieldDef,\n        scaleName,\n        bandPosition: isSignalRef(bandPosition) ? {\n          signal: `1-${bandPosition.signal}`\n        } : 1 - bandPosition,\n        offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n      })\n    };\n  } else if (isBinned(fieldDef.bin)) {\n    const startRef = ref.valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, {\n      offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset)\n    });\n\n    if (isFieldDef(fieldDef2)) {\n      return {\n        [vgChannel2]: startRef,\n        [vgChannel]: ref.valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, {\n          offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n        })\n      };\n    } else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {\n      return {\n        [vgChannel2]: startRef,\n        [vgChannel]: {\n          signal: `scale(\"${scaleName}\", ${vgField(fieldDef, {\n            expr: 'datum'\n          })} + ${fieldDef.bin.step})`,\n          offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n        }\n      };\n    }\n  }\n\n  log.warn(log.message.channelRequiredForBinned(channel2));\n  return undefined;\n}\n/**\n * Value Ref for binned fields\n */\n\n\nexport function rectBinRef(_ref2) {\n  let {\n    fieldDef,\n    scaleName,\n    bandPosition,\n    offset\n  } = _ref2;\n  return ref.interpolatedSignalRef({\n    scaleName,\n    fieldOrDatumDef: fieldDef,\n    bandPosition,\n    offset\n  });\n}","map":{"version":3,"mappings":"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","names":["isArray","isNumber","isBinned","isBinning","isBinParams","getOffsetChannel","getSecondaryRangeChannel","getSizeChannel","getVgPositionChannel","isPolarPositionChannel","isXorY","getBandSize","isFieldDef","isFieldOrDatumDef","vgField","getViewConfigDiscreteStep","log","isRelativeBandSize","hasDiscreteDomain","isSignalRef","isVgRangeStep","getMarkPropOrConfig","signalOrStringValue","signalOrValueRef","nonPosition","positionOffset","vgAlignedPositionChannel","pointPositionDefaultRef","rangePosition","ref","rectPosition","model","channel","config","encoding","markDef","mark","type","channel2","sizeChannel","channelDef","channelDef2","scale","getScaleComponent","scaleType","get","undefined","orient","hasSizeDef","_a","size","_b","vgChannel","isBarBand","bin","timeUnit","rectBinPosition","fieldDef","fieldDef2","positionAndSize","defaultPos","defaultPos2","defaultSizeRef","scaleName","bandSize","band","warn","message","cannotUseRelativeBandSizeWithNonBandScale","mult","field","group","value","scaleRange","step","defaultStep","view","stack","vgSizeChannel","offsetScaleChannel","offsetScaleName","useVlSizeChannel","sizeMixins","defaultRef","cannotApplySizeToNonOrientedMark","defaultBandAlign","center","offset","offsetType","bandPosition","posRef","midPointRefWithPositionInvalidTest","signal","vgChannel2","sizeRef","sizeOffset","Object","getBinSpacing","spacing","reverse","translate","spacingOffset","reverseExpr","offsetExpr","translateExpr","t","r","o","axis","component","axes","axisTranslate","_c","rectBinRef","startRef","valueRefForFieldOrDatumDef","expr","channelRequiredForBinned","interpolatedSignalRef","fieldOrDatumDef"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/mark/encode/position-rect.ts"],"sourcesContent":["import {SignalRef} from 'vega';\nimport {isArray, isNumber} from 'vega-util';\nimport {isBinned, isBinning, isBinParams} from '../../../bin';\nimport {\n  getOffsetChannel,\n  getSecondaryRangeChannel,\n  getSizeChannel,\n  getVgPositionChannel,\n  isPolarPositionChannel,\n  isXorY,\n  PolarPositionChannel,\n  PositionChannel\n} from '../../../channel';\nimport {getBandSize, isFieldDef, isFieldOrDatumDef, TypedFieldDef, vgField} from '../../../channeldef';\nimport {Config, getViewConfigDiscreteStep} from '../../../config';\nimport {Encoding} from '../../../encoding';\nimport * as log from '../../../log';\nimport {BandSize, isRelativeBandSize} from '../../../mark';\nimport {hasDiscreteDomain} from '../../../scale';\nimport {isSignalRef, isVgRangeStep, VgEncodeEntry, VgValueRef} from '../../../vega.schema';\nimport {getMarkPropOrConfig, signalOrStringValue, signalOrValueRef} from '../../common';\nimport {ScaleComponent} from '../../scale/component';\nimport {UnitModel} from '../../unit';\nimport {nonPosition} from './nonposition';\nimport {positionOffset} from './offset';\nimport {vgAlignedPositionChannel} from './position-align';\nimport {pointPositionDefaultRef} from './position-point';\nimport {rangePosition} from './position-range';\nimport * as ref from './valueref';\n\nexport function rectPosition(model: UnitModel, channel: 'x' | 'y' | 'theta' | 'radius'): VgEncodeEntry {\n  const {config, encoding, markDef} = model;\n  const mark = markDef.type;\n\n  const channel2 = getSecondaryRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n  const channelDef = encoding[channel];\n  const channelDef2 = encoding[channel2];\n\n  const scale = model.getScaleComponent(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n\n  const orient = markDef.orient;\n  const hasSizeDef =\n    encoding[sizeChannel] ?? encoding.size ?? getMarkPropOrConfig('size', markDef, config, {vgChannel: sizeChannel});\n\n  const isBarBand = mark === 'bar' && (channel === 'x' ? orient === 'vertical' : orient === 'horizontal');\n\n  // x, x2, and width -- we must specify two of these in all conditions\n  if (\n    isFieldDef(channelDef) &&\n    (isBinning(channelDef.bin) || isBinned(channelDef.bin) || (channelDef.timeUnit && !channelDef2)) &&\n    !(hasSizeDef && !isRelativeBandSize(hasSizeDef)) &&\n    !hasDiscreteDomain(scaleType)\n  ) {\n    return rectBinPosition({\n      fieldDef: channelDef,\n      fieldDef2: channelDef2,\n      channel,\n      model\n    });\n  } else if (((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType)) || isBarBand) && !channelDef2) {\n    return positionAndSize(channelDef, channel, model);\n  } else {\n    return rangePosition(channel, model, {defaultPos: 'zeroOrMax', defaultPos2: 'zeroOrMin'});\n  }\n}\n\nfunction defaultSizeRef(\n  sizeChannel: 'width' | 'height',\n  scaleName: string,\n  scale: ScaleComponent,\n  config: Config,\n  bandSize: BandSize\n): VgValueRef {\n  if (isRelativeBandSize(bandSize)) {\n    if (scale) {\n      const scaleType = scale.get('type');\n      if (scaleType === 'band') {\n        return {scale: scaleName, band: bandSize.band};\n      } else if (bandSize.band !== 1) {\n        log.warn(log.message.cannotUseRelativeBandSizeWithNonBandScale(scaleType));\n        bandSize = undefined;\n      }\n    } else {\n      return {\n        mult: bandSize.band,\n        field: {group: sizeChannel}\n      };\n    }\n  } else if (isSignalRef(bandSize)) {\n    return bandSize;\n  } else if (bandSize) {\n    return {value: bandSize};\n  }\n\n  // no valid band size\n  if (scale) {\n    const scaleRange = scale.get('range');\n    if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n      return {value: scaleRange.step - 2};\n    }\n  }\n  const defaultStep = getViewConfigDiscreteStep(config.view, sizeChannel);\n  return {value: defaultStep - 2};\n}\n\n/**\n * Output position encoding and its size encoding for continuous, point, and band scales.\n */\nfunction positionAndSize(\n  fieldDef: Encoding<string>['x' | 'y' | 'theta' | 'radius'],\n  channel: 'x' | 'y' | 'theta' | 'radius',\n  model: UnitModel\n) {\n  const {markDef, encoding, config, stack} = model;\n  const orient = markDef.orient;\n\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n  const vgSizeChannel = getSizeChannel(channel);\n  const channel2 = getSecondaryRangeChannel(channel);\n\n  const offsetScaleChannel = getOffsetChannel(channel);\n  const offsetScaleName = model.scaleName(offsetScaleChannel);\n\n  // use \"size\" channel for bars, if there is orient and the channel matches the right orientation\n  const useVlSizeChannel = (orient === 'horizontal' && channel === 'y') || (orient === 'vertical' && channel === 'x');\n\n  // Use size encoding / mark property / config if it exists\n  let sizeMixins;\n  if (encoding.size || markDef.size) {\n    if (useVlSizeChannel) {\n      sizeMixins = nonPosition('size', model, {\n        vgChannel: vgSizeChannel,\n        defaultRef: signalOrValueRef(markDef.size)\n      });\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(markDef.type));\n    }\n  }\n\n  // Otherwise, apply default value\n  const bandSize = getBandSize({channel, fieldDef, markDef, config, scaleType: scale?.get('type'), useVlSizeChannel});\n\n  sizeMixins = sizeMixins || {\n    [vgSizeChannel]: defaultSizeRef(vgSizeChannel, offsetScaleName || scaleName, scale, config, bandSize)\n  };\n\n  /*\n    Band scales with size value and all point scales, use xc/yc + band=0.5\n\n    Otherwise (band scales that has size based on a band ref), use x/y with position band = (1 - size_band) / 2.\n    In this case, size_band is the band specified in the x/y-encoding.\n    By default band is 1, so `(1 - band) / 2` = 0.\n    If band is 0.6, the the x/y position in such case should be `(1 - band) / 2` = 0.2\n   */\n\n  const defaultBandAlign = scale?.get('type') !== 'band' || !('band' in sizeMixins[vgSizeChannel]) ? 'middle' : 'top';\n\n  const vgChannel = vgAlignedPositionChannel(channel, markDef, config, defaultBandAlign);\n  const center = vgChannel === 'xc' || vgChannel === 'yc';\n  const {offset, offsetType} = positionOffset({channel, markDef, encoding, model, bandPosition: center ? 0.5 : 0});\n\n  const posRef = ref.midPointRefWithPositionInvalidTest({\n    channel,\n    channelDef: fieldDef,\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: pointPositionDefaultRef({model, defaultPos: 'mid', channel, scaleName, scale}),\n    bandPosition: center\n      ? offsetType === 'encoding'\n        ? 0\n        : 0.5\n      : isSignalRef(bandSize)\n      ? {signal: `(1-${bandSize})/2`}\n      : isRelativeBandSize(bandSize)\n      ? (1 - bandSize.band) / 2\n      : 0\n  });\n\n  if (vgSizeChannel) {\n    return {[vgChannel]: posRef, ...sizeMixins};\n  } else {\n    // otherwise, we must simulate size by setting position2 = position + size\n    // (for theta/radius since Vega doesn't have thetaWidth/radiusWidth)\n    const vgChannel2 = getVgPositionChannel(channel2);\n    const sizeRef = sizeMixins[vgSizeChannel];\n    const sizeOffset = offset ? {...sizeRef, offset} : sizeRef;\n    return {\n      [vgChannel]: posRef,\n\n      // posRef might be an array that wraps position invalid test\n      [vgChannel2]: isArray(posRef)\n        ? [posRef[0], {...posRef[1], offset: sizeOffset}]\n        : {\n            ...posRef,\n            offset: sizeOffset\n          }\n    };\n  }\n}\n\nfunction getBinSpacing(\n  channel: PositionChannel | PolarPositionChannel,\n  spacing: number,\n  reverse: boolean | SignalRef,\n  translate: number | SignalRef,\n  offset: number | VgValueRef\n) {\n  if (isPolarPositionChannel(channel)) {\n    return 0;\n  }\n\n  const spacingOffset = channel === 'x' || channel === 'y2' ? -spacing / 2 : spacing / 2;\n\n  if (isSignalRef(reverse) || isSignalRef(offset) || isSignalRef(translate)) {\n    const reverseExpr = signalOrStringValue(reverse);\n    const offsetExpr = signalOrStringValue(offset);\n    const translateExpr = signalOrStringValue(translate);\n\n    const t = translateExpr ? `${translateExpr} + ` : '';\n    const r = reverseExpr ? `(${reverseExpr} ? -1 : 1) * ` : '';\n    const o = offsetExpr ? `(${offsetExpr} + ${spacingOffset})` : spacingOffset;\n\n    return {\n      signal: t + r + o\n    };\n  } else {\n    offset = offset || 0;\n    return translate + (reverse ? -offset - spacingOffset : +offset + spacingOffset);\n  }\n}\n\nfunction rectBinPosition({\n  fieldDef,\n  fieldDef2,\n  channel,\n  model\n}: {\n  fieldDef: TypedFieldDef<string>;\n  fieldDef2?: Encoding<string>['x2' | 'y2'];\n  channel: 'x' | 'y' | 'theta' | 'radius';\n  model: UnitModel;\n}) {\n  const {config, markDef, encoding} = model;\n\n  const scale = model.getScaleComponent(channel);\n  const scaleName = model.scaleName(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n  const reverse = scale.get('reverse');\n\n  const bandSize = getBandSize({channel, fieldDef, markDef, config, scaleType});\n\n  const axis = model.component.axes[channel]?.[0];\n  const axisTranslate = axis?.get('translate') ?? 0.5; // vega default is 0.5\n\n  const spacing = isXorY(channel) ? getMarkPropOrConfig('binSpacing', markDef, config) ?? 0 : 0;\n\n  const channel2 = getSecondaryRangeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n  const vgChannel2 = getVgPositionChannel(channel2);\n\n  const {offset} = positionOffset({channel, markDef, encoding, model, bandPosition: 0});\n\n  const bandPosition = isSignalRef(bandSize)\n    ? {signal: `(1-${bandSize.signal})/2`}\n    : isRelativeBandSize(bandSize)\n    ? (1 - bandSize.band) / 2\n    : 0.5;\n\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n    return {\n      [vgChannel2]: rectBinRef({\n        fieldDef,\n        scaleName,\n        bandPosition,\n        offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset)\n      }),\n      [vgChannel]: rectBinRef({\n        fieldDef,\n        scaleName,\n        bandPosition: isSignalRef(bandPosition) ? {signal: `1-${bandPosition.signal}`} : 1 - bandPosition,\n        offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n      })\n    };\n  } else if (isBinned(fieldDef.bin)) {\n    const startRef = ref.valueRefForFieldOrDatumDef(\n      fieldDef,\n      scaleName,\n      {},\n      {offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset)}\n    );\n\n    if (isFieldDef(fieldDef2)) {\n      return {\n        [vgChannel2]: startRef,\n        [vgChannel]: ref.valueRefForFieldOrDatumDef(\n          fieldDef2,\n          scaleName,\n          {},\n          {offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)}\n        )\n      };\n    } else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {\n      return {\n        [vgChannel2]: startRef,\n        [vgChannel]: {\n          signal: `scale(\"${scaleName}\", ${vgField(fieldDef, {expr: 'datum'})} + ${fieldDef.bin.step})`,\n          offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n        }\n      };\n    }\n  }\n  log.warn(log.message.channelRequiredForBinned(channel2));\n  return undefined;\n}\n\n/**\n * Value Ref for binned fields\n */\nexport function rectBinRef({\n  fieldDef,\n  scaleName,\n  bandPosition,\n  offset\n}: {\n  fieldDef: TypedFieldDef<string>;\n  scaleName: string;\n  bandPosition: number | SignalRef;\n  offset?: number | SignalRef;\n}) {\n  return ref.interpolatedSignalRef({\n    scaleName,\n    fieldOrDatumDef: fieldDef,\n    bandPosition,\n    offset\n  });\n}\n"]},"metadata":{},"sourceType":"module"}