{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { array, isObject } from 'vega-util';\nimport { isSingleDefUnitChannel } from '../../channel';\nimport * as log from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { hash, keys, replacePathInField, varName, isEmpty } from '../../util';\nimport { TimeUnitNode } from '../data/timeunit';\nexport const TUPLE_FIELDS = '_tuple_fields';\nexport class SelectionProjectionComponent {\n  constructor() {\n    for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n      items[_key] = arguments[_key];\n    }\n\n    this.items = items;\n    this.hasChannel = {};\n    this.hasField = {};\n  }\n\n}\nconst project = {\n  defined: () => {\n    return true; // This transform handles its own defaults, so always run parse.\n  },\n  parse: (model, selCmpt, selDef) => {\n    var _a;\n\n    const name = selCmpt.name;\n    const proj = (_a = selCmpt.project) !== null && _a !== void 0 ? _a : selCmpt.project = new SelectionProjectionComponent();\n    const parsed = {};\n    const timeUnits = {};\n    const signals = new Set();\n\n    const signalName = (p, range) => {\n      const suffix = range === 'visual' ? p.channel : p.field;\n      let sg = varName(`${name}_${suffix}`);\n\n      for (let counter = 1; signals.has(sg); counter++) {\n        sg = varName(`${name}_${suffix}_${counter}`);\n      }\n\n      signals.add(sg);\n      return {\n        [range]: sg\n      };\n    };\n\n    const type = selCmpt.type;\n    const cfg = model.config.selection[type];\n    const init = selDef.value !== undefined ? array(selDef.value) : null; // If no explicit projection (either fields or encodings) is specified, set some defaults.\n    // If an initial value is set, try to infer projections.\n\n    let {\n      fields,\n      encodings\n    } = isObject(selDef.select) ? selDef.select : {};\n\n    if (!fields && !encodings && init) {\n      for (const initVal of init) {\n        // initVal may be a scalar value to smoothen varParam -> pointSelection gradient.\n        if (!isObject(initVal)) {\n          continue;\n        }\n\n        for (const key of keys(initVal)) {\n          if (isSingleDefUnitChannel(key)) {\n            (encodings || (encodings = [])).push(key);\n          } else {\n            if (type === 'interval') {\n              log.warn(log.message.INTERVAL_INITIALIZED_WITH_X_Y);\n              encodings = cfg.encodings;\n            } else {\n              (fields || (fields = [])).push(key);\n            }\n          }\n        }\n      }\n    } // If no initial value is specified, use the default configuration.\n    // We break this out as a separate if block (instead of an else condition)\n    // to account for unprojected point selections that have scalar initial values\n\n\n    if (!fields && !encodings) {\n      encodings = cfg.encodings;\n\n      if ('fields' in cfg) {\n        fields = cfg.fields;\n      }\n    }\n\n    for (const channel of encodings !== null && encodings !== void 0 ? encodings : []) {\n      const fieldDef = model.fieldDef(channel);\n\n      if (fieldDef) {\n        let field = fieldDef.field;\n\n        if (fieldDef.aggregate) {\n          log.warn(log.message.cannotProjectAggregate(channel, fieldDef.aggregate));\n          continue;\n        } else if (!field) {\n          log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n          continue;\n        }\n\n        if (fieldDef.timeUnit) {\n          field = model.vgField(channel); // Construct TimeUnitComponents which will be combined into a\n          // TimeUnitNode. This node may need to be inserted into the\n          // dataflow if the selection is used across views that do not\n          // have these time units defined.\n\n          const component = {\n            timeUnit: fieldDef.timeUnit,\n            as: field,\n            field: fieldDef.field\n          };\n          timeUnits[hash(component)] = component;\n        } // Prevent duplicate projections on the same field.\n        // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n\n\n        if (!parsed[field]) {\n          // Determine whether the tuple will store enumerated or ranged values.\n          // Interval selections store ranges for continuous scales, and enumerations otherwise.\n          // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n          let tplType = 'E';\n\n          if (type === 'interval') {\n            const scaleType = model.getScaleComponent(channel).get('type');\n\n            if (hasContinuousDomain(scaleType)) {\n              tplType = 'R';\n            }\n          } else if (fieldDef.bin) {\n            tplType = 'R-RE';\n          }\n\n          const p = {\n            field,\n            channel,\n            type: tplType\n          };\n          p.signals = Object.assign(Object.assign({}, signalName(p, 'data')), signalName(p, 'visual'));\n          proj.items.push(parsed[field] = p);\n          proj.hasField[field] = proj.hasChannel[channel] = parsed[field];\n        }\n      } else {\n        log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n      }\n    }\n\n    for (const field of fields !== null && fields !== void 0 ? fields : []) {\n      if (proj.hasField[field]) continue;\n      const p = {\n        type: 'E',\n        field\n      };\n      p.signals = Object.assign({}, signalName(p, 'data'));\n      proj.items.push(p);\n      proj.hasField[field] = p;\n    }\n\n    if (init) {\n      selCmpt.init = init.map(v => {\n        // Selections can be initialized either with a full object that maps projections to values\n        // or scalar values to smoothen the abstraction gradient from variable params to point selections.\n        return proj.items.map(p => isObject(v) ? v[p.channel] !== undefined ? v[p.channel] : v[p.field] : v);\n      });\n    }\n\n    if (!isEmpty(timeUnits)) {\n      proj.timeUnit = new TimeUnitNode(null, timeUnits);\n    }\n  },\n  signals: (model, selCmpt, allSignals) => {\n    const name = selCmpt.name + TUPLE_FIELDS;\n    const hasSignal = allSignals.filter(s => s.name === name);\n    return hasSignal.length > 0 ? allSignals : allSignals.concat({\n      name,\n      value: selCmpt.project.items.map(proj => {\n        const {\n          signals,\n          hasLegend\n        } = proj,\n              rest = __rest(proj, [\"signals\", \"hasLegend\"]);\n\n        rest.field = replacePathInField(rest.field);\n        return rest;\n      })\n    });\n  }\n};\nexport default project;","map":{"version":3,"mappings":";;;;;;;;;;;AAAA,SAAQA,KAAR,EAAeC,QAAf,QAA8B,WAA9B;AACA,SAAQC,sBAAR,QAAyE,eAAzE;AACA,OAAO,KAAKC,GAAZ,MAAqB,WAArB;AACA,SAAQC,mBAAR,QAAkC,aAAlC;AAEA,SAAcC,IAAd,EAAoBC,IAApB,EAA0BC,kBAA1B,EAA8CC,OAA9C,EAAuDC,OAAvD,QAAqE,YAArE;AACA,SAA2BC,YAA3B,QAA8C,kBAA9C;AAEA,OAAO,MAAMC,YAAY,GAAG,eAArB;AAqBP,OAAM,MAAOC,4BAAP,CAAmC;EAMvCC,cAA2C;IAAA,kCAA5BC,KAA4B;MAA5BA,KAA4B;IAAA;;IACzC,KAAKA,KAAL,GAAaA,KAAb;IACA,KAAKC,UAAL,GAAkB,EAAlB;IACA,KAAKC,QAAL,GAAgB,EAAhB;EACD;;AAVsC;AAazC,MAAMC,OAAO,GAAsB;EACjCC,OAAO,EAAE,MAAK;IACZ,OAAO,IAAP,CADY,CACC;EACd,CAHgC;EAKjCC,KAAK,EAAE,CAACC,KAAD,EAAQC,OAAR,EAAiBC,MAAjB,KAA2B;;;IAChC,MAAMC,IAAI,GAAGF,OAAO,CAACE,IAArB;IACA,MAAMC,IAAI,GAAG,MAACH,OAAO,CAACJ,OAAT,MAAgB,IAAhB,IAAgBQ,aAAhB,GAAgBA,EAAhB,GAACJ,OAAO,CAACJ,OAAR,GAAoB,IAAIL,4BAAJ,EAAlC;IACA,MAAMc,MAAM,GAA8B,EAA1C;IACA,MAAMC,SAAS,GAA4B,EAA3C;IAEA,MAAMC,OAAO,GAAG,IAAIC,GAAJ,EAAhB;;IACA,MAAMC,UAAU,GAAG,CAACC,CAAD,EAAyBC,KAAzB,KAAqD;MACtE,MAAMC,MAAM,GAAGD,KAAK,KAAK,QAAV,GAAqBD,CAAC,CAACG,OAAvB,GAAiCH,CAAC,CAACI,KAAlD;MACA,IAAIC,EAAE,GAAG5B,OAAO,CAAC,GAAGe,IAAI,IAAIU,MAAM,EAAlB,CAAhB;;MACA,KAAK,IAAII,OAAO,GAAG,CAAnB,EAAsBT,OAAO,CAACU,GAAR,CAAYF,EAAZ,CAAtB,EAAuCC,OAAO,EAA9C,EAAkD;QAChDD,EAAE,GAAG5B,OAAO,CAAC,GAAGe,IAAI,IAAIU,MAAM,IAAII,OAAO,EAA7B,CAAZ;MACD;;MACDT,OAAO,CAACW,GAAR,CAAYH,EAAZ;MACA,OAAO;QAAC,CAACJ,KAAD,GAASI;MAAV,CAAP;IACD,CARD;;IAUA,MAAMI,IAAI,GAAGnB,OAAO,CAACmB,IAArB;IACA,MAAMC,GAAG,GAAGrB,KAAK,CAACsB,MAAN,CAAaC,SAAb,CAAuBH,IAAvB,CAAZ;IACA,MAAMI,IAAI,GACRtB,MAAM,CAACuB,KAAP,KAAiBC,SAAjB,GACK9C,KAAK,CAACsB,MAAM,CAACuB,KAAR,CADV,GAEI,IAHN,CAnBgC,CAwBhC;IACA;;IACA,IAAI;MAACE,MAAD;MAASC;IAAT,IAAuB/C,QAAQ,CAACqB,MAAM,CAAC2B,MAAR,CAAR,GAA0B3B,MAAM,CAAC2B,MAAjC,GAA0C,EAArE;;IACA,IAAI,CAACF,MAAD,IAAW,CAACC,SAAZ,IAAyBJ,IAA7B,EAAmC;MACjC,KAAK,MAAMM,OAAX,IAAsBN,IAAtB,EAA4B;QAC1B;QACA,IAAI,CAAC3C,QAAQ,CAACiD,OAAD,CAAb,EAAwB;UACtB;QACD;;QAED,KAAK,MAAMC,GAAX,IAAkB7C,IAAI,CAAC4C,OAAD,CAAtB,EAAiC;UAC/B,IAAIhD,sBAAsB,CAACiD,GAAD,CAA1B,EAAiC;YAC/B,CAACH,SAAS,KAAKA,SAAS,GAAG,EAAjB,CAAV,EAAgCI,IAAhC,CAAqCD,GAArC;UACD,CAFD,MAEO;YACL,IAAIX,IAAI,KAAK,UAAb,EAAyB;cACvBrC,GAAG,CAACkD,IAAJ,CAASlD,GAAG,CAACmD,OAAJ,CAAYC,6BAArB;cACAP,SAAS,GAAGP,GAAG,CAACO,SAAhB;YACD,CAHD,MAGO;cACL,CAACD,MAAM,KAAKA,MAAM,GAAG,EAAd,CAAP,EAA0BK,IAA1B,CAA+BD,GAA/B;YACD;UACF;QACF;MACF;IACF,CA/C+B,CAiDhC;IACA;IACA;;;IACA,IAAI,CAACJ,MAAD,IAAW,CAACC,SAAhB,EAA2B;MACzBA,SAAS,GAAGP,GAAG,CAACO,SAAhB;;MACA,IAAI,YAAYP,GAAhB,EAAqB;QACnBM,MAAM,GAAGN,GAAG,CAACM,MAAb;MACD;IACF;;IAED,KAAK,MAAMb,OAAX,IAAsBc,SAAS,SAAT,aAAS,WAAT,eAAa,EAAnC,EAAuC;MACrC,MAAMQ,QAAQ,GAAGpC,KAAK,CAACoC,QAAN,CAAetB,OAAf,CAAjB;;MACA,IAAIsB,QAAJ,EAAc;QACZ,IAAIrB,KAAK,GAAGqB,QAAQ,CAACrB,KAArB;;QAEA,IAAIqB,QAAQ,CAACC,SAAb,EAAwB;UACtBtD,GAAG,CAACkD,IAAJ,CAASlD,GAAG,CAACmD,OAAJ,CAAYI,sBAAZ,CAAmCxB,OAAnC,EAA4CsB,QAAQ,CAACC,SAArD,CAAT;UACA;QACD,CAHD,MAGO,IAAI,CAACtB,KAAL,EAAY;UACjBhC,GAAG,CAACkD,IAAJ,CAASlD,GAAG,CAACmD,OAAJ,CAAYK,kCAAZ,CAA+CzB,OAA/C,CAAT;UACA;QACD;;QAED,IAAIsB,QAAQ,CAACI,QAAb,EAAuB;UACrBzB,KAAK,GAAGf,KAAK,CAACyC,OAAN,CAAc3B,OAAd,CAAR,CADqB,CAErB;UACA;UACA;UACA;;UACA,MAAM4B,SAAS,GAAG;YAChBF,QAAQ,EAAEJ,QAAQ,CAACI,QADH;YAEhBG,EAAE,EAAE5B,KAFY;YAGhBA,KAAK,EAAEqB,QAAQ,CAACrB;UAHA,CAAlB;UAMAR,SAAS,CAACtB,IAAI,CAACyD,SAAD,CAAL,CAAT,GAA6BA,SAA7B;QACD,CAxBW,CA0BZ;QACA;;;QACA,IAAI,CAACpC,MAAM,CAACS,KAAD,CAAX,EAAoB;UAClB;UACA;UACA;UACA,IAAI6B,OAAO,GAAmB,GAA9B;;UACA,IAAIxB,IAAI,KAAK,UAAb,EAAyB;YACvB,MAAMyB,SAAS,GAAG7C,KAAK,CAAC8C,iBAAN,CAAwBhC,OAAxB,EAAiDiC,GAAjD,CAAqD,MAArD,CAAlB;;YACA,IAAI/D,mBAAmB,CAAC6D,SAAD,CAAvB,EAAoC;cAClCD,OAAO,GAAG,GAAV;YACD;UACF,CALD,MAKO,IAAIR,QAAQ,CAACY,GAAb,EAAkB;YACvBJ,OAAO,GAAG,MAAV;UACD;;UAED,MAAMjC,CAAC,GAAwB;YAACI,KAAD;YAAQD,OAAR;YAAiBM,IAAI,EAAEwB;UAAvB,CAA/B;UACAjC,CAAC,CAACH,OAAF,GAASyC,gCAAOvC,UAAU,CAACC,CAAD,EAAI,MAAJ,CAAjB,GAAiCD,UAAU,CAACC,CAAD,EAAI,QAAJ,CAA3C,CAAT;UACAP,IAAI,CAACV,KAAL,CAAWsC,IAAX,CAAiB1B,MAAM,CAACS,KAAD,CAAN,GAAgBJ,CAAjC;UACAP,IAAI,CAACR,QAAL,CAAcmB,KAAd,IAAuBX,IAAI,CAACT,UAAL,CAAgBmB,OAAhB,IAA2BR,MAAM,CAACS,KAAD,CAAxD;QACD;MACF,CA/CD,MA+CO;QACLhC,GAAG,CAACkD,IAAJ,CAASlD,GAAG,CAACmD,OAAJ,CAAYK,kCAAZ,CAA+CzB,OAA/C,CAAT;MACD;IACF;;IAED,KAAK,MAAMC,KAAX,IAAoBY,MAAM,SAAN,UAAM,WAAN,YAAU,EAA9B,EAAkC;MAChC,IAAIvB,IAAI,CAACR,QAAL,CAAcmB,KAAd,CAAJ,EAA0B;MAC1B,MAAMJ,CAAC,GAAwB;QAACS,IAAI,EAAE,GAAP;QAAYL;MAAZ,CAA/B;MACAJ,CAAC,CAACH,OAAF,GAASyC,kBAAOvC,UAAU,CAACC,CAAD,EAAI,MAAJ,CAAjB,CAAT;MACAP,IAAI,CAACV,KAAL,CAAWsC,IAAX,CAAgBrB,CAAhB;MACAP,IAAI,CAACR,QAAL,CAAcmB,KAAd,IAAuBJ,CAAvB;IACD;;IAED,IAAIa,IAAJ,EAAU;MACRvB,OAAO,CAACuB,IAAR,GAAgBA,IAAY,CAAC0B,GAAb,CAAkBC,CAAD,IAA2D;QAC1F;QACA;QACA,OAAO/C,IAAI,CAACV,KAAL,CAAWwD,GAAX,CAAevC,CAAC,IAAK9B,QAAQ,CAACsE,CAAD,CAAR,GAAeA,CAAC,CAACxC,CAAC,CAACG,OAAH,CAAD,KAAiBY,SAAjB,GAA6ByB,CAAC,CAACxC,CAAC,CAACG,OAAH,CAA9B,GAA4CqC,CAAC,CAACxC,CAAC,CAACI,KAAH,CAA5D,GAAyEoC,CAA9F,CAAP;MACD,CAJe,CAAhB;IAKD;;IAED,IAAI,CAAC9D,OAAO,CAACkB,SAAD,CAAZ,EAAyB;MACvBH,IAAI,CAACoC,QAAL,GAAgB,IAAIlD,YAAJ,CAAiB,IAAjB,EAAuBiB,SAAvB,CAAhB;IACD;EACF,CAzIgC;EA2IjCC,OAAO,EAAE,CAACR,KAAD,EAAQC,OAAR,EAAiBmD,UAAjB,KAA+B;IACtC,MAAMjD,IAAI,GAAGF,OAAO,CAACE,IAAR,GAAeZ,YAA5B;IACA,MAAM8D,SAAS,GAAGD,UAAU,CAACE,MAAX,CAAkBC,CAAC,IAAIA,CAAC,CAACpD,IAAF,KAAWA,IAAlC,CAAlB;IACA,OAAOkD,SAAS,CAACG,MAAV,GAAmB,CAAnB,GACHJ,UADG,GAEHA,UAAU,CAACK,MAAX,CAAkB;MAChBtD,IADgB;MAEhBsB,KAAK,EAAExB,OAAO,CAACJ,OAAR,CAAgBH,KAAhB,CAAsBwD,GAAtB,CAA0B9C,IAAI,IAAG;QACtC,MAAM;UAACI,OAAD;UAAUkD;QAAV,IAAgCtD,IAAtC;QAAA,MAA8BuD,IAAI,UAAIvD,IAAJ,EAA5B,wBAA4B,CAAlC;;QACAuD,IAAI,CAAC5C,KAAL,GAAa5B,kBAAkB,CAACwE,IAAI,CAAC5C,KAAN,CAA/B;QACA,OAAO4C,IAAP;MACD,CAJM;IAFS,CAAlB,CAFJ;EAUD;AAxJgC,CAAnC;AA2JA,eAAe9D,OAAf","names":["array","isObject","isSingleDefUnitChannel","log","hasContinuousDomain","hash","keys","replacePathInField","varName","isEmpty","TimeUnitNode","TUPLE_FIELDS","SelectionProjectionComponent","constructor","items","hasChannel","hasField","project","defined","parse","model","selCmpt","selDef","name","proj","_a","parsed","timeUnits","signals","Set","signalName","p","range","suffix","channel","field","sg","counter","has","add","type","cfg","config","selection","init","value","undefined","fields","encodings","select","initVal","key","push","warn","message","INTERVAL_INITIALIZED_WITH_X_Y","fieldDef","aggregate","cannotProjectAggregate","cannotProjectOnChannelWithoutField","timeUnit","vgField","component","as","tplType","scaleType","getScaleComponent","get","bin","Object","map","v","allSignals","hasSignal","filter","s","length","concat","hasLegend","rest"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/selection/project.ts"],"sourcesContent":["import {array, isObject} from 'vega-util';\nimport {isSingleDefUnitChannel, ScaleChannel, SingleDefUnitChannel} from '../../channel';\nimport * as log from '../../log';\nimport {hasContinuousDomain} from '../../scale';\nimport {PointSelectionConfig, SelectionInitIntervalMapping, SelectionInitMapping} from '../../selection';\nimport {Dict, hash, keys, replacePathInField, varName, isEmpty} from '../../util';\nimport {TimeUnitComponent, TimeUnitNode} from '../data/timeunit';\nimport {SelectionCompiler} from '.';\nexport const TUPLE_FIELDS = '_tuple_fields';\n\n/**\n * Whether the selection tuples hold enumerated or ranged values for a field.\n */\nexport type TupleStoreType =\n  // enumerated\n  | 'E'\n  // ranged, exclusive, left-right inclusive\n  | 'R'\n  // ranged, left-inclusive, right-exclusive\n  | 'R-RE';\n\nexport interface SelectionProjection {\n  type: TupleStoreType;\n  field: string;\n  channel?: SingleDefUnitChannel;\n  signals?: {data?: string; visual?: string};\n  hasLegend?: boolean;\n}\n\nexport class SelectionProjectionComponent {\n  public hasChannel: Partial<Record<SingleDefUnitChannel, SelectionProjection>>;\n  public hasField: Record<string, SelectionProjection>;\n  public timeUnit?: TimeUnitNode;\n  public items: SelectionProjection[];\n\n  constructor(...items: SelectionProjection[]) {\n    this.items = items;\n    this.hasChannel = {};\n    this.hasField = {};\n  }\n}\n\nconst project: SelectionCompiler = {\n  defined: () => {\n    return true; // This transform handles its own defaults, so always run parse.\n  },\n\n  parse: (model, selCmpt, selDef) => {\n    const name = selCmpt.name;\n    const proj = (selCmpt.project ??= new SelectionProjectionComponent());\n    const parsed: Dict<SelectionProjection> = {};\n    const timeUnits: Dict<TimeUnitComponent> = {};\n\n    const signals = new Set<string>();\n    const signalName = (p: SelectionProjection, range: 'data' | 'visual') => {\n      const suffix = range === 'visual' ? p.channel : p.field;\n      let sg = varName(`${name}_${suffix}`);\n      for (let counter = 1; signals.has(sg); counter++) {\n        sg = varName(`${name}_${suffix}_${counter}`);\n      }\n      signals.add(sg);\n      return {[range]: sg};\n    };\n\n    const type = selCmpt.type;\n    const cfg = model.config.selection[type];\n    const init =\n      selDef.value !== undefined\n        ? (array(selDef.value as any) as SelectionInitMapping[] | SelectionInitIntervalMapping[])\n        : null;\n\n    // If no explicit projection (either fields or encodings) is specified, set some defaults.\n    // If an initial value is set, try to infer projections.\n    let {fields, encodings} = (isObject(selDef.select) ? selDef.select : {}) as PointSelectionConfig;\n    if (!fields && !encodings && init) {\n      for (const initVal of init) {\n        // initVal may be a scalar value to smoothen varParam -> pointSelection gradient.\n        if (!isObject(initVal)) {\n          continue;\n        }\n\n        for (const key of keys(initVal)) {\n          if (isSingleDefUnitChannel(key)) {\n            (encodings || (encodings = [])).push(key as SingleDefUnitChannel);\n          } else {\n            if (type === 'interval') {\n              log.warn(log.message.INTERVAL_INITIALIZED_WITH_X_Y);\n              encodings = cfg.encodings;\n            } else {\n              (fields || (fields = [])).push(key);\n            }\n          }\n        }\n      }\n    }\n\n    // If no initial value is specified, use the default configuration.\n    // We break this out as a separate if block (instead of an else condition)\n    // to account for unprojected point selections that have scalar initial values\n    if (!fields && !encodings) {\n      encodings = cfg.encodings;\n      if ('fields' in cfg) {\n        fields = cfg.fields;\n      }\n    }\n\n    for (const channel of encodings ?? []) {\n      const fieldDef = model.fieldDef(channel);\n      if (fieldDef) {\n        let field = fieldDef.field;\n\n        if (fieldDef.aggregate) {\n          log.warn(log.message.cannotProjectAggregate(channel, fieldDef.aggregate));\n          continue;\n        } else if (!field) {\n          log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n          continue;\n        }\n\n        if (fieldDef.timeUnit) {\n          field = model.vgField(channel);\n          // Construct TimeUnitComponents which will be combined into a\n          // TimeUnitNode. This node may need to be inserted into the\n          // dataflow if the selection is used across views that do not\n          // have these time units defined.\n          const component = {\n            timeUnit: fieldDef.timeUnit,\n            as: field,\n            field: fieldDef.field\n          };\n\n          timeUnits[hash(component)] = component;\n        }\n\n        // Prevent duplicate projections on the same field.\n        // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n        if (!parsed[field]) {\n          // Determine whether the tuple will store enumerated or ranged values.\n          // Interval selections store ranges for continuous scales, and enumerations otherwise.\n          // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n          let tplType: TupleStoreType = 'E';\n          if (type === 'interval') {\n            const scaleType = model.getScaleComponent(channel as ScaleChannel).get('type');\n            if (hasContinuousDomain(scaleType)) {\n              tplType = 'R';\n            }\n          } else if (fieldDef.bin) {\n            tplType = 'R-RE';\n          }\n\n          const p: SelectionProjection = {field, channel, type: tplType};\n          p.signals = {...signalName(p, 'data'), ...signalName(p, 'visual')};\n          proj.items.push((parsed[field] = p));\n          proj.hasField[field] = proj.hasChannel[channel] = parsed[field];\n        }\n      } else {\n        log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n      }\n    }\n\n    for (const field of fields ?? []) {\n      if (proj.hasField[field]) continue;\n      const p: SelectionProjection = {type: 'E', field};\n      p.signals = {...signalName(p, 'data')};\n      proj.items.push(p);\n      proj.hasField[field] = p;\n    }\n\n    if (init) {\n      selCmpt.init = (init as any).map((v: SelectionInitMapping | SelectionInitIntervalMapping) => {\n        // Selections can be initialized either with a full object that maps projections to values\n        // or scalar values to smoothen the abstraction gradient from variable params to point selections.\n        return proj.items.map(p => (isObject(v) ? (v[p.channel] !== undefined ? v[p.channel] : v[p.field]) : v));\n      });\n    }\n\n    if (!isEmpty(timeUnits)) {\n      proj.timeUnit = new TimeUnitNode(null, timeUnits);\n    }\n  },\n\n  signals: (model, selCmpt, allSignals) => {\n    const name = selCmpt.name + TUPLE_FIELDS;\n    const hasSignal = allSignals.filter(s => s.name === name);\n    return hasSignal.length > 0\n      ? allSignals\n      : allSignals.concat({\n          name,\n          value: selCmpt.project.items.map(proj => {\n            const {signals, hasLegend, ...rest} = proj;\n            rest.field = replacePathInField(rest.field);\n            return rest;\n          })\n        });\n  }\n};\n\nexport default project;\n"]},"metadata":{},"sourceType":"module"}