{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { keys } from './util';\nexport function isSignalRef(o) {\n  return o && !!o['signal'];\n}\nexport function isVgRangeStep(range) {\n  return !!range['step'];\n}\nexport function isDataRefUnionedDomain(domain) {\n  if (!isArray(domain)) {\n    return 'fields' in domain && !('data' in domain);\n  }\n\n  return false;\n}\nexport function isFieldRefUnionDomain(domain) {\n  if (!isArray(domain)) {\n    return 'fields' in domain && 'data' in domain;\n  }\n\n  return false;\n}\nexport function isDataRefDomain(domain) {\n  if (!isArray(domain)) {\n    return 'field' in domain && 'data' in domain;\n  }\n\n  return false;\n}\nconst VG_MARK_CONFIG_INDEX = {\n  aria: 1,\n  description: 1,\n  ariaRole: 1,\n  ariaRoleDescription: 1,\n  blend: 1,\n  opacity: 1,\n  fill: 1,\n  fillOpacity: 1,\n  stroke: 1,\n  strokeCap: 1,\n  strokeWidth: 1,\n  strokeOpacity: 1,\n  strokeDash: 1,\n  strokeDashOffset: 1,\n  strokeJoin: 1,\n  strokeOffset: 1,\n  strokeMiterLimit: 1,\n  startAngle: 1,\n  endAngle: 1,\n  padAngle: 1,\n  innerRadius: 1,\n  outerRadius: 1,\n  size: 1,\n  shape: 1,\n  interpolate: 1,\n  tension: 1,\n  orient: 1,\n  align: 1,\n  baseline: 1,\n  text: 1,\n  dir: 1,\n  dx: 1,\n  dy: 1,\n  ellipsis: 1,\n  limit: 1,\n  radius: 1,\n  theta: 1,\n  angle: 1,\n  font: 1,\n  fontSize: 1,\n  fontWeight: 1,\n  fontStyle: 1,\n  lineBreak: 1,\n  lineHeight: 1,\n  cursor: 1,\n  href: 1,\n  tooltip: 1,\n  cornerRadius: 1,\n  cornerRadiusTopLeft: 1,\n  cornerRadiusTopRight: 1,\n  cornerRadiusBottomLeft: 1,\n  cornerRadiusBottomRight: 1,\n  aspect: 1,\n  width: 1,\n  height: 1,\n  url: 1,\n  smooth: 1 // commented below are vg channel that do not have mark config.\n  // x: 1,\n  // y: 1,\n  // x2: 1,\n  // y2: 1,\n  // xc'|'yc'\n  // clip: 1,\n  // path: 1,\n  // url: 1,\n\n};\nexport const VG_MARK_CONFIGS = keys(VG_MARK_CONFIG_INDEX);\nexport const VG_MARK_INDEX = {\n  arc: 1,\n  area: 1,\n  group: 1,\n  image: 1,\n  line: 1,\n  path: 1,\n  rect: 1,\n  rule: 1,\n  shape: 1,\n  symbol: 1,\n  text: 1,\n  trail: 1\n}; // Vega's cornerRadius channels.\n\nexport const VG_CORNERRADIUS_CHANNELS = ['cornerRadius', 'cornerRadiusTopLeft', 'cornerRadiusTopRight', 'cornerRadiusBottomLeft', 'cornerRadiusBottomRight'];","map":{"version":3,"mappings":"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","names":["isArray","keys","isSignalRef","o","isVgRangeStep","range","isDataRefUnionedDomain","domain","isFieldRefUnionDomain","isDataRefDomain","VG_MARK_CONFIG_INDEX","aria","description","ariaRole","ariaRoleDescription","blend","opacity","fill","fillOpacity","stroke","strokeCap","strokeWidth","strokeOpacity","strokeDash","strokeDashOffset","strokeJoin","strokeOffset","strokeMiterLimit","startAngle","endAngle","padAngle","innerRadius","outerRadius","size","shape","interpolate","tension","orient","align","baseline","text","dir","dx","dy","ellipsis","limit","radius","theta","angle","font","fontSize","fontWeight","fontStyle","lineBreak","lineHeight","cursor","href","tooltip","cornerRadius","cornerRadiusTopLeft","cornerRadiusTopRight","cornerRadiusBottomLeft","cornerRadiusBottomRight","aspect","width","height","url","smooth","VG_MARK_CONFIGS","VG_MARK_INDEX","arc","area","group","image","line","path","rect","rule","symbol","trail","VG_CORNERRADIUS_CHANNELS"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/vega.schema.ts"],"sourcesContent":["import type {\n  AggregateOp,\n  BandScale,\n  BaseScale,\n  BinOrdinalScale,\n  ColorValueRef,\n  Compare as VgCompare,\n  ExprRef as VgExprRef,\n  GeoShapeTransform as VgGeoShapeTransform,\n  IdentityScale,\n  LayoutAlign,\n  LinearScale,\n  LogScale,\n  Mark,\n  MarkConfig,\n  NumericValueRef,\n  OrdinalScale,\n  PointScale,\n  PowScale,\n  ProjectionType,\n  QuantileScale,\n  QuantizeScale,\n  RangeBand,\n  RangeRaw,\n  RangeScheme,\n  ScaleData,\n  ScaleDataRef,\n  ScaledValueRef,\n  ScaleMultiDataRef,\n  ScaleMultiFieldsRef,\n  SequentialScale,\n  SignalRef,\n  SortField as VgSortField,\n  SqrtScale,\n  SymLogScale,\n  ThresholdScale,\n  TimeInterval,\n  TimeIntervalStep,\n  TimeScale,\n  Title as VgTitle,\n  Transforms as VgTransform,\n  UnionSortField as VgUnionSortField\n} from 'vega';\nimport {isArray} from 'vega-util';\nimport {Value} from './channeldef';\nimport {ExprRef} from './expr';\nimport {SortOrder} from './sort';\nimport {Dict, Flag, keys} from './util';\n\nexport type {VgSortField, VgUnionSortField, VgCompare, VgTitle, LayoutAlign, ProjectionType, VgExprRef};\n\n// TODO: make recursive (e.g. with https://stackoverflow.com/a/64900252/214950 but needs https://github.com/vega/ts-json-schema-generator/issues/568)\nexport type MappedExclude<T, E> = {\n  [P in keyof T]: Exclude<T[P], E>;\n};\n\nexport type MapExcludeAndKeepSignalAs<T, E, S extends ExprRef | SignalRef> = {\n  [P in keyof T]: SignalRef extends T[P] ? Exclude<T[P], E> | S : Exclude<T[P], E>;\n};\n\n// Remove ValueRefs from mapped types\nexport type MappedExcludeValueRef<T> = MappedExclude<T, ScaledValueRef<any> | NumericValueRef | ColorValueRef>;\n\nexport type MapExcludeValueRefAndReplaceSignalWith<T, S extends ExprRef | SignalRef> = MapExcludeAndKeepSignalAs<\n  T,\n  ScaledValueRef<any> | NumericValueRef | ColorValueRef,\n  S\n>;\n\nexport interface VgData {\n  name: string;\n  source?: string;\n  values?: any;\n  format?: {\n    type?: string;\n    parse?: string | Dict<unknown>;\n    property?: string;\n    feature?: string;\n    mesh?: string;\n  };\n  url?: string;\n  transform?: VgTransform[];\n}\n\nexport type VgScaleDataRefWithSort = ScaleDataRef & {\n  sort?: VgSortField;\n};\n\nexport function isSignalRef(o: any): o is SignalRef {\n  return o && !!o['signal'];\n}\n\n// TODO: add type of value (Make it VgValueRef<V extends ValueOrGradient> {value?:V ...})\nexport interface VgValueRef {\n  value?: Value<never>; // value should never be a signal so we use never\n  field?:\n    | string\n    | {\n        datum?: string;\n        group?: string;\n        parent?: string;\n      };\n  signal?: string;\n  scale?: string; // TODO: object\n  mult?: number;\n  offset?: number | VgValueRef;\n  band?: boolean | number | VgValueRef;\n  test?: string;\n}\n\n// TODO: add vg prefix\nexport type VgScaleMultiDataRefWithSort = ScaleMultiDataRef & {\n  fields: (any[] | VgScaleDataRefWithSort | SignalRef)[];\n  sort?: VgUnionSortField;\n};\n\nexport type VgMultiFieldsRefWithSort = ScaleMultiFieldsRef & {\n  sort?: VgUnionSortField;\n};\n\nexport type VgRange = RangeScheme | ScaleData | RangeBand | RangeRaw;\n\nexport function isVgRangeStep(range: VgRange): range is VgRangeStep {\n  return !!range['step'];\n}\n\nexport interface VgRangeStep {\n  step: number | SignalRef;\n}\n// Domains that are not a union of domains\nexport type VgNonUnionDomain = (null | string | number | boolean | SignalRef)[] | VgScaleDataRefWithSort | SignalRef;\n\nexport type VgDomain = BaseScale['domain'];\n\nexport type VgMarkGroup = any;\n\n/**\n * A combined type for any Vega scales that Vega-Lite can generate\n */\nexport type VgScale = Pick<BaseScale, 'type'> & {\n  range?: RangeScheme | RangeBand | ScaleData; // different Vega scales have conflicting range, need to union them here\n  nice?: boolean | number | TimeInterval | TimeIntervalStep | SignalRef; // different Vega scales have conflicting range, need to union them here\n  zero?: boolean | SignalRef; // LogScale only allow false, making the intersection type overly strict\n} & Omit<\n    // Continuous\n    Omit<LinearScale, 'type'> &\n      Omit<LogScale, 'type'> &\n      Omit<SymLogScale, 'type'> &\n      Omit<Partial<PowScale>, 'type'> & // use partial so exponent is not required\n      Omit<SqrtScale, 'type'> &\n      Omit<IdentityScale, 'type'> &\n      Omit<TimeScale, 'type'> &\n      // Discretizing\n      Omit<QuantileScale, 'type'> &\n      Omit<QuantizeScale, 'type'> &\n      Omit<ThresholdScale, 'type'> &\n      Omit<BinOrdinalScale, 'type'> &\n      // Sequential\n      Omit<SequentialScale, 'type'> &\n      // Discrete\n      Omit<BandScale, 'type'> &\n      Omit<PointScale, 'type'> &\n      Omit<OrdinalScale, 'type'>,\n    'range' | 'nice' | 'zero'\n  >;\n\nexport interface RowCol<T> {\n  row?: T;\n  column?: T;\n}\n\nexport interface VgLayout {\n  center?: boolean | RowCol<boolean>;\n  padding?: number | RowCol<number>;\n  headerBand?: number | RowCol<number>;\n  footerBand?: number | RowCol<number>;\n\n  titleAnchor?: 'start' | 'end' | RowCol<'start' | 'end'>;\n  offset?:\n    | number\n    | {\n        rowHeader?: number;\n        rowFooter?: number;\n        rowTitle?: number;\n        columnHeader?: number;\n        columnFooter?: number;\n        columnTitle?: number;\n      };\n  bounds?: 'full' | 'flush';\n  columns?: number | {signal: string};\n  align?: LayoutAlign | RowCol<LayoutAlign>;\n}\n\nexport function isDataRefUnionedDomain(domain: VgDomain): domain is VgScaleMultiDataRefWithSort {\n  if (!isArray(domain)) {\n    return 'fields' in domain && !('data' in domain);\n  }\n  return false;\n}\n\nexport function isFieldRefUnionDomain(domain: VgDomain): domain is VgMultiFieldsRefWithSort {\n  if (!isArray(domain)) {\n    return 'fields' in domain && 'data' in domain;\n  }\n  return false;\n}\n\nexport function isDataRefDomain(domain: VgDomain | any): domain is VgScaleDataRefWithSort {\n  if (!isArray(domain)) {\n    return 'field' in domain && 'data' in domain;\n  }\n  return false;\n}\n\nexport type VgEncodeChannel =\n  | 'x'\n  | 'x2'\n  | 'xc'\n  | 'width'\n  | 'y'\n  | 'y2'\n  | 'yc'\n  | 'height'\n  | 'opacity'\n  | 'fill'\n  | 'fillOpacity'\n  | 'stroke'\n  | 'strokeWidth'\n  | 'strokeCap'\n  | 'strokeOpacity'\n  | 'strokeDash'\n  | 'strokeDashOffset'\n  | 'strokeMiterLimit'\n  | 'strokeJoin'\n  | 'strokeOffset'\n  | 'strokeForeground'\n  | 'cursor'\n  | 'clip'\n  | 'size'\n  | 'shape'\n  | 'path'\n  | 'innerRadius'\n  | 'outerRadius'\n  | 'startAngle'\n  | 'endAngle'\n  | 'interpolate'\n  | 'tension'\n  | 'orient'\n  | 'url'\n  | 'align'\n  | 'baseline'\n  | 'text'\n  | 'dir'\n  | 'ellipsis'\n  | 'limit'\n  | 'dx'\n  | 'dy'\n  | 'radius'\n  | 'theta'\n  | 'angle'\n  | 'font'\n  | 'fontSize'\n  | 'fontWeight'\n  | 'fontStyle'\n  | 'tooltip'\n  | 'href'\n  | 'cursor'\n  | 'defined'\n  | 'cornerRadius'\n  | 'cornerRadiusTopLeft'\n  | 'cornerRadiusTopRight'\n  | 'cornerRadiusBottomRight'\n  | 'cornerRadiusBottomLeft'\n  | 'scaleX'\n  | 'scaleY';\n\nexport type VgEncodeEntry = Partial<Record<VgEncodeChannel, VgValueRef | (VgValueRef & {test?: string})[]>>;\n\n// TODO: make export interface VgEncodeEntry {\n//   x?: VgValueRef<number>\n//   y?: VgValueRef<number>\n//  ...\n//   color?: VgValueRef<string>\n//  ...\n// }\n\nexport type VgPostEncodingTransform = VgGeoShapeTransform;\n\nconst VG_MARK_CONFIG_INDEX: Flag<keyof MarkConfig> = {\n  aria: 1,\n  description: 1,\n  ariaRole: 1,\n  ariaRoleDescription: 1,\n  blend: 1,\n  opacity: 1,\n  fill: 1,\n  fillOpacity: 1,\n  stroke: 1,\n  strokeCap: 1,\n  strokeWidth: 1,\n  strokeOpacity: 1,\n  strokeDash: 1,\n  strokeDashOffset: 1,\n  strokeJoin: 1,\n  strokeOffset: 1,\n  strokeMiterLimit: 1,\n  startAngle: 1,\n  endAngle: 1,\n  padAngle: 1,\n  innerRadius: 1,\n  outerRadius: 1,\n  size: 1,\n  shape: 1,\n  interpolate: 1,\n  tension: 1,\n  orient: 1,\n  align: 1,\n  baseline: 1,\n  text: 1,\n  dir: 1,\n  dx: 1,\n  dy: 1,\n  ellipsis: 1,\n  limit: 1,\n  radius: 1,\n  theta: 1,\n  angle: 1,\n  font: 1,\n  fontSize: 1,\n  fontWeight: 1,\n  fontStyle: 1,\n  lineBreak: 1,\n  lineHeight: 1,\n  cursor: 1,\n  href: 1,\n  tooltip: 1,\n  cornerRadius: 1,\n  cornerRadiusTopLeft: 1,\n  cornerRadiusTopRight: 1,\n  cornerRadiusBottomLeft: 1,\n  cornerRadiusBottomRight: 1,\n  aspect: 1,\n  width: 1,\n  height: 1,\n  url: 1,\n  smooth: 1\n\n  // commented below are vg channel that do not have mark config.\n  // x: 1,\n  // y: 1,\n  // x2: 1,\n  // y2: 1,\n\n  // xc'|'yc'\n  // clip: 1,\n  // path: 1,\n  // url: 1,\n};\n\nexport const VG_MARK_CONFIGS = keys(VG_MARK_CONFIG_INDEX);\n\nexport const VG_MARK_INDEX: Flag<Mark['type']> = {\n  arc: 1,\n  area: 1,\n  group: 1,\n  image: 1,\n  line: 1,\n  path: 1,\n  rect: 1,\n  rule: 1,\n  shape: 1,\n  symbol: 1,\n  text: 1,\n  trail: 1\n};\n\n// Vega's cornerRadius channels.\nexport const VG_CORNERRADIUS_CHANNELS = [\n  'cornerRadius',\n  'cornerRadiusTopLeft',\n  'cornerRadiusTopRight',\n  'cornerRadiusBottomLeft',\n  'cornerRadiusBottomRight'\n] as const;\n\nexport interface VgComparator {\n  field?: string | string[];\n  order?: SortOrder | SortOrder[];\n}\n\nexport interface VgJoinAggregateTransform {\n  type: 'joinaggregate';\n  as?: string[];\n  ops?: AggregateOp[];\n  fields?: string[];\n  groupby?: string[];\n}\n"]},"metadata":{},"sourceType":"module"}