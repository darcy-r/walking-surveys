{"ast":null,"code":"import { isObject } from 'vega-util';\nimport { isBinned } from '../bin';\nimport { getMainRangeChannel, SECONDARY_RANGE_CHANNEL } from '../channel';\nimport { isDatumDef, isFieldDef } from '../channeldef';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { isUnitSpec } from '../spec/unit';\nexport class RuleForRangedLineNormalizer {\n  constructor() {\n    this.name = 'RuleForRangedLine';\n  }\n\n  hasMatchingType(spec) {\n    if (isUnitSpec(spec)) {\n      const {\n        encoding,\n        mark\n      } = spec;\n\n      if (mark === 'line' || isMarkDef(mark) && mark.type === 'line') {\n        for (const channel of SECONDARY_RANGE_CHANNEL) {\n          const mainChannel = getMainRangeChannel(channel);\n          const mainChannelDef = encoding[mainChannel];\n\n          if (encoding[channel]) {\n            if (isFieldDef(mainChannelDef) && !isBinned(mainChannelDef.bin) || isDatumDef(mainChannelDef)) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  run(spec, params, normalize) {\n    const {\n      encoding,\n      mark\n    } = spec;\n    log.warn(log.message.lineWithRange(!!encoding.x2, !!encoding.y2));\n    return normalize(Object.assign(Object.assign({}, spec), {\n      mark: isObject(mark) ? Object.assign(Object.assign({}, mark), {\n        type: 'rule'\n      }) : 'rule'\n    }), params);\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAAQA,QAAR,QAAuB,WAAvB;AACA,SAAQC,QAAR,QAAuB,QAAvB;AACA,SAAQC,mBAAR,EAA6BC,uBAA7B,QAA2D,YAA3D;AACA,SAAeC,UAAf,EAA2BC,UAA3B,QAA4C,eAA5C;AAEA,OAAO,KAAKC,GAAZ,MAAqB,QAArB;AACA,SAAQC,SAAR,QAAwB,SAAxB;AAEA,SAAyBC,UAAzB,QAA0C,cAA1C;AAaA,OAAM,MAAOC,2BAAP,CAAkC;EAAxCC;IACS,YAAO,mBAAP;EAiCR;;EA/BQC,eAAe,CAACC,IAAD,EAAsC;IAC1D,IAAIJ,UAAU,CAACI,IAAD,CAAd,EAAsB;MACpB,MAAM;QAACC,QAAD;QAAWC;MAAX,IAAmBF,IAAzB;;MACA,IAAIE,IAAI,KAAK,MAAT,IAAoBP,SAAS,CAACO,IAAD,CAAT,IAAmBA,IAAI,CAACC,IAAL,KAAc,MAAzD,EAAkE;QAChE,KAAK,MAAMC,OAAX,IAAsBb,uBAAtB,EAA+C;UAC7C,MAAMc,WAAW,GAAGf,mBAAmB,CAACc,OAAD,CAAvC;UACA,MAAME,cAAc,GAAGL,QAAQ,CAACI,WAAD,CAA/B;;UAEA,IAAIJ,QAAQ,CAACG,OAAD,CAAZ,EAAuB;YACrB,IAAKX,UAAU,CAACa,cAAD,CAAV,IAA8B,CAACjB,QAAQ,CAACiB,cAAc,CAACC,GAAhB,CAAxC,IAAiEf,UAAU,CAACc,cAAD,CAA/E,EAAiG;cAC/F,OAAO,IAAP;YACD;UACF;QACF;MACF;IACF;;IACD,OAAO,KAAP;EACD;;EAEME,GAAG,CAACR,IAAD,EAAuBS,MAAvB,EAAiDC,SAAjD,EAAgF;IACxF,MAAM;MAACT,QAAD;MAAWC;IAAX,IAAmBF,IAAzB;IACAN,GAAG,CAACiB,IAAJ,CAASjB,GAAG,CAACkB,OAAJ,CAAYC,aAAZ,CAA0B,CAAC,CAACZ,QAAQ,CAACa,EAArC,EAAyC,CAAC,CAACb,QAAQ,CAACc,EAApD,CAAT;IAEA,OAAOL,SAAS,iCAETV,IAFS,GAEL;MACPE,IAAI,EAAEd,QAAQ,CAACc,IAAD,CAAR,GAAgBc,gCAAKd,IAAL,GAAS;QAAEC,IAAI,EAAE;MAAR,CAAT,CAAhB,GAA2C;IAD1C,CAFK,GAKdM,MALc,CAAhB;EAOD;;AAjCqC","names":["isObject","isBinned","getMainRangeChannel","SECONDARY_RANGE_CHANNEL","isDatumDef","isFieldDef","log","isMarkDef","isUnitSpec","RuleForRangedLineNormalizer","constructor","hasMatchingType","spec","encoding","mark","type","channel","mainChannel","mainChannelDef","bin","run","params","normalize","warn","message","lineWithRange","x2","y2","Object"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/normalize/ruleforrangedline.ts"],"sourcesContent":["import {isObject} from 'vega-util';\nimport {isBinned} from '../bin';\nimport {getMainRangeChannel, SECONDARY_RANGE_CHANNEL} from '../channel';\nimport {Field, isDatumDef, isFieldDef} from '../channeldef';\nimport {Encoding} from '../encoding';\nimport * as log from '../log';\nimport {isMarkDef} from '../mark';\nimport {GenericSpec} from '../spec';\nimport {GenericUnitSpec, isUnitSpec} from '../spec/unit';\nimport {NonFacetUnitNormalizer, NormalizeLayerOrUnit, NormalizerParams} from './base';\n\ninterface EncodingX2Mixins {\n  x2: Encoding<Field>['x2'];\n}\n\ninterface EncodingY2Mixins {\n  y2: Encoding<Field>['y2'];\n}\n\ntype RangedLineSpec = GenericUnitSpec<Encoding<Field> & (EncodingX2Mixins | EncodingY2Mixins), 'line' | {mark: 'line'}>;\n\nexport class RuleForRangedLineNormalizer implements NonFacetUnitNormalizer<RangedLineSpec> {\n  public name = 'RuleForRangedLine';\n\n  public hasMatchingType(spec: GenericSpec<any, any, any, any>): spec is RangedLineSpec {\n    if (isUnitSpec(spec)) {\n      const {encoding, mark} = spec;\n      if (mark === 'line' || (isMarkDef(mark) && mark.type === 'line')) {\n        for (const channel of SECONDARY_RANGE_CHANNEL) {\n          const mainChannel = getMainRangeChannel(channel);\n          const mainChannelDef = encoding[mainChannel];\n\n          if (encoding[channel]) {\n            if ((isFieldDef(mainChannelDef) && !isBinned(mainChannelDef.bin)) || isDatumDef(mainChannelDef)) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  public run(spec: RangedLineSpec, params: NormalizerParams, normalize: NormalizeLayerOrUnit) {\n    const {encoding, mark} = spec;\n    log.warn(log.message.lineWithRange(!!encoding.x2, !!encoding.y2));\n\n    return normalize(\n      {\n        ...spec,\n        mark: isObject(mark) ? {...mark, type: 'rule'} : 'rule'\n      },\n      params\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}