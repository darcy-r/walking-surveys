{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isObject, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, MULTIDOMAIN_SORT_OP_INDEX as UNIONDOMAIN_SORT_OP_INDEX, SHARED_DOMAIN_OPS } from '../../aggregate';\nimport { isBinning, isBinParams, isParameterExtent } from '../../bin';\nimport { getSecondaryRangeChannel, isScaleChannel } from '../../channel';\nimport { binRequiresRange, getFieldOrDatumDef, hasBandEnd, isDatumDef, isFieldDef, valueExpr, vgField } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport * as log from '../../log';\nimport { hasDiscreteDomain, isDomainUnionWith, isParameterDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortArray, isSortByEncoding, isSortField } from '../../sort';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport * as util from '../../util';\nimport { isDataRefDomain, isDataRefUnionedDomain, isFieldRefUnionDomain, isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { sortArrayIndexField } from '../data/calculate';\nimport { FACET_SCALE_PREFIX } from '../data/optimize';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit, mergeValuesWithExplicit } from '../split';\nexport function parseScaleDomain(model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleDomain(model);\n  } else {\n    parseNonUnitScaleDomain(model);\n  }\n}\n\nfunction parseUnitScaleDomain(model) {\n  const localScaleComponents = model.component.scales;\n\n  for (const channel of util.keys(localScaleComponents)) {\n    const domains = parseDomainForChannel(model, channel);\n    const localScaleCmpt = localScaleComponents[channel];\n    localScaleCmpt.setWithExplicit('domains', domains);\n    parseSelectionDomain(model, channel);\n\n    if (model.component.data.isFaceted) {\n      // get resolve from closest facet parent as this decides whether we need to refer to cloned subtree or not\n      let facetParent = model;\n\n      while (!isFacetModel(facetParent) && facetParent.parent) {\n        facetParent = facetParent.parent;\n      }\n\n      const resolve = facetParent.component.resolve.scale[channel];\n\n      if (resolve === 'shared') {\n        for (const domain of domains.value) {\n          // Replace the scale domain with data output from a cloned subtree after the facet.\n          if (isDataRefDomain(domain)) {\n            // use data from cloned subtree (which is the same as data but with a prefix added once)\n            domain.data = FACET_SCALE_PREFIX + domain.data.replace(FACET_SCALE_PREFIX, '');\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction parseNonUnitScaleDomain(model) {\n  for (const child of model.children) {\n    parseScaleDomain(child);\n  }\n\n  const localScaleComponents = model.component.scales;\n\n  for (const channel of util.keys(localScaleComponents)) {\n    let domains;\n    let selectionExtent = null;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n\n      if (childComponent) {\n        if (domains === undefined) {\n          domains = childComponent.getWithExplicit('domains');\n        } else {\n          domains = mergeValuesWithExplicit(domains, childComponent.getWithExplicit('domains'), 'domains', 'scale', domainsTieBreaker);\n        }\n\n        const se = childComponent.get('selectionExtent');\n\n        if (selectionExtent && se && selectionExtent.param !== se.param) {\n          log.warn(log.message.NEEDS_SAME_SELECTION);\n        }\n\n        selectionExtent = se;\n      }\n    }\n\n    localScaleComponents[channel].setWithExplicit('domains', domains);\n\n    if (selectionExtent) {\n      localScaleComponents[channel].set('selectionExtent', selectionExtent, true);\n    }\n  }\n}\n/**\n * Remove unaggregated domain if it is not applicable\n * Add unaggregated domain if domain is not specified and config.scale.useUnaggregatedDomain is true.\n */\n\n\nfunction normalizeUnaggregatedDomain(domain, fieldDef, scaleType, scaleConfig) {\n  if (domain === 'unaggregated') {\n    const {\n      valid,\n      reason\n    } = canUseUnaggregatedDomain(fieldDef, scaleType);\n\n    if (!valid) {\n      log.warn(reason);\n      return undefined;\n    }\n  } else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n    // Apply config if domain is not specified.\n    const {\n      valid\n    } = canUseUnaggregatedDomain(fieldDef, scaleType);\n\n    if (valid) {\n      return 'unaggregated';\n    }\n  }\n\n  return domain;\n}\n\nexport function parseDomainForChannel(model, channel) {\n  const scaleType = model.getScaleComponent(channel).get('type');\n  const {\n    encoding\n  } = model;\n  const domain = normalizeUnaggregatedDomain(model.scaleDomain(channel), model.typedFieldDef(channel), scaleType, model.config.scale);\n\n  if (domain !== model.scaleDomain(channel)) {\n    model.specifiedScales[channel] = Object.assign(Object.assign({}, model.specifiedScales[channel]), {\n      domain\n    });\n  } // If channel is either X or Y then union them with X2 & Y2 if they exist\n\n\n  if (channel === 'x' && getFieldOrDatumDef(encoding.x2)) {\n    if (getFieldOrDatumDef(encoding.x)) {\n      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'x'), parseSingleChannelDomain(scaleType, domain, model, 'x2'), 'domain', 'scale', domainsTieBreaker);\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'x2');\n    }\n  } else if (channel === 'y' && getFieldOrDatumDef(encoding.y2)) {\n    if (getFieldOrDatumDef(encoding.y)) {\n      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'y'), parseSingleChannelDomain(scaleType, domain, model, 'y2'), 'domain', 'scale', domainsTieBreaker);\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'y2');\n    }\n  }\n\n  return parseSingleChannelDomain(scaleType, domain, model, channel);\n}\n\nfunction mapDomainToDataSignal(domain, type, timeUnit) {\n  return domain.map(v => {\n    const data = valueExpr(v, {\n      timeUnit,\n      type\n    });\n    return {\n      signal: `{data: ${data}}`\n    };\n  });\n}\n\nfunction convertDomainIfItIsDateTime(domain, type, timeUnit) {\n  var _a; // explicit value\n\n\n  const normalizedTimeUnit = (_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;\n\n  if (type === 'temporal' || normalizedTimeUnit) {\n    return mapDomainToDataSignal(domain, type, normalizedTimeUnit);\n  }\n\n  return [domain]; // Date time won't make sense\n}\n\nfunction parseSingleChannelDomain(scaleType, domain, model, channel) {\n  const {\n    encoding\n  } = model;\n  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n  const {\n    type\n  } = fieldOrDatumDef;\n  const timeUnit = fieldOrDatumDef['timeUnit'];\n\n  if (isDomainUnionWith(domain)) {\n    const defaultDomain = parseSingleChannelDomain(scaleType, undefined, model, channel);\n    const unionWith = convertDomainIfItIsDateTime(domain.unionWith, type, timeUnit);\n    return makeExplicit([...defaultDomain.value, ...unionWith]);\n  } else if (isSignalRef(domain)) {\n    return makeExplicit([domain]);\n  } else if (domain && domain !== 'unaggregated' && !isParameterDomain(domain)) {\n    return makeExplicit(convertDomainIfItIsDateTime(domain, type, timeUnit));\n  }\n\n  const stack = model.stack;\n\n  if (stack && channel === stack.fieldChannel) {\n    if (stack.offset === 'normalize') {\n      return makeImplicit([[0, 1]]);\n    }\n\n    const data = model.requestDataName(DataSourceType.Main);\n    return makeImplicit([{\n      data,\n      field: model.vgField(channel, {\n        suffix: 'start'\n      })\n    }, {\n      data,\n      field: model.vgField(channel, {\n        suffix: 'end'\n      })\n    }]);\n  }\n\n  const sort = isScaleChannel(channel) && isFieldDef(fieldOrDatumDef) ? domainSort(model, channel, scaleType) : undefined;\n\n  if (isDatumDef(fieldOrDatumDef)) {\n    const d = convertDomainIfItIsDateTime([fieldOrDatumDef.datum], type, timeUnit);\n    return makeImplicit(d);\n  }\n\n  const fieldDef = fieldOrDatumDef; // now we can be sure it's a fieldDef\n\n  if (domain === 'unaggregated') {\n    const data = model.requestDataName(DataSourceType.Main);\n    const {\n      field\n    } = fieldOrDatumDef;\n    return makeImplicit([{\n      data,\n      field: vgField({\n        field,\n        aggregate: 'min'\n      })\n    }, {\n      data,\n      field: vgField({\n        field,\n        aggregate: 'max'\n      })\n    }]);\n  } else if (isBinning(fieldDef.bin)) {\n    if (hasDiscreteDomain(scaleType)) {\n      if (scaleType === 'bin-ordinal') {\n        // we can omit the domain as it is inferred from the `bins` property\n        return makeImplicit([]);\n      } // ordinal bin scale takes domain from bin_range, ordered by bin start\n      // This is useful for both axis-based scale (x/y) and legend-based scale (other channels).\n\n\n      return makeImplicit([{\n        // If sort by aggregation of a specified sort field, we need to use RAW table,\n        // so we can aggregate values for the scale independently from the main aggregation.\n        data: util.isBoolean(sort) ? model.requestDataName(DataSourceType.Main) : model.requestDataName(DataSourceType.Raw),\n        // Use range if we added it and the scale does not support computing a range as a signal.\n        field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? {\n          binSuffix: 'range'\n        } : {}),\n        // we have to use a sort object if sort = true to make the sort correct by bin start\n        sort: sort === true || !isObject(sort) ? {\n          field: model.vgField(channel, {}),\n          op: 'min' // min or max doesn't matter since we sort by the start of the bin range\n\n        } : sort\n      }]);\n    } else {\n      // continuous scales\n      const {\n        bin\n      } = fieldDef;\n\n      if (isBinning(bin)) {\n        const binSignal = getBinSignalName(model, fieldDef.field, bin);\n        return makeImplicit([new SignalRefWrapper(() => {\n          const signal = model.getSignalName(binSignal);\n          return `[${signal}.start, ${signal}.stop]`;\n        })]);\n      } else {\n        return makeImplicit([{\n          data: model.requestDataName(DataSourceType.Main),\n          field: model.vgField(channel, {})\n        }]);\n      }\n    }\n  } else if (fieldDef.timeUnit && util.contains(['time', 'utc'], scaleType) && hasBandEnd(fieldDef, isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined, model.markDef, model.config)) {\n    const data = model.requestDataName(DataSourceType.Main);\n    return makeImplicit([{\n      data,\n      field: model.vgField(channel)\n    }, {\n      data,\n      field: model.vgField(channel, {\n        suffix: 'end'\n      })\n    }]);\n  } else if (sort) {\n    return makeImplicit([{\n      // If sort by aggregation of a specified sort field, we need to use RAW table,\n      // so we can aggregate values for the scale independently from the main aggregation.\n      data: util.isBoolean(sort) ? model.requestDataName(DataSourceType.Main) : model.requestDataName(DataSourceType.Raw),\n      field: model.vgField(channel),\n      sort\n    }]);\n  } else {\n    return makeImplicit([{\n      data: model.requestDataName(DataSourceType.Main),\n      field: model.vgField(channel)\n    }]);\n  }\n}\n\nfunction normalizeSortField(sort, isStackedMeasure) {\n  const {\n    op,\n    field,\n    order\n  } = sort;\n  return Object.assign(Object.assign({\n    // Apply default op\n    op: op !== null && op !== void 0 ? op : isStackedMeasure ? 'sum' : DEFAULT_SORT_OP\n  }, field ? {\n    field: util.replacePathInField(field)\n  } : {}), order ? {\n    order\n  } : {});\n}\n\nfunction parseSelectionDomain(model, channel) {\n  var _a;\n\n  const scale = model.component.scales[channel];\n  const spec = model.specifiedScales[channel].domain;\n  const bin = (_a = model.fieldDef(channel)) === null || _a === void 0 ? void 0 : _a.bin;\n  const domain = isParameterDomain(spec) && spec;\n  const extent = isBinParams(bin) && isParameterExtent(bin.extent) && bin.extent;\n\n  if (domain || extent) {\n    // As scale parsing occurs before selection parsing, we cannot set\n    // domainRaw directly. So instead, we store the selectionExtent on\n    // the scale component, and then add domainRaw during scale assembly.\n    scale.set('selectionExtent', domain !== null && domain !== void 0 ? domain : extent, true);\n  }\n}\n\nexport function domainSort(model, channel, scaleType) {\n  if (!hasDiscreteDomain(scaleType)) {\n    return undefined;\n  } // save to cast as the only exception is the geojson type for shape, which would not generate a scale\n\n\n  const fieldDef = model.fieldDef(channel);\n  const sort = fieldDef.sort; // if the sort is specified with array, use the derived sort index field\n\n  if (isSortArray(sort)) {\n    return {\n      op: 'min',\n      field: sortArrayIndexField(fieldDef, channel),\n      order: 'ascending'\n    };\n  }\n\n  const {\n    stack\n  } = model;\n  const stackDimensions = stack ? new Set([...stack.groupbyFields, ...stack.stackBy.map(s => s.fieldDef.field)]) : undefined; // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n\n  if (isSortField(sort)) {\n    const isStackedMeasure = stack && !stackDimensions.has(sort.field);\n    return normalizeSortField(sort, isStackedMeasure);\n  } else if (isSortByEncoding(sort)) {\n    const {\n      encoding,\n      order\n    } = sort;\n    const fieldDefToSortBy = model.fieldDef(encoding);\n    const {\n      aggregate,\n      field\n    } = fieldDefToSortBy;\n    const isStackedMeasure = stack && !stackDimensions.has(field);\n\n    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n      return normalizeSortField({\n        field: vgField(fieldDefToSortBy),\n        order\n      }, isStackedMeasure);\n    } else if (isAggregateOp(aggregate) || !aggregate) {\n      return normalizeSortField({\n        op: aggregate,\n        field,\n        order\n      }, isStackedMeasure);\n    }\n  } else if (sort === 'descending') {\n    return {\n      op: 'min',\n      field: model.vgField(channel),\n      order: 'descending'\n    };\n  } else if (util.contains(['ascending', undefined\n  /* default =ascending*/\n  ], sort)) {\n    return true;\n  } // sort == null\n\n\n  return undefined;\n}\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditions apply:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\n\nexport function canUseUnaggregatedDomain(fieldDef, scaleType) {\n  const {\n    aggregate,\n    type\n  } = fieldDef;\n\n  if (!aggregate) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n    };\n  }\n\n  if (isString(aggregate) && !SHARED_DOMAIN_OPS.has(aggregate)) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainWithNonSharedDomainOp(aggregate)\n    };\n  }\n\n  if (type === 'quantitative') {\n    if (scaleType === 'log') {\n      return {\n        valid: false,\n        reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n      };\n    }\n  }\n\n  return {\n    valid: true\n  };\n}\n/**\n * Tie breaker for mergeValuesWithExplicit for domains. We concat the specified values.\n */\n\nfunction domainsTieBreaker(v1, v2, property, propertyOf) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingDomainProperty(property, propertyOf, v1.value, v2.value));\n  } // If equal score, concat the domains so that we union them later.\n\n\n  return {\n    explicit: v1.explicit,\n    value: [...v1.value, ...v2.value]\n  };\n}\n/**\n * Converts an array of domains to a single Vega scale domain.\n */\n\n\nexport function mergeDomains(domains) {\n  const uniqueDomains = util.unique(domains.map(domain => {\n    // ignore sort property when computing the unique domains\n    if (isDataRefDomain(domain)) {\n      const {\n        sort: _s\n      } = domain,\n            domainWithoutSort = __rest(domain, [\"sort\"]);\n\n      return domainWithoutSort;\n    }\n\n    return domain;\n  }), util.hash);\n  const sorts = util.unique(domains.map(d => {\n    if (isDataRefDomain(d)) {\n      const s = d.sort;\n\n      if (s !== undefined && !util.isBoolean(s)) {\n        if ('op' in s && s.op === 'count') {\n          // let's make sure that if op is count, we don't use a field\n          delete s.field;\n        }\n\n        if (s.order === 'ascending') {\n          // drop order: ascending as it is the default\n          delete s.order;\n        }\n      }\n\n      return s;\n    }\n\n    return undefined;\n  }).filter(s => s !== undefined), util.hash);\n\n  if (uniqueDomains.length === 0) {\n    return undefined;\n  } else if (uniqueDomains.length === 1) {\n    const domain = domains[0];\n\n    if (isDataRefDomain(domain) && sorts.length > 0) {\n      let sort = sorts[0];\n\n      if (sorts.length > 1) {\n        log.warn(log.message.MORE_THAN_ONE_SORT);\n        sort = true;\n      } else {\n        // Simplify domain sort by removing field and op when the field is the same as the domain field.\n        if (isObject(sort) && 'field' in sort) {\n          const sortField = sort.field;\n\n          if (domain.field === sortField) {\n            sort = sort.order ? {\n              order: sort.order\n            } : true;\n          }\n        }\n      }\n\n      return Object.assign(Object.assign({}, domain), {\n        sort\n      });\n    }\n\n    return domain;\n  } // only keep sort properties that work with unioned domains\n\n\n  const unionDomainSorts = util.unique(sorts.map(s => {\n    if (util.isBoolean(s) || !('op' in s) || isString(s.op) && s.op in UNIONDOMAIN_SORT_OP_INDEX) {\n      return s;\n    }\n\n    log.warn(log.message.domainSortDropped(s));\n    return true;\n  }), util.hash);\n  let sort;\n\n  if (unionDomainSorts.length === 1) {\n    sort = unionDomainSorts[0];\n  } else if (unionDomainSorts.length > 1) {\n    log.warn(log.message.MORE_THAN_ONE_SORT);\n    sort = true;\n  }\n\n  const allData = util.unique(domains.map(d => {\n    if (isDataRefDomain(d)) {\n      return d.data;\n    }\n\n    return null;\n  }), x => x);\n\n  if (allData.length === 1 && allData[0] !== null) {\n    // create a union domain of different fields with a single data source\n    const domain = Object.assign({\n      data: allData[0],\n      fields: uniqueDomains.map(d => d.field)\n    }, sort ? {\n      sort\n    } : {});\n    return domain;\n  }\n\n  return Object.assign({\n    fields: uniqueDomains\n  }, sort ? {\n    sort\n  } : {});\n}\n/**\n * Return a field if a scale uses a single field.\n * Return `undefined` otherwise.\n */\n\nexport function getFieldFromDomain(domain) {\n  if (isDataRefDomain(domain) && isString(domain.field)) {\n    return domain.field;\n  } else if (isDataRefUnionedDomain(domain)) {\n    let field;\n\n    for (const nonUnionDomain of domain.fields) {\n      if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {\n        if (!field) {\n          field = nonUnionDomain.field;\n        } else if (field !== nonUnionDomain.field) {\n          log.warn(log.message.FACETED_INDEPENDENT_DIFFERENT_SOURCES);\n          return field;\n        }\n      }\n    }\n\n    log.warn(log.message.FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES);\n    return field;\n  } else if (isFieldRefUnionDomain(domain)) {\n    log.warn(log.message.FACETED_INDEPENDENT_SAME_SOURCE);\n    const field = domain.fields[0];\n    return isString(field) ? field : undefined;\n  }\n\n  return undefined;\n}\nexport function assembleDomain(model, channel) {\n  const scaleComponent = model.component.scales[channel];\n  const domains = scaleComponent.get('domains').map(domain => {\n    // Correct references to data as the original domain's data was determined\n    // in parseScale, which happens before parseData. Thus the original data\n    // reference can be incorrect.\n    if (isDataRefDomain(domain)) {\n      domain.data = model.lookupDataSource(domain.data);\n    }\n\n    return domain;\n  }); // domains is an array that has to be merged into a single vega domain\n\n  return mergeDomains(domains);\n}","map":{"version":3,"mappings":"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","names":["isObject","isString","isAggregateOp","isArgmaxDef","isArgminDef","MULTIDOMAIN_SORT_OP_INDEX","UNIONDOMAIN_SORT_OP_INDEX","SHARED_DOMAIN_OPS","isBinning","isBinParams","isParameterExtent","getSecondaryRangeChannel","isScaleChannel","binRequiresRange","getFieldOrDatumDef","hasBandEnd","isDatumDef","isFieldDef","valueExpr","vgField","DataSourceType","log","hasDiscreteDomain","isDomainUnionWith","isParameterDomain","DEFAULT_SORT_OP","isSortArray","isSortByEncoding","isSortField","normalizeTimeUnit","util","isDataRefDomain","isDataRefUnionedDomain","isFieldRefUnionDomain","isSignalRef","getBinSignalName","sortArrayIndexField","FACET_SCALE_PREFIX","isFacetModel","isUnitModel","SignalRefWrapper","makeExplicit","makeImplicit","mergeValuesWithExplicit","parseScaleDomain","model","parseUnitScaleDomain","parseNonUnitScaleDomain","localScaleComponents","component","scales","channel","keys","domains","parseDomainForChannel","localScaleCmpt","setWithExplicit","parseSelectionDomain","data","isFaceted","facetParent","parent","resolve","scale","domain","value","replace","child","children","selectionExtent","childComponent","undefined","getWithExplicit","domainsTieBreaker","se","get","param","warn","message","NEEDS_SAME_SELECTION","set","normalizeUnaggregatedDomain","fieldDef","scaleType","scaleConfig","valid","reason","canUseUnaggregatedDomain","useUnaggregatedDomain","getScaleComponent","encoding","scaleDomain","typedFieldDef","config","specifiedScales","Object","x2","x","parseSingleChannelDomain","y2","y","mapDomainToDataSignal","type","timeUnit","map","v","signal","convertDomainIfItIsDateTime","normalizedTimeUnit","_a","unit","fieldOrDatumDef","defaultDomain","unionWith","stack","fieldChannel","offset","requestDataName","Main","field","suffix","sort","domainSort","d","datum","aggregate","bin","isBoolean","Raw","binSuffix","op","binSignal","getSignalName","contains","markDef","normalizeSortField","isStackedMeasure","order","replacePathInField","spec","extent","stackDimensions","Set","groupbyFields","stackBy","s","has","fieldDefToSortBy","unaggregateDomainHasNoEffectForRawField","unaggregateDomainWithNonSharedDomainOp","unaggregatedDomainWithLogScale","v1","v2","property","propertyOf","explicit","mergeConflictingDomainProperty","mergeDomains","uniqueDomains","unique","_s","domainWithoutSort","hash","sorts","filter","length","MORE_THAN_ONE_SORT","sortField","unionDomainSorts","domainSortDropped","allData","fields","getFieldFromDomain","nonUnionDomain","FACETED_INDEPENDENT_DIFFERENT_SOURCES","FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES","FACETED_INDEPENDENT_SAME_SOURCE","assembleDomain","scaleComponent","lookupDataSource"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/scale/domain.ts"],"sourcesContent":["import {SignalRef} from 'vega';\nimport {isObject, isString} from 'vega-util';\nimport {\n  Aggregate,\n  isAggregateOp,\n  isArgmaxDef,\n  isArgminDef,\n  MULTIDOMAIN_SORT_OP_INDEX as UNIONDOMAIN_SORT_OP_INDEX,\n  NonArgAggregateOp,\n  SHARED_DOMAIN_OPS\n} from '../../aggregate';\nimport {isBinning, isBinParams, isParameterExtent} from '../../bin';\nimport {getSecondaryRangeChannel, isScaleChannel, ScaleChannel} from '../../channel';\nimport {\n  binRequiresRange,\n  getFieldOrDatumDef,\n  hasBandEnd,\n  isDatumDef,\n  isFieldDef,\n  ScaleDatumDef,\n  ScaleFieldDef,\n  TypedFieldDef,\n  valueExpr,\n  vgField\n} from '../../channeldef';\nimport {CompositeAggregate} from '../../compositemark';\nimport {DataSourceType} from '../../data';\nimport {DateTime} from '../../datetime';\nimport {ExprRef} from '../../expr';\nimport * as log from '../../log';\nimport {Domain, hasDiscreteDomain, isDomainUnionWith, isParameterDomain, ScaleConfig, ScaleType} from '../../scale';\nimport {ParameterExtent} from '../../selection';\nimport {DEFAULT_SORT_OP, EncodingSortField, isSortArray, isSortByEncoding, isSortField} from '../../sort';\nimport {normalizeTimeUnit, TimeUnit, TimeUnitParams} from '../../timeunit';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {\n  isDataRefDomain,\n  isDataRefUnionedDomain,\n  isFieldRefUnionDomain,\n  isSignalRef,\n  VgDomain,\n  VgMultiFieldsRefWithSort,\n  VgNonUnionDomain,\n  VgScaleDataRefWithSort,\n  VgSortField,\n  VgUnionSortField\n} from '../../vega.schema';\nimport {getBinSignalName} from '../data/bin';\nimport {sortArrayIndexField} from '../data/calculate';\nimport {FACET_SCALE_PREFIX} from '../data/optimize';\nimport {isFacetModel, isUnitModel, Model} from '../model';\nimport {SignalRefWrapper} from '../signal';\nimport {Explicit, makeExplicit, makeImplicit, mergeValuesWithExplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponent, ScaleComponentIndex} from './component';\n\nexport function parseScaleDomain(model: Model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleDomain(model);\n  } else {\n    parseNonUnitScaleDomain(model);\n  }\n}\n\nfunction parseUnitScaleDomain(model: UnitModel) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  for (const channel of util.keys(localScaleComponents)) {\n    const domains = parseDomainForChannel(model, channel);\n    const localScaleCmpt = localScaleComponents[channel];\n    localScaleCmpt.setWithExplicit('domains', domains);\n    parseSelectionDomain(model, channel);\n\n    if (model.component.data.isFaceted) {\n      // get resolve from closest facet parent as this decides whether we need to refer to cloned subtree or not\n      let facetParent: Model = model;\n      while (!isFacetModel(facetParent) && facetParent.parent) {\n        facetParent = facetParent.parent;\n      }\n\n      const resolve = facetParent.component.resolve.scale[channel];\n\n      if (resolve === 'shared') {\n        for (const domain of domains.value) {\n          // Replace the scale domain with data output from a cloned subtree after the facet.\n          if (isDataRefDomain(domain)) {\n            // use data from cloned subtree (which is the same as data but with a prefix added once)\n            domain.data = FACET_SCALE_PREFIX + domain.data.replace(FACET_SCALE_PREFIX, '');\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction parseNonUnitScaleDomain(model: Model) {\n  for (const child of model.children) {\n    parseScaleDomain(child);\n  }\n\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  for (const channel of util.keys(localScaleComponents)) {\n    let domains: Explicit<VgNonUnionDomain[]>;\n    let selectionExtent: ParameterExtent = null;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        if (domains === undefined) {\n          domains = childComponent.getWithExplicit('domains');\n        } else {\n          domains = mergeValuesWithExplicit(\n            domains,\n            childComponent.getWithExplicit('domains'),\n            'domains',\n            'scale',\n            domainsTieBreaker\n          );\n        }\n\n        const se = childComponent.get('selectionExtent');\n        if (selectionExtent && se && selectionExtent.param !== se.param) {\n          log.warn(log.message.NEEDS_SAME_SELECTION);\n        }\n        selectionExtent = se;\n      }\n    }\n\n    localScaleComponents[channel].setWithExplicit('domains', domains);\n\n    if (selectionExtent) {\n      localScaleComponents[channel].set('selectionExtent', selectionExtent, true);\n    }\n  }\n}\n\n/**\n * Remove unaggregated domain if it is not applicable\n * Add unaggregated domain if domain is not specified and config.scale.useUnaggregatedDomain is true.\n */\nfunction normalizeUnaggregatedDomain(\n  domain: Domain,\n  fieldDef: TypedFieldDef<string>,\n  scaleType: ScaleType,\n  scaleConfig: ScaleConfig<SignalRef>\n) {\n  if (domain === 'unaggregated') {\n    const {valid, reason} = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if (!valid) {\n      log.warn(reason);\n      return undefined;\n    }\n  } else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n    // Apply config if domain is not specified.\n    const {valid} = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if (valid) {\n      return 'unaggregated';\n    }\n  }\n\n  return domain;\n}\n\nexport function parseDomainForChannel(model: UnitModel, channel: ScaleChannel): Explicit<VgNonUnionDomain[]> {\n  const scaleType = model.getScaleComponent(channel).get('type');\n  const {encoding} = model;\n\n  const domain = normalizeUnaggregatedDomain(\n    model.scaleDomain(channel),\n    model.typedFieldDef(channel),\n    scaleType,\n    model.config.scale\n  );\n  if (domain !== model.scaleDomain(channel)) {\n    model.specifiedScales[channel] = {\n      ...model.specifiedScales[channel],\n      domain\n    };\n  }\n\n  // If channel is either X or Y then union them with X2 & Y2 if they exist\n  if (channel === 'x' && getFieldOrDatumDef(encoding.x2)) {\n    if (getFieldOrDatumDef(encoding.x)) {\n      return mergeValuesWithExplicit(\n        parseSingleChannelDomain(scaleType, domain, model, 'x'),\n        parseSingleChannelDomain(scaleType, domain, model, 'x2'),\n        'domain',\n        'scale',\n        domainsTieBreaker\n      );\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'x2');\n    }\n  } else if (channel === 'y' && getFieldOrDatumDef(encoding.y2)) {\n    if (getFieldOrDatumDef(encoding.y)) {\n      return mergeValuesWithExplicit(\n        parseSingleChannelDomain(scaleType, domain, model, 'y'),\n        parseSingleChannelDomain(scaleType, domain, model, 'y2'),\n        'domain',\n        'scale',\n        domainsTieBreaker\n      );\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'y2');\n    }\n  }\n  return parseSingleChannelDomain(scaleType, domain, model, channel);\n}\n\nfunction mapDomainToDataSignal(\n  domain: (number | string | boolean | DateTime | ExprRef | SignalRef | number[])[],\n  type: Type,\n  timeUnit: TimeUnit\n) {\n  return domain.map(v => {\n    const data = valueExpr(v, {timeUnit, type});\n    return {signal: `{data: ${data}}`};\n  });\n}\n\nfunction convertDomainIfItIsDateTime(\n  domain: (number | string | boolean | DateTime | ExprRef | SignalRef | number[])[],\n  type: Type,\n  timeUnit: TimeUnit | TimeUnitParams\n): [number[]] | [string[]] | [boolean[]] | SignalRef[] {\n  // explicit value\n  const normalizedTimeUnit = normalizeTimeUnit(timeUnit)?.unit;\n  if (type === 'temporal' || normalizedTimeUnit) {\n    return mapDomainToDataSignal(domain, type, normalizedTimeUnit);\n  }\n\n  return [domain] as [number[]] | [string[]] | [boolean[]]; // Date time won't make sense\n}\n\nfunction parseSingleChannelDomain(\n  scaleType: ScaleType,\n  domain: Domain,\n  model: UnitModel,\n  channel: ScaleChannel | 'x2' | 'y2'\n): Explicit<VgNonUnionDomain[]> {\n  const {encoding} = model;\n  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) as ScaleDatumDef<string> | ScaleFieldDef<string>;\n\n  const {type} = fieldOrDatumDef;\n  const timeUnit = fieldOrDatumDef['timeUnit'];\n\n  if (isDomainUnionWith(domain)) {\n    const defaultDomain = parseSingleChannelDomain(scaleType, undefined, model, channel);\n\n    const unionWith = convertDomainIfItIsDateTime(domain.unionWith, type, timeUnit);\n\n    return makeExplicit([...defaultDomain.value, ...unionWith]);\n  } else if (isSignalRef(domain)) {\n    return makeExplicit([domain]);\n  } else if (domain && domain !== 'unaggregated' && !isParameterDomain(domain)) {\n    return makeExplicit(convertDomainIfItIsDateTime(domain, type, timeUnit));\n  }\n\n  const stack = model.stack;\n  if (stack && channel === stack.fieldChannel) {\n    if (stack.offset === 'normalize') {\n      return makeImplicit([[0, 1]]);\n    }\n\n    const data = model.requestDataName(DataSourceType.Main);\n    return makeImplicit([\n      {\n        data,\n        field: model.vgField(channel, {suffix: 'start'})\n      },\n      {\n        data,\n        field: model.vgField(channel, {suffix: 'end'})\n      }\n    ]);\n  }\n\n  const sort: undefined | true | VgSortField =\n    isScaleChannel(channel) && isFieldDef(fieldOrDatumDef) ? domainSort(model, channel, scaleType) : undefined;\n\n  if (isDatumDef(fieldOrDatumDef)) {\n    const d = convertDomainIfItIsDateTime([fieldOrDatumDef.datum], type, timeUnit);\n    return makeImplicit(d);\n  }\n\n  const fieldDef = fieldOrDatumDef; // now we can be sure it's a fieldDef\n  if (domain === 'unaggregated') {\n    const data = model.requestDataName(DataSourceType.Main);\n    const {field} = fieldOrDatumDef;\n    return makeImplicit([\n      {\n        data,\n        field: vgField({field, aggregate: 'min'})\n      },\n      {\n        data,\n        field: vgField({field, aggregate: 'max'})\n      }\n    ]);\n  } else if (isBinning(fieldDef.bin)) {\n    if (hasDiscreteDomain(scaleType)) {\n      if (scaleType === 'bin-ordinal') {\n        // we can omit the domain as it is inferred from the `bins` property\n        return makeImplicit([]);\n      }\n\n      // ordinal bin scale takes domain from bin_range, ordered by bin start\n      // This is useful for both axis-based scale (x/y) and legend-based scale (other channels).\n      return makeImplicit([\n        {\n          // If sort by aggregation of a specified sort field, we need to use RAW table,\n          // so we can aggregate values for the scale independently from the main aggregation.\n          data: util.isBoolean(sort)\n            ? model.requestDataName(DataSourceType.Main)\n            : model.requestDataName(DataSourceType.Raw),\n          // Use range if we added it and the scale does not support computing a range as a signal.\n          field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? {binSuffix: 'range'} : {}),\n          // we have to use a sort object if sort = true to make the sort correct by bin start\n          sort:\n            sort === true || !isObject(sort)\n              ? {\n                  field: model.vgField(channel, {}),\n                  op: 'min' // min or max doesn't matter since we sort by the start of the bin range\n                }\n              : sort\n        }\n      ]);\n    } else {\n      // continuous scales\n      const {bin} = fieldDef;\n      if (isBinning(bin)) {\n        const binSignal = getBinSignalName(model, fieldDef.field, bin);\n        return makeImplicit([\n          new SignalRefWrapper(() => {\n            const signal = model.getSignalName(binSignal);\n            return `[${signal}.start, ${signal}.stop]`;\n          })\n        ]);\n      } else {\n        return makeImplicit([\n          {\n            data: model.requestDataName(DataSourceType.Main),\n            field: model.vgField(channel, {})\n          }\n        ]);\n      }\n    }\n  } else if (\n    fieldDef.timeUnit &&\n    util.contains(['time', 'utc'], scaleType) &&\n    hasBandEnd(\n      fieldDef,\n      isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined,\n      model.markDef,\n      model.config\n    )\n  ) {\n    const data = model.requestDataName(DataSourceType.Main);\n    return makeImplicit([\n      {\n        data,\n        field: model.vgField(channel)\n      },\n      {\n        data,\n        field: model.vgField(channel, {suffix: 'end'})\n      }\n    ]);\n  } else if (sort) {\n    return makeImplicit([\n      {\n        // If sort by aggregation of a specified sort field, we need to use RAW table,\n        // so we can aggregate values for the scale independently from the main aggregation.\n        data: util.isBoolean(sort)\n          ? model.requestDataName(DataSourceType.Main)\n          : model.requestDataName(DataSourceType.Raw),\n        field: model.vgField(channel),\n        sort\n      }\n    ]);\n  } else {\n    return makeImplicit([\n      {\n        data: model.requestDataName(DataSourceType.Main),\n        field: model.vgField(channel)\n      }\n    ]);\n  }\n}\n\nfunction normalizeSortField(sort: EncodingSortField<string>, isStackedMeasure: boolean): VgSortField {\n  const {op, field, order} = sort;\n  return {\n    // Apply default op\n    op: op ?? (isStackedMeasure ? 'sum' : DEFAULT_SORT_OP),\n    // flatten nested fields\n    ...(field ? {field: util.replacePathInField(field)} : {}),\n\n    ...(order ? {order} : {})\n  };\n}\n\nfunction parseSelectionDomain(model: UnitModel, channel: ScaleChannel) {\n  const scale = model.component.scales[channel];\n  const spec = model.specifiedScales[channel].domain;\n  const bin = model.fieldDef(channel)?.bin;\n  const domain = isParameterDomain(spec) && spec;\n  const extent = isBinParams(bin) && isParameterExtent(bin.extent) && bin.extent;\n\n  if (domain || extent) {\n    // As scale parsing occurs before selection parsing, we cannot set\n    // domainRaw directly. So instead, we store the selectionExtent on\n    // the scale component, and then add domainRaw during scale assembly.\n    scale.set('selectionExtent', domain ?? extent, true);\n  }\n}\n\nexport function domainSort(\n  model: UnitModel,\n  channel: ScaleChannel,\n  scaleType: ScaleType\n): undefined | true | VgSortField {\n  if (!hasDiscreteDomain(scaleType)) {\n    return undefined;\n  }\n\n  // save to cast as the only exception is the geojson type for shape, which would not generate a scale\n  const fieldDef = model.fieldDef(channel) as ScaleFieldDef<string>;\n  const sort = fieldDef.sort;\n\n  // if the sort is specified with array, use the derived sort index field\n  if (isSortArray(sort)) {\n    return {\n      op: 'min',\n      field: sortArrayIndexField(fieldDef, channel),\n      order: 'ascending'\n    };\n  }\n\n  const {stack} = model;\n  const stackDimensions = stack\n    ? new Set([...stack.groupbyFields, ...stack.stackBy.map(s => s.fieldDef.field)])\n    : undefined;\n\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n  if (isSortField(sort)) {\n    const isStackedMeasure = stack && !stackDimensions.has(sort.field);\n    return normalizeSortField(sort, isStackedMeasure);\n  } else if (isSortByEncoding(sort)) {\n    const {encoding, order} = sort;\n    const fieldDefToSortBy = model.fieldDef(encoding);\n    const {aggregate, field} = fieldDefToSortBy;\n\n    const isStackedMeasure = stack && !stackDimensions.has(field);\n\n    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n      return normalizeSortField(\n        {\n          field: vgField(fieldDefToSortBy),\n          order\n        },\n        isStackedMeasure\n      );\n    } else if (isAggregateOp(aggregate) || !aggregate) {\n      return normalizeSortField(\n        {\n          op: aggregate as NonArgAggregateOp, // can't be argmin/argmax since we don't support them in encoding field def\n          field,\n          order\n        },\n        isStackedMeasure\n      );\n    }\n  } else if (sort === 'descending') {\n    return {\n      op: 'min',\n      field: model.vgField(channel),\n      order: 'descending'\n    };\n  } else if (util.contains(['ascending', undefined /* default =ascending*/], sort)) {\n    return true;\n  }\n\n  // sort == null\n  return undefined;\n}\n\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditions apply:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nexport function canUseUnaggregatedDomain(\n  fieldDef: TypedFieldDef<string>,\n  scaleType: ScaleType\n): {valid: boolean; reason?: string} {\n  const {aggregate, type} = fieldDef;\n\n  if (!aggregate) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n    };\n  }\n\n  if (isString(aggregate) && !(SHARED_DOMAIN_OPS as Set<Aggregate | CompositeAggregate>).has(aggregate)) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainWithNonSharedDomainOp(aggregate)\n    };\n  }\n\n  if (type === 'quantitative') {\n    if (scaleType === 'log') {\n      return {\n        valid: false,\n        reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n      };\n    }\n  }\n\n  return {valid: true};\n}\n\n/**\n * Tie breaker for mergeValuesWithExplicit for domains. We concat the specified values.\n */\nfunction domainsTieBreaker(\n  v1: Explicit<VgNonUnionDomain[]>,\n  v2: Explicit<VgNonUnionDomain[]>,\n  property: 'domains',\n  propertyOf: 'scale'\n) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingDomainProperty(property, propertyOf, v1.value, v2.value));\n  }\n  // If equal score, concat the domains so that we union them later.\n  return {explicit: v1.explicit, value: [...v1.value, ...v2.value]};\n}\n\n/**\n * Converts an array of domains to a single Vega scale domain.\n */\nexport function mergeDomains(domains: VgNonUnionDomain[]): VgDomain {\n  const uniqueDomains = util.unique(\n    domains.map(domain => {\n      // ignore sort property when computing the unique domains\n      if (isDataRefDomain(domain)) {\n        const {sort: _s, ...domainWithoutSort} = domain;\n        return domainWithoutSort;\n      }\n      return domain;\n    }),\n    util.hash\n  );\n\n  const sorts: VgSortField[] = util.unique(\n    domains\n      .map(d => {\n        if (isDataRefDomain(d)) {\n          const s = d.sort;\n          if (s !== undefined && !util.isBoolean(s)) {\n            if ('op' in s && s.op === 'count') {\n              // let's make sure that if op is count, we don't use a field\n              delete s.field;\n            }\n            if (s.order === 'ascending') {\n              // drop order: ascending as it is the default\n              delete s.order;\n            }\n          }\n          return s;\n        }\n        return undefined;\n      })\n      .filter(s => s !== undefined),\n    util.hash\n  );\n\n  if (uniqueDomains.length === 0) {\n    return undefined;\n  } else if (uniqueDomains.length === 1) {\n    const domain = domains[0];\n    if (isDataRefDomain(domain) && sorts.length > 0) {\n      let sort = sorts[0];\n      if (sorts.length > 1) {\n        log.warn(log.message.MORE_THAN_ONE_SORT);\n        sort = true;\n      } else {\n        // Simplify domain sort by removing field and op when the field is the same as the domain field.\n        if (isObject(sort) && 'field' in sort) {\n          const sortField = sort.field;\n          if (domain.field === sortField) {\n            sort = sort.order ? {order: sort.order} : true;\n          }\n        }\n      }\n      return {\n        ...domain,\n        sort\n      };\n    }\n    return domain;\n  }\n\n  // only keep sort properties that work with unioned domains\n  const unionDomainSorts = util.unique<VgUnionSortField>(\n    sorts.map(s => {\n      if (util.isBoolean(s) || !('op' in s) || (isString(s.op) && s.op in UNIONDOMAIN_SORT_OP_INDEX)) {\n        return s as VgUnionSortField;\n      }\n      log.warn(log.message.domainSortDropped(s));\n      return true;\n    }),\n    util.hash\n  ) as VgUnionSortField[];\n\n  let sort: VgUnionSortField;\n\n  if (unionDomainSorts.length === 1) {\n    sort = unionDomainSorts[0];\n  } else if (unionDomainSorts.length > 1) {\n    log.warn(log.message.MORE_THAN_ONE_SORT);\n    sort = true;\n  }\n\n  const allData = util.unique(\n    domains.map(d => {\n      if (isDataRefDomain(d)) {\n        return d.data;\n      }\n      return null;\n    }),\n    x => x\n  );\n\n  if (allData.length === 1 && allData[0] !== null) {\n    // create a union domain of different fields with a single data source\n    const domain: VgMultiFieldsRefWithSort = {\n      data: allData[0],\n      fields: uniqueDomains.map(d => (d as VgScaleDataRefWithSort).field),\n      ...(sort ? {sort} : {})\n    };\n\n    return domain;\n  }\n\n  return {fields: uniqueDomains, ...(sort ? {sort} : {})};\n}\n\n/**\n * Return a field if a scale uses a single field.\n * Return `undefined` otherwise.\n */\nexport function getFieldFromDomain(domain: VgDomain): string {\n  if (isDataRefDomain(domain) && isString(domain.field)) {\n    return domain.field;\n  } else if (isDataRefUnionedDomain(domain)) {\n    let field;\n    for (const nonUnionDomain of domain.fields) {\n      if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {\n        if (!field) {\n          field = nonUnionDomain.field;\n        } else if (field !== nonUnionDomain.field) {\n          log.warn(log.message.FACETED_INDEPENDENT_DIFFERENT_SOURCES);\n          return field;\n        }\n      }\n    }\n    log.warn(log.message.FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES);\n    return field;\n  } else if (isFieldRefUnionDomain(domain)) {\n    log.warn(log.message.FACETED_INDEPENDENT_SAME_SOURCE);\n    const field = domain.fields[0];\n    return isString(field) ? field : undefined;\n  }\n\n  return undefined;\n}\n\nexport function assembleDomain(model: Model, channel: ScaleChannel) {\n  const scaleComponent: ScaleComponent = model.component.scales[channel];\n\n  const domains = scaleComponent.get('domains').map((domain: VgNonUnionDomain) => {\n    // Correct references to data as the original domain's data was determined\n    // in parseScale, which happens before parseData. Thus the original data\n    // reference can be incorrect.\n    if (isDataRefDomain(domain)) {\n      domain.data = model.lookupDataSource(domain.data);\n    }\n\n    return domain;\n  });\n\n  // domains is an array that has to be merged into a single vega domain\n  return mergeDomains(domains);\n}\n"]},"metadata":{},"sourceType":"module"}