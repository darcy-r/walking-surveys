{"ast":null,"code":"import { array, isArray, isObject, isString } from 'vega-util';\nimport { isBinned } from '../../../bin';\nimport { getMainRangeChannel, isXorY } from '../../../channel';\nimport { defaultTitle, getFieldDef, getFormatMixins, hasConditionalFieldDef, isFieldDef, isTypedFieldDef, vgField } from '../../../channeldef';\nimport { forEach } from '../../../encoding';\nimport { entries } from '../../../util';\nimport { isSignalRef } from '../../../vega.schema';\nimport { getMarkPropOrConfig } from '../../common';\nimport { binFormatExpression, formatSignalRef } from '../../format';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nexport function tooltip(model) {\n  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    encoding,\n    markDef,\n    config,\n    stack\n  } = model;\n  const channelDef = encoding.tooltip;\n\n  if (isArray(channelDef)) {\n    return {\n      tooltip: tooltipRefForEncoding({\n        tooltip: channelDef\n      }, stack, config, opt)\n    };\n  } else {\n    const datum = opt.reactiveGeom ? 'datum.datum' : 'datum';\n    return wrapCondition(model, channelDef, 'tooltip', cDef => {\n      // use valueRef based on channelDef first\n      const tooltipRefFromChannelDef = textRef(cDef, config, datum);\n\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n\n      if (cDef === null) {\n        // Allow using encoding.tooltip = null to disable tooltip\n        return undefined;\n      }\n\n      let markTooltip = getMarkPropOrConfig('tooltip', markDef, config);\n\n      if (markTooltip === true) {\n        markTooltip = {\n          content: 'encoding'\n        };\n      }\n\n      if (isString(markTooltip)) {\n        return {\n          value: markTooltip\n        };\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (isSignalRef(markTooltip)) {\n          return markTooltip;\n        } else if (markTooltip.content === 'encoding') {\n          return tooltipRefForEncoding(encoding, stack, config, opt);\n        } else {\n          return {\n            signal: datum\n          };\n        }\n      }\n\n      return undefined;\n    });\n  }\n}\nexport function tooltipData(encoding, stack, config) {\n  let {\n    reactiveGeom\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const toSkip = {};\n  const expr = reactiveGeom ? 'datum.datum' : 'datum';\n  const tuples = [];\n\n  function add(fDef, channel) {\n    const mainChannel = getMainRangeChannel(channel);\n    const fieldDef = isTypedFieldDef(fDef) ? fDef : Object.assign(Object.assign({}, fDef), {\n      type: encoding[mainChannel].type // for secondary field def, copy type from main channel\n\n    });\n    const title = fieldDef.title || defaultTitle(fieldDef, config);\n    const key = array(title).join(', ');\n    let value;\n\n    if (isXorY(channel)) {\n      const channel2 = channel === 'x' ? 'x2' : 'y2';\n      const fieldDef2 = getFieldDef(encoding[channel2]);\n\n      if (isBinned(fieldDef.bin) && fieldDef2) {\n        const startField = vgField(fieldDef, {\n          expr\n        });\n        const endField = vgField(fieldDef2, {\n          expr\n        });\n        const {\n          format,\n          formatType\n        } = getFormatMixins(fieldDef);\n        value = binFormatExpression(startField, endField, format, formatType, config);\n        toSkip[channel2] = true;\n      } else if (stack && stack.fieldChannel === channel && stack.offset === 'normalize') {\n        const {\n          format,\n          formatType\n        } = getFormatMixins(fieldDef);\n        value = formatSignalRef({\n          fieldOrDatumDef: fieldDef,\n          format,\n          formatType,\n          expr,\n          config,\n          normalizeStack: true\n        }).signal;\n      }\n    }\n\n    value !== null && value !== void 0 ? value : value = textRef(fieldDef, config, expr).signal;\n    tuples.push({\n      channel,\n      key,\n      value\n    });\n  }\n\n  forEach(encoding, (channelDef, channel) => {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n  const out = {};\n\n  for (const {\n    channel,\n    key,\n    value\n  } of tuples) {\n    if (!toSkip[channel] && !out[key]) {\n      out[key] = value;\n    }\n  }\n\n  return out;\n}\nexport function tooltipRefForEncoding(encoding, stack, config) {\n  let {\n    reactiveGeom\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const data = tooltipData(encoding, stack, config, {\n    reactiveGeom\n  });\n  const keyValues = entries(data).map(_ref => {\n    let [key, value] = _ref;\n    return `\"${key}\": ${value}`;\n  });\n  return keyValues.length > 0 ? {\n    signal: `{${keyValues.join(', ')}}`\n  } : undefined;\n}","map":{"version":3,"mappings":"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","names":["array","isArray","isObject","isString","isBinned","getMainRangeChannel","isXorY","defaultTitle","getFieldDef","getFormatMixins","hasConditionalFieldDef","isFieldDef","isTypedFieldDef","vgField","forEach","entries","isSignalRef","getMarkPropOrConfig","binFormatExpression","formatSignalRef","wrapCondition","textRef","tooltip","model","opt","encoding","markDef","config","stack","channelDef","tooltipRefForEncoding","datum","reactiveGeom","cDef","tooltipRefFromChannelDef","undefined","markTooltip","content","value","signal","tooltipData","toSkip","expr","tuples","add","fDef","channel","mainChannel","fieldDef","Object","type","title","key","join","channel2","fieldDef2","bin","startField","endField","format","formatType","fieldChannel","offset","fieldOrDatumDef","normalizeStack","push","condition","out","data","keyValues","map","length"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/mark/encode/tooltip.ts"],"sourcesContent":["import {array, isArray, isObject, isString} from 'vega-util';\nimport {isBinned} from '../../../bin';\nimport {getMainRangeChannel, isXorY, Channel} from '../../../channel';\nimport {\n  defaultTitle,\n  getFieldDef,\n  getFormatMixins,\n  hasConditionalFieldDef,\n  isFieldDef,\n  isTypedFieldDef,\n  SecondaryFieldDef,\n  TypedFieldDef,\n  vgField\n} from '../../../channeldef';\nimport {Config} from '../../../config';\nimport {Encoding, forEach} from '../../../encoding';\nimport {StackProperties} from '../../../stack';\nimport {entries} from '../../../util';\nimport {isSignalRef} from '../../../vega.schema';\nimport {getMarkPropOrConfig} from '../../common';\nimport {binFormatExpression, formatSignalRef} from '../../format';\nimport {UnitModel} from '../../unit';\nimport {wrapCondition} from './conditional';\nimport {textRef} from './text';\n\nexport function tooltip(model: UnitModel, opt: {reactiveGeom?: boolean} = {}) {\n  const {encoding, markDef, config, stack} = model;\n  const channelDef = encoding.tooltip;\n  if (isArray(channelDef)) {\n    return {tooltip: tooltipRefForEncoding({tooltip: channelDef}, stack, config, opt)};\n  } else {\n    const datum = opt.reactiveGeom ? 'datum.datum' : 'datum';\n    return wrapCondition(model, channelDef, 'tooltip', cDef => {\n      // use valueRef based on channelDef first\n      const tooltipRefFromChannelDef = textRef(cDef, config, datum);\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n\n      if (cDef === null) {\n        // Allow using encoding.tooltip = null to disable tooltip\n        return undefined;\n      }\n\n      let markTooltip = getMarkPropOrConfig('tooltip', markDef, config);\n\n      if (markTooltip === true) {\n        markTooltip = {content: 'encoding'};\n      }\n\n      if (isString(markTooltip)) {\n        return {value: markTooltip};\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (isSignalRef(markTooltip)) {\n          return markTooltip;\n        } else if (markTooltip.content === 'encoding') {\n          return tooltipRefForEncoding(encoding, stack, config, opt);\n        } else {\n          return {signal: datum};\n        }\n      }\n\n      return undefined;\n    });\n  }\n}\n\nexport function tooltipData(\n  encoding: Encoding<string>,\n  stack: StackProperties,\n  config: Config,\n  {reactiveGeom}: {reactiveGeom?: boolean} = {}\n) {\n  const toSkip = {};\n  const expr = reactiveGeom ? 'datum.datum' : 'datum';\n  const tuples: {channel: Channel; key: string; value: string}[] = [];\n\n  function add(fDef: TypedFieldDef<string> | SecondaryFieldDef<string>, channel: Channel) {\n    const mainChannel = getMainRangeChannel(channel);\n\n    const fieldDef: TypedFieldDef<string> = isTypedFieldDef(fDef)\n      ? fDef\n      : {\n          ...fDef,\n          type: (encoding[mainChannel] as TypedFieldDef<any>).type // for secondary field def, copy type from main channel\n        };\n\n    const title = fieldDef.title || defaultTitle(fieldDef, config);\n    const key = array(title).join(', ');\n\n    let value: string;\n\n    if (isXorY(channel)) {\n      const channel2 = channel === 'x' ? 'x2' : 'y2';\n      const fieldDef2 = getFieldDef(encoding[channel2]);\n\n      if (isBinned(fieldDef.bin) && fieldDef2) {\n        const startField = vgField(fieldDef, {expr});\n        const endField = vgField(fieldDef2, {expr});\n        const {format, formatType} = getFormatMixins(fieldDef);\n        value = binFormatExpression(startField, endField, format, formatType, config);\n        toSkip[channel2] = true;\n      } else if (stack && stack.fieldChannel === channel && stack.offset === 'normalize') {\n        const {format, formatType} = getFormatMixins(fieldDef);\n        value = formatSignalRef({\n          fieldOrDatumDef: fieldDef,\n          format,\n          formatType,\n          expr,\n          config,\n          normalizeStack: true\n        }).signal;\n      }\n    }\n\n    value ??= textRef(fieldDef, config, expr).signal;\n\n    tuples.push({channel, key, value});\n  }\n\n  forEach(encoding, (channelDef, channel) => {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n\n  const out = {};\n  for (const {channel, key, value} of tuples) {\n    if (!toSkip[channel] && !out[key]) {\n      out[key] = value;\n    }\n  }\n\n  return out;\n}\n\nexport function tooltipRefForEncoding(\n  encoding: Encoding<string>,\n  stack: StackProperties,\n  config: Config,\n  {reactiveGeom}: {reactiveGeom?: boolean} = {}\n) {\n  const data = tooltipData(encoding, stack, config, {reactiveGeom});\n\n  const keyValues = entries(data).map(([key, value]) => `\"${key}\": ${value}`);\n  return keyValues.length > 0 ? {signal: `{${keyValues.join(', ')}}`} : undefined;\n}\n"]},"metadata":{},"sourceType":"module"}