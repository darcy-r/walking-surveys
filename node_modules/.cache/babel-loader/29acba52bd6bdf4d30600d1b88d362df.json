{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { VL_SELECTION_RESOLVE } from '.';\nimport { isScaleChannel } from '../../channel';\nimport * as log from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { isLayerModel } from '../model';\nimport { replacePathInField } from '../../util';\nconst scaleBindings = {\n  defined: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind === 'scales';\n  },\n  parse: (model, selCmpt) => {\n    const bound = selCmpt.scales = [];\n\n    for (const proj of selCmpt.project.items) {\n      const channel = proj.channel;\n\n      if (!isScaleChannel(channel)) {\n        continue;\n      }\n\n      const scale = model.getScaleComponent(channel);\n      const scaleType = scale ? scale.get('type') : undefined;\n\n      if (!scale || !hasContinuousDomain(scaleType)) {\n        log.warn(log.message.SCALE_BINDINGS_CONTINUOUS);\n        continue;\n      }\n\n      scale.set('selectionExtent', {\n        param: selCmpt.name,\n        field: proj.field\n      }, true);\n      bound.push(proj);\n    }\n  },\n  topLevelSignals: (model, selCmpt, signals) => {\n    const bound = selCmpt.scales.filter(proj => signals.filter(s => s.name === proj.signals.data).length === 0); // Top-level signals are only needed for multiview displays and if this\n    // view's top-level signals haven't already been generated.\n\n    if (!model.parent || isTopLevelLayer(model) || bound.length === 0) {\n      return signals;\n    } // vlSelectionResolve does not account for the behavior of bound scales in\n    // multiview displays. Each unit view adds a tuple to the store, but the\n    // state of the selection is the unit selection most recently updated. This\n    // state is captured by the top-level signals that we insert and \"push\n    // outer\" to from within the units. We need to reassemble this state into\n    // the top-level named signal, except no single selCmpt has a global view.\n\n\n    const namedSg = signals.filter(s => s.name === selCmpt.name)[0];\n    let update = namedSg.update;\n\n    if (update.indexOf(VL_SELECTION_RESOLVE) >= 0) {\n      namedSg.update = `{${bound.map(proj => `${stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`).join(', ')}}`;\n    } else {\n      for (const proj of bound) {\n        const mapping = `${stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`;\n\n        if (!update.includes(mapping)) {\n          update = `${update.substring(0, update.length - 1)}, ${mapping}}`;\n        }\n      }\n\n      namedSg.update = update;\n    }\n\n    return signals.concat(bound.map(proj => ({\n      name: proj.signals.data\n    })));\n  },\n  signals: (model, selCmpt, signals) => {\n    // Nested signals need only push to top-level signals with multiview displays.\n    if (model.parent && !isTopLevelLayer(model)) {\n      for (const proj of selCmpt.scales) {\n        const signal = signals.filter(s => s.name === proj.signals.data)[0];\n        signal.push = 'outer';\n        delete signal.value;\n        delete signal.update;\n      }\n    }\n\n    return signals;\n  }\n};\nexport default scaleBindings;\nexport function domain(model, channel) {\n  const scale = stringValue(model.scaleName(channel));\n  return `domain(${scale})`;\n}\n\nfunction isTopLevelLayer(model) {\n  var _a;\n\n  return model.parent && isLayerModel(model.parent) && ((_a = !model.parent.parent) !== null && _a !== void 0 ? _a : isTopLevelLayer(model.parent.parent));\n}","map":{"version":3,"mappings":"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","names":["stringValue","VL_SELECTION_RESOLVE","isScaleChannel","log","hasContinuousDomain","isLayerModel","replacePathInField","scaleBindings","defined","selCmpt","type","resolve","bind","parse","model","bound","scales","proj","project","items","channel","scale","getScaleComponent","scaleType","get","undefined","warn","message","SCALE_BINDINGS_CONTINUOUS","set","param","name","field","push","topLevelSignals","signals","filter","s","data","length","parent","isTopLevelLayer","namedSg","update","indexOf","map","join","mapping","includes","substring","concat","signal","value","domain","scaleName","_a"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/selection/scales.ts"],"sourcesContent":["import {stringValue} from 'vega-util';\nimport {VL_SELECTION_RESOLVE} from '.';\nimport {isScaleChannel, ScaleChannel} from '../../channel';\nimport * as log from '../../log';\nimport {hasContinuousDomain} from '../../scale';\nimport {isLayerModel, Model} from '../model';\nimport {UnitModel} from '../unit';\nimport {SelectionProjection} from './project';\nimport {SelectionCompiler} from '.';\nimport {replacePathInField} from '../../util';\n\nconst scaleBindings: SelectionCompiler<'interval'> = {\n  defined: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind === 'scales';\n  },\n\n  parse: (model, selCmpt) => {\n    const bound: SelectionProjection[] = (selCmpt.scales = []);\n\n    for (const proj of selCmpt.project.items) {\n      const channel = proj.channel;\n\n      if (!isScaleChannel(channel)) {\n        continue;\n      }\n\n      const scale = model.getScaleComponent(channel);\n      const scaleType = scale ? scale.get('type') : undefined;\n\n      if (!scale || !hasContinuousDomain(scaleType)) {\n        log.warn(log.message.SCALE_BINDINGS_CONTINUOUS);\n        continue;\n      }\n\n      scale.set('selectionExtent', {param: selCmpt.name, field: proj.field}, true);\n      bound.push(proj);\n    }\n  },\n\n  topLevelSignals: (model, selCmpt, signals) => {\n    const bound = selCmpt.scales.filter(proj => signals.filter(s => s.name === proj.signals.data).length === 0);\n\n    // Top-level signals are only needed for multiview displays and if this\n    // view's top-level signals haven't already been generated.\n    if (!model.parent || isTopLevelLayer(model) || bound.length === 0) {\n      return signals;\n    }\n\n    // vlSelectionResolve does not account for the behavior of bound scales in\n    // multiview displays. Each unit view adds a tuple to the store, but the\n    // state of the selection is the unit selection most recently updated. This\n    // state is captured by the top-level signals that we insert and \"push\n    // outer\" to from within the units. We need to reassemble this state into\n    // the top-level named signal, except no single selCmpt has a global view.\n    const namedSg = signals.filter(s => s.name === selCmpt.name)[0];\n    let update = namedSg.update;\n    if (update.indexOf(VL_SELECTION_RESOLVE) >= 0) {\n      namedSg.update = `{${bound\n        .map(proj => `${stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`)\n        .join(', ')}}`;\n    } else {\n      for (const proj of bound) {\n        const mapping = `${stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`;\n        if (!update.includes(mapping)) {\n          update = `${update.substring(0, update.length - 1)}, ${mapping}}`;\n        }\n      }\n      namedSg.update = update;\n    }\n\n    return signals.concat(bound.map(proj => ({name: proj.signals.data})));\n  },\n\n  signals: (model, selCmpt, signals) => {\n    // Nested signals need only push to top-level signals with multiview displays.\n    if (model.parent && !isTopLevelLayer(model)) {\n      for (const proj of selCmpt.scales) {\n        const signal: any = signals.filter(s => s.name === proj.signals.data)[0];\n        signal.push = 'outer';\n        delete signal.value;\n        delete signal.update;\n      }\n    }\n\n    return signals;\n  }\n};\n\nexport default scaleBindings;\n\nexport function domain(model: UnitModel, channel: ScaleChannel) {\n  const scale = stringValue(model.scaleName(channel));\n  return `domain(${scale})`;\n}\n\nfunction isTopLevelLayer(model: Model): boolean {\n  return model.parent && isLayerModel(model.parent) && (!model.parent.parent ?? isTopLevelLayer(model.parent.parent));\n}\n"]},"metadata":{},"sourceType":"module"}