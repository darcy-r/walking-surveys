{"ast":null,"code":"import { isArray, isString } from 'vega-util';\nimport { getFieldDef, isFieldDef, vgField } from '../../channeldef';\nimport { duplicate, getFirstDefined, hash } from '../../util';\nimport { sortParams } from '../common';\nimport { DataFlowNode } from './dataflow';\n\nfunction getStackByFields(model) {\n  return model.stack.stackBy.reduce((fields, by) => {\n    const fieldDef = by.fieldDef;\n\n    const _field = vgField(fieldDef);\n\n    if (_field) {\n      fields.push(_field);\n    }\n\n    return fields;\n  }, []);\n}\n\nfunction isValidAsArray(as) {\n  return isArray(as) && as.every(s => isString(s)) && as.length > 1;\n}\n\nexport class StackNode extends DataFlowNode {\n  constructor(parent, stack) {\n    super(parent);\n    this._stack = stack;\n  }\n\n  clone() {\n    return new StackNode(null, duplicate(this._stack));\n  }\n\n  static makeFromTransform(parent, stackTransform) {\n    const {\n      stack,\n      groupby,\n      as,\n      offset = 'zero'\n    } = stackTransform;\n    const sortFields = [];\n    const sortOrder = [];\n\n    if (stackTransform.sort !== undefined) {\n      for (const sortField of stackTransform.sort) {\n        sortFields.push(sortField.field);\n        sortOrder.push(getFirstDefined(sortField.order, 'ascending'));\n      }\n    }\n\n    const sort = {\n      field: sortFields,\n      order: sortOrder\n    };\n    let normalizedAs;\n\n    if (isValidAsArray(as)) {\n      normalizedAs = as;\n    } else if (isString(as)) {\n      normalizedAs = [as, `${as}_end`];\n    } else {\n      normalizedAs = [`${stackTransform.stack}_start`, `${stackTransform.stack}_end`];\n    }\n\n    return new StackNode(parent, {\n      dimensionFieldDefs: [],\n      stackField: stack,\n      groupby,\n      offset,\n      sort,\n      facetby: [],\n      as: normalizedAs\n    });\n  }\n\n  static makeFromEncoding(parent, model) {\n    const stackProperties = model.stack;\n    const {\n      encoding\n    } = model;\n\n    if (!stackProperties) {\n      return null;\n    }\n\n    const {\n      groupbyChannels,\n      fieldChannel,\n      offset,\n      impute\n    } = stackProperties;\n    const dimensionFieldDefs = groupbyChannels.map(groupbyChannel => {\n      const cDef = encoding[groupbyChannel];\n      return getFieldDef(cDef);\n    }).filter(def => !!def);\n    const stackby = getStackByFields(model);\n    const orderDef = model.encoding.order;\n    let sort;\n\n    if (isArray(orderDef) || isFieldDef(orderDef)) {\n      sort = sortParams(orderDef);\n    } else {\n      // default = descending by stackFields\n      // FIXME is the default here correct for binned fields?\n      sort = stackby.reduce((s, field) => {\n        s.field.push(field);\n        s.order.push(fieldChannel === 'y' ? 'descending' : 'ascending');\n        return s;\n      }, {\n        field: [],\n        order: []\n      });\n    }\n\n    return new StackNode(parent, {\n      dimensionFieldDefs,\n      stackField: model.vgField(fieldChannel),\n      facetby: [],\n      stackby,\n      sort,\n      offset,\n      impute,\n      as: [model.vgField(fieldChannel, {\n        suffix: 'start',\n        forAs: true\n      }), model.vgField(fieldChannel, {\n        suffix: 'end',\n        forAs: true\n      })]\n    });\n  }\n\n  get stack() {\n    return this._stack;\n  }\n\n  addDimensions(fields) {\n    this._stack.facetby.push(...fields);\n  }\n\n  dependentFields() {\n    const out = new Set();\n    out.add(this._stack.stackField);\n    this.getGroupbyFields().forEach(out.add, out);\n\n    this._stack.facetby.forEach(out.add, out);\n\n    this._stack.sort.field.forEach(out.add, out);\n\n    return out;\n  }\n\n  producedFields() {\n    return new Set(this._stack.as);\n  }\n\n  hash() {\n    return `Stack ${hash(this._stack)}`;\n  }\n\n  getGroupbyFields() {\n    const {\n      dimensionFieldDefs,\n      impute,\n      groupby\n    } = this._stack;\n\n    if (dimensionFieldDefs.length > 0) {\n      return dimensionFieldDefs.map(dimensionFieldDef => {\n        if (dimensionFieldDef.bin) {\n          if (impute) {\n            // For binned group by field with impute, we calculate bin_mid\n            // as we cannot impute two fields simultaneously\n            return [vgField(dimensionFieldDef, {\n              binSuffix: 'mid'\n            })];\n          }\n\n          return [// For binned group by field without impute, we need both bin (start) and bin_end\n          vgField(dimensionFieldDef, {}), vgField(dimensionFieldDef, {\n            binSuffix: 'end'\n          })];\n        }\n\n        return [vgField(dimensionFieldDef)];\n      }).flat();\n    }\n\n    return groupby !== null && groupby !== void 0 ? groupby : [];\n  }\n\n  assemble() {\n    const transform = [];\n    const {\n      facetby,\n      dimensionFieldDefs,\n      stackField: field,\n      stackby,\n      sort,\n      offset,\n      impute,\n      as\n    } = this._stack; // Impute\n\n    if (impute) {\n      for (const dimensionFieldDef of dimensionFieldDefs) {\n        const {\n          bandPosition = 0.5,\n          bin\n        } = dimensionFieldDef;\n\n        if (bin) {\n          // As we can only impute one field at a time, we need to calculate\n          // mid point for a binned field\n          const binStart = vgField(dimensionFieldDef, {\n            expr: 'datum'\n          });\n          const binEnd = vgField(dimensionFieldDef, {\n            expr: 'datum',\n            binSuffix: 'end'\n          });\n          transform.push({\n            type: 'formula',\n            expr: `${bandPosition}*${binStart}+${1 - bandPosition}*${binEnd}`,\n            as: vgField(dimensionFieldDef, {\n              binSuffix: 'mid',\n              forAs: true\n            })\n          });\n        }\n\n        transform.push({\n          type: 'impute',\n          field,\n          groupby: [...stackby, ...facetby],\n          key: vgField(dimensionFieldDef, {\n            binSuffix: 'mid'\n          }),\n          method: 'value',\n          value: 0\n        });\n      }\n    } // Stack\n\n\n    transform.push({\n      type: 'stack',\n      groupby: [...this.getGroupbyFields(), ...facetby],\n      field,\n      sort,\n      as,\n      offset\n    });\n    return transform;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["isArray","isString","getFieldDef","isFieldDef","vgField","duplicate","getFirstDefined","hash","sortParams","DataFlowNode","getStackByFields","model","stack","stackBy","reduce","fields","by","fieldDef","_field","push","isValidAsArray","as","every","s","length","StackNode","constructor","parent","_stack","clone","makeFromTransform","stackTransform","groupby","offset","sortFields","sortOrder","sort","undefined","sortField","field","order","normalizedAs","dimensionFieldDefs","stackField","facetby","makeFromEncoding","stackProperties","encoding","groupbyChannels","fieldChannel","impute","map","groupbyChannel","cDef","filter","def","stackby","orderDef","suffix","forAs","addDimensions","dependentFields","out","Set","add","getGroupbyFields","forEach","producedFields","dimensionFieldDef","bin","binSuffix","flat","assemble","transform","bandPosition","binStart","expr","binEnd","type","key","method","value"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/data/stack.ts"],"sourcesContent":["import {Transforms as VgTransform} from 'vega';\nimport {isArray, isString} from 'vega-util';\nimport {FieldDef, FieldName, getFieldDef, isFieldDef, vgField} from '../../channeldef';\nimport {SortFields, SortOrder} from '../../sort';\nimport {StackOffset} from '../../stack';\nimport {StackTransform} from '../../transform';\nimport {duplicate, getFirstDefined, hash} from '../../util';\nimport {sortParams} from '../common';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\nfunction getStackByFields(model: UnitModel): string[] {\n  return model.stack.stackBy.reduce((fields, by) => {\n    const fieldDef = by.fieldDef;\n\n    const _field = vgField(fieldDef);\n    if (_field) {\n      fields.push(_field);\n    }\n    return fields;\n  }, [] as string[]);\n}\n\nexport interface StackComponent {\n  /**\n   * Faceted field.\n   */\n  facetby: string[];\n\n  dimensionFieldDefs: FieldDef<string>[];\n\n  /**\n   * Stack measure's field. Used in makeFromEncoding.\n   */\n  stackField: string;\n\n  /**\n   * Level of detail fields for each level in the stacked charts such as color or detail.\n   * Used in makeFromEncoding.\n   */\n  stackby?: string[];\n\n  /**\n   * Field that determines order of levels in the stacked charts.\n   * Used in both but optional in transform.\n   */\n  sort: SortFields;\n\n  /** Mode for stacking marks.\n   */\n  offset: StackOffset;\n\n  /**\n   * Whether to impute the data before stacking. Used only in makeFromEncoding.\n   */\n  impute?: boolean;\n\n  /**\n   * The data fields to group by.\n   */\n  groupby?: FieldName[];\n  /**\n   * Output field names of each stack field.\n   */\n  as: [FieldName, FieldName];\n}\n\nfunction isValidAsArray(as: string[] | string): as is string[] {\n  return isArray(as) && as.every(s => isString(s)) && as.length > 1;\n}\n\nexport class StackNode extends DataFlowNode {\n  private _stack: StackComponent;\n\n  public clone() {\n    return new StackNode(null, duplicate(this._stack));\n  }\n\n  constructor(parent: DataFlowNode, stack: StackComponent) {\n    super(parent);\n\n    this._stack = stack;\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, stackTransform: StackTransform) {\n    const {stack, groupby, as, offset = 'zero'} = stackTransform;\n\n    const sortFields: string[] = [];\n    const sortOrder: SortOrder[] = [];\n    if (stackTransform.sort !== undefined) {\n      for (const sortField of stackTransform.sort) {\n        sortFields.push(sortField.field);\n        sortOrder.push(getFirstDefined(sortField.order, 'ascending'));\n      }\n    }\n    const sort: SortFields = {\n      field: sortFields,\n      order: sortOrder\n    };\n    let normalizedAs: [string, string];\n    if (isValidAsArray(as)) {\n      normalizedAs = as;\n    } else if (isString(as)) {\n      normalizedAs = [as, `${as}_end`];\n    } else {\n      normalizedAs = [`${stackTransform.stack}_start`, `${stackTransform.stack}_end`];\n    }\n\n    return new StackNode(parent, {\n      dimensionFieldDefs: [],\n      stackField: stack,\n      groupby,\n      offset,\n      sort,\n      facetby: [],\n      as: normalizedAs\n    });\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: UnitModel) {\n    const stackProperties = model.stack;\n    const {encoding} = model;\n\n    if (!stackProperties) {\n      return null;\n    }\n\n    const {groupbyChannels, fieldChannel, offset, impute} = stackProperties;\n\n    const dimensionFieldDefs = groupbyChannels\n      .map(groupbyChannel => {\n        const cDef = encoding[groupbyChannel];\n        return getFieldDef(cDef);\n      })\n      .filter(def => !!def);\n\n    const stackby = getStackByFields(model);\n    const orderDef = model.encoding.order;\n\n    let sort: SortFields;\n    if (isArray(orderDef) || isFieldDef(orderDef)) {\n      sort = sortParams(orderDef);\n    } else {\n      // default = descending by stackFields\n      // FIXME is the default here correct for binned fields?\n      sort = stackby.reduce(\n        (s, field) => {\n          s.field.push(field);\n          s.order.push(fieldChannel === 'y' ? 'descending' : 'ascending');\n          return s;\n        },\n        {field: [], order: []}\n      );\n    }\n\n    return new StackNode(parent, {\n      dimensionFieldDefs,\n      stackField: model.vgField(fieldChannel),\n      facetby: [],\n      stackby,\n      sort,\n      offset,\n      impute,\n      as: [\n        model.vgField(fieldChannel, {suffix: 'start', forAs: true}),\n        model.vgField(fieldChannel, {suffix: 'end', forAs: true})\n      ]\n    });\n  }\n\n  get stack(): StackComponent {\n    return this._stack;\n  }\n\n  public addDimensions(fields: string[]) {\n    this._stack.facetby.push(...fields);\n  }\n\n  public dependentFields() {\n    const out = new Set<string>();\n\n    out.add(this._stack.stackField);\n\n    this.getGroupbyFields().forEach(out.add, out);\n    this._stack.facetby.forEach(out.add, out);\n    this._stack.sort.field.forEach(out.add, out);\n\n    return out;\n  }\n\n  public producedFields() {\n    return new Set(this._stack.as);\n  }\n\n  public hash() {\n    return `Stack ${hash(this._stack)}`;\n  }\n\n  private getGroupbyFields() {\n    const {dimensionFieldDefs, impute, groupby} = this._stack;\n\n    if (dimensionFieldDefs.length > 0) {\n      return dimensionFieldDefs\n        .map(dimensionFieldDef => {\n          if (dimensionFieldDef.bin) {\n            if (impute) {\n              // For binned group by field with impute, we calculate bin_mid\n              // as we cannot impute two fields simultaneously\n              return [vgField(dimensionFieldDef, {binSuffix: 'mid'})];\n            }\n            return [\n              // For binned group by field without impute, we need both bin (start) and bin_end\n              vgField(dimensionFieldDef, {}),\n              vgField(dimensionFieldDef, {binSuffix: 'end'})\n            ];\n          }\n          return [vgField(dimensionFieldDef)];\n        })\n        .flat();\n    }\n    return groupby ?? [];\n  }\n\n  public assemble(): VgTransform[] {\n    const transform: VgTransform[] = [];\n    const {facetby, dimensionFieldDefs, stackField: field, stackby, sort, offset, impute, as} = this._stack;\n\n    // Impute\n    if (impute) {\n      for (const dimensionFieldDef of dimensionFieldDefs) {\n        const {bandPosition = 0.5, bin} = dimensionFieldDef;\n        if (bin) {\n          // As we can only impute one field at a time, we need to calculate\n          // mid point for a binned field\n\n          const binStart = vgField(dimensionFieldDef, {expr: 'datum'});\n          const binEnd = vgField(dimensionFieldDef, {expr: 'datum', binSuffix: 'end'});\n          transform.push({\n            type: 'formula',\n            expr: `${bandPosition}*${binStart}+${1 - bandPosition}*${binEnd}`,\n            as: vgField(dimensionFieldDef, {binSuffix: 'mid', forAs: true})\n          });\n        }\n\n        transform.push({\n          type: 'impute',\n          field,\n          groupby: [...stackby, ...facetby],\n          key: vgField(dimensionFieldDef, {binSuffix: 'mid'}),\n          method: 'value',\n          value: 0\n        });\n      }\n    }\n\n    // Stack\n    transform.push({\n      type: 'stack',\n      groupby: [...this.getGroupbyFields(), ...facetby],\n      field,\n      sort,\n      as,\n      offset\n    });\n\n    return transform;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}