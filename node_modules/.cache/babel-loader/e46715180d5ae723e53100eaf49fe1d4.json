{"ast":null,"code":"import { array } from 'vega-util';\nimport { isQuantitative } from '../../scale';\nimport { keys, titleCase } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getStyleConfig, signalOrStringValue } from '../common';\n\nfunction getAxisConfigFromConfigTypes(configTypes, config, channel, orient) {\n  // TODO: add special casing to add conditional value based on orient signal\n  return Object.assign.apply(null, [{}, ...configTypes.map(configType => {\n    if (configType === 'axisOrient') {\n      const orient1 = channel === 'x' ? 'bottom' : 'left';\n      const orientConfig1 = config[channel === 'x' ? 'axisBottom' : 'axisLeft'] || {};\n      const orientConfig2 = config[channel === 'x' ? 'axisTop' : 'axisRight'] || {};\n      const props = new Set([...keys(orientConfig1), ...keys(orientConfig2)]);\n      const conditionalOrientAxisConfig = {};\n\n      for (const prop of props.values()) {\n        conditionalOrientAxisConfig[prop] = {\n          // orient is surely signal in this case\n          signal: `${orient['signal']} === \"${orient1}\" ? ${signalOrStringValue(orientConfig1[prop])} : ${signalOrStringValue(orientConfig2[prop])}`\n        };\n      }\n\n      return conditionalOrientAxisConfig;\n    }\n\n    return config[configType];\n  })]);\n}\n\nexport function getAxisConfigs(channel, scaleType, orient, config) {\n  const typeBasedConfigTypes = scaleType === 'band' ? ['axisDiscrete', 'axisBand'] : scaleType === 'point' ? ['axisDiscrete', 'axisPoint'] : isQuantitative(scaleType) ? ['axisQuantitative'] : scaleType === 'time' || scaleType === 'utc' ? ['axisTemporal'] : [];\n  const axisChannel = channel === 'x' ? 'axisX' : 'axisY';\n  const axisOrient = isSignalRef(orient) ? 'axisOrient' : `axis${titleCase(orient)}`; // axisTop, axisBottom, ...\n\n  const vlOnlyConfigTypes = [// technically Vega does have axisBand, but if we make another separation here,\n  // it will further introduce complexity in the code\n  ...typeBasedConfigTypes, ...typeBasedConfigTypes.map(c => axisChannel + c.substr(4))];\n  const vgConfigTypes = ['axis', axisOrient, axisChannel];\n  return {\n    vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config, channel, orient),\n    vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config, channel, orient),\n    axisConfigStyle: getAxisConfigStyle([...vgConfigTypes, ...vlOnlyConfigTypes], config)\n  };\n}\nexport function getAxisConfigStyle(axisConfigTypes, config) {\n  var _a;\n\n  const toMerge = [{}];\n\n  for (const configType of axisConfigTypes) {\n    // TODO: add special casing to add conditional value based on orient signal\n    let style = (_a = config[configType]) === null || _a === void 0 ? void 0 : _a.style;\n\n    if (style) {\n      style = array(style);\n\n      for (const s of style) {\n        toMerge.push(config.style[s]);\n      }\n    }\n  }\n\n  return Object.assign.apply(null, toMerge);\n}\nexport function getAxisConfig(property, styleConfigIndex, style) {\n  let axisConfigs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var _a;\n\n  const styleConfig = getStyleConfig(property, style, styleConfigIndex);\n\n  if (styleConfig !== undefined) {\n    return {\n      configFrom: 'style',\n      configValue: styleConfig\n    };\n  }\n\n  for (const configFrom of ['vlOnlyAxisConfig', 'vgAxisConfig', 'axisConfigStyle']) {\n    if (((_a = axisConfigs[configFrom]) === null || _a === void 0 ? void 0 : _a[property]) !== undefined) {\n      return {\n        configFrom,\n        configValue: axisConfigs[configFrom][property]\n      };\n    }\n  }\n\n  return {};\n}","map":{"version":3,"mappings":"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","names":["array","isQuantitative","keys","titleCase","isSignalRef","getStyleConfig","signalOrStringValue","getAxisConfigFromConfigTypes","configTypes","config","channel","orient","Object","assign","apply","map","configType","orient1","orientConfig1","orientConfig2","props","Set","conditionalOrientAxisConfig","prop","values","signal","getAxisConfigs","scaleType","typeBasedConfigTypes","axisChannel","axisOrient","vlOnlyConfigTypes","c","substr","vgConfigTypes","vlOnlyAxisConfig","vgAxisConfig","axisConfigStyle","getAxisConfigStyle","axisConfigTypes","toMerge","style","_a","s","push","getAxisConfig","property","styleConfigIndex","axisConfigs","styleConfig","undefined","configFrom","configValue"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/axis/config.ts"],"sourcesContent":["import {ScaleType, SignalRef} from 'vega';\nimport {array} from 'vega-util';\nimport {AxisConfig} from '../../axis';\nimport {PositionScaleChannel} from '../../channel';\nimport {Config, StyleConfigIndex} from '../../config';\nimport {isQuantitative} from '../../scale';\nimport {keys, titleCase} from '../../util';\nimport {isSignalRef} from '../../vega.schema';\nimport {getStyleConfig, signalOrStringValue} from '../common';\n\nfunction getAxisConfigFromConfigTypes(\n  configTypes: string[],\n  config: Config,\n  channel: 'x' | 'y',\n  orient: string | SignalRef\n) {\n  // TODO: add special casing to add conditional value based on orient signal\n  return Object.assign.apply(null, [\n    {},\n    ...configTypes.map(configType => {\n      if (configType === 'axisOrient') {\n        const orient1 = channel === 'x' ? 'bottom' : 'left';\n        const orientConfig1 = config[channel === 'x' ? 'axisBottom' : 'axisLeft'] || {};\n        const orientConfig2 = config[channel === 'x' ? 'axisTop' : 'axisRight'] || {};\n\n        const props = new Set([...keys(orientConfig1), ...keys(orientConfig2)]);\n\n        const conditionalOrientAxisConfig = {};\n        for (const prop of props.values()) {\n          conditionalOrientAxisConfig[prop] = {\n            // orient is surely signal in this case\n            signal: `${orient['signal']} === \"${orient1}\" ? ${signalOrStringValue(\n              orientConfig1[prop]\n            )} : ${signalOrStringValue(orientConfig2[prop])}`\n          };\n        }\n\n        return conditionalOrientAxisConfig;\n      }\n\n      return config[configType];\n    })\n  ]);\n}\n\nexport type AxisConfigs = ReturnType<typeof getAxisConfigs>;\n\nexport function getAxisConfigs(\n  channel: PositionScaleChannel,\n  scaleType: ScaleType,\n  orient: string | SignalRef,\n  config: Config\n) {\n  const typeBasedConfigTypes =\n    scaleType === 'band'\n      ? ['axisDiscrete', 'axisBand']\n      : scaleType === 'point'\n      ? ['axisDiscrete', 'axisPoint']\n      : isQuantitative(scaleType)\n      ? ['axisQuantitative']\n      : scaleType === 'time' || scaleType === 'utc'\n      ? ['axisTemporal']\n      : [];\n\n  const axisChannel = channel === 'x' ? 'axisX' : 'axisY';\n  const axisOrient = isSignalRef(orient) ? 'axisOrient' : `axis${titleCase(orient)}`; // axisTop, axisBottom, ...\n\n  const vlOnlyConfigTypes = [\n    // technically Vega does have axisBand, but if we make another separation here,\n    // it will further introduce complexity in the code\n    ...typeBasedConfigTypes,\n    ...typeBasedConfigTypes.map(c => axisChannel + c.substr(4))\n  ];\n\n  const vgConfigTypes = ['axis', axisOrient, axisChannel];\n\n  return {\n    vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config, channel, orient),\n    vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config, channel, orient),\n    axisConfigStyle: getAxisConfigStyle([...vgConfigTypes, ...vlOnlyConfigTypes], config)\n  };\n}\n\nexport function getAxisConfigStyle(axisConfigTypes: string[], config: Config) {\n  const toMerge = [{}];\n  for (const configType of axisConfigTypes) {\n    // TODO: add special casing to add conditional value based on orient signal\n    let style = config[configType]?.style;\n    if (style) {\n      style = array(style);\n      for (const s of style) {\n        toMerge.push(config.style[s]);\n      }\n    }\n  }\n  return Object.assign.apply(null, toMerge);\n}\nexport function getAxisConfig(\n  property: keyof AxisConfig<SignalRef>,\n  styleConfigIndex: StyleConfigIndex<SignalRef>,\n  style: string | string[],\n  axisConfigs: Partial<AxisConfigs> = {}\n): {configFrom?: string; configValue?: any} {\n  const styleConfig = getStyleConfig(property, style, styleConfigIndex);\n\n  if (styleConfig !== undefined) {\n    return {\n      configFrom: 'style',\n      configValue: styleConfig\n    };\n  }\n\n  for (const configFrom of ['vlOnlyAxisConfig', 'vgAxisConfig', 'axisConfigStyle']) {\n    if (axisConfigs[configFrom]?.[property] !== undefined) {\n      return {configFrom, configValue: axisConfigs[configFrom][property]};\n    }\n  }\n  return {};\n}\n"]},"metadata":{},"sourceType":"module"}