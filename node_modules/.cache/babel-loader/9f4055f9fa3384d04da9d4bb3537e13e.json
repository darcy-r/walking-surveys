{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { title as fieldDefTitle } from '../../channeldef';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { assembleAxis } from '../axis/assemble';\nimport { parseGuideResolve } from '../resolve';\nimport { getHeaderProperty } from './common';\nexport function getHeaderType(orient) {\n  if (orient === 'top' || orient === 'left' || isSignalRef(orient)) {\n    // we always use header for orient signal since we can't dynamically make header becomes footer\n    return 'header';\n  }\n\n  return 'footer';\n}\nexport function parseFacetHeaders(model) {\n  for (const channel of FACET_CHANNELS) {\n    parseFacetHeader(model, channel);\n  }\n\n  mergeChildAxis(model, 'x');\n  mergeChildAxis(model, 'y');\n}\n\nfunction parseFacetHeader(model, channel) {\n  var _a;\n\n  const {\n    facet,\n    config,\n    child,\n    component\n  } = model;\n\n  if (model.channelHasField(channel)) {\n    const fieldDef = facet[channel];\n    const titleConfig = getHeaderProperty('title', null, config, channel);\n    let title = fieldDefTitle(fieldDef, config, {\n      allowDisabling: true,\n      includeDefault: titleConfig === undefined || !!titleConfig\n    });\n\n    if (child.component.layoutHeaders[channel].title) {\n      // TODO: better handle multiline titles\n      title = isArray(title) ? title.join(', ') : title; // merge title with child to produce \"Title / Subtitle / Sub-subtitle\"\n\n      title += ` / ${child.component.layoutHeaders[channel].title}`;\n      child.component.layoutHeaders[channel].title = null;\n    }\n\n    const labelOrient = getHeaderProperty('labelOrient', fieldDef.header, config, channel);\n    const labels = fieldDef.header !== null ? getFirstDefined((_a = fieldDef.header) === null || _a === void 0 ? void 0 : _a.labels, config.header.labels, true) : false;\n    const headerType = contains(['bottom', 'right'], labelOrient) ? 'footer' : 'header';\n    component.layoutHeaders[channel] = {\n      title: fieldDef.header !== null ? title : null,\n      facetFieldDef: fieldDef,\n      [headerType]: channel === 'facet' ? [] : [makeHeaderComponent(model, channel, labels)]\n    };\n  }\n}\n\nfunction makeHeaderComponent(model, channel, labels) {\n  const sizeType = channel === 'row' ? 'height' : 'width';\n  return {\n    labels,\n    sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : undefined,\n    axes: []\n  };\n}\n\nfunction mergeChildAxis(model, channel) {\n  var _a;\n\n  const {\n    child\n  } = model;\n\n  if (child.component.axes[channel]) {\n    const {\n      layoutHeaders,\n      resolve\n    } = model.component;\n    resolve.axis[channel] = parseGuideResolve(resolve, channel);\n\n    if (resolve.axis[channel] === 'shared') {\n      // For shared axis, move the axes to facet's header or footer\n      const headerChannel = channel === 'x' ? 'column' : 'row';\n      const layoutHeader = layoutHeaders[headerChannel];\n\n      for (const axisComponent of child.component.axes[channel]) {\n        const headerType = getHeaderType(axisComponent.get('orient'));\n        (_a = layoutHeader[headerType]) !== null && _a !== void 0 ? _a : layoutHeader[headerType] = [makeHeaderComponent(model, headerChannel, false)]; // FIXME: assemble shouldn't be called here, but we do it this way so we only extract the main part of the axes\n\n        const mainAxis = assembleAxis(axisComponent, 'main', model.config, {\n          header: true\n        });\n\n        if (mainAxis) {\n          // LayoutHeader no longer keep track of property precedence, thus let's combine.\n          layoutHeader[headerType][0].axes.push(mainAxis);\n        }\n\n        axisComponent.mainExtracted = true;\n      }\n    } else {// Otherwise do nothing for independent axes\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["isArray","FACET_CHANNELS","title","fieldDefTitle","contains","getFirstDefined","isSignalRef","assembleAxis","parseGuideResolve","getHeaderProperty","getHeaderType","orient","parseFacetHeaders","model","channel","parseFacetHeader","mergeChildAxis","facet","config","child","component","channelHasField","fieldDef","titleConfig","allowDisabling","includeDefault","undefined","layoutHeaders","join","labelOrient","header","labels","_a","headerType","facetFieldDef","makeHeaderComponent","sizeType","sizeSignal","layoutSize","get","getSizeSignalRef","axes","resolve","axis","headerChannel","layoutHeader","axisComponent","mainAxis","push","mainExtracted"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/header/parse.ts"],"sourcesContent":["import {AxisOrient, SignalRef} from 'vega';\nimport {isArray} from 'vega-util';\nimport {FacetChannel, FACET_CHANNELS} from '../../channel';\nimport {title as fieldDefTitle} from '../../channeldef';\nimport {contains, getFirstDefined} from '../../util';\nimport {isSignalRef} from '../../vega.schema';\nimport {assembleAxis} from '../axis/assemble';\nimport {FacetModel} from '../facet';\nimport {parseGuideResolve} from '../resolve';\nimport {getHeaderProperty} from './common';\nimport {HeaderChannel, HeaderComponent} from './component';\n\nexport function getHeaderType(orient: AxisOrient | SignalRef) {\n  if (orient === 'top' || orient === 'left' || isSignalRef(orient)) {\n    // we always use header for orient signal since we can't dynamically make header becomes footer\n    return 'header';\n  }\n  return 'footer';\n}\n\nexport function parseFacetHeaders(model: FacetModel) {\n  for (const channel of FACET_CHANNELS) {\n    parseFacetHeader(model, channel);\n  }\n\n  mergeChildAxis(model, 'x');\n  mergeChildAxis(model, 'y');\n}\n\nfunction parseFacetHeader(model: FacetModel, channel: FacetChannel) {\n  const {facet, config, child, component} = model;\n  if (model.channelHasField(channel)) {\n    const fieldDef = facet[channel];\n    const titleConfig = getHeaderProperty('title', null, config, channel);\n    let title = fieldDefTitle(fieldDef, config, {\n      allowDisabling: true,\n      includeDefault: titleConfig === undefined || !!titleConfig\n    });\n\n    if (child.component.layoutHeaders[channel].title) {\n      // TODO: better handle multiline titles\n      title = isArray(title) ? title.join(', ') : title;\n\n      // merge title with child to produce \"Title / Subtitle / Sub-subtitle\"\n      title += ` / ${child.component.layoutHeaders[channel].title}`;\n      child.component.layoutHeaders[channel].title = null;\n    }\n\n    const labelOrient = getHeaderProperty('labelOrient', fieldDef.header, config, channel);\n\n    const labels =\n      fieldDef.header !== null ? getFirstDefined(fieldDef.header?.labels, config.header.labels, true) : false;\n    const headerType = contains(['bottom', 'right'], labelOrient) ? 'footer' : 'header';\n\n    component.layoutHeaders[channel] = {\n      title: fieldDef.header !== null ? title : null,\n      facetFieldDef: fieldDef,\n      [headerType]: channel === 'facet' ? [] : [makeHeaderComponent(model, channel, labels)]\n    };\n  }\n}\n\nfunction makeHeaderComponent(model: FacetModel, channel: HeaderChannel, labels: boolean): HeaderComponent {\n  const sizeType = channel === 'row' ? 'height' : 'width';\n\n  return {\n    labels,\n    sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : undefined,\n    axes: []\n  };\n}\n\nfunction mergeChildAxis(model: FacetModel, channel: 'x' | 'y') {\n  const {child} = model;\n  if (child.component.axes[channel]) {\n    const {layoutHeaders, resolve} = model.component;\n    resolve.axis[channel] = parseGuideResolve(resolve, channel);\n\n    if (resolve.axis[channel] === 'shared') {\n      // For shared axis, move the axes to facet's header or footer\n      const headerChannel = channel === 'x' ? 'column' : 'row';\n\n      const layoutHeader = layoutHeaders[headerChannel];\n      for (const axisComponent of child.component.axes[channel]) {\n        const headerType = getHeaderType(axisComponent.get('orient'));\n        layoutHeader[headerType] ??= [makeHeaderComponent(model, headerChannel, false)];\n\n        // FIXME: assemble shouldn't be called here, but we do it this way so we only extract the main part of the axes\n        const mainAxis = assembleAxis(axisComponent, 'main', model.config, {header: true});\n        if (mainAxis) {\n          // LayoutHeader no longer keep track of property precedence, thus let's combine.\n          layoutHeader[headerType][0].axes.push(mainAxis);\n        }\n        axisComponent.mainExtracted = true;\n      }\n    } else {\n      // Otherwise do nothing for independent axes\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}