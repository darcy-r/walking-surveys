{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { LEGEND_SCALE_CHANNELS } from '../../legend';\nimport { keys, replaceAll, stringify, vals } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeLegendComponent } from './parse';\n\nfunction setLegendEncode(legend, part, vgProp, vgRef) {\n  var _a, _b, _c;\n\n  var _d, _e;\n\n  (_a = legend.encode) !== null && _a !== void 0 ? _a : legend.encode = {};\n  (_b = (_d = legend.encode)[part]) !== null && _b !== void 0 ? _b : _d[part] = {};\n  (_c = (_e = legend.encode[part]).update) !== null && _c !== void 0 ? _c : _e.update = {}; // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n\n  legend.encode[part].update[vgProp] = vgRef;\n}\n\nexport function assembleLegends(model) {\n  const legendComponentIndex = model.component.legends;\n  const legendByDomain = {};\n\n  for (const channel of keys(legendComponentIndex)) {\n    const scaleComponent = model.getScaleComponent(channel);\n    const domainHash = stringify(scaleComponent.get('domains'));\n\n    if (legendByDomain[domainHash]) {\n      for (const mergedLegendComponent of legendByDomain[domainHash]) {\n        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);\n\n        if (!merged) {\n          // If cannot merge, need to add this legend separately\n          legendByDomain[domainHash].push(legendComponentIndex[channel]);\n        }\n      }\n    } else {\n      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];\n    }\n  }\n\n  const legends = vals(legendByDomain).flat().map(l => assembleLegend(l, model.config)).filter(l => l !== undefined);\n  return legends;\n}\nexport function assembleLegend(legendCmpt, config) {\n  var _a, _b, _c;\n\n  const _d = legendCmpt.combine(),\n        {\n    disable,\n    labelExpr,\n    selections\n  } = _d,\n        legend = __rest(_d, [\"disable\", \"labelExpr\", \"selections\"]);\n\n  if (disable) {\n    return undefined;\n  }\n\n  if (config.aria === false && legend.aria == undefined) {\n    legend.aria = false;\n  }\n\n  if ((_a = legend.encode) === null || _a === void 0 ? void 0 : _a.symbols) {\n    const out = legend.encode.symbols.update;\n\n    if (out.fill && out.fill['value'] !== 'transparent' && !out.stroke && !legend.stroke) {\n      // For non color channel's legend, we need to override symbol stroke config from Vega config if stroke channel is not used.\n      out.stroke = {\n        value: 'transparent'\n      };\n    } // Remove properties that the legend is encoding.\n\n\n    for (const property of LEGEND_SCALE_CHANNELS) {\n      if (legend[property]) {\n        delete out[property];\n      }\n    }\n  }\n\n  if (!legend.title) {\n    // title schema doesn't include null, ''\n    delete legend.title;\n  }\n\n  if (labelExpr !== undefined) {\n    let expr = labelExpr;\n\n    if (((_c = (_b = legend.encode) === null || _b === void 0 ? void 0 : _b.labels) === null || _c === void 0 ? void 0 : _c.update) && isSignalRef(legend.encode.labels.update.text)) {\n      expr = replaceAll(labelExpr, 'datum.label', legend.encode.labels.update.text.signal);\n    }\n\n    setLegendEncode(legend, 'labels', 'text', {\n      signal: expr\n    });\n  }\n\n  return legend;\n}","map":{"version":3,"mappings":";;;;;;;;;;;AAEA,SAAQA,qBAAR,QAAoC,cAApC;AACA,SAAQC,IAAR,EAAcC,UAAd,EAA0BC,SAA1B,EAAqCC,IAArC,QAAgD,YAAhD;AACA,SAAQC,WAAR,QAAuD,mBAAvD;AAGA,SAAQC,oBAAR,QAAmC,SAAnC;;AAEA,SAASC,eAAT,CACEC,MADF,EAEEC,IAFF,EAGEC,MAHF,EAIEC,KAJF,EAIkC;;;;;EAEhC,YAAM,CAACC,MAAP,MAAa,IAAb,IAAaC,aAAb,GAAaA,EAAb,SAAM,CAACD,MAAP,GAAkB,EAAlB;EACA,kBAAM,CAACA,MAAP,EAAcH,IAAd,OAAkB,IAAlB,IAAkBK,aAAlB,GAAkBA,EAAlB,GAAkBC,GAAJN,IAAI,IAAM,EAAxB;EACA,kBAAM,CAACG,MAAP,CAAcH,IAAd,GAAoBO,MAApB,MAA0B,IAA1B,IAA0BC,aAA1B,GAA0BA,EAA1B,GAA0BC,GAANF,MAAM,GAAK,EAA/B,CAJgC,CAKhC;;EACCR,MAAM,CAACI,MAAP,CAAcH,IAAd,EAAoBO,MAApB,CAA2BN,MAA3B,IAA6CC,KAA7C;AACF;;AAED,OAAM,SAAUQ,eAAV,CAA0BC,KAA1B,EAAsC;EAC1C,MAAMC,oBAAoB,GAAGD,KAAK,CAACE,SAAN,CAAgBC,OAA7C;EACA,MAAMC,cAAc,GAAsC,EAA1D;;EAEA,KAAK,MAAMC,OAAX,IAAsBxB,IAAI,CAACoB,oBAAD,CAA1B,EAAkD;IAChD,MAAMK,cAAc,GAAGN,KAAK,CAACO,iBAAN,CAAwBF,OAAxB,CAAvB;IACA,MAAMG,UAAU,GAAGzB,SAAS,CAACuB,cAAc,CAACG,GAAf,CAAmB,SAAnB,CAAD,CAA5B;;IACA,IAAIL,cAAc,CAACI,UAAD,CAAlB,EAAgC;MAC9B,KAAK,MAAME,qBAAX,IAAoCN,cAAc,CAACI,UAAD,CAAlD,EAAgE;QAC9D,MAAMG,MAAM,GAAGzB,oBAAoB,CAACwB,qBAAD,EAAwBT,oBAAoB,CAACI,OAAD,CAA5C,CAAnC;;QACA,IAAI,CAACM,MAAL,EAAa;UACX;UACAP,cAAc,CAACI,UAAD,CAAd,CAA2BI,IAA3B,CAAgCX,oBAAoB,CAACI,OAAD,CAApD;QACD;MACF;IACF,CARD,MAQO;MACLD,cAAc,CAACI,UAAD,CAAd,GAA6B,CAACP,oBAAoB,CAACI,OAAD,CAApB,CAA8BQ,KAA9B,EAAD,CAA7B;IACD;EACF;;EAED,MAAMV,OAAO,GAAGnB,IAAI,CAACoB,cAAD,CAAJ,CACbU,IADa,GAEbC,GAFa,CAETC,CAAC,IAAIC,cAAc,CAACD,CAAD,EAAIhB,KAAK,CAACkB,MAAV,CAFV,EAGbC,MAHa,CAGNH,CAAC,IAAIA,CAAC,KAAKI,SAHL,CAAhB;EAKA,OAAOjB,OAAP;AACD;AAED,OAAM,SAAUc,cAAV,CAAyBI,UAAzB,EAAsDH,MAAtD,EAAoE;;;EACxE,MAAMvB,KAA8C0B,UAAU,CAACC,OAAX,EAApD;EAAA,MAAM;IAACC,OAAD;IAAUC,SAAV;IAAqBC;EAArB,IAA+B9B,EAArC;EAAA,MAA0CP,MAAM,cAA1C,sCAA0C,CAAhD;;EAEA,IAAImC,OAAJ,EAAa;IACX,OAAOH,SAAP;EACD;;EAED,IAAIF,MAAM,CAACQ,IAAP,KAAgB,KAAhB,IAAyBtC,MAAM,CAACsC,IAAP,IAAeN,SAA5C,EAAuD;IACrDhC,MAAM,CAACsC,IAAP,GAAc,KAAd;EACD;;EAED,IAAI,YAAM,CAAClC,MAAP,MAAa,IAAb,IAAaC,aAAb,GAAa,MAAb,GAAaA,GAAEkC,OAAnB,EAA4B;IAC1B,MAAMC,GAAG,GAAGxC,MAAM,CAACI,MAAP,CAAcmC,OAAd,CAAsB/B,MAAlC;;IACA,IAAIgC,GAAG,CAACC,IAAJ,IAAYD,GAAG,CAACC,IAAJ,CAAS,OAAT,MAAsB,aAAlC,IAAmD,CAACD,GAAG,CAACE,MAAxD,IAAkE,CAAC1C,MAAM,CAAC0C,MAA9E,EAAsF;MACpF;MACAF,GAAG,CAACE,MAAJ,GAAa;QAACC,KAAK,EAAE;MAAR,CAAb;IACD,CALyB,CAO1B;;;IACA,KAAK,MAAMC,QAAX,IAAuBpD,qBAAvB,EAA8C;MAC5C,IAAIQ,MAAM,CAAC4C,QAAD,CAAV,EAAsB;QACpB,OAAOJ,GAAG,CAACI,QAAD,CAAV;MACD;IACF;EACF;;EAED,IAAI,CAAC5C,MAAM,CAAC6C,KAAZ,EAAmB;IACjB;IACA,OAAO7C,MAAM,CAAC6C,KAAd;EACD;;EAED,IAAIT,SAAS,KAAKJ,SAAlB,EAA6B;IAC3B,IAAIc,IAAI,GAAGV,SAAX;;IACA,IAAI,mBAAM,CAAChC,MAAP,MAAa,IAAb,IAAaE,aAAb,GAAa,MAAb,GAAaA,GAAEyC,MAAf,MAAqB,IAArB,IAAqBtC,aAArB,GAAqB,MAArB,GAAqBA,GAAED,MAAvB,KAAiCX,WAAW,CAACG,MAAM,CAACI,MAAP,CAAc2C,MAAd,CAAqBvC,MAArB,CAA4BwC,IAA7B,CAAhD,EAAoF;MAClFF,IAAI,GAAGpD,UAAU,CAAC0C,SAAD,EAAY,aAAZ,EAA2BpC,MAAM,CAACI,MAAP,CAAc2C,MAAd,CAAqBvC,MAArB,CAA4BwC,IAA5B,CAAiCC,MAA5D,CAAjB;IACD;;IACDlD,eAAe,CAACC,MAAD,EAAS,QAAT,EAAmB,MAAnB,EAA2B;MAACiD,MAAM,EAAEH;IAAT,CAA3B,CAAf;EACD;;EAED,OAAO9C,MAAP;AACD","names":["LEGEND_SCALE_CHANNELS","keys","replaceAll","stringify","vals","isSignalRef","mergeLegendComponent","setLegendEncode","legend","part","vgProp","vgRef","encode","_a","_b","_d","update","_c","_e","assembleLegends","model","legendComponentIndex","component","legends","legendByDomain","channel","scaleComponent","getScaleComponent","domainHash","get","mergedLegendComponent","merged","push","clone","flat","map","l","assembleLegend","config","filter","undefined","legendCmpt","combine","disable","labelExpr","selections","aria","symbols","out","fill","stroke","value","property","title","expr","labels","text","signal"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/legend/assemble.ts"],"sourcesContent":["import {Legend as VgLegend, LegendEncode} from 'vega';\nimport {Config} from '../../config';\nimport {LEGEND_SCALE_CHANNELS} from '../../legend';\nimport {keys, replaceAll, stringify, vals} from '../../util';\nimport {isSignalRef, VgEncodeChannel, VgValueRef} from '../../vega.schema';\nimport {Model} from '../model';\nimport {LegendComponent} from './component';\nimport {mergeLegendComponent} from './parse';\n\nfunction setLegendEncode(\n  legend: VgLegend,\n  part: keyof LegendEncode,\n  vgProp: VgEncodeChannel,\n  vgRef: VgValueRef | VgValueRef[]\n) {\n  legend.encode ??= {};\n  legend.encode[part] ??= {};\n  legend.encode[part].update ??= {};\n  // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n  (legend.encode[part].update[vgProp] as any) = vgRef;\n}\n\nexport function assembleLegends(model: Model): VgLegend[] {\n  const legendComponentIndex = model.component.legends;\n  const legendByDomain: Record<string, LegendComponent[]> = {};\n\n  for (const channel of keys(legendComponentIndex)) {\n    const scaleComponent = model.getScaleComponent(channel);\n    const domainHash = stringify(scaleComponent.get('domains'));\n    if (legendByDomain[domainHash]) {\n      for (const mergedLegendComponent of legendByDomain[domainHash]) {\n        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);\n        if (!merged) {\n          // If cannot merge, need to add this legend separately\n          legendByDomain[domainHash].push(legendComponentIndex[channel]);\n        }\n      }\n    } else {\n      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];\n    }\n  }\n\n  const legends = vals(legendByDomain)\n    .flat()\n    .map(l => assembleLegend(l, model.config))\n    .filter(l => l !== undefined);\n\n  return legends;\n}\n\nexport function assembleLegend(legendCmpt: LegendComponent, config: Config) {\n  const {disable, labelExpr, selections, ...legend} = legendCmpt.combine();\n\n  if (disable) {\n    return undefined;\n  }\n\n  if (config.aria === false && legend.aria == undefined) {\n    legend.aria = false;\n  }\n\n  if (legend.encode?.symbols) {\n    const out = legend.encode.symbols.update;\n    if (out.fill && out.fill['value'] !== 'transparent' && !out.stroke && !legend.stroke) {\n      // For non color channel's legend, we need to override symbol stroke config from Vega config if stroke channel is not used.\n      out.stroke = {value: 'transparent'};\n    }\n\n    // Remove properties that the legend is encoding.\n    for (const property of LEGEND_SCALE_CHANNELS) {\n      if (legend[property]) {\n        delete out[property];\n      }\n    }\n  }\n\n  if (!legend.title) {\n    // title schema doesn't include null, ''\n    delete legend.title;\n  }\n\n  if (labelExpr !== undefined) {\n    let expr = labelExpr;\n    if (legend.encode?.labels?.update && isSignalRef(legend.encode.labels.update.text)) {\n      expr = replaceAll(labelExpr, 'datum.label', legend.encode.labels.update.text.signal);\n    }\n    setLegendEncode(legend, 'labels', 'text', {signal: expr});\n  }\n\n  return legend;\n}\n"]},"metadata":{},"sourceType":"module"}