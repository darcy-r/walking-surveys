{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isString, mergeConfig } from 'vega-util';\nimport { getPositionScaleChannel } from '../channel';\nimport * as vlFieldDef from '../channeldef';\nimport { initConfig, stripAndRedirectConfig } from '../config';\nimport * as log from '../log';\nimport { normalize } from '../normalize';\nimport { assembleParameterSignals } from '../parameter';\nimport { extractTopLevelProperties, getFitType, isFitType } from '../spec/toplevel';\nimport { keys } from '../util';\nimport { buildModel } from './buildmodel';\nimport { assembleRootData } from './data/assemble';\nimport { optimizeDataflow } from './data/optimize';\n/**\n * Vega-Lite's main function, for compiling Vega-Lite spec into Vega spec.\n *\n * At a high-level, we make the following transformations in different phases:\n *\n * Input spec\n *     |\n *     |  (Normalization)\n *     v\n * Normalized Spec (Row/Column channels in single-view specs becomes faceted specs, composite marks becomes layered specs.)\n *     |\n *     |  (Build Model)\n *     v\n * A model tree of the spec\n *     |\n *     |  (Parse)\n *     v\n * A model tree with parsed components (intermediate structure of visualization primitives in a format that can be easily merged)\n *     |\n *     | (Optimize)\n *     v\n * A model tree with parsed components with the data component optimized\n *     |\n *     | (Assemble)\n *     v\n * Vega spec\n *\n * @param inputSpec The Vega-Lite specification.\n * @param opt       Optional arguments passed to the Vega-Lite compiler.\n * @returns         An object containing the compiled Vega spec and normalized Vega-Lite spec.\n */\n\nexport function compile(inputSpec) {\n  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  // 0. Augment opt with default opts\n  if (opt.logger) {\n    // set the singleton logger to the provided logger\n    log.set(opt.logger);\n  }\n\n  if (opt.fieldTitle) {\n    // set the singleton field title formatter\n    vlFieldDef.setTitleFormatter(opt.fieldTitle);\n  }\n\n  try {\n    // 1. Initialize config by deep merging default config with the config provided via option and the input spec.\n    const config = initConfig(mergeConfig(opt.config, inputSpec.config)); // 2. Normalize: Convert input spec -> normalized spec\n    // - Decompose all extended unit specs into composition of unit spec. For example, a box plot get expanded into multiple layers of bars, ticks, and rules. The shorthand row/column channel is also expanded to a facet spec.\n    // - Normalize autosize and width or height spec\n\n    const spec = normalize(inputSpec, config); // 3. Build Model: normalized spec -> Model (a tree structure)\n    // This phases instantiates the models with default config by doing a top-down traversal. This allows us to pass properties that child models derive from their parents via their constructors.\n    // See the abstract `Model` class and its children (UnitModel, LayerModel, FacetModel, ConcatModel) for different types of models.\n\n    const model = buildModel(spec, null, '', undefined, config); // 4 Parse: Model --> Model with components\n    // Note that components = intermediate representations that are equivalent to Vega specs.\n    // We need these intermediate representation because we need to merge many visualization \"components\" like projections, scales, axes, and legends.\n    // We will later convert these components into actual Vega specs in the assemble phase.\n    // In this phase, we do a bottom-up traversal over the whole tree to\n    // parse for each type of components once (e.g., data, layout, mark, scale).\n    // By doing bottom-up traversal, we start parsing components of unit specs and\n    // then merge child components of parent composite specs.\n    //\n    // Please see inside model.parse() for order of different components parsed.\n\n    model.parse(); // drawDataflow(model.component.data.sources);\n    // 5. Optimize the dataflow. This will modify the data component of the model.\n\n    optimizeDataflow(model.component.data, model); // drawDataflow(model.component.data.sources);\n    // 6. Assemble: convert model components --> Vega Spec.\n\n    const vgSpec = assembleTopLevelModel(model, getTopLevelProperties(inputSpec, spec.autosize, config, model), inputSpec.datasets, inputSpec.usermeta);\n    return {\n      spec: vgSpec,\n      normalized: spec\n    };\n  } finally {\n    // Reset the singleton logger if a logger is provided\n    if (opt.logger) {\n      log.reset();\n    } // Reset the singleton field title formatter if provided\n\n\n    if (opt.fieldTitle) {\n      vlFieldDef.resetTitleFormatter();\n    }\n  }\n}\n\nfunction getTopLevelProperties(inputSpec, autosize, config, model) {\n  const width = model.component.layoutSize.get('width');\n  const height = model.component.layoutSize.get('height');\n\n  if (autosize === undefined) {\n    autosize = {\n      type: 'pad'\n    };\n\n    if (model.hasAxisOrientSignalRef()) {\n      autosize.resize = true;\n    }\n  } else if (isString(autosize)) {\n    autosize = {\n      type: autosize\n    };\n  }\n\n  if (width && height && isFitType(autosize.type)) {\n    if (width === 'step' && height === 'step') {\n      log.warn(log.message.droppingFit());\n      autosize.type = 'pad';\n    } else if (width === 'step' || height === 'step') {\n      // effectively XOR, because else if\n      // get step dimension\n      const sizeType = width === 'step' ? 'width' : 'height'; // log that we're dropping fit for respective channel\n\n      log.warn(log.message.droppingFit(getPositionScaleChannel(sizeType))); // setting type to inverse fit (so if we dropped fit-x, type is now fit-y)\n\n      const inverseSizeType = sizeType === 'width' ? 'height' : 'width';\n      autosize.type = getFitType(inverseSizeType);\n    }\n  }\n\n  return Object.assign(Object.assign(Object.assign({}, keys(autosize).length === 1 && autosize.type ? autosize.type === 'pad' ? {} : {\n    autosize: autosize.type\n  } : {\n    autosize\n  }), extractTopLevelProperties(config, false)), extractTopLevelProperties(inputSpec, true));\n}\n/*\n * Assemble the top-level model to a Vega spec.\n *\n * Note: this couldn't be `model.assemble()` since the top-level model\n * needs some special treatment to generate top-level properties.\n */\n\n\nfunction assembleTopLevelModel(model, topLevelProperties) {\n  let datasets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let usermeta = arguments.length > 3 ? arguments[3] : undefined;\n  // Config with Vega-Lite only config removed.\n  const vgConfig = model.config ? stripAndRedirectConfig(model.config) : undefined;\n  const data = [].concat(model.assembleSelectionData([]), // only assemble data in the root\n  assembleRootData(model.component.data, datasets));\n  const projections = model.assembleProjections();\n  const title = model.assembleTitle();\n  const style = model.assembleGroupStyle();\n  const encodeEntry = model.assembleGroupEncodeEntry(true);\n  let layoutSignals = model.assembleLayoutSignals(); // move width and height signals with values to top level\n\n  layoutSignals = layoutSignals.filter(signal => {\n    if ((signal.name === 'width' || signal.name === 'height') && signal.value !== undefined) {\n      topLevelProperties[signal.name] = +signal.value;\n      return false;\n    }\n\n    return true;\n  });\n\n  const {\n    params\n  } = topLevelProperties,\n        otherTopLevelProps = __rest(topLevelProperties, [\"params\"]);\n\n  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n    $schema: 'https://vega.github.io/schema/vega/v5.json'\n  }, model.description ? {\n    description: model.description\n  } : {}), otherTopLevelProps), title ? {\n    title\n  } : {}), style ? {\n    style\n  } : {}), encodeEntry ? {\n    encode: {\n      update: encodeEntry\n    }\n  } : {}), {\n    data\n  }), projections.length > 0 ? {\n    projections\n  } : {}), model.assembleGroup([...layoutSignals, ...model.assembleSelectionTopLevelSignals([]), ...assembleParameterSignals(params)])), vgConfig ? {\n    config: vgConfig\n  } : {}), usermeta ? {\n    usermeta\n  } : {});\n}","map":{"version":3,"mappings":"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","names":["isString","mergeConfig","getPositionScaleChannel","vlFieldDef","initConfig","stripAndRedirectConfig","log","normalize","assembleParameterSignals","extractTopLevelProperties","getFitType","isFitType","keys","buildModel","assembleRootData","optimizeDataflow","compile","inputSpec","opt","logger","set","fieldTitle","setTitleFormatter","config","spec","model","undefined","parse","component","data","vgSpec","assembleTopLevelModel","getTopLevelProperties","autosize","datasets","usermeta","normalized","reset","resetTitleFormatter","width","layoutSize","get","height","type","hasAxisOrientSignalRef","resize","warn","message","droppingFit","sizeType","inverseSizeType","length","topLevelProperties","vgConfig","concat","assembleSelectionData","projections","assembleProjections","title","assembleTitle","style","assembleGroupStyle","encodeEntry","assembleGroupEncodeEntry","layoutSignals","assembleLayoutSignals","filter","signal","name","value","params","otherTopLevelProps","$schema","description","encode","update","assembleGroup","assembleSelectionTopLevelSignals"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/compile.ts"],"sourcesContent":["import {AutoSizeType, LoggerInterface, Spec as VgSpec} from 'vega';\nimport {isString, mergeConfig} from 'vega-util';\nimport {getPositionScaleChannel} from '../channel';\nimport * as vlFieldDef from '../channeldef';\nimport {Config, initConfig, stripAndRedirectConfig} from '../config';\nimport * as log from '../log';\nimport {normalize} from '../normalize';\nimport {assembleParameterSignals} from '../parameter';\nimport {LayoutSizeMixins, TopLevel, TopLevelSpec} from '../spec';\nimport {\n  AutoSizeParams,\n  Datasets,\n  extractTopLevelProperties,\n  getFitType,\n  isFitType,\n  TopLevelProperties\n} from '../spec/toplevel';\nimport {Dict, keys} from '../util';\nimport {buildModel} from './buildmodel';\nimport {assembleRootData} from './data/assemble';\nimport {optimizeDataflow} from './data/optimize';\nimport {Model} from './model';\n\nexport interface CompileOptions {\n  /**\n   * Sets a Vega-Lite configuration.\n   */\n  config?: Config;\n\n  /**\n   * Sets a custom logger.\n   */\n  logger?: LoggerInterface;\n\n  /**\n   * Sets a field title formatter.\n   */\n  fieldTitle?: vlFieldDef.FieldTitleFormatter;\n}\n\n/**\n * Vega-Lite's main function, for compiling Vega-Lite spec into Vega spec.\n *\n * At a high-level, we make the following transformations in different phases:\n *\n * Input spec\n *     |\n *     |  (Normalization)\n *     v\n * Normalized Spec (Row/Column channels in single-view specs becomes faceted specs, composite marks becomes layered specs.)\n *     |\n *     |  (Build Model)\n *     v\n * A model tree of the spec\n *     |\n *     |  (Parse)\n *     v\n * A model tree with parsed components (intermediate structure of visualization primitives in a format that can be easily merged)\n *     |\n *     | (Optimize)\n *     v\n * A model tree with parsed components with the data component optimized\n *     |\n *     | (Assemble)\n *     v\n * Vega spec\n *\n * @param inputSpec The Vega-Lite specification.\n * @param opt       Optional arguments passed to the Vega-Lite compiler.\n * @returns         An object containing the compiled Vega spec and normalized Vega-Lite spec.\n */\nexport function compile(inputSpec: TopLevelSpec, opt: CompileOptions = {}) {\n  // 0. Augment opt with default opts\n  if (opt.logger) {\n    // set the singleton logger to the provided logger\n    log.set(opt.logger);\n  }\n\n  if (opt.fieldTitle) {\n    // set the singleton field title formatter\n    vlFieldDef.setTitleFormatter(opt.fieldTitle);\n  }\n\n  try {\n    // 1. Initialize config by deep merging default config with the config provided via option and the input spec.\n    const config = initConfig(mergeConfig(opt.config, inputSpec.config));\n\n    // 2. Normalize: Convert input spec -> normalized spec\n\n    // - Decompose all extended unit specs into composition of unit spec. For example, a box plot get expanded into multiple layers of bars, ticks, and rules. The shorthand row/column channel is also expanded to a facet spec.\n    // - Normalize autosize and width or height spec\n    const spec = normalize(inputSpec, config);\n\n    // 3. Build Model: normalized spec -> Model (a tree structure)\n\n    // This phases instantiates the models with default config by doing a top-down traversal. This allows us to pass properties that child models derive from their parents via their constructors.\n    // See the abstract `Model` class and its children (UnitModel, LayerModel, FacetModel, ConcatModel) for different types of models.\n    const model: Model = buildModel(spec, null, '', undefined, config);\n\n    // 4 Parse: Model --> Model with components\n\n    // Note that components = intermediate representations that are equivalent to Vega specs.\n    // We need these intermediate representation because we need to merge many visualization \"components\" like projections, scales, axes, and legends.\n    // We will later convert these components into actual Vega specs in the assemble phase.\n\n    // In this phase, we do a bottom-up traversal over the whole tree to\n    // parse for each type of components once (e.g., data, layout, mark, scale).\n    // By doing bottom-up traversal, we start parsing components of unit specs and\n    // then merge child components of parent composite specs.\n    //\n    // Please see inside model.parse() for order of different components parsed.\n    model.parse();\n\n    // drawDataflow(model.component.data.sources);\n\n    // 5. Optimize the dataflow. This will modify the data component of the model.\n    optimizeDataflow(model.component.data, model);\n\n    // drawDataflow(model.component.data.sources);\n\n    // 6. Assemble: convert model components --> Vega Spec.\n    const vgSpec = assembleTopLevelModel(\n      model,\n      getTopLevelProperties(inputSpec, spec.autosize, config, model),\n      inputSpec.datasets,\n      inputSpec.usermeta\n    );\n\n    return {\n      spec: vgSpec,\n      normalized: spec\n    };\n  } finally {\n    // Reset the singleton logger if a logger is provided\n    if (opt.logger) {\n      log.reset();\n    }\n    // Reset the singleton field title formatter if provided\n    if (opt.fieldTitle) {\n      vlFieldDef.resetTitleFormatter();\n    }\n  }\n}\n\nfunction getTopLevelProperties(\n  inputSpec: TopLevel<any>,\n  autosize: AutoSizeType | AutoSizeParams,\n  config: Config,\n  model: Model\n) {\n  const width = model.component.layoutSize.get('width');\n  const height = model.component.layoutSize.get('height');\n  if (autosize === undefined) {\n    autosize = {type: 'pad'};\n    if (model.hasAxisOrientSignalRef()) {\n      autosize.resize = true;\n    }\n  } else if (isString(autosize)) {\n    autosize = {type: autosize};\n  }\n  if (width && height && isFitType(autosize.type)) {\n    if (width === 'step' && height === 'step') {\n      log.warn(log.message.droppingFit());\n      autosize.type = 'pad';\n    } else if (width === 'step' || height === 'step') {\n      // effectively XOR, because else if\n\n      // get step dimension\n      const sizeType = width === 'step' ? 'width' : 'height';\n      // log that we're dropping fit for respective channel\n      log.warn(log.message.droppingFit(getPositionScaleChannel(sizeType)));\n\n      // setting type to inverse fit (so if we dropped fit-x, type is now fit-y)\n      const inverseSizeType = sizeType === 'width' ? 'height' : 'width';\n      autosize.type = getFitType(inverseSizeType);\n    }\n  }\n\n  return {\n    ...(keys(autosize).length === 1 && autosize.type\n      ? autosize.type === 'pad'\n        ? {}\n        : {autosize: autosize.type}\n      : {autosize}),\n    ...extractTopLevelProperties(config, false),\n    ...extractTopLevelProperties(inputSpec, true)\n  };\n}\n\n/*\n * Assemble the top-level model to a Vega spec.\n *\n * Note: this couldn't be `model.assemble()` since the top-level model\n * needs some special treatment to generate top-level properties.\n */\nfunction assembleTopLevelModel(\n  model: Model,\n  topLevelProperties: TopLevelProperties & LayoutSizeMixins,\n  datasets: Datasets = {},\n  usermeta: Dict<any>\n): VgSpec {\n  // Config with Vega-Lite only config removed.\n  const vgConfig = model.config ? stripAndRedirectConfig(model.config) : undefined;\n\n  const data = [].concat(\n    model.assembleSelectionData([]),\n    // only assemble data in the root\n    assembleRootData(model.component.data, datasets)\n  );\n\n  const projections = model.assembleProjections();\n  const title = model.assembleTitle();\n  const style = model.assembleGroupStyle();\n  const encodeEntry = model.assembleGroupEncodeEntry(true);\n\n  let layoutSignals = model.assembleLayoutSignals();\n\n  // move width and height signals with values to top level\n  layoutSignals = layoutSignals.filter(signal => {\n    if ((signal.name === 'width' || signal.name === 'height') && signal.value !== undefined) {\n      topLevelProperties[signal.name] = +signal.value;\n      return false;\n    }\n    return true;\n  });\n\n  const {params, ...otherTopLevelProps} = topLevelProperties;\n\n  return {\n    $schema: 'https://vega.github.io/schema/vega/v5.json',\n    ...(model.description ? {description: model.description} : {}),\n    ...otherTopLevelProps,\n    ...(title ? {title} : {}),\n    ...(style ? {style} : {}),\n    ...(encodeEntry ? {encode: {update: encodeEntry}} : {}),\n    data,\n    ...(projections.length > 0 ? {projections} : {}),\n    ...model.assembleGroup([\n      ...layoutSignals,\n      ...model.assembleSelectionTopLevelSignals([]),\n      ...assembleParameterSignals(params)\n    ]),\n    ...(vgConfig ? {config: vgConfig} : {}),\n    ...(usermeta ? {usermeta} : {})\n  };\n}\n"]},"metadata":{},"sourceType":"module"}