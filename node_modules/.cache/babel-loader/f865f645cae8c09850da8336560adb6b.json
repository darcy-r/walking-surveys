{"ast":null,"code":"import { isFunction, isString } from 'vega-util';\nimport { isCountingAggregateOp } from '../../../aggregate';\nimport { isBinned, isBinning } from '../../../bin';\nimport { getMainRangeChannel, X, X2, Y2 } from '../../../channel';\nimport { binRequiresRange, getBandPosition, isDatumDef, isFieldDef, isFieldOrDatumDef, isTypedFieldDef, isValueDef, vgField } from '../../../channeldef';\nimport { dateTimeToExpr, isDateTime } from '../../../datetime';\nimport { isExprRef } from '../../../expr';\nimport * as log from '../../../log';\nimport { isPathMark } from '../../../mark';\nimport { fieldValidPredicate } from '../../../predicate';\nimport { hasDiscreteDomain, isContinuousToContinuous } from '../../../scale';\nimport { TEMPORAL } from '../../../type';\nimport { contains, stringify } from '../../../util';\nimport { isSignalRef } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nexport function midPointRefWithPositionInvalidTest(params) {\n  const {\n    channel,\n    channelDef,\n    markDef,\n    scale,\n    config\n  } = params;\n  const ref = midPoint(params); // Wrap to check if the positional value is invalid, if so, plot the point on the min value\n\n  if ( // Only this for field def without counting aggregate (as count wouldn't be null)\n  isFieldDef(channelDef) && !isCountingAggregateOp(channelDef.aggregate) && // and only for continuous scale\n  scale && isContinuousToContinuous(scale.get('type'))) {\n    return wrapPositionInvalidTest({\n      fieldDef: channelDef,\n      channel,\n      markDef,\n      ref,\n      config\n    });\n  }\n\n  return ref;\n}\nexport function wrapPositionInvalidTest(_ref) {\n  let {\n    fieldDef,\n    channel,\n    markDef,\n    ref,\n    config\n  } = _ref;\n\n  if (isPathMark(markDef.type)) {\n    // path mark already use defined to skip points, no need to do it here.\n    return ref;\n  }\n\n  const invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid === null) {\n    // if there is no invalid filter, don't do the invalid test\n    return [fieldInvalidTestValueRef(fieldDef, channel), ref];\n  }\n\n  return ref;\n}\nexport function fieldInvalidTestValueRef(fieldDef, channel) {\n  const test = fieldInvalidPredicate(fieldDef, true);\n  const mainChannel = getMainRangeChannel(channel); // we can cast here as the output can't be other things.\n\n  const zeroValueRef = mainChannel === 'y' ? {\n    field: {\n      group: 'height'\n    }\n  } : // x / angle / radius can all use 0\n  {\n    value: 0\n  };\n  return Object.assign({\n    test\n  }, zeroValueRef);\n}\nexport function fieldInvalidPredicate(field) {\n  let invalid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return fieldValidPredicate(isString(field) ? field : vgField(field, {\n    expr: 'datum'\n  }), !invalid);\n}\nexport function datumDefToExpr(datumDef) {\n  const {\n    datum\n  } = datumDef;\n\n  if (isDateTime(datum)) {\n    return dateTimeToExpr(datum);\n  }\n\n  return `${stringify(datum)}`;\n}\nexport function valueRefForFieldOrDatumDef(fieldDef, scaleName, opt, encode) {\n  const ref = {};\n\n  if (scaleName) {\n    ref.scale = scaleName;\n  }\n\n  if (isDatumDef(fieldDef)) {\n    const {\n      datum\n    } = fieldDef;\n\n    if (isDateTime(datum)) {\n      ref.signal = dateTimeToExpr(datum);\n    } else if (isSignalRef(datum)) {\n      ref.signal = datum.signal;\n    } else if (isExprRef(datum)) {\n      ref.signal = datum.expr;\n    } else {\n      ref.value = datum;\n    }\n  } else {\n    ref.field = vgField(fieldDef, opt);\n  }\n\n  if (encode) {\n    const {\n      offset,\n      band\n    } = encode;\n\n    if (offset) {\n      ref.offset = offset;\n    }\n\n    if (band) {\n      ref.band = band;\n    }\n  }\n\n  return ref;\n}\n/**\n * Signal that returns the middle of a bin from start and end field. Should only be used with x and y.\n */\n\nexport function interpolatedSignalRef(_ref2) {\n  let {\n    scaleName,\n    fieldOrDatumDef,\n    fieldOrDatumDef2,\n    offset,\n    startSuffix,\n    bandPosition = 0.5\n  } = _ref2;\n  const expr = 0 < bandPosition && bandPosition < 1 ? 'datum' : undefined;\n  const start = vgField(fieldOrDatumDef, {\n    expr,\n    suffix: startSuffix\n  });\n  const end = fieldOrDatumDef2 !== undefined ? vgField(fieldOrDatumDef2, {\n    expr\n  }) : vgField(fieldOrDatumDef, {\n    suffix: 'end',\n    expr\n  });\n  const ref = {};\n\n  if (bandPosition === 0 || bandPosition === 1) {\n    ref.scale = scaleName;\n    const val = bandPosition === 0 ? start : end;\n    ref.field = val;\n  } else {\n    const datum = isSignalRef(bandPosition) ? `${bandPosition.signal} * ${start} + (1-${bandPosition.signal}) * ${end}` : `${bandPosition} * ${start} + ${1 - bandPosition} * ${end}`;\n    ref.signal = `scale(\"${scaleName}\", ${datum})`;\n  }\n\n  if (offset) {\n    ref.offset = offset;\n  }\n\n  return ref;\n}\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\n\nexport function midPoint(_ref3) {\n  let {\n    channel,\n    channelDef,\n    channel2Def,\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef,\n    bandPosition\n  } = _ref3;\n\n  var _a; // TODO: datum support\n\n\n  if (channelDef) {\n    /* istanbul ignore else */\n    if (isFieldOrDatumDef(channelDef)) {\n      const scaleType = scale === null || scale === void 0 ? void 0 : scale.get('type');\n\n      if (isTypedFieldDef(channelDef)) {\n        bandPosition !== null && bandPosition !== void 0 ? bandPosition : bandPosition = getBandPosition({\n          fieldDef: channelDef,\n          fieldDef2: channel2Def,\n          markDef,\n          config\n        });\n        const {\n          bin,\n          timeUnit,\n          type\n        } = channelDef;\n\n        if (isBinning(bin) || bandPosition && timeUnit && type === TEMPORAL) {\n          // Use middle only for x an y to place marks in the center between start and end of the bin range.\n          // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n          if (stack === null || stack === void 0 ? void 0 : stack.impute) {\n            // For stack, we computed bin_mid so we can impute.\n            return valueRefForFieldOrDatumDef(channelDef, scaleName, {\n              binSuffix: 'mid'\n            }, {\n              offset\n            });\n          }\n\n          if (bandPosition && !hasDiscreteDomain(scaleType)) {\n            // if band = 0, no need to call interpolation\n            // For non-stack, we can just calculate bin mid on the fly using signal.\n            return interpolatedSignalRef({\n              scaleName,\n              fieldOrDatumDef: channelDef,\n              bandPosition,\n              offset\n            });\n          }\n\n          return valueRefForFieldOrDatumDef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? {\n            binSuffix: 'range'\n          } : {}, {\n            offset\n          });\n        } else if (isBinned(bin)) {\n          if (isFieldDef(channel2Def)) {\n            return interpolatedSignalRef({\n              scaleName,\n              fieldOrDatumDef: channelDef,\n              fieldOrDatumDef2: channel2Def,\n              bandPosition,\n              offset\n            });\n          } else {\n            const channel2 = channel === X ? X2 : Y2;\n            log.warn(log.message.channelRequiredForBinned(channel2));\n          }\n        }\n      }\n\n      return valueRefForFieldOrDatumDef(channelDef, scaleName, hasDiscreteDomain(scaleType) ? {\n        binSuffix: 'range'\n      } : {}, // no need for bin suffix if there is no scale\n      {\n        offset,\n        // For band, to get mid point, need to offset by half of the band\n        band: scaleType === 'band' ? (_a = bandPosition !== null && bandPosition !== void 0 ? bandPosition : channelDef.bandPosition) !== null && _a !== void 0 ? _a : 0.5 : undefined\n      });\n    } else if (isValueDef(channelDef)) {\n      const value = channelDef.value;\n      const offsetMixins = offset ? {\n        offset\n      } : {};\n      return Object.assign(Object.assign({}, widthHeightValueOrSignalRef(channel, value)), offsetMixins);\n    } // If channelDef is neither field def or value def, it's a condition-only def.\n    // In such case, we will use default ref.\n\n  }\n\n  if (isFunction(defaultRef)) {\n    defaultRef = defaultRef();\n  }\n\n  if (defaultRef) {\n    // for non-position, ref could be undefined.\n    return Object.assign(Object.assign({}, defaultRef), offset ? {\n      offset\n    } : {});\n  }\n\n  return defaultRef;\n}\n/**\n * Convert special \"width\" and \"height\" values in Vega-Lite into Vega value ref.\n */\n\nexport function widthHeightValueOrSignalRef(channel, value) {\n  if (contains(['x', 'x2'], channel) && value === 'width') {\n    return {\n      field: {\n        group: 'width'\n      }\n    };\n  } else if (contains(['y', 'y2'], channel) && value === 'height') {\n    return {\n      field: {\n        group: 'height'\n      }\n    };\n  }\n\n  return signalOrValueRef(value);\n}","map":{"version":3,"mappings":"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","names":["isFunction","isString","isCountingAggregateOp","isBinned","isBinning","getMainRangeChannel","X","X2","Y2","binRequiresRange","getBandPosition","isDatumDef","isFieldDef","isFieldOrDatumDef","isTypedFieldDef","isValueDef","vgField","dateTimeToExpr","isDateTime","isExprRef","log","isPathMark","fieldValidPredicate","hasDiscreteDomain","isContinuousToContinuous","TEMPORAL","contains","stringify","isSignalRef","getMarkPropOrConfig","signalOrValueRef","midPointRefWithPositionInvalidTest","params","channel","channelDef","markDef","scale","config","ref","midPoint","aggregate","get","wrapPositionInvalidTest","fieldDef","type","invalid","fieldInvalidTestValueRef","test","fieldInvalidPredicate","mainChannel","zeroValueRef","field","group","value","expr","datumDefToExpr","datumDef","datum","valueRefForFieldOrDatumDef","scaleName","opt","encode","signal","offset","band","interpolatedSignalRef","fieldOrDatumDef","fieldOrDatumDef2","startSuffix","bandPosition","undefined","start","suffix","end","val","channel2Def","stack","defaultRef","scaleType","fieldDef2","bin","timeUnit","impute","binSuffix","channel2","warn","message","channelRequiredForBinned","_a","offsetMixins","widthHeightValueOrSignalRef"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/mark/encode/valueref.ts"],"sourcesContent":["/**\n * Utility files for producing Vega ValueRef for marks\n */\nimport {SignalRef} from 'vega';\nimport {isFunction, isString} from 'vega-util';\nimport {isCountingAggregateOp} from '../../../aggregate';\nimport {isBinned, isBinning} from '../../../bin';\nimport {Channel, getMainRangeChannel, PolarPositionChannel, PositionChannel, X, X2, Y2} from '../../../channel';\nimport {\n  binRequiresRange,\n  ChannelDef,\n  DatumDef,\n  FieldDef,\n  FieldDefBase,\n  FieldName,\n  FieldRefOption,\n  getBandPosition,\n  isDatumDef,\n  isFieldDef,\n  isFieldOrDatumDef,\n  isTypedFieldDef,\n  isValueDef,\n  SecondaryChannelDef,\n  SecondaryFieldDef,\n  TypedFieldDef,\n  Value,\n  vgField\n} from '../../../channeldef';\nimport {Config} from '../../../config';\nimport {dateTimeToExpr, isDateTime} from '../../../datetime';\nimport {isExprRef} from '../../../expr';\nimport * as log from '../../../log';\nimport {isPathMark, Mark, MarkDef} from '../../../mark';\nimport {fieldValidPredicate} from '../../../predicate';\nimport {hasDiscreteDomain, isContinuousToContinuous} from '../../../scale';\nimport {StackProperties} from '../../../stack';\nimport {TEMPORAL} from '../../../type';\nimport {contains, stringify} from '../../../util';\nimport {isSignalRef, VgValueRef} from '../../../vega.schema';\nimport {getMarkPropOrConfig, signalOrValueRef} from '../../common';\nimport {ScaleComponent} from '../../scale/component';\n\nexport function midPointRefWithPositionInvalidTest(\n  params: MidPointParams & {\n    channel: PositionChannel | PolarPositionChannel;\n  }\n) {\n  const {channel, channelDef, markDef, scale, config} = params;\n  const ref = midPoint(params);\n\n  // Wrap to check if the positional value is invalid, if so, plot the point on the min value\n  if (\n    // Only this for field def without counting aggregate (as count wouldn't be null)\n    isFieldDef(channelDef) &&\n    !isCountingAggregateOp(channelDef.aggregate) &&\n    // and only for continuous scale\n    scale &&\n    isContinuousToContinuous(scale.get('type'))\n  ) {\n    return wrapPositionInvalidTest({\n      fieldDef: channelDef,\n      channel,\n      markDef,\n      ref,\n      config\n    });\n  }\n  return ref;\n}\n\nexport function wrapPositionInvalidTest({\n  fieldDef,\n  channel,\n  markDef,\n  ref,\n  config\n}: {\n  fieldDef: FieldDef<string>;\n  channel: PositionChannel | PolarPositionChannel;\n  markDef: MarkDef<Mark>;\n  ref: VgValueRef;\n  config: Config<SignalRef>;\n}): VgValueRef | VgValueRef[] {\n  if (isPathMark(markDef.type)) {\n    // path mark already use defined to skip points, no need to do it here.\n    return ref;\n  }\n\n  const invalid = getMarkPropOrConfig('invalid', markDef, config);\n  if (invalid === null) {\n    // if there is no invalid filter, don't do the invalid test\n    return [fieldInvalidTestValueRef(fieldDef, channel), ref];\n  }\n  return ref;\n}\n\nexport function fieldInvalidTestValueRef(fieldDef: FieldDef<string>, channel: PositionChannel | PolarPositionChannel) {\n  const test = fieldInvalidPredicate(fieldDef, true);\n\n  const mainChannel = getMainRangeChannel(channel) as PositionChannel | PolarPositionChannel; // we can cast here as the output can't be other things.\n  const zeroValueRef =\n    mainChannel === 'y'\n      ? {field: {group: 'height'}}\n      : // x / angle / radius can all use 0\n        {value: 0};\n\n  return {test, ...zeroValueRef};\n}\n\nexport function fieldInvalidPredicate(field: FieldName | FieldDef<string>, invalid = true) {\n  return fieldValidPredicate(isString(field) ? field : vgField(field, {expr: 'datum'}), !invalid);\n}\n\nexport function datumDefToExpr(datumDef: DatumDef<string>) {\n  const {datum} = datumDef;\n  if (isDateTime(datum)) {\n    return dateTimeToExpr(datum);\n  }\n  return `${stringify(datum)}`;\n}\n\nexport function valueRefForFieldOrDatumDef(\n  fieldDef: FieldDefBase<string> | DatumDef<string>,\n  scaleName: string,\n  opt: FieldRefOption,\n  encode: {offset?: number | VgValueRef; band?: number | boolean | SignalRef}\n): VgValueRef {\n  const ref: VgValueRef = {};\n\n  if (scaleName) {\n    ref.scale = scaleName;\n  }\n\n  if (isDatumDef<string>(fieldDef)) {\n    const {datum} = fieldDef;\n    if (isDateTime(datum)) {\n      ref.signal = dateTimeToExpr(datum);\n    } else if (isSignalRef(datum)) {\n      ref.signal = datum.signal;\n    } else if (isExprRef(datum)) {\n      ref.signal = datum.expr;\n    } else {\n      ref.value = datum;\n    }\n  } else {\n    ref.field = vgField(fieldDef, opt);\n  }\n\n  if (encode) {\n    const {offset, band} = encode;\n    if (offset) {\n      ref.offset = offset;\n    }\n    if (band) {\n      ref.band = band;\n    }\n  }\n  return ref;\n}\n\n/**\n * Signal that returns the middle of a bin from start and end field. Should only be used with x and y.\n */\nexport function interpolatedSignalRef({\n  scaleName,\n  fieldOrDatumDef,\n  fieldOrDatumDef2,\n  offset,\n  startSuffix,\n  bandPosition = 0.5\n}: {\n  scaleName: string;\n  fieldOrDatumDef: TypedFieldDef<string>;\n  fieldOrDatumDef2?: SecondaryFieldDef<string>;\n  startSuffix?: string;\n  offset: number | SignalRef | VgValueRef;\n  bandPosition: number | SignalRef;\n}): VgValueRef {\n  const expr = 0 < bandPosition && bandPosition < 1 ? 'datum' : undefined;\n  const start = vgField(fieldOrDatumDef, {expr, suffix: startSuffix});\n  const end =\n    fieldOrDatumDef2 !== undefined\n      ? vgField(fieldOrDatumDef2, {expr})\n      : vgField(fieldOrDatumDef, {suffix: 'end', expr});\n\n  const ref: VgValueRef = {};\n\n  if (bandPosition === 0 || bandPosition === 1) {\n    ref.scale = scaleName;\n    const val = bandPosition === 0 ? start : end;\n    ref.field = val;\n  } else {\n    const datum = isSignalRef(bandPosition)\n      ? `${bandPosition.signal} * ${start} + (1-${bandPosition.signal}) * ${end}`\n      : `${bandPosition} * ${start} + ${1 - bandPosition} * ${end}`;\n    ref.signal = `scale(\"${scaleName}\", ${datum})`;\n  }\n\n  if (offset) {\n    ref.offset = offset;\n  }\n  return ref;\n}\n\nexport interface MidPointParams {\n  channel: Channel;\n  channelDef: ChannelDef;\n  channel2Def?: SecondaryChannelDef<string>;\n\n  markDef: MarkDef<Mark, SignalRef>;\n  config: Config<SignalRef>;\n\n  scaleName: string;\n  scale: ScaleComponent;\n  stack?: StackProperties;\n  offset?: number | SignalRef | VgValueRef;\n  defaultRef: VgValueRef | (() => VgValueRef);\n\n  bandPosition?: number | SignalRef;\n}\n\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\nexport function midPoint({\n  channel,\n  channelDef,\n  channel2Def,\n  markDef,\n  config,\n  scaleName,\n  scale,\n  stack,\n  offset,\n  defaultRef,\n  bandPosition\n}: MidPointParams): VgValueRef {\n  // TODO: datum support\n  if (channelDef) {\n    /* istanbul ignore else */\n\n    if (isFieldOrDatumDef(channelDef)) {\n      const scaleType = scale?.get('type');\n      if (isTypedFieldDef(channelDef)) {\n        bandPosition ??= getBandPosition({\n          fieldDef: channelDef,\n          fieldDef2: channel2Def,\n          markDef,\n          config\n        });\n        const {bin, timeUnit, type} = channelDef;\n\n        if (isBinning(bin) || (bandPosition && timeUnit && type === TEMPORAL)) {\n          // Use middle only for x an y to place marks in the center between start and end of the bin range.\n          // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n          if (stack?.impute) {\n            // For stack, we computed bin_mid so we can impute.\n            return valueRefForFieldOrDatumDef(channelDef, scaleName, {binSuffix: 'mid'}, {offset});\n          }\n\n          if (bandPosition && !hasDiscreteDomain(scaleType)) {\n            // if band = 0, no need to call interpolation\n            // For non-stack, we can just calculate bin mid on the fly using signal.\n            return interpolatedSignalRef({scaleName, fieldOrDatumDef: channelDef, bandPosition, offset});\n          }\n          return valueRefForFieldOrDatumDef(\n            channelDef,\n            scaleName,\n            binRequiresRange(channelDef, channel) ? {binSuffix: 'range'} : {},\n            {\n              offset\n            }\n          );\n        } else if (isBinned(bin)) {\n          if (isFieldDef(channel2Def)) {\n            return interpolatedSignalRef({\n              scaleName,\n              fieldOrDatumDef: channelDef,\n              fieldOrDatumDef2: channel2Def,\n              bandPosition,\n              offset\n            });\n          } else {\n            const channel2 = channel === X ? X2 : Y2;\n            log.warn(log.message.channelRequiredForBinned(channel2));\n          }\n        }\n      }\n\n      return valueRefForFieldOrDatumDef(\n        channelDef,\n        scaleName,\n        hasDiscreteDomain(scaleType) ? {binSuffix: 'range'} : {}, // no need for bin suffix if there is no scale\n        {\n          offset,\n          // For band, to get mid point, need to offset by half of the band\n          band: scaleType === 'band' ? bandPosition ?? channelDef.bandPosition ?? 0.5 : undefined\n        }\n      );\n    } else if (isValueDef(channelDef)) {\n      const value = channelDef.value;\n      const offsetMixins = offset ? {offset} : {};\n\n      return {...widthHeightValueOrSignalRef(channel, value), ...offsetMixins};\n    }\n\n    // If channelDef is neither field def or value def, it's a condition-only def.\n    // In such case, we will use default ref.\n  }\n\n  if (isFunction(defaultRef)) {\n    defaultRef = defaultRef();\n  }\n\n  if (defaultRef) {\n    // for non-position, ref could be undefined.\n    return {\n      ...defaultRef,\n      // only include offset when it is non-zero (zero = no offset)\n      ...(offset ? {offset} : {})\n    };\n  }\n  return defaultRef;\n}\n\n/**\n * Convert special \"width\" and \"height\" values in Vega-Lite into Vega value ref.\n */\nexport function widthHeightValueOrSignalRef(channel: Channel, value: Value | SignalRef) {\n  if (contains(['x', 'x2'], channel) && value === 'width') {\n    return {field: {group: 'width'}};\n  } else if (contains(['y', 'y2'], channel) && value === 'height') {\n    return {field: {group: 'height'}};\n  }\n  return signalOrValueRef(value);\n}\n"]},"metadata":{},"sourceType":"module"}