{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isColorChannel } from '../../channel';\nimport { title as fieldDefTitle, valueArray } from '../../channeldef';\nimport { isContinuousToContinuous } from '../../scale';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { guideFormat, guideFormatType } from '../format';\nimport { getFirstConditionValue } from './encode';\nexport const legendRules = {\n  direction: _ref => {\n    let {\n      direction\n    } = _ref;\n    return direction;\n  },\n  format: _ref2 => {\n    let {\n      fieldOrDatumDef,\n      legend,\n      config\n    } = _ref2;\n    const {\n      format,\n      formatType\n    } = legend;\n    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, false);\n  },\n  formatType: _ref3 => {\n    let {\n      legend,\n      fieldOrDatumDef,\n      scaleType\n    } = _ref3;\n    const {\n      formatType\n    } = legend;\n    return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n  },\n  gradientLength: params => {\n    var _a, _b;\n\n    const {\n      legend,\n      legendConfig\n    } = params;\n    return (_b = (_a = legend.gradientLength) !== null && _a !== void 0 ? _a : legendConfig.gradientLength) !== null && _b !== void 0 ? _b : defaultGradientLength(params);\n  },\n  labelOverlap: _ref4 => {\n    let {\n      legend,\n      legendConfig,\n      scaleType\n    } = _ref4;\n\n    var _a, _b;\n\n    return (_b = (_a = legend.labelOverlap) !== null && _a !== void 0 ? _a : legendConfig.labelOverlap) !== null && _b !== void 0 ? _b : defaultLabelOverlap(scaleType);\n  },\n  symbolType: _ref5 => {\n    let {\n      legend,\n      markDef,\n      channel,\n      encoding\n    } = _ref5;\n\n    var _a;\n\n    return (_a = legend.symbolType) !== null && _a !== void 0 ? _a : defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape);\n  },\n  title: _ref6 => {\n    let {\n      fieldOrDatumDef,\n      config\n    } = _ref6;\n    return fieldDefTitle(fieldOrDatumDef, config, {\n      allowDisabling: true\n    });\n  },\n  type: _ref7 => {\n    let {\n      legendType,\n      scaleType,\n      channel\n    } = _ref7;\n\n    if (isColorChannel(channel) && isContinuousToContinuous(scaleType)) {\n      if (legendType === 'gradient') {\n        return undefined;\n      }\n    } else if (legendType === 'symbol') {\n      return undefined;\n    }\n\n    return legendType;\n  },\n  values: _ref8 => {\n    let {\n      fieldOrDatumDef,\n      legend\n    } = _ref8;\n    return values(legend, fieldOrDatumDef);\n  }\n};\nexport function values(legend, fieldOrDatumDef) {\n  const vals = legend.values;\n\n  if (isArray(vals)) {\n    return valueArray(fieldOrDatumDef, vals);\n  } else if (isSignalRef(vals)) {\n    return vals;\n  }\n\n  return undefined;\n}\nexport function defaultSymbolType(mark, channel, shapeChannelDef, markShape) {\n  var _a;\n\n  if (channel !== 'shape') {\n    // use the value from the shape encoding or the mark config if they exist\n    const shape = (_a = getFirstConditionValue(shapeChannelDef)) !== null && _a !== void 0 ? _a : markShape;\n\n    if (shape) {\n      return shape;\n    }\n  }\n\n  switch (mark) {\n    case 'bar':\n    case 'rect':\n    case 'image':\n    case 'square':\n      return 'square';\n\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return 'stroke';\n\n    case 'arc':\n    case 'point':\n    case 'circle':\n    case 'tick':\n    case 'geoshape':\n    case 'area':\n    case 'text':\n      return 'circle';\n  }\n}\nexport function clipHeight(legendType) {\n  if (legendType === 'gradient') {\n    return 20;\n  }\n\n  return undefined;\n}\nexport function getLegendType(params) {\n  const {\n    legend\n  } = params;\n  return getFirstDefined(legend.type, defaultType(params));\n}\nexport function defaultType(_ref9) {\n  let {\n    channel,\n    timeUnit,\n    scaleType\n  } = _ref9;\n\n  // Following the logic in https://github.com/vega/vega-parser/blob/master/src/parsers/legend.js\n  if (isColorChannel(channel)) {\n    if (contains(['quarter', 'month', 'day'], timeUnit)) {\n      return 'symbol';\n    }\n\n    if (isContinuousToContinuous(scaleType)) {\n      return 'gradient';\n    }\n  }\n\n  return 'symbol';\n}\nexport function getDirection(_ref10) {\n  let {\n    legendConfig,\n    legendType,\n    orient,\n    legend\n  } = _ref10;\n\n  var _a, _b;\n\n  return (_b = (_a = legend.direction) !== null && _a !== void 0 ? _a : legendConfig[legendType ? 'gradientDirection' : 'symbolDirection']) !== null && _b !== void 0 ? _b : defaultDirection(orient, legendType);\n}\nexport function defaultDirection(orient, legendType) {\n  switch (orient) {\n    case 'top':\n    case 'bottom':\n      return 'horizontal';\n\n    case 'left':\n    case 'right':\n    case 'none':\n    case undefined:\n      // undefined = \"right\" in Vega\n      return undefined;\n    // vertical is Vega's default\n\n    default:\n      // top-left / ...\n      // For inner legend, uses compact layout like Tableau\n      return legendType === 'gradient' ? 'horizontal' : undefined;\n  }\n}\nexport function defaultGradientLength(_ref11) {\n  let {\n    legendConfig,\n    model,\n    direction,\n    orient,\n    scaleType\n  } = _ref11;\n  const {\n    gradientHorizontalMaxLength,\n    gradientHorizontalMinLength,\n    gradientVerticalMaxLength,\n    gradientVerticalMinLength\n  } = legendConfig;\n\n  if (isContinuousToContinuous(scaleType)) {\n    if (direction === 'horizontal') {\n      if (orient === 'top' || orient === 'bottom') {\n        return gradientLengthSignal(model, 'width', gradientHorizontalMinLength, gradientHorizontalMaxLength);\n      } else {\n        return gradientHorizontalMinLength;\n      }\n    } else {\n      // vertical / undefined (Vega uses vertical by default)\n      return gradientLengthSignal(model, 'height', gradientVerticalMinLength, gradientVerticalMaxLength);\n    }\n  }\n\n  return undefined;\n}\n\nfunction gradientLengthSignal(model, sizeType, min, max) {\n  const sizeSignal = model.getSizeSignalRef(sizeType).signal;\n  return {\n    signal: `clamp(${sizeSignal}, ${min}, ${max})`\n  };\n}\n\nexport function defaultLabelOverlap(scaleType) {\n  if (contains(['quantile', 'threshold', 'log', 'symlog'], scaleType)) {\n    return 'greedy';\n  }\n\n  return undefined;\n}","map":{"version":3,"mappings":"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","names":["isArray","isColorChannel","title","fieldDefTitle","valueArray","isContinuousToContinuous","contains","getFirstDefined","isSignalRef","guideFormat","guideFormatType","getFirstConditionValue","legendRules","direction","format","fieldOrDatumDef","legend","config","formatType","type","scaleType","gradientLength","params","legendConfig","_a","_b","defaultGradientLength","labelOverlap","defaultLabelOverlap","symbolType","markDef","channel","encoding","defaultSymbolType","shape","allowDisabling","legendType","undefined","values","vals","mark","shapeChannelDef","markShape","clipHeight","getLegendType","defaultType","timeUnit","getDirection","orient","defaultDirection","model","gradientHorizontalMaxLength","gradientHorizontalMinLength","gradientVerticalMaxLength","gradientVerticalMinLength","gradientLengthSignal","sizeType","min","max","sizeSignal","getSizeSignalRef","signal"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/legend/properties.ts"],"sourcesContent":["import {LabelOverlap, LegendOrient, LegendType, Orientation, SignalRef, SymbolShape} from 'vega';\nimport {isArray} from 'vega-util';\nimport {isColorChannel} from '../../channel';\nimport {DatumDef, MarkPropFieldOrDatumDef, title as fieldDefTitle, TypedFieldDef, valueArray} from '../../channeldef';\nimport {Config} from '../../config';\nimport {Encoding} from '../../encoding';\nimport {Legend, LegendConfig, LegendInternal} from '../../legend';\nimport {Mark, MarkDef} from '../../mark';\nimport {isContinuousToContinuous, ScaleType} from '../../scale';\nimport {TimeUnit} from '../../timeunit';\nimport {contains, getFirstDefined} from '../../util';\nimport {isSignalRef} from '../../vega.schema';\nimport {guideFormat, guideFormatType} from '../format';\nimport {Model} from '../model';\nimport {UnitModel} from '../unit';\nimport {NonPositionScaleChannel} from './../../channel';\nimport {LegendComponentProps} from './component';\nimport {getFirstConditionValue} from './encode';\n\nexport interface LegendRuleParams {\n  legend: LegendInternal;\n  channel: NonPositionScaleChannel;\n  model: UnitModel;\n  markDef: MarkDef<Mark, SignalRef>;\n  encoding: Encoding<string>;\n  fieldOrDatumDef: MarkPropFieldOrDatumDef<string>;\n  legendConfig: LegendConfig<SignalRef>;\n  config: Config<SignalRef>;\n  scaleType: ScaleType;\n  orient: LegendOrient;\n  legendType: LegendType;\n  direction: Orientation;\n}\n\nexport const legendRules: {\n  [k in keyof LegendComponentProps]?: (params: LegendRuleParams) => LegendComponentProps[k];\n} = {\n  direction: ({direction}) => direction,\n\n  format: ({fieldOrDatumDef, legend, config}) => {\n    const {format, formatType} = legend;\n    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, false);\n  },\n\n  formatType: ({legend, fieldOrDatumDef, scaleType}) => {\n    const {formatType} = legend;\n    return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n  },\n\n  gradientLength: params => {\n    const {legend, legendConfig} = params;\n    return legend.gradientLength ?? legendConfig.gradientLength ?? defaultGradientLength(params);\n  },\n\n  labelOverlap: ({legend, legendConfig, scaleType}) =>\n    legend.labelOverlap ?? legendConfig.labelOverlap ?? defaultLabelOverlap(scaleType),\n\n  symbolType: ({legend, markDef, channel, encoding}) =>\n    legend.symbolType ?? defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape),\n\n  title: ({fieldOrDatumDef, config}) => fieldDefTitle(fieldOrDatumDef, config, {allowDisabling: true}),\n\n  type: ({legendType, scaleType, channel}) => {\n    if (isColorChannel(channel) && isContinuousToContinuous(scaleType)) {\n      if (legendType === 'gradient') {\n        return undefined;\n      }\n    } else if (legendType === 'symbol') {\n      return undefined;\n    }\n    return legendType;\n  }, // depended by other property, let's define upfront\n\n  values: ({fieldOrDatumDef, legend}) => values(legend, fieldOrDatumDef)\n};\n\nexport function values(legend: LegendInternal, fieldOrDatumDef: TypedFieldDef<string> | DatumDef) {\n  const vals = legend.values;\n\n  if (isArray(vals)) {\n    return valueArray(fieldOrDatumDef, vals);\n  } else if (isSignalRef(vals)) {\n    return vals;\n  }\n  return undefined;\n}\n\nexport function defaultSymbolType(\n  mark: Mark,\n  channel: NonPositionScaleChannel,\n  shapeChannelDef: Encoding<string>['shape'],\n  markShape: SymbolShape | SignalRef\n): SymbolShape | SignalRef {\n  if (channel !== 'shape') {\n    // use the value from the shape encoding or the mark config if they exist\n    const shape = getFirstConditionValue<string>(shapeChannelDef) ?? markShape;\n    if (shape) {\n      return shape;\n    }\n  }\n\n  switch (mark) {\n    case 'bar':\n    case 'rect':\n    case 'image':\n    case 'square':\n      return 'square';\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return 'stroke';\n    case 'arc':\n    case 'point':\n    case 'circle':\n    case 'tick':\n    case 'geoshape':\n    case 'area':\n    case 'text':\n      return 'circle';\n  }\n}\n\nexport function clipHeight(legendType: LegendType) {\n  if (legendType === 'gradient') {\n    return 20;\n  }\n  return undefined;\n}\n\nexport function getLegendType(params: {\n  legend: LegendInternal;\n  channel: NonPositionScaleChannel;\n  timeUnit?: TimeUnit;\n  scaleType: ScaleType;\n}): LegendType {\n  const {legend} = params;\n\n  return getFirstDefined(legend.type, defaultType(params));\n}\n\nexport function defaultType({\n  channel,\n  timeUnit,\n  scaleType\n}: {\n  channel: NonPositionScaleChannel;\n  timeUnit?: TimeUnit;\n  scaleType: ScaleType;\n}): LegendType {\n  // Following the logic in https://github.com/vega/vega-parser/blob/master/src/parsers/legend.js\n\n  if (isColorChannel(channel)) {\n    if (contains(['quarter', 'month', 'day'], timeUnit)) {\n      return 'symbol';\n    }\n\n    if (isContinuousToContinuous(scaleType)) {\n      return 'gradient';\n    }\n  }\n  return 'symbol';\n}\n\nexport function getDirection({\n  legendConfig,\n  legendType,\n  orient,\n  legend\n}: {\n  orient: LegendOrient;\n  legendConfig: LegendConfig<SignalRef>;\n  legendType: LegendType;\n  legend: Legend<SignalRef>;\n}): Orientation {\n  return (\n    legend.direction ??\n    legendConfig[legendType ? 'gradientDirection' : 'symbolDirection'] ??\n    defaultDirection(orient, legendType)\n  );\n}\n\nexport function defaultDirection(orient: LegendOrient, legendType: LegendType): 'horizontal' | undefined {\n  switch (orient) {\n    case 'top':\n    case 'bottom':\n      return 'horizontal';\n\n    case 'left':\n    case 'right':\n    case 'none':\n    case undefined: // undefined = \"right\" in Vega\n      return undefined; // vertical is Vega's default\n    default:\n      // top-left / ...\n      // For inner legend, uses compact layout like Tableau\n      return legendType === 'gradient' ? 'horizontal' : undefined;\n  }\n}\n\nexport function defaultGradientLength({\n  legendConfig,\n  model,\n  direction,\n  orient,\n  scaleType\n}: {\n  scaleType: ScaleType;\n  direction: Orientation;\n  orient: LegendOrient;\n  model: Model;\n  legendConfig: LegendConfig<SignalRef>;\n}) {\n  const {\n    gradientHorizontalMaxLength,\n    gradientHorizontalMinLength,\n    gradientVerticalMaxLength,\n    gradientVerticalMinLength\n  } = legendConfig;\n  if (isContinuousToContinuous(scaleType)) {\n    if (direction === 'horizontal') {\n      if (orient === 'top' || orient === 'bottom') {\n        return gradientLengthSignal(model, 'width', gradientHorizontalMinLength, gradientHorizontalMaxLength);\n      } else {\n        return gradientHorizontalMinLength;\n      }\n    } else {\n      // vertical / undefined (Vega uses vertical by default)\n      return gradientLengthSignal(model, 'height', gradientVerticalMinLength, gradientVerticalMaxLength);\n    }\n  }\n  return undefined;\n}\n\nfunction gradientLengthSignal(model: Model, sizeType: 'width' | 'height', min: number, max: number) {\n  const sizeSignal = model.getSizeSignalRef(sizeType).signal;\n  return {signal: `clamp(${sizeSignal}, ${min}, ${max})`};\n}\n\nexport function defaultLabelOverlap(scaleType: ScaleType): LabelOverlap {\n  if (contains(['quantile', 'threshold', 'log', 'symlog'], scaleType)) {\n    return 'greedy';\n  }\n  return undefined;\n}\n"]},"metadata":{},"sourceType":"module"}