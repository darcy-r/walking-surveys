{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar _Optimizer_modified;\n\nimport { GraticuleNode } from './graticule';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\n/**\n * Whether this dataflow node is the source of the dataflow that produces data i.e. a source or a generator.\n */\n\nexport function isDataSourceNode(node) {\n  return node instanceof SourceNode || node instanceof GraticuleNode || node instanceof SequenceNode;\n}\n/**\n * Abstract base class for Dataflow optimizers.\n * Contains only mutation handling logic. Subclasses need to implement iteration logic.\n */\n\nexport class Optimizer {\n  constructor() {\n    _Optimizer_modified.set(this, void 0);\n\n    __classPrivateFieldSet(this, _Optimizer_modified, false, \"f\");\n  } // Once true, #modified is never set to false\n\n\n  setModified() {\n    __classPrivateFieldSet(this, _Optimizer_modified, true, \"f\");\n  }\n\n  get modifiedFlag() {\n    return __classPrivateFieldGet(this, _Optimizer_modified, \"f\");\n  }\n\n}\n_Optimizer_modified = new WeakMap();\n/**\n * Starts from a node and runs the optimization function (the \"run\" method) upwards to the root,\n * depending on the continue and modified flag values returned by the optimization function.\n */\n\nexport class BottomUpOptimizer extends Optimizer {\n  /**\n   * Compute a map of node depths that we can use to determine a topological sort order.\n   */\n  getNodeDepths(node, depth, depths) {\n    depths.set(node, depth);\n\n    for (const child of node.children) {\n      this.getNodeDepths(child, depth + 1, depths);\n    }\n\n    return depths;\n  }\n  /**\n   * Run the optimizer on all nodes starting from the leaves.\n   */\n\n\n  optimize(node) {\n    const depths = this.getNodeDepths(node, 0, new Map());\n    const topologicalSort = [...depths.entries()].sort((a, b) => b[1] - a[1]);\n\n    for (const tuple of topologicalSort) {\n      this.run(tuple[0]);\n    }\n\n    return this.modifiedFlag;\n  }\n\n}\n/**\n * The optimizer function (the \"run\" method), is invoked on the given node and then continues recursively.\n */\n\nexport class TopDownOptimizer extends Optimizer {\n  /**\n   * Run the optimizer depth first on all nodes starting from the roots.\n   */\n  optimize(node) {\n    this.run(node);\n\n    for (const child of node.children) {\n      this.optimize(child);\n    }\n\n    return this.modifiedFlag;\n  }\n\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;AACA,SAAQA,aAAR,QAA4B,aAA5B;AACA,SAAQC,YAAR,QAA2B,YAA3B;AACA,SAAQC,UAAR,QAAyB,UAAzB;AAEA;;;;AAGA,OAAM,SAAUC,gBAAV,CAA2BC,IAA3B,EAA6C;EACjD,OAAOA,IAAI,YAAYF,UAAhB,IAA8BE,IAAI,YAAYJ,aAA9C,IAA+DI,IAAI,YAAYH,YAAtF;AACD;AAED;;;;;AAIA,OAAM,MAAgBI,SAAhB,CAAyB;EAG7BC;IAFAC;;IAGEC,6BAAID,mBAAJ,EAAiB,KAAjB,EAAsB,GAAtB;EACD,CAL4B,CAO7B;;;EACOE,WAAW;IAChBD,6BAAID,mBAAJ,EAAiB,IAAjB,EAAqB,GAArB;EACD;;EAEe,IAAZG,YAAY;IACd,OAAOC,6BAAIJ,mBAAJ,EAAI,GAAJ,CAAP;EACD;;AAd4B;;AAsB/B;;;;;AAIA,OAAM,MAAgBK,iBAAhB,SAA0CP,SAA1C,CAAmD;EAMvD;;;EAGQQ,aAAa,CACnBT,IADmB,EAEnBU,KAFmB,EAGnBC,MAHmB,EAGc;IAEjCA,MAAM,CAACC,GAAP,CAAWZ,IAAX,EAAiBU,KAAjB;;IAEA,KAAK,MAAMG,KAAX,IAAoBb,IAAI,CAACc,QAAzB,EAAmC;MACjC,KAAKL,aAAL,CAAmBI,KAAnB,EAA0BH,KAAK,GAAG,CAAlC,EAAqCC,MAArC;IACD;;IAED,OAAOA,MAAP;EACD;EAED;;;;;EAGOI,QAAQ,CAACf,IAAD,EAAmB;IAChC,MAAMW,MAAM,GAAG,KAAKF,aAAL,CAAmBT,IAAnB,EAAyB,CAAzB,EAA4B,IAAIgB,GAAJ,EAA5B,CAAf;IACA,MAAMC,eAAe,GAAG,CAAC,GAAGN,MAAM,CAACO,OAAP,EAAJ,EAAsBC,IAAtB,CAA2B,CAACC,CAAD,EAAIC,CAAJ,KAAUA,CAAC,CAAC,CAAD,CAAD,GAAOD,CAAC,CAAC,CAAD,CAA7C,CAAxB;;IAEA,KAAK,MAAME,KAAX,IAAoBL,eAApB,EAAqC;MACnC,KAAKM,GAAL,CAASD,KAAK,CAAC,CAAD,CAAd;IACD;;IAED,OAAO,KAAKhB,YAAZ;EACD;;AAnCsD;AAsCzD;;;;AAGA,OAAM,MAAgBkB,gBAAhB,SAAyCvB,SAAzC,CAAkD;EAMtD;;;EAGOc,QAAQ,CAACf,IAAD,EAAmB;IAChC,KAAKuB,GAAL,CAASvB,IAAT;;IAEA,KAAK,MAAMa,KAAX,IAAoBb,IAAI,CAACc,QAAzB,EAAmC;MACjC,KAAKC,QAAL,CAAcF,KAAd;IACD;;IAED,OAAO,KAAKP,YAAZ;EACD;;AAjBqD","names":["GraticuleNode","SequenceNode","SourceNode","isDataSourceNode","node","Optimizer","constructor","_Optimizer_modified","__classPrivateFieldSet","setModified","modifiedFlag","__classPrivateFieldGet","BottomUpOptimizer","getNodeDepths","depth","depths","set","child","children","optimize","Map","topologicalSort","entries","sort","a","b","tuple","run","TopDownOptimizer"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/data/optimizer.ts"],"sourcesContent":["import {DataFlowNode} from './dataflow';\nimport {GraticuleNode} from './graticule';\nimport {SequenceNode} from './sequence';\nimport {SourceNode} from './source';\n\n/**\n * Whether this dataflow node is the source of the dataflow that produces data i.e. a source or a generator.\n */\nexport function isDataSourceNode(node: DataFlowNode) {\n  return node instanceof SourceNode || node instanceof GraticuleNode || node instanceof SequenceNode;\n}\n\n/**\n * Abstract base class for Dataflow optimizers.\n * Contains only mutation handling logic. Subclasses need to implement iteration logic.\n */\nexport abstract class Optimizer {\n  #modified: boolean;\n\n  constructor() {\n    this.#modified = false;\n  }\n\n  // Once true, #modified is never set to false\n  public setModified() {\n    this.#modified = true;\n  }\n\n  get modifiedFlag() {\n    return this.#modified;\n  }\n\n  /**\n   * Run the optimization for the tree with the provided root.\n   */\n  public abstract optimize(root: DataFlowNode): boolean;\n}\n\n/**\n * Starts from a node and runs the optimization function (the \"run\" method) upwards to the root,\n * depending on the continue and modified flag values returned by the optimization function.\n */\nexport abstract class BottomUpOptimizer extends Optimizer {\n  /**\n   * Run the optimizer at the node. This method should not change the parent of the passed in node (it should only affect children).\n   */\n  public abstract run(node: DataFlowNode): void;\n\n  /**\n   * Compute a map of node depths that we can use to determine a topological sort order.\n   */\n  private getNodeDepths(\n    node: DataFlowNode,\n    depth: number,\n    depths: Map<DataFlowNode, number>\n  ): Map<DataFlowNode, number> {\n    depths.set(node, depth);\n\n    for (const child of node.children) {\n      this.getNodeDepths(child, depth + 1, depths);\n    }\n\n    return depths;\n  }\n\n  /**\n   * Run the optimizer on all nodes starting from the leaves.\n   */\n  public optimize(node: DataFlowNode): boolean {\n    const depths = this.getNodeDepths(node, 0, new Map());\n    const topologicalSort = [...depths.entries()].sort((a, b) => b[1] - a[1]);\n\n    for (const tuple of topologicalSort) {\n      this.run(tuple[0]);\n    }\n\n    return this.modifiedFlag;\n  }\n}\n\n/**\n * The optimizer function (the \"run\" method), is invoked on the given node and then continues recursively.\n */\nexport abstract class TopDownOptimizer extends Optimizer {\n  /**\n   * Run the optimizer at the node.\n   */\n  public abstract run(node: DataFlowNode): void;\n\n  /**\n   * Run the optimizer depth first on all nodes starting from the roots.\n   */\n  public optimize(node: DataFlowNode): boolean {\n    this.run(node);\n\n    for (const child of node.children) {\n      this.optimize(child);\n    }\n\n    return this.modifiedFlag;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}