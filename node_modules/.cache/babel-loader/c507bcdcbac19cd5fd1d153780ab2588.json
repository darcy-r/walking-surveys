{"ast":null,"code":"import { isFieldDef } from '../../channeldef';\nimport { pathGroupingFields } from '../../encoding';\nimport { isImputeSequence } from '../../transform';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class ImputeNode extends DataFlowNode {\n  constructor(parent, transform) {\n    super(parent);\n    this.transform = transform;\n  }\n\n  clone() {\n    return new ImputeNode(null, duplicate(this.transform));\n  }\n\n  dependentFields() {\n    var _a;\n\n    return new Set([this.transform.impute, this.transform.key, ...((_a = this.transform.groupby) !== null && _a !== void 0 ? _a : [])]);\n  }\n\n  producedFields() {\n    return new Set([this.transform.impute]);\n  }\n\n  processSequence(keyvals) {\n    const {\n      start = 0,\n      stop,\n      step\n    } = keyvals;\n    const result = [start, stop, ...(step ? [step] : [])].join(',');\n    return {\n      signal: `sequence(${result})`\n    };\n  }\n\n  static makeFromTransform(parent, imputeTransform) {\n    return new ImputeNode(parent, imputeTransform);\n  }\n\n  static makeFromEncoding(parent, model) {\n    const encoding = model.encoding;\n    const xDef = encoding.x;\n    const yDef = encoding.y;\n\n    if (isFieldDef(xDef) && isFieldDef(yDef)) {\n      const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : undefined;\n\n      if (imputedChannel === undefined) {\n        return undefined;\n      }\n\n      const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : undefined;\n      const {\n        method,\n        value,\n        frame,\n        keyvals\n      } = imputedChannel.impute;\n      const groupbyFields = pathGroupingFields(model.mark, encoding);\n      return new ImputeNode(parent, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n        impute: imputedChannel.field,\n        key: keyChannel.field\n      }, method ? {\n        method\n      } : {}), value !== undefined ? {\n        value\n      } : {}), frame ? {\n        frame\n      } : {}), keyvals !== undefined ? {\n        keyvals\n      } : {}), groupbyFields.length ? {\n        groupby: groupbyFields\n      } : {}));\n    }\n\n    return null;\n  }\n\n  hash() {\n    return `Impute ${hash(this.transform)}`;\n  }\n\n  assemble() {\n    const {\n      impute,\n      key,\n      keyvals,\n      method,\n      groupby,\n      value,\n      frame = [null, null]\n    } = this.transform;\n    const imputeTransform = Object.assign(Object.assign(Object.assign(Object.assign({\n      type: 'impute',\n      field: impute,\n      key\n    }, keyvals ? {\n      keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals\n    } : {}), {\n      method: 'value'\n    }), groupby ? {\n      groupby\n    } : {}), {\n      value: !method || method === 'value' ? value : null\n    });\n\n    if (method && method !== 'value') {\n      const deriveNewField = Object.assign({\n        type: 'window',\n        as: [`imputed_${impute}_value`],\n        ops: [method],\n        fields: [impute],\n        frame,\n        ignorePeers: false\n      }, groupby ? {\n        groupby\n      } : {});\n      const replaceOriginal = {\n        type: 'formula',\n        expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,\n        as: impute\n      };\n      return [imputeTransform, deriveNewField, replaceOriginal];\n    } else {\n      return [imputeTransform];\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["isFieldDef","pathGroupingFields","isImputeSequence","duplicate","hash","DataFlowNode","ImputeNode","constructor","parent","transform","clone","dependentFields","Set","impute","key","groupby","_a","producedFields","processSequence","keyvals","start","stop","step","result","join","signal","makeFromTransform","imputeTransform","makeFromEncoding","model","encoding","xDef","x","yDef","y","imputedChannel","undefined","keyChannel","method","value","frame","groupbyFields","mark","Object","field","length","assemble","type","deriveNewField","as","ops","fields","ignorePeers","replaceOriginal","expr"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/data/impute.ts"],"sourcesContent":["import {\n  FormulaTransform as VgFormulaTransform,\n  ImputeTransform as VgImputeTransform,\n  SignalRef,\n  WindowTransform as VgWindowTransform\n} from 'vega';\nimport {isFieldDef} from '../../channeldef';\nimport {pathGroupingFields} from '../../encoding';\nimport {ImputeSequence, ImputeTransform, isImputeSequence} from '../../transform';\nimport {duplicate, hash} from '../../util';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\nexport class ImputeNode extends DataFlowNode {\n  public clone() {\n    return new ImputeNode(null, duplicate(this.transform));\n  }\n\n  constructor(parent: DataFlowNode, private readonly transform: ImputeTransform) {\n    super(parent);\n  }\n\n  public dependentFields() {\n    return new Set([this.transform.impute, this.transform.key, ...(this.transform.groupby ?? [])]);\n  }\n\n  public producedFields() {\n    return new Set([this.transform.impute]);\n  }\n\n  private processSequence(keyvals: ImputeSequence): SignalRef {\n    const {start = 0, stop, step} = keyvals;\n    const result = [start, stop, ...(step ? [step] : [])].join(',');\n\n    return {signal: `sequence(${result})`};\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, imputeTransform: ImputeTransform): ImputeNode {\n    return new ImputeNode(parent, imputeTransform);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: UnitModel) {\n    const encoding = model.encoding;\n    const xDef = encoding.x;\n    const yDef = encoding.y;\n\n    if (isFieldDef(xDef) && isFieldDef(yDef)) {\n      const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : undefined;\n      if (imputedChannel === undefined) {\n        return undefined;\n      }\n      const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : undefined;\n      const {method, value, frame, keyvals} = imputedChannel.impute;\n      const groupbyFields = pathGroupingFields(model.mark, encoding);\n\n      return new ImputeNode(parent, {\n        impute: imputedChannel.field,\n        key: keyChannel.field,\n        ...(method ? {method} : {}),\n        ...(value !== undefined ? {value} : {}),\n        ...(frame ? {frame} : {}),\n        ...(keyvals !== undefined ? {keyvals} : {}),\n        ...(groupbyFields.length ? {groupby: groupbyFields} : {})\n      });\n    }\n    return null;\n  }\n\n  public hash() {\n    return `Impute ${hash(this.transform)}`;\n  }\n\n  public assemble() {\n    const {impute, key, keyvals, method, groupby, value, frame = [null, null] as [null, null]} = this.transform;\n\n    const imputeTransform: VgImputeTransform = {\n      type: 'impute',\n      field: impute,\n      key,\n      ...(keyvals ? {keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals} : {}),\n      method: 'value',\n      ...(groupby ? {groupby} : {}),\n      value: !method || method === 'value' ? value : null\n    };\n\n    if (method && method !== 'value') {\n      const deriveNewField: VgWindowTransform = {\n        type: 'window',\n        as: [`imputed_${impute}_value`],\n        ops: [method],\n        fields: [impute],\n        frame,\n        ignorePeers: false,\n        ...(groupby ? {groupby} : {})\n      };\n      const replaceOriginal: VgFormulaTransform = {\n        type: 'formula',\n        expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,\n        as: impute\n      };\n      return [imputeTransform, deriveNewField, replaceOriginal];\n    } else {\n      return [imputeTransform];\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}