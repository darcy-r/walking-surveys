{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isNumber, isObject } from 'vega-util';\nimport { getMarkPropOrConfig } from '../compile/common';\nimport { extractTransformsFromEncoding, normalizeEncoding } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { isEmpty, omit } from '../util';\nimport { CompositeMarkNormalizer } from './base';\nimport { compositeMarkContinuousAxis, compositeMarkOrient, filterTooltipWithAggregatedField, getCompositeMarkTooltip, getTitle, makeCompositeAggregatePartFactory, partLayerMixins } from './common';\nexport const BOXPLOT = 'boxplot';\nexport const BOXPLOT_PARTS = ['box', 'median', 'outliers', 'rule', 'ticks'];\nexport const boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);\nexport function getBoxPlotType(extent) {\n  if (isNumber(extent)) {\n    return 'tukey';\n  } // Ham: If we ever want to, we could add another extent syntax `{kIQR: number}` for the original [Q1-k*IQR, Q3+k*IQR] whisker and call this boxPlotType = `kIQR`. However, I'm not exposing this for now.\n\n\n  return extent;\n}\nexport function normalizeBoxPlot(spec, _ref) {\n  let {\n    config\n  } = _ref;\n\n  var _a, _b; // Need to initEncoding first so we can infer type\n\n\n  spec = Object.assign(Object.assign({}, spec), {\n    encoding: normalizeEncoding(spec.encoding, config)\n  });\n\n  const {\n    mark,\n    encoding: _encoding,\n    params,\n    projection: _p\n  } = spec,\n        outerSpec = __rest(spec, [\"mark\", \"encoding\", \"params\", \"projection\"]);\n\n  const markDef = isMarkDef(mark) ? mark : {\n    type: mark\n  }; // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n\n  if (params) {\n    log.warn(log.message.selectionNotSupported('boxplot'));\n  }\n\n  const extent = (_a = markDef.extent) !== null && _a !== void 0 ? _a : config.boxplot.extent;\n  const sizeValue = getMarkPropOrConfig('size', markDef, // TODO: https://github.com/vega/vega-lite/issues/6245\n  config);\n  const boxPlotType = getBoxPlotType(extent);\n  const {\n    bins,\n    timeUnits,\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    groupby,\n    aggregate,\n    encodingWithoutContinuousAxis,\n    ticksOrient,\n    boxOrient,\n    customTooltipWithoutAggregatedField\n  } = boxParams(spec, extent, config);\n\n  const {\n    color,\n    size\n  } = encodingWithoutContinuousAxis,\n        encodingWithoutSizeColorAndContinuousAxis = __rest(encodingWithoutContinuousAxis, [\"color\", \"size\"]);\n\n  const makeBoxPlotPart = sharedEncoding => {\n    return makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, config.boxplot);\n  };\n\n  const makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);\n  const makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);\n  const makeBoxPlotMidTick = makeBoxPlotPart(Object.assign(Object.assign({}, encodingWithoutSizeColorAndContinuousAxis), size ? {\n    size\n  } : {}));\n  const fiveSummaryTooltipEncoding = getCompositeMarkTooltip([{\n    fieldPrefix: boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_',\n    titlePrefix: 'Max'\n  }, {\n    fieldPrefix: 'upper_box_',\n    titlePrefix: 'Q3'\n  }, {\n    fieldPrefix: 'mid_box_',\n    titlePrefix: 'Median'\n  }, {\n    fieldPrefix: 'lower_box_',\n    titlePrefix: 'Q1'\n  }, {\n    fieldPrefix: boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_',\n    titlePrefix: 'Min'\n  }], continuousAxisChannelDef, encodingWithoutContinuousAxis); // ## Whisker Layers\n\n  const endTick = {\n    type: 'tick',\n    color: 'black',\n    opacity: 1,\n    orient: ticksOrient,\n    invalid: null,\n    aria: false\n  };\n  const whiskerTooltipEncoding = boxPlotType === 'min-max' ? fiveSummaryTooltipEncoding // for min-max, show five-summary tooltip for whisker\n  : // for tukey / k-IQR, just show upper/lower-whisker\n  getCompositeMarkTooltip([{\n    fieldPrefix: 'upper_whisker_',\n    titlePrefix: 'Upper Whisker'\n  }, {\n    fieldPrefix: 'lower_whisker_',\n    titlePrefix: 'Lower Whisker'\n  }], continuousAxisChannelDef, encodingWithoutContinuousAxis);\n  const whiskerLayers = [...makeBoxPlotExtent({\n    partName: 'rule',\n    mark: {\n      type: 'rule',\n      invalid: null,\n      aria: false\n    },\n    positionPrefix: 'lower_whisker',\n    endPositionPrefix: 'lower_box',\n    extraEncoding: whiskerTooltipEncoding\n  }), ...makeBoxPlotExtent({\n    partName: 'rule',\n    mark: {\n      type: 'rule',\n      invalid: null,\n      aria: false\n    },\n    positionPrefix: 'upper_box',\n    endPositionPrefix: 'upper_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  }), ...makeBoxPlotExtent({\n    partName: 'ticks',\n    mark: endTick,\n    positionPrefix: 'lower_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  }), ...makeBoxPlotExtent({\n    partName: 'ticks',\n    mark: endTick,\n    positionPrefix: 'upper_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  })]; // ## Box Layers\n  // TODO: support hiding certain mark parts\n\n  const boxLayers = [...(boxPlotType !== 'tukey' ? whiskerLayers : []), ...makeBoxPlotBox({\n    partName: 'box',\n    mark: Object.assign(Object.assign({\n      type: 'bar'\n    }, sizeValue ? {\n      size: sizeValue\n    } : {}), {\n      orient: boxOrient,\n      invalid: null,\n      ariaRoleDescription: 'box'\n    }),\n    positionPrefix: 'lower_box',\n    endPositionPrefix: 'upper_box',\n    extraEncoding: fiveSummaryTooltipEncoding\n  }), ...makeBoxPlotMidTick({\n    partName: 'median',\n    mark: Object.assign(Object.assign(Object.assign({\n      type: 'tick',\n      invalid: null\n    }, isObject(config.boxplot.median) && config.boxplot.median.color ? {\n      color: config.boxplot.median.color\n    } : {}), sizeValue ? {\n      size: sizeValue\n    } : {}), {\n      orient: ticksOrient,\n      aria: false\n    }),\n    positionPrefix: 'mid_box',\n    extraEncoding: fiveSummaryTooltipEncoding\n  })];\n\n  if (boxPlotType === 'min-max') {\n    return Object.assign(Object.assign({}, outerSpec), {\n      transform: ((_b = outerSpec.transform) !== null && _b !== void 0 ? _b : []).concat(transform),\n      layer: boxLayers\n    });\n  } // Tukey Box Plot\n\n\n  const lowerBoxExpr = `datum[\"lower_box_${continuousAxisChannelDef.field}\"]`;\n  const upperBoxExpr = `datum[\"upper_box_${continuousAxisChannelDef.field}\"]`;\n  const iqrExpr = `(${upperBoxExpr} - ${lowerBoxExpr})`;\n  const lowerWhiskerExpr = `${lowerBoxExpr} - ${extent} * ${iqrExpr}`;\n  const upperWhiskerExpr = `${upperBoxExpr} + ${extent} * ${iqrExpr}`;\n  const fieldExpr = `datum[\"${continuousAxisChannelDef.field}\"]`;\n  const joinaggregateTransform = {\n    joinaggregate: boxParamsQuartiles(continuousAxisChannelDef.field),\n    groupby\n  };\n  const filteredWhiskerSpec = {\n    transform: [{\n      filter: `(${lowerWhiskerExpr} <= ${fieldExpr}) && (${fieldExpr} <= ${upperWhiskerExpr})`\n    }, {\n      aggregate: [{\n        op: 'min',\n        field: continuousAxisChannelDef.field,\n        as: `lower_whisker_${continuousAxisChannelDef.field}`\n      }, {\n        op: 'max',\n        field: continuousAxisChannelDef.field,\n        as: `upper_whisker_${continuousAxisChannelDef.field}`\n      }, // preserve lower_box / upper_box\n      {\n        op: 'min',\n        field: `lower_box_${continuousAxisChannelDef.field}`,\n        as: `lower_box_${continuousAxisChannelDef.field}`\n      }, {\n        op: 'max',\n        field: `upper_box_${continuousAxisChannelDef.field}`,\n        as: `upper_box_${continuousAxisChannelDef.field}`\n      }, ...aggregate],\n      groupby\n    }],\n    layer: whiskerLayers\n  };\n\n  const {\n    tooltip\n  } = encodingWithoutSizeColorAndContinuousAxis,\n        encodingWithoutSizeColorContinuousAxisAndTooltip = __rest(encodingWithoutSizeColorAndContinuousAxis, [\"tooltip\"]);\n\n  const {\n    scale,\n    axis\n  } = continuousAxisChannelDef;\n  const title = getTitle(continuousAxisChannelDef);\n  const axisWithoutTitle = omit(axis, ['title']);\n  const outlierLayersMixins = partLayerMixins(markDef, 'outliers', config.boxplot, {\n    transform: [{\n      filter: `(${fieldExpr} < ${lowerWhiskerExpr}) || (${fieldExpr} > ${upperWhiskerExpr})`\n    }],\n    mark: 'point',\n    encoding: Object.assign(Object.assign(Object.assign({\n      [continuousAxis]: Object.assign(Object.assign(Object.assign({\n        field: continuousAxisChannelDef.field,\n        type: continuousAxisChannelDef.type\n      }, title !== undefined ? {\n        title\n      } : {}), scale !== undefined ? {\n        scale\n      } : {}), isEmpty(axisWithoutTitle) ? {} : {\n        axis: axisWithoutTitle\n      })\n    }, encodingWithoutSizeColorContinuousAxisAndTooltip), color ? {\n      color\n    } : {}), customTooltipWithoutAggregatedField ? {\n      tooltip: customTooltipWithoutAggregatedField\n    } : {})\n  })[0];\n  let filteredLayersMixins;\n  const filteredLayersMixinsTransforms = [...bins, ...timeUnits, joinaggregateTransform];\n\n  if (outlierLayersMixins) {\n    filteredLayersMixins = {\n      transform: filteredLayersMixinsTransforms,\n      layer: [outlierLayersMixins, filteredWhiskerSpec]\n    };\n  } else {\n    filteredLayersMixins = filteredWhiskerSpec;\n    filteredLayersMixins.transform.unshift(...filteredLayersMixinsTransforms);\n  }\n\n  return Object.assign(Object.assign({}, outerSpec), {\n    layer: [filteredLayersMixins, {\n      // boxplot\n      transform,\n      layer: boxLayers\n    }]\n  });\n}\n\nfunction boxParamsQuartiles(continousAxisField) {\n  return [{\n    op: 'q1',\n    field: continousAxisField,\n    as: `lower_box_${continousAxisField}`\n  }, {\n    op: 'q3',\n    field: continousAxisField,\n    as: `upper_box_${continousAxisField}`\n  }];\n}\n\nfunction boxParams(spec, extent, config) {\n  const orient = compositeMarkOrient(spec, BOXPLOT);\n  const {\n    continuousAxisChannelDef,\n    continuousAxis\n  } = compositeMarkContinuousAxis(spec, orient, BOXPLOT);\n  const continuousFieldName = continuousAxisChannelDef.field;\n  const boxPlotType = getBoxPlotType(extent);\n  const boxplotSpecificAggregate = [...boxParamsQuartiles(continuousFieldName), {\n    op: 'median',\n    field: continuousFieldName,\n    as: `mid_box_${continuousFieldName}`\n  }, {\n    op: 'min',\n    field: continuousFieldName,\n    as: (boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_') + continuousFieldName\n  }, {\n    op: 'max',\n    field: continuousFieldName,\n    as: (boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_') + continuousFieldName\n  }];\n  const postAggregateCalculates = boxPlotType === 'min-max' || boxPlotType === 'tukey' ? [] : [// This is for the  original k-IQR, which we do not expose\n  {\n    calculate: `datum[\"upper_box_${continuousFieldName}\"] - datum[\"lower_box_${continuousFieldName}\"]`,\n    as: `iqr_${continuousFieldName}`\n  }, {\n    calculate: `min(datum[\"upper_box_${continuousFieldName}\"] + datum[\"iqr_${continuousFieldName}\"] * ${extent}, datum[\"max_${continuousFieldName}\"])`,\n    as: `upper_whisker_${continuousFieldName}`\n  }, {\n    calculate: `max(datum[\"lower_box_${continuousFieldName}\"] - datum[\"iqr_${continuousFieldName}\"] * ${extent}, datum[\"min_${continuousFieldName}\"])`,\n    as: `lower_whisker_${continuousFieldName}`\n  }];\n\n  const _a = spec.encoding,\n        _b = continuousAxis,\n        oldContinuousAxisChannelDef = _a[_b],\n        oldEncodingWithoutContinuousAxis = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n  const {\n    customTooltipWithoutAggregatedField,\n    filteredEncoding\n  } = filterTooltipWithAggregatedField(oldEncodingWithoutContinuousAxis);\n  const {\n    bins,\n    timeUnits,\n    aggregate,\n    groupby,\n    encoding: encodingWithoutContinuousAxis\n  } = extractTransformsFromEncoding(filteredEncoding, config);\n  const ticksOrient = orient === 'vertical' ? 'horizontal' : 'vertical';\n  const boxOrient = orient;\n  const transform = [...bins, ...timeUnits, {\n    aggregate: [...aggregate, ...boxplotSpecificAggregate],\n    groupby\n  }, ...postAggregateCalculates];\n  return {\n    bins,\n    timeUnits,\n    transform,\n    groupby,\n    aggregate,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    ticksOrient,\n    boxOrient,\n    customTooltipWithoutAggregatedField\n  };\n}","map":{"version":3,"mappings":"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","names":["isNumber","isObject","getMarkPropOrConfig","extractTransformsFromEncoding","normalizeEncoding","log","isMarkDef","isEmpty","omit","CompositeMarkNormalizer","compositeMarkContinuousAxis","compositeMarkOrient","filterTooltipWithAggregatedField","getCompositeMarkTooltip","getTitle","makeCompositeAggregatePartFactory","partLayerMixins","BOXPLOT","BOXPLOT_PARTS","boxPlotNormalizer","normalizeBoxPlot","getBoxPlotType","extent","spec","config","encoding","mark","_encoding","params","projection","_p","outerSpec","markDef","type","warn","message","selectionNotSupported","_a","boxplot","sizeValue","boxPlotType","bins","timeUnits","transform","continuousAxisChannelDef","continuousAxis","groupby","aggregate","encodingWithoutContinuousAxis","ticksOrient","boxOrient","customTooltipWithoutAggregatedField","boxParams","color","size","encodingWithoutSizeColorAndContinuousAxis","makeBoxPlotPart","sharedEncoding","makeBoxPlotExtent","makeBoxPlotBox","makeBoxPlotMidTick","fiveSummaryTooltipEncoding","fieldPrefix","titlePrefix","endTick","opacity","orient","invalid","aria","whiskerTooltipEncoding","whiskerLayers","partName","positionPrefix","endPositionPrefix","extraEncoding","boxLayers","ariaRoleDescription","median","_b","concat","layer","lowerBoxExpr","field","upperBoxExpr","iqrExpr","lowerWhiskerExpr","upperWhiskerExpr","fieldExpr","joinaggregateTransform","joinaggregate","boxParamsQuartiles","filteredWhiskerSpec","filter","op","as","tooltip","encodingWithoutSizeColorContinuousAxisAndTooltip","scale","axis","title","axisWithoutTitle","outlierLayersMixins","Object","undefined","filteredLayersMixins","filteredLayersMixinsTransforms","unshift","continousAxisField","continuousFieldName","boxplotSpecificAggregate","postAggregateCalculates","calculate","oldContinuousAxisChannelDef","oldEncodingWithoutContinuousAxis","filteredEncoding"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compositemark/boxplot.ts"],"sourcesContent":["import {Orientation} from 'vega';\nimport {isNumber, isObject} from 'vega-util';\nimport {getMarkPropOrConfig} from '../compile/common';\nimport {Config} from '../config';\nimport {Encoding, extractTransformsFromEncoding, normalizeEncoding} from '../encoding';\nimport * as log from '../log';\nimport {isMarkDef, MarkDef} from '../mark';\nimport {NormalizerParams} from '../normalize';\nimport {GenericUnitSpec, NormalizedLayerSpec, NormalizedUnitSpec} from '../spec';\nimport {AggregatedFieldDef, CalculateTransform, JoinAggregateTransform, Transform} from '../transform';\nimport {isEmpty, omit} from '../util';\nimport {CompositeMarkNormalizer} from './base';\nimport {\n  compositeMarkContinuousAxis,\n  compositeMarkOrient,\n  filterTooltipWithAggregatedField,\n  GenericCompositeMarkDef,\n  getCompositeMarkTooltip,\n  getTitle,\n  makeCompositeAggregatePartFactory,\n  partLayerMixins,\n  PartsMixins\n} from './common';\n\nexport const BOXPLOT = 'boxplot' as const;\nexport type BoxPlot = typeof BOXPLOT;\n\nexport const BOXPLOT_PARTS = ['box', 'median', 'outliers', 'rule', 'ticks'] as const;\n\ntype BoxPlotPart = typeof BOXPLOT_PARTS[number];\n\nexport type BoxPlotPartsMixins = PartsMixins<BoxPlotPart>;\n\nexport interface BoxPlotConfig extends BoxPlotPartsMixins {\n  /** Size of the box and median tick of a box plot */\n  size?: number;\n\n  /**\n   * The extent of the whiskers. Available options include:\n   * - `\"min-max\"`: min and max are the lower and upper whiskers respectively.\n   * - A number representing multiple of the interquartile range. This number will be multiplied by the IQR to determine whisker boundary, which spans from the smallest data to the largest data within the range _[Q1 - k * IQR, Q3 + k * IQR]_ where _Q1_ and _Q3_ are the first and third quartiles while _IQR_ is the interquartile range (_Q3-Q1_).\n   *\n   * __Default value:__ `1.5`.\n   */\n  extent?: 'min-max' | number;\n}\n\nexport type BoxPlotDef = GenericCompositeMarkDef<BoxPlot> &\n  BoxPlotConfig & {\n    /**\n     * Type of the mark. For box plots, this should always be `\"boxplot\"`.\n     * [boxplot](https://vega.github.io/vega-lite/docs/boxplot.html)\n     */\n    type: BoxPlot;\n\n    /**\n     * Orientation of the box plot. This is normally automatically determined based on types of fields on x and y channels. However, an explicit `orient` be specified when the orientation is ambiguous.\n     *\n     * __Default value:__ `\"vertical\"`.\n     */\n    orient?: Orientation;\n  };\n\nexport interface BoxPlotConfigMixins {\n  /**\n   * Box Config\n   */\n  boxplot?: BoxPlotConfig;\n}\n\nexport const boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);\n\nexport function getBoxPlotType(extent: number | 'min-max') {\n  if (isNumber(extent)) {\n    return 'tukey';\n  }\n  // Ham: If we ever want to, we could add another extent syntax `{kIQR: number}` for the original [Q1-k*IQR, Q3+k*IQR] whisker and call this boxPlotType = `kIQR`. However, I'm not exposing this for now.\n  return extent;\n}\n\nexport function normalizeBoxPlot(\n  spec: GenericUnitSpec<Encoding<string>, BoxPlot | BoxPlotDef>,\n  {config}: NormalizerParams\n): NormalizedLayerSpec {\n  // Need to initEncoding first so we can infer type\n  spec = {\n    ...spec,\n    encoding: normalizeEncoding(spec.encoding, config)\n  };\n  const {mark, encoding: _encoding, params, projection: _p, ...outerSpec} = spec;\n  const markDef: BoxPlotDef = isMarkDef(mark) ? mark : {type: mark};\n\n  // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n  if (params) {\n    log.warn(log.message.selectionNotSupported('boxplot'));\n  }\n\n  const extent = markDef.extent ?? config.boxplot.extent;\n  const sizeValue = getMarkPropOrConfig(\n    'size',\n    markDef as any, // TODO: https://github.com/vega/vega-lite/issues/6245\n    config\n  );\n\n  const boxPlotType = getBoxPlotType(extent);\n  const {\n    bins,\n    timeUnits,\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    groupby,\n    aggregate,\n    encodingWithoutContinuousAxis,\n    ticksOrient,\n    boxOrient,\n    customTooltipWithoutAggregatedField\n  } = boxParams(spec, extent, config);\n\n  const {color, size, ...encodingWithoutSizeColorAndContinuousAxis} = encodingWithoutContinuousAxis;\n\n  const makeBoxPlotPart = (sharedEncoding: Encoding<string>) => {\n    return makeCompositeAggregatePartFactory<BoxPlotPartsMixins>(\n      markDef,\n      continuousAxis,\n      continuousAxisChannelDef,\n      sharedEncoding,\n      config.boxplot\n    );\n  };\n\n  const makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);\n  const makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);\n  const makeBoxPlotMidTick = makeBoxPlotPart({...encodingWithoutSizeColorAndContinuousAxis, ...(size ? {size} : {})});\n\n  const fiveSummaryTooltipEncoding: Encoding<string> = getCompositeMarkTooltip(\n    [\n      {fieldPrefix: boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_', titlePrefix: 'Max'},\n      {fieldPrefix: 'upper_box_', titlePrefix: 'Q3'},\n      {fieldPrefix: 'mid_box_', titlePrefix: 'Median'},\n      {fieldPrefix: 'lower_box_', titlePrefix: 'Q1'},\n      {fieldPrefix: boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_', titlePrefix: 'Min'}\n    ],\n    continuousAxisChannelDef,\n    encodingWithoutContinuousAxis\n  );\n\n  // ## Whisker Layers\n\n  const endTick: MarkDef = {type: 'tick', color: 'black', opacity: 1, orient: ticksOrient, invalid: null, aria: false};\n  const whiskerTooltipEncoding: Encoding<string> =\n    boxPlotType === 'min-max'\n      ? fiveSummaryTooltipEncoding // for min-max, show five-summary tooltip for whisker\n      : // for tukey / k-IQR, just show upper/lower-whisker\n        getCompositeMarkTooltip(\n          [\n            {fieldPrefix: 'upper_whisker_', titlePrefix: 'Upper Whisker'},\n            {fieldPrefix: 'lower_whisker_', titlePrefix: 'Lower Whisker'}\n          ],\n          continuousAxisChannelDef,\n          encodingWithoutContinuousAxis\n        );\n\n  const whiskerLayers = [\n    ...makeBoxPlotExtent({\n      partName: 'rule',\n      mark: {type: 'rule', invalid: null, aria: false},\n      positionPrefix: 'lower_whisker',\n      endPositionPrefix: 'lower_box',\n      extraEncoding: whiskerTooltipEncoding\n    }),\n    ...makeBoxPlotExtent({\n      partName: 'rule',\n      mark: {type: 'rule', invalid: null, aria: false},\n      positionPrefix: 'upper_box',\n      endPositionPrefix: 'upper_whisker',\n      extraEncoding: whiskerTooltipEncoding\n    }),\n    ...makeBoxPlotExtent({\n      partName: 'ticks',\n      mark: endTick,\n      positionPrefix: 'lower_whisker',\n      extraEncoding: whiskerTooltipEncoding\n    }),\n    ...makeBoxPlotExtent({\n      partName: 'ticks',\n      mark: endTick,\n      positionPrefix: 'upper_whisker',\n      extraEncoding: whiskerTooltipEncoding\n    })\n  ];\n\n  // ## Box Layers\n\n  // TODO: support hiding certain mark parts\n  const boxLayers: NormalizedUnitSpec[] = [\n    ...(boxPlotType !== 'tukey' ? whiskerLayers : []),\n    ...makeBoxPlotBox({\n      partName: 'box',\n      mark: {\n        type: 'bar',\n        ...(sizeValue ? {size: sizeValue} : {}),\n        orient: boxOrient,\n        invalid: null,\n        ariaRoleDescription: 'box'\n      },\n      positionPrefix: 'lower_box',\n      endPositionPrefix: 'upper_box',\n      extraEncoding: fiveSummaryTooltipEncoding\n    }),\n    ...makeBoxPlotMidTick({\n      partName: 'median',\n      mark: {\n        type: 'tick',\n        invalid: null,\n        ...(isObject(config.boxplot.median) && config.boxplot.median.color ? {color: config.boxplot.median.color} : {}),\n        ...(sizeValue ? {size: sizeValue} : {}),\n        orient: ticksOrient,\n        aria: false\n      },\n      positionPrefix: 'mid_box',\n      extraEncoding: fiveSummaryTooltipEncoding\n    })\n  ];\n\n  if (boxPlotType === 'min-max') {\n    return {\n      ...outerSpec,\n      transform: (outerSpec.transform ?? []).concat(transform),\n      layer: boxLayers\n    };\n  }\n\n  // Tukey Box Plot\n\n  const lowerBoxExpr = `datum[\"lower_box_${continuousAxisChannelDef.field}\"]`;\n  const upperBoxExpr = `datum[\"upper_box_${continuousAxisChannelDef.field}\"]`;\n  const iqrExpr = `(${upperBoxExpr} - ${lowerBoxExpr})`;\n  const lowerWhiskerExpr = `${lowerBoxExpr} - ${extent} * ${iqrExpr}`;\n  const upperWhiskerExpr = `${upperBoxExpr} + ${extent} * ${iqrExpr}`;\n  const fieldExpr = `datum[\"${continuousAxisChannelDef.field}\"]`;\n\n  const joinaggregateTransform: JoinAggregateTransform = {\n    joinaggregate: boxParamsQuartiles(continuousAxisChannelDef.field),\n    groupby\n  };\n\n  const filteredWhiskerSpec: NormalizedLayerSpec = {\n    transform: [\n      {\n        filter: `(${lowerWhiskerExpr} <= ${fieldExpr}) && (${fieldExpr} <= ${upperWhiskerExpr})`\n      },\n      {\n        aggregate: [\n          {\n            op: 'min',\n            field: continuousAxisChannelDef.field,\n            as: `lower_whisker_${continuousAxisChannelDef.field}`\n          },\n          {\n            op: 'max',\n            field: continuousAxisChannelDef.field,\n            as: `upper_whisker_${continuousAxisChannelDef.field}`\n          },\n          // preserve lower_box / upper_box\n          {\n            op: 'min',\n            field: `lower_box_${continuousAxisChannelDef.field}`,\n            as: `lower_box_${continuousAxisChannelDef.field}`\n          },\n          {\n            op: 'max',\n            field: `upper_box_${continuousAxisChannelDef.field}`,\n            as: `upper_box_${continuousAxisChannelDef.field}`\n          },\n          ...aggregate\n        ],\n        groupby\n      }\n    ],\n    layer: whiskerLayers\n  };\n\n  const {tooltip, ...encodingWithoutSizeColorContinuousAxisAndTooltip} = encodingWithoutSizeColorAndContinuousAxis;\n\n  const {scale, axis} = continuousAxisChannelDef;\n  const title = getTitle(continuousAxisChannelDef);\n  const axisWithoutTitle = omit(axis, ['title']);\n\n  const outlierLayersMixins = partLayerMixins<BoxPlotPartsMixins>(markDef, 'outliers', config.boxplot, {\n    transform: [{filter: `(${fieldExpr} < ${lowerWhiskerExpr}) || (${fieldExpr} > ${upperWhiskerExpr})`}],\n    mark: 'point',\n    encoding: {\n      [continuousAxis]: {\n        field: continuousAxisChannelDef.field,\n        type: continuousAxisChannelDef.type,\n        ...(title !== undefined ? {title} : {}),\n        ...(scale !== undefined ? {scale} : {}),\n        // add axis without title since we already added the title above\n        ...(isEmpty(axisWithoutTitle) ? {} : {axis: axisWithoutTitle})\n      },\n      ...encodingWithoutSizeColorContinuousAxisAndTooltip,\n      ...(color ? {color} : {}),\n      ...(customTooltipWithoutAggregatedField ? {tooltip: customTooltipWithoutAggregatedField} : {})\n    }\n  })[0];\n\n  let filteredLayersMixins: NormalizedLayerSpec;\n  const filteredLayersMixinsTransforms = [...bins, ...timeUnits, joinaggregateTransform];\n  if (outlierLayersMixins) {\n    filteredLayersMixins = {\n      transform: filteredLayersMixinsTransforms,\n      layer: [outlierLayersMixins, filteredWhiskerSpec]\n    };\n  } else {\n    filteredLayersMixins = filteredWhiskerSpec;\n    filteredLayersMixins.transform.unshift(...filteredLayersMixinsTransforms);\n  }\n\n  return {\n    ...outerSpec,\n    layer: [\n      filteredLayersMixins,\n      {\n        // boxplot\n        transform,\n        layer: boxLayers\n      }\n    ]\n  };\n}\n\nfunction boxParamsQuartiles(continousAxisField: string): AggregatedFieldDef[] {\n  return [\n    {\n      op: 'q1',\n      field: continousAxisField,\n      as: `lower_box_${continousAxisField}`\n    },\n    {\n      op: 'q3',\n      field: continousAxisField,\n      as: `upper_box_${continousAxisField}`\n    }\n  ];\n}\n\nfunction boxParams(\n  spec: GenericUnitSpec<Encoding<string>, BoxPlot | BoxPlotDef>,\n  extent: 'min-max' | number,\n  config: Config\n) {\n  const orient = compositeMarkOrient(spec, BOXPLOT);\n  const {continuousAxisChannelDef, continuousAxis} = compositeMarkContinuousAxis(spec, orient, BOXPLOT);\n  const continuousFieldName: string = continuousAxisChannelDef.field;\n\n  const boxPlotType = getBoxPlotType(extent);\n\n  const boxplotSpecificAggregate: AggregatedFieldDef[] = [\n    ...boxParamsQuartiles(continuousFieldName),\n    {\n      op: 'median',\n      field: continuousFieldName,\n      as: `mid_box_${continuousFieldName}`\n    },\n    {\n      op: 'min',\n      field: continuousFieldName,\n      as: (boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_') + continuousFieldName\n    },\n    {\n      op: 'max',\n      field: continuousFieldName,\n      as: (boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_') + continuousFieldName\n    }\n  ];\n\n  const postAggregateCalculates: CalculateTransform[] =\n    boxPlotType === 'min-max' || boxPlotType === 'tukey'\n      ? []\n      : [\n          // This is for the  original k-IQR, which we do not expose\n          {\n            calculate: `datum[\"upper_box_${continuousFieldName}\"] - datum[\"lower_box_${continuousFieldName}\"]`,\n            as: `iqr_${continuousFieldName}`\n          },\n          {\n            calculate: `min(datum[\"upper_box_${continuousFieldName}\"] + datum[\"iqr_${continuousFieldName}\"] * ${extent}, datum[\"max_${continuousFieldName}\"])`,\n            as: `upper_whisker_${continuousFieldName}`\n          },\n          {\n            calculate: `max(datum[\"lower_box_${continuousFieldName}\"] - datum[\"iqr_${continuousFieldName}\"] * ${extent}, datum[\"min_${continuousFieldName}\"])`,\n            as: `lower_whisker_${continuousFieldName}`\n          }\n        ];\n\n  const {[continuousAxis]: oldContinuousAxisChannelDef, ...oldEncodingWithoutContinuousAxis} = spec.encoding;\n  const {customTooltipWithoutAggregatedField, filteredEncoding} = filterTooltipWithAggregatedField(\n    oldEncodingWithoutContinuousAxis\n  );\n\n  const {\n    bins,\n    timeUnits,\n    aggregate,\n    groupby,\n    encoding: encodingWithoutContinuousAxis\n  } = extractTransformsFromEncoding(filteredEncoding, config);\n\n  const ticksOrient: Orientation = orient === 'vertical' ? 'horizontal' : 'vertical';\n  const boxOrient: Orientation = orient;\n\n  const transform: Transform[] = [\n    ...bins,\n    ...timeUnits,\n    {\n      aggregate: [...aggregate, ...boxplotSpecificAggregate],\n      groupby\n    },\n    ...postAggregateCalculates\n  ];\n\n  return {\n    bins,\n    timeUnits,\n    transform,\n    groupby,\n    aggregate,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    ticksOrient,\n    boxOrient,\n    customTooltipWithoutAggregatedField\n  };\n}\n"]},"metadata":{},"sourceType":"module"}