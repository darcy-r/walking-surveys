{"ast":null,"code":"import { array } from 'vega-util';\nimport { isConditionalDef, isConditionalParameter } from '../../../channeldef';\nimport { expression } from '../../predicate';\nimport { parseSelectionPredicate } from '../../selection/parse';\n/**\n * Return a mixin that includes a Vega production rule for a Vega-Lite conditional channel definition\n * or a simple mixin if channel def has no condition.\n */\n\nexport function wrapCondition(model, channelDef, vgChannel, refFn) {\n  const condition = isConditionalDef(channelDef) && channelDef.condition;\n  const valueRef = refFn(channelDef);\n\n  if (condition) {\n    const conditions = array(condition);\n    const vgConditions = conditions.map(c => {\n      const conditionValueRef = refFn(c);\n\n      if (isConditionalParameter(c)) {\n        const {\n          param,\n          empty\n        } = c;\n        const test = parseSelectionPredicate(model, {\n          param,\n          empty\n        });\n        return Object.assign({\n          test\n        }, conditionValueRef);\n      } else {\n        const test = expression(model, c.test); // FIXME: remove casting once TS is no longer dumb about it\n\n        return Object.assign({\n          test\n        }, conditionValueRef);\n      }\n    });\n    return {\n      [vgChannel]: [...vgConditions, ...(valueRef !== undefined ? [valueRef] : [])]\n    };\n  } else {\n    return valueRef !== undefined ? {\n      [vgChannel]: valueRef\n    } : {};\n  }\n}","map":{"version":3,"mappings":"AAAA,SAAQA,KAAR,QAAoB,WAApB;AACA,SAA0CC,gBAA1C,EAA4DC,sBAA5D,QAAyF,qBAAzF;AAGA,SAAQC,UAAR,QAAyB,iBAAzB;AACA,SAAQC,uBAAR,QAAsC,uBAAtC;AAGA;;;;;AAIA,OAAM,SAAUC,aAAV,CACJC,KADI,EAEJC,UAFI,EAGJC,SAHI,EAIJC,KAJI,EAI2B;EAE/B,MAAMC,SAAS,GAAGT,gBAAgB,CAAKM,UAAL,CAAhB,IAAoCA,UAAU,CAACG,SAAjE;EACA,MAAMC,QAAQ,GAAGF,KAAK,CAACF,UAAD,CAAtB;;EACA,IAAIG,SAAJ,EAAe;IACb,MAAME,UAAU,GAAGZ,KAAK,CAACU,SAAD,CAAxB;IACA,MAAMG,YAAY,GAAGD,UAAU,CAACE,GAAX,CAAeC,CAAC,IAAG;MACtC,MAAMC,iBAAiB,GAAGP,KAAK,CAACM,CAAD,CAA/B;;MACA,IAAIb,sBAAsB,CAAMa,CAAN,CAA1B,EAAoC;QAClC,MAAM;UAACE,KAAD;UAAQC;QAAR,IAAiBH,CAAvB;QACA,MAAMI,IAAI,GAAGf,uBAAuB,CAACE,KAAD,EAAQ;UAACW,KAAD;UAAQC;QAAR,CAAR,CAApC;QACA;UAAQC;QAAR,GAAiBH,iBAAjB;MACD,CAJD,MAIO;QACL,MAAMG,IAAI,GAAGhB,UAAU,CAACG,KAAD,EAASS,CAA+B,CAACI,IAAzC,CAAvB,CADK,CACkE;;QACvE;UAAQA;QAAR,GAAiBH,iBAAjB;MACD;IACF,CAVoB,CAArB;IAWA,OAAO;MACL,CAACR,SAAD,GAAa,CAAC,GAAGK,YAAJ,EAAkB,IAAIF,QAAQ,KAAKS,SAAb,GAAyB,CAACT,QAAD,CAAzB,GAAsC,EAA1C,CAAlB;IADR,CAAP;EAGD,CAhBD,MAgBO;IACL,OAAOA,QAAQ,KAAKS,SAAb,GAAyB;MAAC,CAACZ,SAAD,GAAaG;IAAd,CAAzB,GAAmD,EAA1D;EACD;AACF","names":["array","isConditionalDef","isConditionalParameter","expression","parseSelectionPredicate","wrapCondition","model","channelDef","vgChannel","refFn","condition","valueRef","conditions","vgConditions","map","c","conditionValueRef","param","empty","test","undefined"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/mark/encode/conditional.ts"],"sourcesContent":["import {array} from 'vega-util';\nimport {ChannelDef, ConditionalPredicate, isConditionalDef, isConditionalParameter} from '../../../channeldef';\nimport {GuideEncodingConditionalValueDef} from '../../../guide';\nimport {VgEncodeEntry, VgValueRef} from '../../../vega.schema';\nimport {expression} from '../../predicate';\nimport {parseSelectionPredicate} from '../../selection/parse';\nimport {UnitModel} from '../../unit';\n\n/**\n * Return a mixin that includes a Vega production rule for a Vega-Lite conditional channel definition\n * or a simple mixin if channel def has no condition.\n */\nexport function wrapCondition<CD extends ChannelDef | GuideEncodingConditionalValueDef>(\n  model: UnitModel,\n  channelDef: CD,\n  vgChannel: string,\n  refFn: (cDef: CD) => VgValueRef\n): VgEncodeEntry {\n  const condition = isConditionalDef<CD>(channelDef) && channelDef.condition;\n  const valueRef = refFn(channelDef);\n  if (condition) {\n    const conditions = array(condition);\n    const vgConditions = conditions.map(c => {\n      const conditionValueRef = refFn(c);\n      if (isConditionalParameter<any>(c)) {\n        const {param, empty} = c;\n        const test = parseSelectionPredicate(model, {param, empty});\n        return {test, ...conditionValueRef};\n      } else {\n        const test = expression(model, (c as ConditionalPredicate<any>).test); // FIXME: remove casting once TS is no longer dumb about it\n        return {test, ...conditionValueRef};\n      }\n    });\n    return {\n      [vgChannel]: [...vgConditions, ...(valueRef !== undefined ? [valueRef] : [])]\n    };\n  } else {\n    return valueRef !== undefined ? {[vgChannel]: valueRef} : {};\n  }\n}\n"]},"metadata":{},"sourceType":"module"}