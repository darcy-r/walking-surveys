{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isArray, isBoolean, isString } from 'vega-util';\nimport { isContinuousFieldOrDatumDef, isFieldDef, isFieldOrDatumDefForTimeFormat } from '../channeldef';\nimport { fieldDefs } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { getFirstDefined, hash, unique } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { toStringFieldDef } from './../channeldef';\nexport function filterTooltipWithAggregatedField(oldEncoding) {\n  const {\n    tooltip\n  } = oldEncoding,\n        filteredEncoding = __rest(oldEncoding, [\"tooltip\"]);\n\n  if (!tooltip) {\n    return {\n      filteredEncoding\n    };\n  }\n\n  let customTooltipWithAggregatedField;\n  let customTooltipWithoutAggregatedField;\n\n  if (isArray(tooltip)) {\n    for (const t of tooltip) {\n      if (t.aggregate) {\n        if (!customTooltipWithAggregatedField) {\n          customTooltipWithAggregatedField = [];\n        }\n\n        customTooltipWithAggregatedField.push(t);\n      } else {\n        if (!customTooltipWithoutAggregatedField) {\n          customTooltipWithoutAggregatedField = [];\n        }\n\n        customTooltipWithoutAggregatedField.push(t);\n      }\n    }\n\n    if (customTooltipWithAggregatedField) {\n      filteredEncoding.tooltip = customTooltipWithAggregatedField;\n    }\n  } else {\n    if (tooltip['aggregate']) {\n      filteredEncoding.tooltip = tooltip;\n    } else {\n      customTooltipWithoutAggregatedField = tooltip;\n    }\n  }\n\n  if (isArray(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {\n    customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];\n  }\n\n  return {\n    customTooltipWithoutAggregatedField,\n    filteredEncoding\n  };\n}\nexport function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis) {\n  let withFieldName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n  if ('tooltip' in encodingWithoutContinuousAxis) {\n    return {\n      tooltip: encodingWithoutContinuousAxis.tooltip\n    };\n  }\n\n  const fiveSummaryTooltip = tooltipSummary.map(_ref => {\n    let {\n      fieldPrefix,\n      titlePrefix\n    } = _ref;\n    const mainTitle = withFieldName ? ` of ${getTitle(continuousAxisChannelDef)}` : '';\n    return {\n      field: fieldPrefix + continuousAxisChannelDef.field,\n      type: continuousAxisChannelDef.type,\n      title: isSignalRef(titlePrefix) ? {\n        signal: `${titlePrefix}\"${escape(mainTitle)}\"`\n      } : titlePrefix + mainTitle\n    };\n  });\n  const tooltipFieldDefs = fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);\n  return {\n    tooltip: [...fiveSummaryTooltip, // need to cast because TextFieldDef supports fewer types of bin\n    ...unique(tooltipFieldDefs, hash)]\n  };\n}\nexport function getTitle(continuousAxisChannelDef) {\n  const {\n    title,\n    field\n  } = continuousAxisChannelDef;\n  return getFirstDefined(title, field);\n}\nexport function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {\n  const {\n    scale,\n    axis\n  } = continuousAxisChannelDef;\n  return _ref2 => {\n    let {\n      partName,\n      mark,\n      positionPrefix,\n      endPositionPrefix = undefined,\n      extraEncoding = {}\n    } = _ref2;\n    const title = getTitle(continuousAxisChannelDef);\n    return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, {\n      mark,\n      encoding: Object.assign(Object.assign(Object.assign({\n        [continuousAxis]: Object.assign(Object.assign(Object.assign({\n          field: `${positionPrefix}_${continuousAxisChannelDef.field}`,\n          type: continuousAxisChannelDef.type\n        }, title !== undefined ? {\n          title\n        } : {}), scale !== undefined ? {\n          scale\n        } : {}), axis !== undefined ? {\n          axis\n        } : {})\n      }, isString(endPositionPrefix) ? {\n        [`${continuousAxis}2`]: {\n          field: `${endPositionPrefix}_${continuousAxisChannelDef.field}`\n        }\n      } : {}), sharedEncoding), extraEncoding)\n    });\n  };\n}\nexport function partLayerMixins(markDef, part, compositeMarkConfig, partBaseSpec) {\n  const {\n    clip,\n    color,\n    opacity\n  } = markDef;\n  const mark = markDef.type;\n\n  if (markDef[part] || markDef[part] === undefined && compositeMarkConfig[part]) {\n    return [Object.assign(Object.assign({}, partBaseSpec), {\n      mark: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, compositeMarkConfig[part]), clip ? {\n        clip\n      } : {}), color ? {\n        color\n      } : {}), opacity ? {\n        opacity\n      } : {}), isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : {\n        type: partBaseSpec.mark\n      }), {\n        style: `${mark}-${part}`\n      }), isBoolean(markDef[part]) ? {} : markDef[part])\n    })];\n  }\n\n  return [];\n}\nexport function compositeMarkContinuousAxis(spec, orient, compositeMark) {\n  const {\n    encoding\n  } = spec;\n  const continuousAxis = orient === 'vertical' ? 'y' : 'x';\n  const continuousAxisChannelDef = encoding[continuousAxis]; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n\n  const continuousAxisChannelDef2 = encoding[`${continuousAxis}2`];\n  const continuousAxisChannelDefError = encoding[`${continuousAxis}Error`];\n  const continuousAxisChannelDefError2 = encoding[`${continuousAxis}Error2`];\n  return {\n    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),\n    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),\n    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),\n    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),\n    continuousAxis\n  };\n}\n\nfunction filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {\n  if (continuousAxisChannelDef === null || continuousAxisChannelDef === void 0 ? void 0 : continuousAxisChannelDef.aggregate) {\n    const {\n      aggregate\n    } = continuousAxisChannelDef,\n          continuousAxisWithoutAggregate = __rest(continuousAxisChannelDef, [\"aggregate\"]);\n\n    if (aggregate !== compositeMark) {\n      log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n    }\n\n    return continuousAxisWithoutAggregate;\n  } else {\n    return continuousAxisChannelDef;\n  }\n}\n\nexport function compositeMarkOrient(spec, compositeMark) {\n  const {\n    mark,\n    encoding\n  } = spec;\n  const {\n    x,\n    y\n  } = encoding;\n\n  if (isMarkDef(mark) && mark.orient) {\n    return mark.orient;\n  }\n\n  if (isContinuousFieldOrDatumDef(x)) {\n    // x is continuous\n    if (isContinuousFieldOrDatumDef(y)) {\n      // both x and y are continuous\n      const xAggregate = isFieldDef(x) && x.aggregate;\n      const yAggregate = isFieldDef(y) && y.aggregate;\n\n      if (!xAggregate && yAggregate === compositeMark) {\n        return 'vertical';\n      } else if (!yAggregate && xAggregate === compositeMark) {\n        return 'horizontal';\n      } else if (xAggregate === compositeMark && yAggregate === compositeMark) {\n        throw new Error('Both x and y cannot have aggregate');\n      } else {\n        if (isFieldOrDatumDefForTimeFormat(y) && !isFieldOrDatumDefForTimeFormat(x)) {\n          // y is temporal but x is not\n          return 'horizontal';\n        } // default orientation for two continuous\n\n\n        return 'vertical';\n      }\n    }\n\n    return 'horizontal';\n  } else if (isContinuousFieldOrDatumDef(y)) {\n    // y is continuous but x is not\n    return 'vertical';\n  } else {\n    // Neither x nor y is continuous.\n    throw new Error(`Need a valid continuous axis for ${compositeMark}s`);\n  }\n}","map":{"version":3,"mappings":"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","names":["isArray","isBoolean","isString","isContinuousFieldOrDatumDef","isFieldDef","isFieldOrDatumDefForTimeFormat","fieldDefs","log","isMarkDef","getFirstDefined","hash","unique","isSignalRef","toStringFieldDef","filterTooltipWithAggregatedField","oldEncoding","tooltip","filteredEncoding","customTooltipWithAggregatedField","customTooltipWithoutAggregatedField","t","aggregate","push","length","getCompositeMarkTooltip","tooltipSummary","continuousAxisChannelDef","encodingWithoutContinuousAxis","withFieldName","fiveSummaryTooltip","map","fieldPrefix","titlePrefix","mainTitle","getTitle","field","type","title","signal","escape","tooltipFieldDefs","makeCompositeAggregatePartFactory","compositeMarkDef","continuousAxis","sharedEncoding","compositeMarkConfig","scale","axis","partName","mark","positionPrefix","endPositionPrefix","undefined","extraEncoding","partLayerMixins","encoding","Object","markDef","part","partBaseSpec","clip","color","opacity","style","compositeMarkContinuousAxis","spec","orient","compositeMark","continuousAxisChannelDef2","continuousAxisChannelDefError","continuousAxisChannelDefError2","filterAggregateFromChannelDef","continuousAxisWithoutAggregate","warn","message","errorBarContinuousAxisHasCustomizedAggregate","compositeMarkOrient","x","y","xAggregate","yAggregate","Error"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compositemark/common.ts"],"sourcesContent":["import {Orientation, SignalRef, Text} from 'vega';\nimport {isArray, isBoolean, isString} from 'vega-util';\nimport {CompositeMark, CompositeMarkDef} from '.';\nimport {\n  Field,\n  FieldDefBase,\n  isContinuousFieldOrDatumDef,\n  isFieldDef,\n  isFieldOrDatumDefForTimeFormat,\n  PositionFieldDef,\n  SecondaryFieldDef,\n  StringFieldDef,\n  StringFieldDefWithCondition,\n  StringValueDefWithCondition\n} from '../channeldef';\nimport {Encoding, fieldDefs} from '../encoding';\nimport {ExprRef} from '../expr';\nimport * as log from '../log';\nimport {ColorMixins, GenericMarkDef, isMarkDef, Mark, MarkConfig, MarkDef} from '../mark';\nimport {GenericUnitSpec, NormalizedUnitSpec} from '../spec';\nimport {getFirstDefined, hash, unique} from '../util';\nimport {isSignalRef} from '../vega.schema';\nimport {toStringFieldDef} from './../channeldef';\n\nexport type PartsMixins<P extends string> = Partial<Record<P, boolean | MarkConfig<ExprRef | SignalRef>>>;\n\nexport type GenericCompositeMarkDef<T> = GenericMarkDef<T> &\n  ColorMixins<ExprRef | SignalRef> & {\n    /**\n     * The opacity (value between [0,1]) of the mark.\n     *\n     * @minimum 0\n     * @maximum 1\n     */\n    opacity?: number;\n\n    /**\n     * Whether a composite mark be clipped to the enclosing group’s width and height.\n     */\n    clip?: boolean;\n  };\n\nexport interface CompositeMarkTooltipSummary {\n  /**\n   * The prefix of the field to be shown in tooltip\n   */\n  fieldPrefix: string;\n\n  /**\n   * The title prefix to show, corresponding to the field with field prefix `fieldPrefix`\n   */\n  titlePrefix: Text | SignalRef;\n}\n\nexport function filterTooltipWithAggregatedField<F extends Field>(\n  oldEncoding: Encoding<F>\n): {\n  customTooltipWithoutAggregatedField?:\n    | StringFieldDefWithCondition<F>\n    | StringValueDefWithCondition<F>\n    | StringFieldDef<F>[];\n  filteredEncoding: Encoding<F>;\n} {\n  const {tooltip, ...filteredEncoding} = oldEncoding;\n  if (!tooltip) {\n    return {filteredEncoding};\n  }\n\n  let customTooltipWithAggregatedField:\n    | StringFieldDefWithCondition<F>\n    | StringValueDefWithCondition<F>\n    | StringFieldDef<F>[];\n  let customTooltipWithoutAggregatedField:\n    | StringFieldDefWithCondition<F>\n    | StringValueDefWithCondition<F>\n    | StringFieldDef<F>[];\n\n  if (isArray(tooltip)) {\n    for (const t of tooltip) {\n      if (t.aggregate) {\n        if (!customTooltipWithAggregatedField) {\n          customTooltipWithAggregatedField = [];\n        }\n        (customTooltipWithAggregatedField as StringFieldDef<F>[]).push(t);\n      } else {\n        if (!customTooltipWithoutAggregatedField) {\n          customTooltipWithoutAggregatedField = [];\n        }\n        (customTooltipWithoutAggregatedField as StringFieldDef<F>[]).push(t);\n      }\n    }\n\n    if (customTooltipWithAggregatedField) {\n      (filteredEncoding as Encoding<F>).tooltip = customTooltipWithAggregatedField;\n    }\n  } else {\n    if (tooltip['aggregate']) {\n      (filteredEncoding as Encoding<F>).tooltip = tooltip;\n    } else {\n      customTooltipWithoutAggregatedField = tooltip;\n    }\n  }\n\n  if (isArray(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {\n    customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];\n  }\n  return {customTooltipWithoutAggregatedField, filteredEncoding};\n}\n\nexport function getCompositeMarkTooltip(\n  tooltipSummary: CompositeMarkTooltipSummary[],\n  continuousAxisChannelDef: PositionFieldDef<string>,\n  encodingWithoutContinuousAxis: Encoding<string>,\n  withFieldName = true\n): Encoding<string> {\n  if ('tooltip' in encodingWithoutContinuousAxis) {\n    return {tooltip: encodingWithoutContinuousAxis.tooltip};\n  }\n\n  const fiveSummaryTooltip: StringFieldDef<string>[] = tooltipSummary.map(\n    ({fieldPrefix, titlePrefix}): StringFieldDef<string> => {\n      const mainTitle = withFieldName ? ` of ${getTitle(continuousAxisChannelDef)}` : '';\n      return {\n        field: fieldPrefix + continuousAxisChannelDef.field,\n        type: continuousAxisChannelDef.type,\n        title: isSignalRef(titlePrefix) ? {signal: `${titlePrefix}\"${escape(mainTitle)}\"`} : titlePrefix + mainTitle\n      };\n    }\n  );\n\n  const tooltipFieldDefs = fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);\n\n  return {\n    tooltip: [\n      ...fiveSummaryTooltip,\n      // need to cast because TextFieldDef supports fewer types of bin\n      ...unique(tooltipFieldDefs, hash)\n    ]\n  };\n}\n\nexport function getTitle(continuousAxisChannelDef: PositionFieldDef<string>) {\n  const {title, field} = continuousAxisChannelDef;\n  return getFirstDefined(title, field);\n}\n\nexport function makeCompositeAggregatePartFactory<P extends PartsMixins<any>>(\n  compositeMarkDef: GenericCompositeMarkDef<any> & P,\n  continuousAxis: 'x' | 'y',\n  continuousAxisChannelDef: PositionFieldDef<string>,\n  sharedEncoding: Encoding<string>,\n  compositeMarkConfig: P\n) {\n  const {scale, axis} = continuousAxisChannelDef;\n\n  return ({\n    partName,\n    mark,\n    positionPrefix,\n    endPositionPrefix = undefined,\n    extraEncoding = {}\n  }: {\n    partName: keyof P;\n    mark: Mark | MarkDef;\n    positionPrefix: string;\n    endPositionPrefix?: string;\n    extraEncoding?: Encoding<string>;\n  }) => {\n    const title = getTitle(continuousAxisChannelDef);\n\n    return partLayerMixins<P>(compositeMarkDef, partName, compositeMarkConfig, {\n      mark, // TODO better remove this method and just have mark as a parameter of the method\n      encoding: {\n        [continuousAxis]: {\n          field: `${positionPrefix}_${continuousAxisChannelDef.field}`,\n          type: continuousAxisChannelDef.type,\n          ...(title !== undefined ? {title} : {}),\n          ...(scale !== undefined ? {scale} : {}),\n          ...(axis !== undefined ? {axis} : {})\n        },\n        ...(isString(endPositionPrefix)\n          ? {\n              [`${continuousAxis}2`]: {\n                field: `${endPositionPrefix}_${continuousAxisChannelDef.field}`\n              }\n            }\n          : {}),\n        ...sharedEncoding,\n        ...extraEncoding\n      }\n    });\n  };\n}\n\nexport function partLayerMixins<P extends PartsMixins<any>>(\n  markDef: GenericCompositeMarkDef<any> & P,\n  part: keyof P,\n  compositeMarkConfig: P,\n  partBaseSpec: NormalizedUnitSpec\n): NormalizedUnitSpec[] {\n  const {clip, color, opacity} = markDef;\n\n  const mark = markDef.type;\n\n  if (markDef[part] || (markDef[part] === undefined && compositeMarkConfig[part])) {\n    return [\n      {\n        ...partBaseSpec,\n        mark: {\n          ...(compositeMarkConfig[part] as MarkConfig<ExprRef | SignalRef>),\n          ...(clip ? {clip} : {}),\n          ...(color ? {color} : {}),\n          ...(opacity ? {opacity} : {}),\n          ...(isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : {type: partBaseSpec.mark}),\n          style: `${mark}-${part}`,\n          ...(isBoolean(markDef[part]) ? {} : (markDef[part] as MarkConfig<ExprRef | SignalRef>))\n        }\n      }\n    ];\n  }\n  return [];\n}\n\nexport function compositeMarkContinuousAxis<M extends CompositeMark>(\n  spec: GenericUnitSpec<Encoding<string>, CompositeMark | CompositeMarkDef>,\n  orient: Orientation,\n  compositeMark: M\n): {\n  continuousAxisChannelDef: PositionFieldDef<string>;\n  continuousAxisChannelDef2: SecondaryFieldDef<string>;\n  continuousAxisChannelDefError: SecondaryFieldDef<string>;\n  continuousAxisChannelDefError2: SecondaryFieldDef<string>;\n  continuousAxis: 'x' | 'y';\n} {\n  const {encoding} = spec;\n  const continuousAxis: 'x' | 'y' = orient === 'vertical' ? 'y' : 'x';\n\n  const continuousAxisChannelDef = encoding[continuousAxis] as PositionFieldDef<string>; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n  const continuousAxisChannelDef2 = encoding[`${continuousAxis}2`] as SecondaryFieldDef<string>;\n  const continuousAxisChannelDefError = encoding[`${continuousAxis}Error`] as SecondaryFieldDef<string>;\n  const continuousAxisChannelDefError2 = encoding[`${continuousAxis}Error2`] as SecondaryFieldDef<string>;\n\n  return {\n    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),\n    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),\n    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),\n    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),\n    continuousAxis\n  };\n}\n\nfunction filterAggregateFromChannelDef<M extends CompositeMark, F extends FieldDefBase<string>>(\n  continuousAxisChannelDef: F,\n  compositeMark: M\n): F {\n  if (continuousAxisChannelDef?.aggregate) {\n    const {aggregate, ...continuousAxisWithoutAggregate} = continuousAxisChannelDef;\n    if (aggregate !== compositeMark) {\n      log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n    }\n    return continuousAxisWithoutAggregate as F;\n  } else {\n    return continuousAxisChannelDef;\n  }\n}\n\nexport function compositeMarkOrient<M extends CompositeMark>(\n  spec: GenericUnitSpec<Encoding<string>, CompositeMark | CompositeMarkDef>,\n  compositeMark: M\n): Orientation {\n  const {mark, encoding} = spec;\n  const {x, y} = encoding;\n\n  if (isMarkDef(mark) && mark.orient) {\n    return mark.orient;\n  }\n\n  if (isContinuousFieldOrDatumDef(x)) {\n    // x is continuous\n    if (isContinuousFieldOrDatumDef(y)) {\n      // both x and y are continuous\n      const xAggregate = isFieldDef(x) && x.aggregate;\n      const yAggregate = isFieldDef(y) && y.aggregate;\n\n      if (!xAggregate && yAggregate === compositeMark) {\n        return 'vertical';\n      } else if (!yAggregate && xAggregate === compositeMark) {\n        return 'horizontal';\n      } else if (xAggregate === compositeMark && yAggregate === compositeMark) {\n        throw new Error('Both x and y cannot have aggregate');\n      } else {\n        if (isFieldOrDatumDefForTimeFormat(y) && !isFieldOrDatumDefForTimeFormat(x)) {\n          // y is temporal but x is not\n          return 'horizontal';\n        }\n\n        // default orientation for two continuous\n        return 'vertical';\n      }\n    }\n\n    return 'horizontal';\n  } else if (isContinuousFieldOrDatumDef(y)) {\n    // y is continuous but x is not\n    return 'vertical';\n  } else {\n    // Neither x nor y is continuous.\n    throw new Error(`Need a valid continuous axis for ${compositeMark}s`);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}