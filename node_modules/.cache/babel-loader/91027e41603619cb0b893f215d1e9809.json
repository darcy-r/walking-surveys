{"ast":null,"code":"import { isArray, isNumber, isObject } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { ANGLE, COLOR, FILL, FILLOPACITY, getOffsetScaleChannel, getSizeChannel, isXorY, isXorYOffset, OPACITY, RADIUS, SCALE_CHANNELS, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, THETA, X, XOFFSET, Y, YOFFSET } from '../../channel';\nimport { getFieldOrDatumDef, isFieldOrDatumDef } from '../../channeldef';\nimport { getViewConfigDiscreteSize, getViewConfigDiscreteStep } from '../../config';\nimport { DataSourceType } from '../../data';\nimport { channelHasFieldOrDatum } from '../../encoding';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, hasDiscreteDomain, isContinuousToDiscrete, isExtendedScheme, scaleTypeSupportProperty } from '../../scale';\nimport { getStepFor, isStep } from '../../spec/base';\nimport { isDiscrete } from '../../type';\nimport * as util from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { exprFromSignalRefOrValue, signalOrStringValue } from '../common';\nimport { getBinSignalName } from '../data/bin';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit } from '../split';\nexport const RANGE_PROPERTIES = ['range', 'scheme'];\nexport function parseUnitScaleRange(model) {\n  const localScaleComponents = model.component.scales; // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n\n  for (const channel of SCALE_CHANNELS) {\n    const localScaleCmpt = localScaleComponents[channel];\n\n    if (!localScaleCmpt) {\n      continue;\n    }\n\n    const rangeWithExplicit = parseRangeForChannel(channel, model);\n    localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n  }\n}\n\nfunction getBinStepSignal(model, channel) {\n  const fieldDef = model.fieldDef(channel);\n\n  if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) {\n    const {\n      bin,\n      field\n    } = fieldDef;\n    const sizeType = getSizeChannel(channel);\n    const sizeSignal = model.getName(sizeType);\n\n    if (isObject(bin) && bin.binned && bin.step !== undefined) {\n      return new SignalRefWrapper(() => {\n        const scaleName = model.scaleName(channel);\n        const binCount = `(domain(\"${scaleName}\")[1] - domain(\"${scaleName}\")[0]) / ${bin.step}`;\n        return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n      });\n    } else if (isBinning(bin)) {\n      const binSignal = getBinSignalName(model, field, bin); // TODO: extract this to be range step signal\n\n      return new SignalRefWrapper(() => {\n        const updatedName = model.getSignalName(binSignal);\n        const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;\n        return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n      });\n    }\n  }\n\n  return undefined;\n}\n/**\n * Return mixins that includes one of the Vega range types (explicit range, range.step, range.scheme).\n */\n\n\nexport function parseRangeForChannel(channel, model) {\n  const specifiedScale = model.specifiedScales[channel];\n  const {\n    size\n  } = model;\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type'); // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n\n  for (const property of RANGE_PROPERTIES) {\n    if (specifiedScale[property] !== undefined) {\n      const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      } else {\n        switch (property) {\n          case 'range':\n            {\n              const range = specifiedScale.range;\n\n              if (isArray(range)) {\n                if (isXorY(channel)) {\n                  return makeExplicit(range.map(v => {\n                    if (v === 'width' || v === 'height') {\n                      // get signal for width/height\n                      // Just like default range logic below, we use SignalRefWrapper to account for potential merges and renames.\n                      const sizeSignal = model.getName(v);\n                      const getSignalName = model.getSignalName.bind(model);\n                      return SignalRefWrapper.fromName(getSignalName, sizeSignal);\n                    }\n\n                    return v;\n                  }));\n                }\n              } else if (isObject(range)) {\n                return makeExplicit({\n                  data: model.requestDataName(DataSourceType.Main),\n                  field: range.field,\n                  sort: {\n                    op: 'min',\n                    field: model.vgField(channel)\n                  }\n                });\n              }\n\n              return makeExplicit(range);\n            }\n\n          case 'scheme':\n            return makeExplicit(parseScheme(specifiedScale[property]));\n        }\n      }\n    }\n  }\n\n  const sizeChannel = channel === X || channel === 'xOffset' ? 'width' : 'height';\n  const sizeValue = size[sizeChannel];\n\n  if (isStep(sizeValue)) {\n    if (isXorY(channel)) {\n      if (hasDiscreteDomain(scaleType)) {\n        const step = getPositionStep(sizeValue, model, channel); // Need to be explicit so layer with step wins over layer without step\n\n        if (step) {\n          return makeExplicit({\n            step\n          });\n        }\n      } else {\n        log.warn(log.message.stepDropped(sizeChannel));\n      }\n    } else if (isXorYOffset(channel)) {\n      const positionChannel = channel === XOFFSET ? 'x' : 'y';\n      const positionScaleCmpt = model.getScaleComponent(positionChannel);\n      const positionScaleType = positionScaleCmpt.get('type');\n\n      if (positionScaleType === 'band') {\n        const step = getOffsetStep(sizeValue, scaleType);\n\n        if (step) {\n          return makeExplicit(step);\n        }\n      }\n    }\n  }\n\n  const {\n    rangeMin,\n    rangeMax\n  } = specifiedScale;\n  const d = defaultRange(channel, model);\n\n  if ((rangeMin !== undefined || rangeMax !== undefined) && // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same\n  scaleTypeSupportProperty(scaleType, 'rangeMin') && isArray(d) && d.length === 2) {\n    return makeExplicit([rangeMin !== null && rangeMin !== void 0 ? rangeMin : d[0], rangeMax !== null && rangeMax !== void 0 ? rangeMax : d[1]]);\n  }\n\n  return makeImplicit(d);\n}\n\nfunction parseScheme(scheme) {\n  if (isExtendedScheme(scheme)) {\n    return Object.assign({\n      scheme: scheme.name\n    }, util.omit(scheme, ['name']));\n  }\n\n  return {\n    scheme\n  };\n}\n\nfunction defaultRange(channel, model) {\n  const {\n    size,\n    config,\n    mark,\n    encoding\n  } = model;\n  const getSignalName = model.getSignalName.bind(model);\n  const {\n    type\n  } = getFieldOrDatumDef(encoding[channel]);\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type');\n  const {\n    domain,\n    domainMid\n  } = model.specifiedScales[channel];\n\n  switch (channel) {\n    case X:\n    case Y:\n      {\n        // If there is no explicit width/height for discrete x/y scales\n        if (util.contains(['point', 'band'], scaleType)) {\n          const positionSize = getDiscretePositionSize(channel, size, config.view);\n\n          if (isStep(positionSize)) {\n            const step = getPositionStep(positionSize, model, channel);\n            return {\n              step\n            };\n          }\n        } // If step is null, use zero to width or height.\n        // Note that we use SignalRefWrapper to account for potential merges and renames.\n\n\n        const sizeType = getSizeChannel(channel);\n        const sizeSignal = model.getName(sizeType);\n\n        if (channel === Y && hasContinuousDomain(scaleType)) {\n          // For y continuous scale, we have to start from the height as the bottom part has the max value.\n          return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];\n        } else {\n          return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];\n        }\n      }\n\n    case XOFFSET:\n    case YOFFSET:\n      return getOffsetRange(channel, model, scaleType);\n\n    case SIZE:\n      {\n        // TODO: support custom rangeMin, rangeMax\n        const zero = model.component.scales[channel].get('zero');\n        const rangeMin = sizeRangeMin(mark, zero, config);\n        const rangeMax = sizeRangeMax(mark, size, model, config);\n\n        if (isContinuousToDiscrete(scaleType)) {\n          return interpolateRange(rangeMin, rangeMax, defaultContinuousToDiscreteCount(scaleType, config, domain, channel));\n        } else {\n          return [rangeMin, rangeMax];\n        }\n      }\n\n    case THETA:\n      return [0, Math.PI * 2];\n\n    case ANGLE:\n      // TODO: add config.scale.min/maxAngleDegree (for point and text) and config.scale.min/maxAngleRadian (for arc) once we add arc marks.\n      // (It's weird to add just config.scale.min/maxAngleDegree for now)\n      return [0, 360];\n\n    case RADIUS:\n      {\n        // max radius = half od min(width,height)\n        return [0, new SignalRefWrapper(() => {\n          const w = model.getSignalName('width');\n          const h = model.getSignalName('height');\n          return `min(${w},${h})/2`;\n        })];\n      }\n\n    case STROKEWIDTH:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];\n\n    case STROKEDASH:\n      return [// TODO: add this to Vega's config.range?\n      [1, 0], [4, 2], [2, 1], [1, 1], [1, 2, 4, 2]];\n\n    case SHAPE:\n      return 'symbol';\n\n    case COLOR:\n    case FILL:\n    case STROKE:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      } else {\n        if (domainMid !== undefined) {\n          return 'diverging';\n        } else {\n          return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n        }\n      }\n\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minOpacity, config.scale.maxOpacity];\n  }\n}\n\nfunction getPositionStep(step, model, channel) {\n  var _a, _b, _c, _d, _e;\n\n  const {\n    encoding\n  } = model;\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const offsetChannel = getOffsetScaleChannel(channel);\n  const offsetDef = encoding[offsetChannel];\n  const stepFor = getStepFor({\n    step,\n    offsetIsDiscrete: isFieldOrDatumDef(offsetDef) && isDiscrete(offsetDef.type)\n  });\n\n  if (stepFor === 'offset' && channelHasFieldOrDatum(encoding, offsetChannel)) {\n    const offsetScaleCmpt = model.getScaleComponent(offsetChannel);\n    const offsetScaleName = model.scaleName(offsetChannel);\n    let stepCount = `domain('${offsetScaleName}').length`;\n\n    if (offsetScaleCmpt.get('type') === 'band') {\n      const offsetPaddingInner = (_b = (_a = offsetScaleCmpt.get('paddingInner')) !== null && _a !== void 0 ? _a : offsetScaleCmpt.get('padding')) !== null && _b !== void 0 ? _b : 0;\n      const offsetPaddingOuter = (_d = (_c = offsetScaleCmpt.get('paddingOuter')) !== null && _c !== void 0 ? _c : offsetScaleCmpt.get('padding')) !== null && _d !== void 0 ? _d : 0;\n      stepCount = `bandspace(${stepCount}, ${offsetPaddingInner}, ${offsetPaddingOuter})`;\n    }\n\n    const paddingInner = (_e = mergedScaleCmpt.get('paddingInner')) !== null && _e !== void 0 ? _e : mergedScaleCmpt.get('padding');\n    return {\n      signal: `${step.step} * ${stepCount} / (1-${exprFromSignalRefOrValue(paddingInner)})`\n    };\n  } else {\n    return step.step;\n  }\n}\n\nfunction getOffsetStep(step, offsetScaleType) {\n  const stepFor = getStepFor({\n    step,\n    offsetIsDiscrete: hasDiscreteDomain(offsetScaleType)\n  });\n\n  if (stepFor === 'offset') {\n    return {\n      step: step.step\n    };\n  }\n\n  return undefined;\n}\n\nfunction getOffsetRange(channel, model, offsetScaleType) {\n  const positionChannel = channel === XOFFSET ? 'x' : 'y';\n  const positionScaleCmpt = model.getScaleComponent(positionChannel);\n  const positionScaleType = positionScaleCmpt.get('type');\n  const positionScaleName = model.scaleName(positionChannel);\n\n  if (positionScaleType === 'band') {\n    const size = getDiscretePositionSize(positionChannel, model.size, model.config.view);\n\n    if (isStep(size)) {\n      // step is for offset\n      const step = getOffsetStep(size, offsetScaleType);\n\n      if (step) {\n        return step;\n      }\n    } // otherwise use the position\n\n\n    return [0, {\n      signal: `bandwidth('${positionScaleName}')`\n    }];\n  } else {\n    // continuous scale\n    return util.never(`Cannot use ${channel} scale if ${positionChannel} scale is not discrete.`);\n  }\n}\n\nfunction getDiscretePositionSize(channel, size, viewConfig) {\n  const sizeChannel = channel === X ? 'width' : 'height';\n  const sizeValue = size[sizeChannel];\n\n  if (sizeValue) {\n    return sizeValue;\n  }\n\n  return getViewConfigDiscreteSize(viewConfig, sizeChannel);\n}\n\nexport function defaultContinuousToDiscreteCount(scaleType, config, domain, channel) {\n  switch (scaleType) {\n    case 'quantile':\n      return config.scale.quantileCount;\n\n    case 'quantize':\n      return config.scale.quantizeCount;\n\n    case 'threshold':\n      if (domain !== undefined && isArray(domain)) {\n        return domain.length + 1;\n      } else {\n        log.warn(log.message.domainRequiredForThresholdScale(channel)); // default threshold boundaries for threshold scale since domain has cardinality of 2\n\n        return 3;\n      }\n\n  }\n}\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\n\nexport function interpolateRange(rangeMin, rangeMax, cardinality) {\n  // always return a signal since it's better to compute the sequence in Vega later\n  const f = () => {\n    const rMax = signalOrStringValue(rangeMax);\n    const rMin = signalOrStringValue(rangeMin);\n    const step = `(${rMax} - ${rMin}) / (${cardinality} - 1)`;\n    return `sequence(${rMin}, ${rMax} + ${step}, ${step})`;\n  };\n\n  if (isSignalRef(rangeMax)) {\n    return new SignalRefWrapper(f);\n  } else {\n    return {\n      signal: f()\n    };\n  }\n}\n\nfunction sizeRangeMin(mark, zero, config) {\n  if (zero) {\n    if (isSignalRef(zero)) {\n      return {\n        signal: `${zero.signal} ? 0 : ${sizeRangeMin(mark, false, config)}`\n      };\n    } else {\n      return 0;\n    }\n  }\n\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      return config.scale.minBandSize;\n\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n\n    case 'text':\n      return config.scale.minFontSize;\n\n    case 'point':\n    case 'square':\n    case 'circle':\n      return config.scale.minSize;\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n\n\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\nexport const MAX_SIZE_RANGE_STEP_RATIO = 0.95;\n\nfunction sizeRangeMax(mark, size, model, config) {\n  const xyStepSignals = {\n    x: getBinStepSignal(model, 'x'),\n    y: getBinStepSignal(model, 'y')\n  };\n\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      {\n        if (config.scale.maxBandSize !== undefined) {\n          return config.scale.maxBandSize;\n        }\n\n        const min = minXYStep(size, xyStepSignals, config.view);\n\n        if (isNumber(min)) {\n          return min - 1;\n        } else {\n          return new SignalRefWrapper(() => `${min.signal} - 1`);\n        }\n      }\n\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n\n    case 'text':\n      return config.scale.maxFontSize;\n\n    case 'point':\n    case 'square':\n    case 'circle':\n      {\n        if (config.scale.maxSize) {\n          return config.scale.maxSize;\n        }\n\n        const pointStep = minXYStep(size, xyStepSignals, config.view);\n\n        if (isNumber(pointStep)) {\n          return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);\n        } else {\n          return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);\n        }\n      }\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n\n\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\n\n\nfunction minXYStep(size, xyStepSignals, viewConfig) {\n  const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, 'width');\n  const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, 'height');\n\n  if (xyStepSignals.x || xyStepSignals.y) {\n    return new SignalRefWrapper(() => {\n      const exprs = [xyStepSignals.x ? xyStepSignals.x.signal : widthStep, xyStepSignals.y ? xyStepSignals.y.signal : heightStep];\n      return `min(${exprs.join(', ')})`;\n    });\n  }\n\n  return Math.min(widthStep, heightStep);\n}","map":{"version":3,"mappings":"AACA,SAAQA,OAAR,EAAiBC,QAAjB,EAA2BC,QAA3B,QAA0C,WAA1C;AACA,SAAQC,SAAR,QAAwB,WAAxB;AACA,SACEC,KADF,EAEEC,KAFF,EAGEC,IAHF,EAIEC,WAJF,EAKEC,qBALF,EAMEC,cANF,EAOEC,MAPF,EAQEC,YARF,EASEC,OATF,EAWEC,MAXF,EAaEC,cAbF,EAcEC,KAdF,EAeEC,IAfF,EAgBEC,MAhBF,EAiBEC,UAjBF,EAkBEC,aAlBF,EAmBEC,WAnBF,EAoBEC,KApBF,EAqBEC,CArBF,EAsBEC,OAtBF,EAuBEC,CAvBF,EAwBEC,OAxBF,QAyBO,eAzBP;AA0BA,SAAQC,kBAAR,EAA4BC,iBAA5B,QAAkF,kBAAlF;AACA,SAAgBC,yBAAhB,EAA2CC,yBAA3C,QAAuF,cAAvF;AACA,SAAQC,cAAR,QAA6B,YAA7B;AACA,SAAQC,sBAAR,QAAqC,gBAArC;AACA,OAAO,KAAKC,GAAZ,MAAqB,WAArB;AAEA,SACEC,mCADF,EAGEC,mBAHF,EAIEC,iBAJF,EAKEC,sBALF,EAMEC,gBANF,EASEC,wBATF,QAWO,aAXP;AAYA,SAAQC,UAAR,EAAoBC,MAApB,QAAyD,iBAAzD;AACA,SAAQC,UAAR,QAAyB,YAAzB;AACA,OAAO,KAAKC,IAAZ,MAAsB,YAAtB;AACA,SAAQC,WAAR,QAAmC,mBAAnC;AACA,SAAQC,wBAAR,EAAkCC,mBAAlC,QAA4D,WAA5D;AACA,SAAQC,gBAAR,QAA+B,aAA/B;AACA,SAAQC,gBAAR,QAA+B,WAA/B;AACA,SAAkBC,YAAlB,EAAgCC,YAAhC,QAAmD,UAAnD;AAIA,OAAO,MAAMC,gBAAgB,GAAoB,CAAC,OAAD,EAAU,QAAV,CAA1C;AAEP,OAAM,SAAUC,mBAAV,CAA8BC,KAA9B,EAA8C;EAClD,MAAMC,oBAAoB,GAAwBD,KAAK,CAACE,SAAN,CAAgBC,MAAlE,CADkD,CAGlD;;EACA,KAAK,MAAMC,OAAX,IAAsB1C,cAAtB,EAAsC;IACpC,MAAM2C,cAAc,GAAGJ,oBAAoB,CAACG,OAAD,CAA3C;;IACA,IAAI,CAACC,cAAL,EAAqB;MACnB;IACD;;IAED,MAAMC,iBAAiB,GAAGC,oBAAoB,CAACH,OAAD,EAAUJ,KAAV,CAA9C;IAEAK,cAAc,CAACG,eAAf,CAA+B,OAA/B,EAAwCF,iBAAxC;EACD;AACF;;AAED,SAASG,gBAAT,CAA0BT,KAA1B,EAA4CI,OAA5C,EAA8D;EAC5D,MAAMM,QAAQ,GAAGV,KAAK,CAACU,QAAN,CAAeN,OAAf,CAAjB;;EAEA,IAAIM,QAAQ,SAAR,YAAQ,WAAR,GAAQ,MAAR,WAAQ,CAAEC,GAAd,EAAmB;IACjB,MAAM;MAACA,GAAD;MAAMC;IAAN,IAAeF,QAArB;IACA,MAAMG,QAAQ,GAAGxD,cAAc,CAAC+C,OAAD,CAA/B;IACA,MAAMU,UAAU,GAAGd,KAAK,CAACe,OAAN,CAAcF,QAAd,CAAnB;;IAEA,IAAI/D,QAAQ,CAAC6D,GAAD,CAAR,IAAiBA,GAAG,CAACK,MAArB,IAA+BL,GAAG,CAACM,IAAJ,KAAaC,SAAhD,EAA2D;MACzD,OAAO,IAAIvB,gBAAJ,CAAqB,MAAK;QAC/B,MAAMwB,SAAS,GAAGnB,KAAK,CAACmB,SAAN,CAAgBf,OAAhB,CAAlB;QACA,MAAMgB,QAAQ,GAAG,YAAYD,SAAS,mBAAmBA,SAAS,YAAYR,GAAG,CAACM,IAAI,EAAtF;QACA,OAAO,GAAGjB,KAAK,CAACqB,aAAN,CAAoBP,UAApB,CAA+B,OAAOM,QAAQ,GAAxD;MACD,CAJM,CAAP;IAKD,CAND,MAMO,IAAIrE,SAAS,CAAC4D,GAAD,CAAb,EAAoB;MACzB,MAAMW,SAAS,GAAG5B,gBAAgB,CAACM,KAAD,EAAQY,KAAR,EAAeD,GAAf,CAAlC,CADyB,CAGzB;;MACA,OAAO,IAAIhB,gBAAJ,CAAqB,MAAK;QAC/B,MAAM4B,WAAW,GAAGvB,KAAK,CAACqB,aAAN,CAAoBC,SAApB,CAApB;QACA,MAAMF,QAAQ,GAAG,IAAIG,WAAW,WAAWA,WAAW,aAAaA,WAAW,OAA9E;QACA,OAAO,GAAGvB,KAAK,CAACqB,aAAN,CAAoBP,UAApB,CAA+B,OAAOM,QAAQ,GAAxD;MACD,CAJM,CAAP;IAKD;EACF;;EACD,OAAOF,SAAP;AACD;AAED;;;;;AAGA,OAAM,SAAUX,oBAAV,CAA+BH,OAA/B,EAAsDJ,KAAtD,EAAsE;EAC1E,MAAMwB,cAAc,GAAGxB,KAAK,CAACyB,eAAN,CAAsBrB,OAAtB,CAAvB;EACA,MAAM;IAACsB;EAAD,IAAS1B,KAAf;EAEA,MAAM2B,eAAe,GAAG3B,KAAK,CAAC4B,iBAAN,CAAwBxB,OAAxB,CAAxB;EACA,MAAMyB,SAAS,GAAGF,eAAe,CAACG,GAAhB,CAAoB,MAApB,CAAlB,CAL0E,CAO1E;EACA;;EACA,KAAK,MAAMC,QAAX,IAAuBjC,gBAAvB,EAAyC;IACvC,IAAI0B,cAAc,CAACO,QAAD,CAAd,KAA6Bb,SAAjC,EAA4C;MAC1C,MAAMc,oBAAoB,GAAG9C,wBAAwB,CAAC2C,SAAD,EAAYE,QAAZ,CAArD;MACA,MAAME,sBAAsB,GAAGpD,mCAAmC,CAACuB,OAAD,EAAU2B,QAAV,CAAlE;;MACA,IAAI,CAACC,oBAAL,EAA2B;QACzBpD,GAAG,CAACsD,IAAJ,CAAStD,GAAG,CAACuD,OAAJ,CAAYC,iCAAZ,CAA8CP,SAA9C,EAAyDE,QAAzD,EAAmE3B,OAAnE,CAAT;MACD,CAFD,MAEO,IAAI6B,sBAAJ,EAA4B;QACjC;QACArD,GAAG,CAACsD,IAAJ,CAASD,sBAAT;MACD,CAHM,MAGA;QACL,QAAQF,QAAR;UACE,KAAK,OAAL;YAAc;cACZ,MAAMM,KAAK,GAAGb,cAAc,CAACa,KAA7B;;cACA,IAAIzF,OAAO,CAACyF,KAAD,CAAX,EAAoB;gBAClB,IAAI/E,MAAM,CAAC8C,OAAD,CAAV,EAAqB;kBACnB,OAAOR,YAAY,CACjByC,KAAK,CAACC,GAAN,CAAUC,CAAC,IAAG;oBACZ,IAAIA,CAAC,KAAK,OAAN,IAAiBA,CAAC,KAAK,QAA3B,EAAqC;sBACnC;sBAEA;sBAEA,MAAMzB,UAAU,GAAGd,KAAK,CAACe,OAAN,CAAcwB,CAAd,CAAnB;sBACA,MAAMlB,aAAa,GAAGrB,KAAK,CAACqB,aAAN,CAAoBmB,IAApB,CAAyBxC,KAAzB,CAAtB;sBACA,OAAOL,gBAAgB,CAAC8C,QAAjB,CAA0BpB,aAA1B,EAAyCP,UAAzC,CAAP;oBACD;;oBACD,OAAOyB,CAAP;kBACD,CAXD,CADiB,CAAnB;gBAcD;cACF,CAjBD,MAiBO,IAAIzF,QAAQ,CAACuF,KAAD,CAAZ,EAAqB;gBAC1B,OAAOzC,YAAY,CAAC;kBAClB8C,IAAI,EAAE1C,KAAK,CAAC2C,eAAN,CAAsBjE,cAAc,CAACkE,IAArC,CADY;kBAElBhC,KAAK,EAAEyB,KAAK,CAACzB,KAFK;kBAGlBiC,IAAI,EAAE;oBAACC,EAAE,EAAE,KAAL;oBAAYlC,KAAK,EAAEZ,KAAK,CAAC+C,OAAN,CAAc3C,OAAd;kBAAnB;gBAHY,CAAD,CAAnB;cAKD;;cAED,OAAOR,YAAY,CAACyC,KAAD,CAAnB;YACD;;UACD,KAAK,QAAL;YACE,OAAOzC,YAAY,CAACoD,WAAW,CAACxB,cAAc,CAACO,QAAD,CAAf,CAAZ,CAAnB;QA/BJ;MAiCD;IACF;EACF;;EAED,MAAMkB,WAAW,GAAG7C,OAAO,KAAKlC,CAAZ,IAAiBkC,OAAO,KAAK,SAA7B,GAAyC,OAAzC,GAAmD,QAAvE;EACA,MAAM8C,SAAS,GAAGxB,IAAI,CAACuB,WAAD,CAAtB;;EACA,IAAI7D,MAAM,CAAC8D,SAAD,CAAV,EAAuB;IACrB,IAAI5F,MAAM,CAAC8C,OAAD,CAAV,EAAqB;MACnB,IAAIrB,iBAAiB,CAAC8C,SAAD,CAArB,EAAkC;QAChC,MAAMZ,IAAI,GAAGkC,eAAe,CAACD,SAAD,EAAYlD,KAAZ,EAAmBI,OAAnB,CAA5B,CADgC,CAEhC;;QACA,IAAIa,IAAJ,EAAU;UACR,OAAOrB,YAAY,CAAC;YAACqB;UAAD,CAAD,CAAnB;QACD;MACF,CAND,MAMO;QACLrC,GAAG,CAACsD,IAAJ,CAAStD,GAAG,CAACuD,OAAJ,CAAYiB,WAAZ,CAAwBH,WAAxB,CAAT;MACD;IACF,CAVD,MAUO,IAAI1F,YAAY,CAAC6C,OAAD,CAAhB,EAA2B;MAChC,MAAMiD,eAAe,GAAGjD,OAAO,KAAKjC,OAAZ,GAAsB,GAAtB,GAA4B,GAApD;MACA,MAAMmF,iBAAiB,GAAGtD,KAAK,CAAC4B,iBAAN,CAAwByB,eAAxB,CAA1B;MACA,MAAME,iBAAiB,GAAGD,iBAAiB,CAACxB,GAAlB,CAAsB,MAAtB,CAA1B;;MACA,IAAIyB,iBAAiB,KAAK,MAA1B,EAAkC;QAChC,MAAMtC,IAAI,GAAGuC,aAAa,CAACN,SAAD,EAAYrB,SAAZ,CAA1B;;QACA,IAAIZ,IAAJ,EAAU;UACR,OAAOrB,YAAY,CAACqB,IAAD,CAAnB;QACD;MACF;IACF;EACF;;EAED,MAAM;IAACwC,QAAD;IAAWC;EAAX,IAAuBlC,cAA7B;EACA,MAAMmC,CAAC,GAAGC,YAAY,CAACxD,OAAD,EAAUJ,KAAV,CAAtB;;EAEA,IACE,CAACyD,QAAQ,KAAKvC,SAAb,IAA0BwC,QAAQ,KAAKxC,SAAxC,KACA;EACAhC,wBAAwB,CAAC2C,SAAD,EAAY,UAAZ,CAFxB,IAGAjF,OAAO,CAAC+G,CAAD,CAHP,IAIAA,CAAC,CAACE,MAAF,KAAa,CALf,EAME;IACA,OAAOjE,YAAY,CAAC,CAAC6D,QAAQ,SAAR,YAAQ,WAAR,cAAYE,CAAC,CAAC,CAAD,CAAd,EAAmBD,QAAQ,SAAR,YAAQ,WAAR,cAAYC,CAAC,CAAC,CAAD,CAAhC,CAAD,CAAnB;EACD;;EAED,OAAO9D,YAAY,CAAC8D,CAAD,CAAnB;AACD;;AAED,SAASX,WAAT,CAAqBc,MAArB,EAA+C;EAC7C,IAAI7E,gBAAgB,CAAC6E,MAAD,CAApB,EAA8B;IAC5B;MACEA,MAAM,EAAEA,MAAM,CAACC;IADjB,GAEKzE,IAAI,CAAC0E,IAAL,CAAUF,MAAV,EAAkB,CAAC,MAAD,CAAlB,CAFL;EAID;;EACD,OAAO;IAACA;EAAD,CAAP;AACD;;AAED,SAASF,YAAT,CAAsBxD,OAAtB,EAA6CJ,KAA7C,EAA6D;EAC3D,MAAM;IAAC0B,IAAD;IAAOuC,MAAP;IAAeC,IAAf;IAAqBC;EAArB,IAAiCnE,KAAvC;EAEA,MAAMqB,aAAa,GAAGrB,KAAK,CAACqB,aAAN,CAAoBmB,IAApB,CAAyBxC,KAAzB,CAAtB;EAEA,MAAM;IAACoE;EAAD,IAAS9F,kBAAkB,CAAC6F,QAAQ,CAAC/D,OAAD,CAAT,CAAjC;EAEA,MAAMuB,eAAe,GAAG3B,KAAK,CAAC4B,iBAAN,CAAwBxB,OAAxB,CAAxB;EACA,MAAMyB,SAAS,GAAGF,eAAe,CAACG,GAAhB,CAAoB,MAApB,CAAlB;EAEA,MAAM;IAACuC,MAAD;IAASC;EAAT,IAAsBtE,KAAK,CAACyB,eAAN,CAAsBrB,OAAtB,CAA5B;;EAEA,QAAQA,OAAR;IACE,KAAKlC,CAAL;IACA,KAAKE,CAAL;MAAQ;QACN;QACA,IAAIkB,IAAI,CAACiF,QAAL,CAAc,CAAC,OAAD,EAAU,MAAV,CAAd,EAAiC1C,SAAjC,CAAJ,EAAiD;UAC/C,MAAM2C,YAAY,GAAGC,uBAAuB,CAACrE,OAAD,EAAUsB,IAAV,EAAgBuC,MAAM,CAACS,IAAvB,CAA5C;;UACA,IAAItF,MAAM,CAACoF,YAAD,CAAV,EAA0B;YACxB,MAAMvD,IAAI,GAAGkC,eAAe,CAACqB,YAAD,EAAexE,KAAf,EAAsBI,OAAtB,CAA5B;YACA,OAAO;cAACa;YAAD,CAAP;UACD;QACF,CARK,CAUN;QACA;;;QAEA,MAAMJ,QAAQ,GAAGxD,cAAc,CAAC+C,OAAD,CAA/B;QACA,MAAMU,UAAU,GAAGd,KAAK,CAACe,OAAN,CAAcF,QAAd,CAAnB;;QAEA,IAAIT,OAAO,KAAKhC,CAAZ,IAAiBU,mBAAmB,CAAC+C,SAAD,CAAxC,EAAqD;UACnD;UACA,OAAO,CAAClC,gBAAgB,CAAC8C,QAAjB,CAA0BpB,aAA1B,EAAyCP,UAAzC,CAAD,EAAuD,CAAvD,CAAP;QACD,CAHD,MAGO;UACL,OAAO,CAAC,CAAD,EAAInB,gBAAgB,CAAC8C,QAAjB,CAA0BpB,aAA1B,EAAyCP,UAAzC,CAAJ,CAAP;QACD;MACF;;IAED,KAAK3C,OAAL;IACA,KAAKE,OAAL;MACE,OAAOsG,cAAc,CAACvE,OAAD,EAAUJ,KAAV,EAAiB6B,SAAjB,CAArB;;IAEF,KAAKjE,IAAL;MAAW;QACT;QACA,MAAMgH,IAAI,GAAG5E,KAAK,CAACE,SAAN,CAAgBC,MAAhB,CAAuBC,OAAvB,EAAgC0B,GAAhC,CAAoC,MAApC,CAAb;QACA,MAAM2B,QAAQ,GAAGoB,YAAY,CAACX,IAAD,EAAOU,IAAP,EAAaX,MAAb,CAA7B;QACA,MAAMP,QAAQ,GAAGoB,YAAY,CAACZ,IAAD,EAAOxC,IAAP,EAAa1B,KAAb,EAAoBiE,MAApB,CAA7B;;QACA,IAAIjF,sBAAsB,CAAC6C,SAAD,CAA1B,EAAuC;UACrC,OAAOkD,gBAAgB,CACrBtB,QADqB,EAErBC,QAFqB,EAGrBsB,gCAAgC,CAACnD,SAAD,EAAYoC,MAAZ,EAAoBI,MAApB,EAA4BjE,OAA5B,CAHX,CAAvB;QAKD,CAND,MAMO;UACL,OAAO,CAACqD,QAAD,EAAWC,QAAX,CAAP;QACD;MACF;;IAED,KAAKzF,KAAL;MACE,OAAO,CAAC,CAAD,EAAIgH,IAAI,CAACC,EAAL,GAAU,CAAd,CAAP;;IAEF,KAAKlI,KAAL;MACE;MACA;MACA,OAAO,CAAC,CAAD,EAAI,GAAJ,CAAP;;IAEF,KAAKS,MAAL;MAAa;QACX;QACA,OAAO,CACL,CADK,EAEL,IAAIkC,gBAAJ,CAAqB,MAAK;UACxB,MAAMwF,CAAC,GAAGnF,KAAK,CAACqB,aAAN,CAAoB,OAApB,CAAV;UACA,MAAM+D,CAAC,GAAGpF,KAAK,CAACqB,aAAN,CAAoB,QAApB,CAAV;UACA,OAAO,OAAO8D,CAAC,IAAIC,CAAC,KAApB;QACD,CAJD,CAFK,CAAP;MAQD;;IAED,KAAKpH,WAAL;MACE;MACA,OAAO,CAACiG,MAAM,CAACoB,KAAP,CAAaC,cAAd,EAA8BrB,MAAM,CAACoB,KAAP,CAAaE,cAA3C,CAAP;;IACF,KAAKzH,UAAL;MACE,OAAO,CACL;MACA,CAAC,CAAD,EAAI,CAAJ,CAFK,EAGL,CAAC,CAAD,EAAI,CAAJ,CAHK,EAIL,CAAC,CAAD,EAAI,CAAJ,CAJK,EAKL,CAAC,CAAD,EAAI,CAAJ,CALK,EAML,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CANK,CAAP;;IAQF,KAAKH,KAAL;MACE,OAAO,QAAP;;IACF,KAAKV,KAAL;IACA,KAAKC,IAAL;IACA,KAAKW,MAAL;MACE,IAAIgE,SAAS,KAAK,SAAlB,EAA6B;QAC3B;QACA,OAAOuC,IAAI,KAAK,SAAT,GAAqB,UAArB,GAAkC,SAAzC;MACD,CAHD,MAGO;QACL,IAAIE,SAAS,KAAKpD,SAAlB,EAA6B;UAC3B,OAAO,WAAP;QACD,CAFD,MAEO;UACL,OAAOgD,IAAI,KAAK,MAAT,IAAmBA,IAAI,KAAK,UAA5B,GAAyC,SAAzC,GAAqD,MAA5D;QACD;MACF;;IACH,KAAK1G,OAAL;IACA,KAAKL,WAAL;IACA,KAAKY,aAAL;MACE;MACA,OAAO,CAACkG,MAAM,CAACoB,KAAP,CAAaG,UAAd,EAA0BvB,MAAM,CAACoB,KAAP,CAAaI,UAAvC,CAAP;EAjGJ;AAmGD;;AAED,SAAStC,eAAT,CAAyBlC,IAAzB,EAAqCjB,KAArC,EAAuDI,OAAvD,EAAoF;;;EAClF,MAAM;IAAC+D;EAAD,IAAanE,KAAnB;EAEA,MAAM2B,eAAe,GAAG3B,KAAK,CAAC4B,iBAAN,CAAwBxB,OAAxB,CAAxB;EACA,MAAMsF,aAAa,GAAGtI,qBAAqB,CAACgD,OAAD,CAA3C;EACA,MAAMuF,SAAS,GAAGxB,QAAQ,CAACuB,aAAD,CAA1B;EACA,MAAME,OAAO,GAAGzG,UAAU,CAAC;IAAC8B,IAAD;IAAO4E,gBAAgB,EAAEtH,iBAAiB,CAACoH,SAAD,CAAjB,IAAgCtG,UAAU,CAACsG,SAAS,CAACvB,IAAX;EAAnE,CAAD,CAA1B;;EAEA,IAAIwB,OAAO,KAAK,QAAZ,IAAwBjH,sBAAsB,CAACwF,QAAD,EAAWuB,aAAX,CAAlD,EAA6E;IAC3E,MAAMI,eAAe,GAAG9F,KAAK,CAAC4B,iBAAN,CAAwB8D,aAAxB,CAAxB;IACA,MAAMK,eAAe,GAAG/F,KAAK,CAACmB,SAAN,CAAgBuE,aAAhB,CAAxB;IAEA,IAAIM,SAAS,GAAG,WAAWD,eAAe,WAA1C;;IAEA,IAAID,eAAe,CAAChE,GAAhB,CAAoB,MAApB,MAAgC,MAApC,EAA4C;MAC1C,MAAMmE,kBAAkB,GAAG,2BAAe,CAACnE,GAAhB,CAAoB,cAApB,OAAmC,IAAnC,IAAmCoE,aAAnC,GAAmCA,EAAnC,GAAuCJ,eAAe,CAAChE,GAAhB,CAAoB,SAApB,CAAvC,MAAqE,IAArE,IAAqEqE,aAArE,GAAqEA,EAArE,GAAyE,CAApG;MACA,MAAMC,kBAAkB,GAAG,2BAAe,CAACtE,GAAhB,CAAoB,cAApB,OAAmC,IAAnC,IAAmCuE,aAAnC,GAAmCA,EAAnC,GAAuCP,eAAe,CAAChE,GAAhB,CAAoB,SAApB,CAAvC,MAAqE,IAArE,IAAqEwE,aAArE,GAAqEA,EAArE,GAAyE,CAApG;MACAN,SAAS,GAAG,aAAaA,SAAS,KAAKC,kBAAkB,KAAKG,kBAAkB,GAAhF;IACD;;IAED,MAAMG,YAAY,GAAG,qBAAe,CAACzE,GAAhB,CAAoB,cAApB,OAAmC,IAAnC,IAAmC0E,aAAnC,GAAmCA,EAAnC,GAAuC7E,eAAe,CAACG,GAAhB,CAAoB,SAApB,CAA5D;IACA,OAAO;MACL2E,MAAM,EAAE,GAAGxF,IAAI,CAACA,IAAI,MAAM+E,SAAS,SAASxG,wBAAwB,CAAC+G,YAAD,CAAc;IAD7E,CAAP;EAGD,CAhBD,MAgBO;IACL,OAAOtF,IAAI,CAACA,IAAZ;EACD;AACF;;AAED,SAASuC,aAAT,CAAuBvC,IAAvB,EAAmCyF,eAAnC,EAA6D;EAC3D,MAAMd,OAAO,GAAGzG,UAAU,CAAC;IAAC8B,IAAD;IAAO4E,gBAAgB,EAAE9G,iBAAiB,CAAC2H,eAAD;EAA1C,CAAD,CAA1B;;EACA,IAAId,OAAO,KAAK,QAAhB,EAA0B;IACxB,OAAO;MAAC3E,IAAI,EAAEA,IAAI,CAACA;IAAZ,CAAP;EACD;;EACD,OAAOC,SAAP;AACD;;AAED,SAASyD,cAAT,CAAwBvE,OAAxB,EAAyCJ,KAAzC,EAA2D0G,eAA3D,EAAqF;EACnF,MAAMrD,eAAe,GAAGjD,OAAO,KAAKjC,OAAZ,GAAsB,GAAtB,GAA4B,GAApD;EACA,MAAMmF,iBAAiB,GAAGtD,KAAK,CAAC4B,iBAAN,CAAwByB,eAAxB,CAA1B;EACA,MAAME,iBAAiB,GAAGD,iBAAiB,CAACxB,GAAlB,CAAsB,MAAtB,CAA1B;EACA,MAAM6E,iBAAiB,GAAG3G,KAAK,CAACmB,SAAN,CAAgBkC,eAAhB,CAA1B;;EAEA,IAAIE,iBAAiB,KAAK,MAA1B,EAAkC;IAChC,MAAM7B,IAAI,GAAG+C,uBAAuB,CAACpB,eAAD,EAAkBrD,KAAK,CAAC0B,IAAxB,EAA8B1B,KAAK,CAACiE,MAAN,CAAaS,IAA3C,CAApC;;IAEA,IAAItF,MAAM,CAACsC,IAAD,CAAV,EAAkB;MAChB;MACA,MAAMT,IAAI,GAAGuC,aAAa,CAAC9B,IAAD,EAAOgF,eAAP,CAA1B;;MACA,IAAIzF,IAAJ,EAAU;QACR,OAAOA,IAAP;MACD;IACF,CAT+B,CAUhC;;;IACA,OAAO,CAAC,CAAD,EAAI;MAACwF,MAAM,EAAE,cAAcE,iBAAiB;IAAxC,CAAJ,CAAP;EACD,CAZD,MAYO;IACL;IACA,OAAOrH,IAAI,CAACsH,KAAL,CAAW,cAAcxG,OAAO,aAAaiD,eAAe,yBAA5D,CAAP;EACD;AACF;;AAED,SAASoB,uBAAT,CACErE,OADF,EAEEsB,IAFF,EAGEmF,UAHF,EAGmC;EAEjC,MAAM5D,WAAW,GAAG7C,OAAO,KAAKlC,CAAZ,GAAgB,OAAhB,GAA0B,QAA9C;EACA,MAAMgF,SAAS,GAAGxB,IAAI,CAACuB,WAAD,CAAtB;;EACA,IAAIC,SAAJ,EAAe;IACb,OAAOA,SAAP;EACD;;EACD,OAAO1E,yBAAyB,CAACqI,UAAD,EAAa5D,WAAb,CAAhC;AACD;;AAED,OAAM,SAAU+B,gCAAV,CACJnD,SADI,EAEJoC,MAFI,EAGJI,MAHI,EAIJjE,OAJI,EAIiB;EAErB,QAAQyB,SAAR;IACE,KAAK,UAAL;MACE,OAAOoC,MAAM,CAACoB,KAAP,CAAayB,aAApB;;IACF,KAAK,UAAL;MACE,OAAO7C,MAAM,CAACoB,KAAP,CAAa0B,aAApB;;IACF,KAAK,WAAL;MACE,IAAI1C,MAAM,KAAKnD,SAAX,IAAwBtE,OAAO,CAACyH,MAAD,CAAnC,EAA6C;QAC3C,OAAOA,MAAM,CAACR,MAAP,GAAgB,CAAvB;MACD,CAFD,MAEO;QACLjF,GAAG,CAACsD,IAAJ,CAAStD,GAAG,CAACuD,OAAJ,CAAY6E,+BAAZ,CAA4C5G,OAA5C,CAAT,EADK,CAEL;;QACA,OAAO,CAAP;MACD;;EAZL;AAcD;AAED;;;;;;;;AAOA,OAAM,SAAU2E,gBAAV,CACJtB,QADI,EAEJC,QAFI,EAGJuD,WAHI,EAGe;EAEnB;EACA,MAAMC,CAAC,GAAG,MAAK;IACb,MAAMC,IAAI,GAAG1H,mBAAmB,CAACiE,QAAD,CAAhC;IACA,MAAM0D,IAAI,GAAG3H,mBAAmB,CAACgE,QAAD,CAAhC;IACA,MAAMxC,IAAI,GAAG,IAAIkG,IAAI,MAAMC,IAAI,QAAQH,WAAW,OAAlD;IACA,OAAO,YAAYG,IAAI,KAAKD,IAAI,MAAMlG,IAAI,KAAKA,IAAI,GAAnD;EACD,CALD;;EAMA,IAAI1B,WAAW,CAACmE,QAAD,CAAf,EAA2B;IACzB,OAAO,IAAI/D,gBAAJ,CAAqBuH,CAArB,CAAP;EACD,CAFD,MAEO;IACL,OAAO;MAACT,MAAM,EAAES,CAAC;IAAV,CAAP;EACD;AACF;;AAED,SAASrC,YAAT,CAAsBX,IAAtB,EAAkCU,IAAlC,EAA6DX,MAA7D,EAA2E;EACzE,IAAIW,IAAJ,EAAU;IACR,IAAIrF,WAAW,CAACqF,IAAD,CAAf,EAAuB;MACrB,OAAO;QAAC6B,MAAM,EAAE,GAAG7B,IAAI,CAAC6B,MAAM,UAAU5B,YAAY,CAACX,IAAD,EAAO,KAAP,EAAcD,MAAd,CAAqB;MAAlE,CAAP;IACD,CAFD,MAEO;MACL,OAAO,CAAP;IACD;EACF;;EACD,QAAQC,IAAR;IACE,KAAK,KAAL;IACA,KAAK,MAAL;MACE,OAAOD,MAAM,CAACoB,KAAP,CAAagC,WAApB;;IACF,KAAK,MAAL;IACA,KAAK,OAAL;IACA,KAAK,MAAL;MACE,OAAOpD,MAAM,CAACoB,KAAP,CAAaC,cAApB;;IACF,KAAK,MAAL;MACE,OAAOrB,MAAM,CAACoB,KAAP,CAAaiC,WAApB;;IACF,KAAK,OAAL;IACA,KAAK,QAAL;IACA,KAAK,QAAL;MACE,OAAOrD,MAAM,CAACoB,KAAP,CAAakC,OAApB;EAbJ;EAeA;EACA;;;EACA,MAAM,IAAIC,KAAJ,CAAU5I,GAAG,CAACuD,OAAJ,CAAYsF,mBAAZ,CAAgC,MAAhC,EAAwCvD,IAAxC,CAAV,CAAN;AACD;;AAED,OAAO,MAAMwD,yBAAyB,GAAG,IAAlC;;AAEP,SAAS5C,YAAT,CACEZ,IADF,EAEExC,IAFF,EAGE1B,KAHF,EAIEiE,MAJF,EAI2B;EAEzB,MAAM0D,aAAa,GAAG;IACpBC,CAAC,EAAEnH,gBAAgB,CAACT,KAAD,EAAQ,GAAR,CADC;IAEpB6H,CAAC,EAAEpH,gBAAgB,CAACT,KAAD,EAAQ,GAAR;EAFC,CAAtB;;EAKA,QAAQkE,IAAR;IACE,KAAK,KAAL;IACA,KAAK,MAAL;MAAa;QACX,IAAID,MAAM,CAACoB,KAAP,CAAayC,WAAb,KAA6B5G,SAAjC,EAA4C;UAC1C,OAAO+C,MAAM,CAACoB,KAAP,CAAayC,WAApB;QACD;;QACD,MAAMC,GAAG,GAAGC,SAAS,CAACtG,IAAD,EAAOiG,aAAP,EAAsB1D,MAAM,CAACS,IAA7B,CAArB;;QAEA,IAAI7H,QAAQ,CAACkL,GAAD,CAAZ,EAAmB;UACjB,OAAOA,GAAG,GAAG,CAAb;QACD,CAFD,MAEO;UACL,OAAO,IAAIpI,gBAAJ,CAAqB,MAAM,GAAGoI,GAAG,CAACtB,MAAM,MAAxC,CAAP;QACD;MACF;;IACD,KAAK,MAAL;IACA,KAAK,OAAL;IACA,KAAK,MAAL;MACE,OAAOxC,MAAM,CAACoB,KAAP,CAAaE,cAApB;;IACF,KAAK,MAAL;MACE,OAAOtB,MAAM,CAACoB,KAAP,CAAa4C,WAApB;;IACF,KAAK,OAAL;IACA,KAAK,QAAL;IACA,KAAK,QAAL;MAAe;QACb,IAAIhE,MAAM,CAACoB,KAAP,CAAa6C,OAAjB,EAA0B;UACxB,OAAOjE,MAAM,CAACoB,KAAP,CAAa6C,OAApB;QACD;;QAED,MAAMC,SAAS,GAAGH,SAAS,CAACtG,IAAD,EAAOiG,aAAP,EAAsB1D,MAAM,CAACS,IAA7B,CAA3B;;QACA,IAAI7H,QAAQ,CAACsL,SAAD,CAAZ,EAAyB;UACvB,OAAOlD,IAAI,CAACmD,GAAL,CAASV,yBAAyB,GAAGS,SAArC,EAAgD,CAAhD,CAAP;QACD,CAFD,MAEO;UACL,OAAO,IAAIxI,gBAAJ,CAAqB,MAAM,OAAO+H,yBAAyB,MAAMS,SAAS,CAAC1B,MAAM,MAAjF,CAAP;QACD;MACF;EAjCH;EAmCA;EACA;;;EACA,MAAM,IAAIe,KAAJ,CAAU5I,GAAG,CAACuD,OAAJ,CAAYsF,mBAAZ,CAAgC,MAAhC,EAAwCvD,IAAxC,CAAV,CAAN;AACD;AAED;;;;;AAGA,SAAS8D,SAAT,CACEtG,IADF,EAEEiG,aAFF,EAGEd,UAHF,EAGmC;EAEjC,MAAMwB,SAAS,GAAGjJ,MAAM,CAACsC,IAAI,CAAC4G,KAAN,CAAN,GAAqB5G,IAAI,CAAC4G,KAAL,CAAWrH,IAAhC,GAAuCxC,yBAAyB,CAACoI,UAAD,EAAa,OAAb,CAAlF;EACA,MAAM0B,UAAU,GAAGnJ,MAAM,CAACsC,IAAI,CAAC8G,MAAN,CAAN,GAAsB9G,IAAI,CAAC8G,MAAL,CAAYvH,IAAlC,GAAyCxC,yBAAyB,CAACoI,UAAD,EAAa,QAAb,CAArF;;EAEA,IAAIc,aAAa,CAACC,CAAd,IAAmBD,aAAa,CAACE,CAArC,EAAwC;IACtC,OAAO,IAAIlI,gBAAJ,CAAqB,MAAK;MAC/B,MAAM8I,KAAK,GAAG,CACZd,aAAa,CAACC,CAAd,GAAkBD,aAAa,CAACC,CAAd,CAAgBnB,MAAlC,GAA2C4B,SAD/B,EAEZV,aAAa,CAACE,CAAd,GAAkBF,aAAa,CAACE,CAAd,CAAgBpB,MAAlC,GAA2C8B,UAF/B,CAAd;MAIA,OAAO,OAAOE,KAAK,CAACC,IAAN,CAAW,IAAX,CAAgB,GAA9B;IACD,CANM,CAAP;EAOD;;EAED,OAAOzD,IAAI,CAAC8C,GAAL,CAASM,SAAT,EAAoBE,UAApB,CAAP;AACD","names":["isArray","isNumber","isObject","isBinning","ANGLE","COLOR","FILL","FILLOPACITY","getOffsetScaleChannel","getSizeChannel","isXorY","isXorYOffset","OPACITY","RADIUS","SCALE_CHANNELS","SHAPE","SIZE","STROKE","STROKEDASH","STROKEOPACITY","STROKEWIDTH","THETA","X","XOFFSET","Y","YOFFSET","getFieldOrDatumDef","isFieldOrDatumDef","getViewConfigDiscreteSize","getViewConfigDiscreteStep","DataSourceType","channelHasFieldOrDatum","log","channelScalePropertyIncompatability","hasContinuousDomain","hasDiscreteDomain","isContinuousToDiscrete","isExtendedScheme","scaleTypeSupportProperty","getStepFor","isStep","isDiscrete","util","isSignalRef","exprFromSignalRefOrValue","signalOrStringValue","getBinSignalName","SignalRefWrapper","makeExplicit","makeImplicit","RANGE_PROPERTIES","parseUnitScaleRange","model","localScaleComponents","component","scales","channel","localScaleCmpt","rangeWithExplicit","parseRangeForChannel","setWithExplicit","getBinStepSignal","fieldDef","bin","field","sizeType","sizeSignal","getName","binned","step","undefined","scaleName","binCount","getSignalName","binSignal","updatedName","specifiedScale","specifiedScales","size","mergedScaleCmpt","getScaleComponent","scaleType","get","property","supportedByScaleType","channelIncompatability","warn","message","scalePropertyNotWorkWithScaleType","range","map","v","bind","fromName","data","requestDataName","Main","sort","op","vgField","parseScheme","sizeChannel","sizeValue","getPositionStep","stepDropped","positionChannel","positionScaleCmpt","positionScaleType","getOffsetStep","rangeMin","rangeMax","d","defaultRange","length","scheme","name","omit","config","mark","encoding","type","domain","domainMid","contains","positionSize","getDiscretePositionSize","view","getOffsetRange","zero","sizeRangeMin","sizeRangeMax","interpolateRange","defaultContinuousToDiscreteCount","Math","PI","w","h","scale","minStrokeWidth","maxStrokeWidth","minOpacity","maxOpacity","offsetChannel","offsetDef","stepFor","offsetIsDiscrete","offsetScaleCmpt","offsetScaleName","stepCount","offsetPaddingInner","_a","_b","offsetPaddingOuter","_c","_d","paddingInner","_e","signal","offsetScaleType","positionScaleName","never","viewConfig","quantileCount","quantizeCount","domainRequiredForThresholdScale","cardinality","f","rMax","rMin","minBandSize","minFontSize","minSize","Error","incompatibleChannel","MAX_SIZE_RANGE_STEP_RATIO","xyStepSignals","x","y","maxBandSize","min","minXYStep","maxFontSize","maxSize","pointStep","pow","widthStep","width","heightStep","height","exprs","join"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/scale/range.ts"],"sourcesContent":["import {RangeScheme, SignalRef} from 'vega';\nimport {isArray, isNumber, isObject} from 'vega-util';\nimport {isBinning} from '../../bin';\nimport {\n  ANGLE,\n  COLOR,\n  FILL,\n  FILLOPACITY,\n  getOffsetScaleChannel,\n  getSizeChannel,\n  isXorY,\n  isXorYOffset,\n  OPACITY,\n  PositionScaleChannel,\n  RADIUS,\n  ScaleChannel,\n  SCALE_CHANNELS,\n  SHAPE,\n  SIZE,\n  STROKE,\n  STROKEDASH,\n  STROKEOPACITY,\n  STROKEWIDTH,\n  THETA,\n  X,\n  XOFFSET,\n  Y,\n  YOFFSET\n} from '../../channel';\nimport {getFieldOrDatumDef, isFieldOrDatumDef, ScaleDatumDef, ScaleFieldDef} from '../../channeldef';\nimport {Config, getViewConfigDiscreteSize, getViewConfigDiscreteStep, ViewConfig} from '../../config';\nimport {DataSourceType} from '../../data';\nimport {channelHasFieldOrDatum} from '../../encoding';\nimport * as log from '../../log';\nimport {Mark} from '../../mark';\nimport {\n  channelScalePropertyIncompatability,\n  Domain,\n  hasContinuousDomain,\n  hasDiscreteDomain,\n  isContinuousToDiscrete,\n  isExtendedScheme,\n  Scale,\n  ScaleType,\n  scaleTypeSupportProperty,\n  Scheme\n} from '../../scale';\nimport {getStepFor, isStep, LayoutSizeMixins, Step} from '../../spec/base';\nimport {isDiscrete} from '../../type';\nimport * as util from '../../util';\nimport {isSignalRef, VgRange} from '../../vega.schema';\nimport {exprFromSignalRefOrValue, signalOrStringValue} from '../common';\nimport {getBinSignalName} from '../data/bin';\nimport {SignalRefWrapper} from '../signal';\nimport {Explicit, makeExplicit, makeImplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex} from './component';\n\nexport const RANGE_PROPERTIES: (keyof Scale)[] = ['range', 'scheme'];\n\nexport function parseUnitScaleRange(model: UnitModel) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n  for (const channel of SCALE_CHANNELS) {\n    const localScaleCmpt = localScaleComponents[channel];\n    if (!localScaleCmpt) {\n      continue;\n    }\n\n    const rangeWithExplicit = parseRangeForChannel(channel, model);\n\n    localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n  }\n}\n\nfunction getBinStepSignal(model: UnitModel, channel: 'x' | 'y'): SignalRefWrapper {\n  const fieldDef = model.fieldDef(channel);\n\n  if (fieldDef?.bin) {\n    const {bin, field} = fieldDef;\n    const sizeType = getSizeChannel(channel);\n    const sizeSignal = model.getName(sizeType);\n\n    if (isObject(bin) && bin.binned && bin.step !== undefined) {\n      return new SignalRefWrapper(() => {\n        const scaleName = model.scaleName(channel);\n        const binCount = `(domain(\"${scaleName}\")[1] - domain(\"${scaleName}\")[0]) / ${bin.step}`;\n        return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n      });\n    } else if (isBinning(bin)) {\n      const binSignal = getBinSignalName(model, field, bin);\n\n      // TODO: extract this to be range step signal\n      return new SignalRefWrapper(() => {\n        const updatedName = model.getSignalName(binSignal);\n        const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;\n        return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n      });\n    }\n  }\n  return undefined;\n}\n\n/**\n * Return mixins that includes one of the Vega range types (explicit range, range.step, range.scheme).\n */\nexport function parseRangeForChannel(channel: ScaleChannel, model: UnitModel): Explicit<VgRange> {\n  const specifiedScale = model.specifiedScales[channel];\n  const {size} = model;\n\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type');\n\n  // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n  for (const property of RANGE_PROPERTIES) {\n    if (specifiedScale[property] !== undefined) {\n      const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      } else {\n        switch (property) {\n          case 'range': {\n            const range = specifiedScale.range;\n            if (isArray(range)) {\n              if (isXorY(channel)) {\n                return makeExplicit(\n                  range.map(v => {\n                    if (v === 'width' || v === 'height') {\n                      // get signal for width/height\n\n                      // Just like default range logic below, we use SignalRefWrapper to account for potential merges and renames.\n\n                      const sizeSignal = model.getName(v);\n                      const getSignalName = model.getSignalName.bind(model);\n                      return SignalRefWrapper.fromName(getSignalName, sizeSignal);\n                    }\n                    return v;\n                  })\n                );\n              }\n            } else if (isObject(range)) {\n              return makeExplicit({\n                data: model.requestDataName(DataSourceType.Main),\n                field: range.field,\n                sort: {op: 'min', field: model.vgField(channel)}\n              });\n            }\n\n            return makeExplicit(range);\n          }\n          case 'scheme':\n            return makeExplicit(parseScheme(specifiedScale[property]));\n        }\n      }\n    }\n  }\n\n  const sizeChannel = channel === X || channel === 'xOffset' ? 'width' : 'height';\n  const sizeValue = size[sizeChannel];\n  if (isStep(sizeValue)) {\n    if (isXorY(channel)) {\n      if (hasDiscreteDomain(scaleType)) {\n        const step = getPositionStep(sizeValue, model, channel);\n        // Need to be explicit so layer with step wins over layer without step\n        if (step) {\n          return makeExplicit({step});\n        }\n      } else {\n        log.warn(log.message.stepDropped(sizeChannel));\n      }\n    } else if (isXorYOffset(channel)) {\n      const positionChannel = channel === XOFFSET ? 'x' : 'y';\n      const positionScaleCmpt = model.getScaleComponent(positionChannel);\n      const positionScaleType = positionScaleCmpt.get('type');\n      if (positionScaleType === 'band') {\n        const step = getOffsetStep(sizeValue, scaleType);\n        if (step) {\n          return makeExplicit(step);\n        }\n      }\n    }\n  }\n\n  const {rangeMin, rangeMax} = specifiedScale;\n  const d = defaultRange(channel, model);\n\n  if (\n    (rangeMin !== undefined || rangeMax !== undefined) &&\n    // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same\n    scaleTypeSupportProperty(scaleType, 'rangeMin') &&\n    isArray(d) &&\n    d.length === 2\n  ) {\n    return makeExplicit([rangeMin ?? d[0], rangeMax ?? d[1]]);\n  }\n\n  return makeImplicit(d);\n}\n\nfunction parseScheme(scheme: Scheme | SignalRef): RangeScheme {\n  if (isExtendedScheme(scheme)) {\n    return {\n      scheme: scheme.name,\n      ...util.omit(scheme, ['name'])\n    };\n  }\n  return {scheme};\n}\n\nfunction defaultRange(channel: ScaleChannel, model: UnitModel): VgRange {\n  const {size, config, mark, encoding} = model;\n\n  const getSignalName = model.getSignalName.bind(model);\n\n  const {type} = getFieldOrDatumDef(encoding[channel]) as ScaleFieldDef<string> | ScaleDatumDef;\n\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type');\n\n  const {domain, domainMid} = model.specifiedScales[channel];\n\n  switch (channel) {\n    case X:\n    case Y: {\n      // If there is no explicit width/height for discrete x/y scales\n      if (util.contains(['point', 'band'], scaleType)) {\n        const positionSize = getDiscretePositionSize(channel, size, config.view);\n        if (isStep(positionSize)) {\n          const step = getPositionStep(positionSize, model, channel);\n          return {step};\n        }\n      }\n\n      // If step is null, use zero to width or height.\n      // Note that we use SignalRefWrapper to account for potential merges and renames.\n\n      const sizeType = getSizeChannel(channel);\n      const sizeSignal = model.getName(sizeType);\n\n      if (channel === Y && hasContinuousDomain(scaleType)) {\n        // For y continuous scale, we have to start from the height as the bottom part has the max value.\n        return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];\n      } else {\n        return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];\n      }\n    }\n\n    case XOFFSET:\n    case YOFFSET:\n      return getOffsetRange(channel, model, scaleType);\n\n    case SIZE: {\n      // TODO: support custom rangeMin, rangeMax\n      const zero = model.component.scales[channel].get('zero');\n      const rangeMin = sizeRangeMin(mark, zero, config);\n      const rangeMax = sizeRangeMax(mark, size, model, config);\n      if (isContinuousToDiscrete(scaleType)) {\n        return interpolateRange(\n          rangeMin,\n          rangeMax,\n          defaultContinuousToDiscreteCount(scaleType, config, domain, channel)\n        );\n      } else {\n        return [rangeMin, rangeMax];\n      }\n    }\n\n    case THETA:\n      return [0, Math.PI * 2];\n\n    case ANGLE:\n      // TODO: add config.scale.min/maxAngleDegree (for point and text) and config.scale.min/maxAngleRadian (for arc) once we add arc marks.\n      // (It's weird to add just config.scale.min/maxAngleDegree for now)\n      return [0, 360];\n\n    case RADIUS: {\n      // max radius = half od min(width,height)\n      return [\n        0,\n        new SignalRefWrapper(() => {\n          const w = model.getSignalName('width');\n          const h = model.getSignalName('height');\n          return `min(${w},${h})/2`;\n        })\n      ];\n    }\n\n    case STROKEWIDTH:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];\n    case STROKEDASH:\n      return [\n        // TODO: add this to Vega's config.range?\n        [1, 0],\n        [4, 2],\n        [2, 1],\n        [1, 1],\n        [1, 2, 4, 2]\n      ];\n    case SHAPE:\n      return 'symbol';\n    case COLOR:\n    case FILL:\n    case STROKE:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      } else {\n        if (domainMid !== undefined) {\n          return 'diverging';\n        } else {\n          return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n        }\n      }\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minOpacity, config.scale.maxOpacity];\n  }\n}\n\nfunction getPositionStep(step: Step, model: UnitModel, channel: PositionScaleChannel): number | SignalRef {\n  const {encoding} = model;\n\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const offsetChannel = getOffsetScaleChannel(channel);\n  const offsetDef = encoding[offsetChannel];\n  const stepFor = getStepFor({step, offsetIsDiscrete: isFieldOrDatumDef(offsetDef) && isDiscrete(offsetDef.type)});\n\n  if (stepFor === 'offset' && channelHasFieldOrDatum(encoding, offsetChannel)) {\n    const offsetScaleCmpt = model.getScaleComponent(offsetChannel);\n    const offsetScaleName = model.scaleName(offsetChannel);\n\n    let stepCount = `domain('${offsetScaleName}').length`;\n\n    if (offsetScaleCmpt.get('type') === 'band') {\n      const offsetPaddingInner = offsetScaleCmpt.get('paddingInner') ?? offsetScaleCmpt.get('padding') ?? 0;\n      const offsetPaddingOuter = offsetScaleCmpt.get('paddingOuter') ?? offsetScaleCmpt.get('padding') ?? 0;\n      stepCount = `bandspace(${stepCount}, ${offsetPaddingInner}, ${offsetPaddingOuter})`;\n    }\n\n    const paddingInner = mergedScaleCmpt.get('paddingInner') ?? mergedScaleCmpt.get('padding');\n    return {\n      signal: `${step.step} * ${stepCount} / (1-${exprFromSignalRefOrValue(paddingInner)})`\n    };\n  } else {\n    return step.step;\n  }\n}\n\nfunction getOffsetStep(step: Step, offsetScaleType: ScaleType) {\n  const stepFor = getStepFor({step, offsetIsDiscrete: hasDiscreteDomain(offsetScaleType)});\n  if (stepFor === 'offset') {\n    return {step: step.step};\n  }\n  return undefined;\n}\n\nfunction getOffsetRange(channel: string, model: UnitModel, offsetScaleType: ScaleType): VgRange {\n  const positionChannel = channel === XOFFSET ? 'x' : 'y';\n  const positionScaleCmpt = model.getScaleComponent(positionChannel);\n  const positionScaleType = positionScaleCmpt.get('type');\n  const positionScaleName = model.scaleName(positionChannel);\n\n  if (positionScaleType === 'band') {\n    const size = getDiscretePositionSize(positionChannel, model.size, model.config.view);\n\n    if (isStep(size)) {\n      // step is for offset\n      const step = getOffsetStep(size, offsetScaleType);\n      if (step) {\n        return step;\n      }\n    }\n    // otherwise use the position\n    return [0, {signal: `bandwidth('${positionScaleName}')`}];\n  } else {\n    // continuous scale\n    return util.never(`Cannot use ${channel} scale if ${positionChannel} scale is not discrete.`);\n  }\n}\n\nfunction getDiscretePositionSize(\n  channel: 'x' | 'y',\n  size: LayoutSizeMixins,\n  viewConfig: ViewConfig<SignalRef>\n): Step | number | 'container' {\n  const sizeChannel = channel === X ? 'width' : 'height';\n  const sizeValue = size[sizeChannel];\n  if (sizeValue) {\n    return sizeValue;\n  }\n  return getViewConfigDiscreteSize(viewConfig, sizeChannel);\n}\n\nexport function defaultContinuousToDiscreteCount(\n  scaleType: 'quantile' | 'quantize' | 'threshold',\n  config: Config,\n  domain: Domain,\n  channel: ScaleChannel\n) {\n  switch (scaleType) {\n    case 'quantile':\n      return config.scale.quantileCount;\n    case 'quantize':\n      return config.scale.quantizeCount;\n    case 'threshold':\n      if (domain !== undefined && isArray(domain)) {\n        return domain.length + 1;\n      } else {\n        log.warn(log.message.domainRequiredForThresholdScale(channel));\n        // default threshold boundaries for threshold scale since domain has cardinality of 2\n        return 3;\n      }\n  }\n}\n\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\nexport function interpolateRange(\n  rangeMin: number | SignalRef,\n  rangeMax: number | SignalRef,\n  cardinality: number\n): SignalRef {\n  // always return a signal since it's better to compute the sequence in Vega later\n  const f = () => {\n    const rMax = signalOrStringValue(rangeMax);\n    const rMin = signalOrStringValue(rangeMin);\n    const step = `(${rMax} - ${rMin}) / (${cardinality} - 1)`;\n    return `sequence(${rMin}, ${rMax} + ${step}, ${step})`;\n  };\n  if (isSignalRef(rangeMax)) {\n    return new SignalRefWrapper(f);\n  } else {\n    return {signal: f()};\n  }\n}\n\nfunction sizeRangeMin(mark: Mark, zero: boolean | SignalRef, config: Config): number | SignalRef {\n  if (zero) {\n    if (isSignalRef(zero)) {\n      return {signal: `${zero.signal} ? 0 : ${sizeRangeMin(mark, false, config)}`};\n    } else {\n      return 0;\n    }\n  }\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      return config.scale.minBandSize;\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n    case 'text':\n      return config.scale.minFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      return config.scale.minSize;\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\nexport const MAX_SIZE_RANGE_STEP_RATIO = 0.95;\n\nfunction sizeRangeMax(\n  mark: Mark,\n  size: LayoutSizeMixins,\n  model: UnitModel,\n  config: Config<SignalRef>\n): number | SignalRef {\n  const xyStepSignals = {\n    x: getBinStepSignal(model, 'x'),\n    y: getBinStepSignal(model, 'y')\n  };\n\n  switch (mark) {\n    case 'bar':\n    case 'tick': {\n      if (config.scale.maxBandSize !== undefined) {\n        return config.scale.maxBandSize;\n      }\n      const min = minXYStep(size, xyStepSignals, config.view);\n\n      if (isNumber(min)) {\n        return min - 1;\n      } else {\n        return new SignalRefWrapper(() => `${min.signal} - 1`);\n      }\n    }\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n    case 'text':\n      return config.scale.maxFontSize;\n    case 'point':\n    case 'square':\n    case 'circle': {\n      if (config.scale.maxSize) {\n        return config.scale.maxSize;\n      }\n\n      const pointStep = minXYStep(size, xyStepSignals, config.view);\n      if (isNumber(pointStep)) {\n        return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);\n      } else {\n        return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);\n      }\n    }\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\nfunction minXYStep(\n  size: LayoutSizeMixins,\n  xyStepSignals: {x?: SignalRefWrapper; y?: SignalRefWrapper},\n  viewConfig: ViewConfig<SignalRef>\n): number | SignalRef {\n  const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, 'width');\n  const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, 'height');\n\n  if (xyStepSignals.x || xyStepSignals.y) {\n    return new SignalRefWrapper(() => {\n      const exprs = [\n        xyStepSignals.x ? xyStepSignals.x.signal : widthStep,\n        xyStepSignals.y ? xyStepSignals.y.signal : heightStep\n      ];\n      return `min(${exprs.join(', ')})`;\n    });\n  }\n\n  return Math.min(widthStep, heightStep);\n}\n"]},"metadata":{},"sourceType":"module"}