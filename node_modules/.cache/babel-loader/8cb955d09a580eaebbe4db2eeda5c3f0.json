{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isObject } from 'vega-util';\nimport { normalizeEncoding } from '../encoding';\nimport { isMarkDef } from '../mark';\nimport { isUnitSpec } from '../spec/unit';\nimport { stack } from '../stack';\nimport { keys, omit, pick } from '../util';\n\nfunction dropLineAndPoint(markDef) {\n  const {\n    point: _point,\n    line: _line\n  } = markDef,\n        mark = __rest(markDef, [\"point\", \"line\"]);\n\n  return keys(mark).length > 1 ? mark : mark.type;\n}\n\nfunction dropLineAndPointFromConfig(config) {\n  for (const mark of ['line', 'area', 'rule', 'trail']) {\n    if (config[mark]) {\n      config = Object.assign(Object.assign({}, config), {\n        // TODO: remove as any\n        [mark]: omit(config[mark], ['point', 'line'])\n      });\n    }\n  }\n\n  return config;\n}\n\nfunction getPointOverlay(markDef) {\n  let markConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let encoding = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (markDef.point === 'transparent') {\n    return {\n      opacity: 0\n    };\n  } else if (markDef.point) {\n    // truthy : true or object\n    return isObject(markDef.point) ? markDef.point : {};\n  } else if (markDef.point !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.point || encoding.shape) {\n      // enable point overlay if config[mark].point is truthy or if encoding.shape is provided\n      return isObject(markConfig.point) ? markConfig.point : {};\n    } // markDef.point is defined as falsy\n\n\n    return undefined;\n  }\n}\n\nfunction getLineOverlay(markDef) {\n  let markConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (markDef.line) {\n    // true or object\n    return markDef.line === true ? {} : markDef.line;\n  } else if (markDef.line !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.line) {\n      // enable line overlay if config[mark].line is truthy\n      return markConfig.line === true ? {} : markConfig.line;\n    } // markDef.point is defined as falsy\n\n\n    return undefined;\n  }\n}\n\nexport class PathOverlayNormalizer {\n  constructor() {\n    this.name = 'path-overlay';\n  }\n\n  hasMatchingType(spec, config) {\n    if (isUnitSpec(spec)) {\n      const {\n        mark,\n        encoding\n      } = spec;\n      const markDef = isMarkDef(mark) ? mark : {\n        type: mark\n      };\n\n      switch (markDef.type) {\n        case 'line':\n        case 'rule':\n        case 'trail':\n          return !!getPointOverlay(markDef, config[markDef.type], encoding);\n\n        case 'area':\n          return (// false / null are also included as we want to remove the properties\n            !!getPointOverlay(markDef, config[markDef.type], encoding) || !!getLineOverlay(markDef, config[markDef.type])\n          );\n      }\n    }\n\n    return false;\n  }\n\n  run(spec, normParams, normalize) {\n    const {\n      config\n    } = normParams;\n\n    const {\n      params,\n      projection,\n      mark,\n      encoding: e\n    } = spec,\n          outerSpec = __rest(spec, [\"params\", \"projection\", \"mark\", \"encoding\"]); // Need to call normalizeEncoding because we need the inferred types to correctly determine stack\n\n\n    const encoding = normalizeEncoding(e, config);\n    const markDef = isMarkDef(mark) ? mark : {\n      type: mark\n    };\n    const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);\n    const lineOverlay = markDef.type === 'area' && getLineOverlay(markDef, config[markDef.type]);\n    const layer = [Object.assign(Object.assign({}, params ? {\n      params\n    } : {}), {\n      mark: dropLineAndPoint(Object.assign(Object.assign({}, markDef.type === 'area' && markDef.opacity === undefined && markDef.fillOpacity === undefined ? {\n        opacity: 0.7\n      } : {}), markDef)),\n      // drop shape from encoding as this might be used to trigger point overlay\n      encoding: omit(encoding, ['shape'])\n    })]; // FIXME: determine rules for applying selections.\n    // Need to copy stack config to overlayed layer\n\n    const stackProps = stack(markDef, encoding);\n    let overlayEncoding = encoding;\n\n    if (stackProps) {\n      const {\n        fieldChannel: stackFieldChannel,\n        offset\n      } = stackProps;\n      overlayEncoding = Object.assign(Object.assign({}, encoding), {\n        [stackFieldChannel]: Object.assign(Object.assign({}, encoding[stackFieldChannel]), offset ? {\n          stack: offset\n        } : {})\n      });\n    }\n\n    if (lineOverlay) {\n      layer.push(Object.assign(Object.assign({}, projection ? {\n        projection\n      } : {}), {\n        mark: Object.assign(Object.assign({\n          type: 'line'\n        }, pick(markDef, ['clip', 'interpolate', 'tension', 'tooltip'])), lineOverlay),\n        encoding: overlayEncoding\n      }));\n    }\n\n    if (pointOverlay) {\n      layer.push(Object.assign(Object.assign({}, projection ? {\n        projection\n      } : {}), {\n        mark: Object.assign(Object.assign({\n          type: 'point',\n          opacity: 1,\n          filled: true\n        }, pick(markDef, ['clip', 'tooltip'])), pointOverlay),\n        encoding: overlayEncoding\n      }));\n    }\n\n    return normalize(Object.assign(Object.assign({}, outerSpec), {\n      layer\n    }), Object.assign(Object.assign({}, normParams), {\n      config: dropLineAndPointFromConfig(config)\n    }));\n  }\n\n}","map":{"version":3,"mappings":"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","names":["isObject","normalizeEncoding","isMarkDef","isUnitSpec","stack","keys","omit","pick","dropLineAndPoint","markDef","point","_point","line","_line","mark","length","type","dropLineAndPointFromConfig","config","getPointOverlay","markConfig","encoding","opacity","undefined","shape","getLineOverlay","PathOverlayNormalizer","constructor","hasMatchingType","spec","run","normParams","normalize","params","projection","e","outerSpec","pointOverlay","lineOverlay","layer","fillOpacity","stackProps","overlayEncoding","fieldChannel","stackFieldChannel","offset","Object","push","filled"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/normalize/pathoverlay.ts"],"sourcesContent":["import {SignalRef} from 'vega';\nimport {isObject} from 'vega-util';\nimport {Config} from '../config';\nimport {Encoding, normalizeEncoding} from '../encoding';\nimport {ExprRef} from '../expr';\nimport {AreaConfig, isMarkDef, LineConfig, Mark, MarkConfig, MarkDef} from '../mark';\nimport {GenericUnitSpec, NormalizedUnitSpec} from '../spec';\nimport {isUnitSpec} from '../spec/unit';\nimport {stack} from '../stack';\nimport {keys, omit, pick} from '../util';\nimport {NonFacetUnitNormalizer, NormalizeLayerOrUnit, NormalizerParams} from './base';\n\ntype UnitSpecWithPathOverlay = GenericUnitSpec<Encoding<string>, Mark | MarkDef<'line' | 'area' | 'rule' | 'trail'>>;\n\nfunction dropLineAndPoint(markDef: MarkDef): MarkDef | Mark {\n  const {point: _point, line: _line, ...mark} = markDef;\n\n  return keys(mark).length > 1 ? mark : mark.type;\n}\n\nfunction dropLineAndPointFromConfig(config: Config<SignalRef>) {\n  for (const mark of ['line', 'area', 'rule', 'trail'] as const) {\n    if (config[mark]) {\n      config = {\n        ...config,\n        // TODO: remove as any\n        [mark]: omit(config[mark], ['point', 'line'] as any)\n      };\n    }\n  }\n  return config;\n}\n\nfunction getPointOverlay(\n  markDef: MarkDef,\n  markConfig: LineConfig<ExprRef | SignalRef> = {},\n  encoding: Encoding<string>\n): MarkConfig<ExprRef | SignalRef> {\n  if (markDef.point === 'transparent') {\n    return {opacity: 0};\n  } else if (markDef.point) {\n    // truthy : true or object\n    return isObject(markDef.point) ? markDef.point : {};\n  } else if (markDef.point !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.point || encoding.shape) {\n      // enable point overlay if config[mark].point is truthy or if encoding.shape is provided\n      return isObject(markConfig.point) ? markConfig.point : {};\n    }\n    // markDef.point is defined as falsy\n    return undefined;\n  }\n}\n\nfunction getLineOverlay(\n  markDef: MarkDef,\n  markConfig: AreaConfig<ExprRef | SignalRef> = {}\n): MarkConfig<ExprRef | SignalRef> {\n  if (markDef.line) {\n    // true or object\n    return markDef.line === true ? {} : markDef.line;\n  } else if (markDef.line !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.line) {\n      // enable line overlay if config[mark].line is truthy\n      return markConfig.line === true ? {} : markConfig.line;\n    }\n    // markDef.point is defined as falsy\n    return undefined;\n  }\n}\n\nexport class PathOverlayNormalizer implements NonFacetUnitNormalizer<UnitSpecWithPathOverlay> {\n  public name = 'path-overlay';\n\n  public hasMatchingType(spec: GenericUnitSpec<any, Mark | MarkDef>, config: Config): spec is UnitSpecWithPathOverlay {\n    if (isUnitSpec(spec)) {\n      const {mark, encoding} = spec;\n      const markDef = isMarkDef(mark) ? mark : {type: mark};\n      switch (markDef.type) {\n        case 'line':\n        case 'rule':\n        case 'trail':\n          return !!getPointOverlay(markDef, config[markDef.type], encoding);\n        case 'area':\n          return (\n            // false / null are also included as we want to remove the properties\n            !!getPointOverlay(markDef, config[markDef.type], encoding) ||\n            !!getLineOverlay(markDef, config[markDef.type])\n          );\n      }\n    }\n    return false;\n  }\n\n  public run(spec: UnitSpecWithPathOverlay, normParams: NormalizerParams, normalize: NormalizeLayerOrUnit) {\n    const {config} = normParams;\n    const {params, projection, mark, encoding: e, ...outerSpec} = spec;\n\n    // Need to call normalizeEncoding because we need the inferred types to correctly determine stack\n    const encoding = normalizeEncoding(e, config);\n\n    const markDef: MarkDef = isMarkDef(mark) ? mark : {type: mark};\n\n    const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);\n    const lineOverlay = markDef.type === 'area' && getLineOverlay(markDef, config[markDef.type]);\n\n    const layer: NormalizedUnitSpec[] = [\n      {\n        ...(params ? {params} : {}),\n        mark: dropLineAndPoint({\n          // TODO: extract this 0.7 to be shared with default opacity for point/tick/...\n          ...(markDef.type === 'area' && markDef.opacity === undefined && markDef.fillOpacity === undefined\n            ? {opacity: 0.7}\n            : {}),\n          ...markDef\n        }),\n        // drop shape from encoding as this might be used to trigger point overlay\n        encoding: omit(encoding, ['shape'])\n      }\n    ];\n\n    // FIXME: determine rules for applying selections.\n\n    // Need to copy stack config to overlayed layer\n    const stackProps = stack(markDef, encoding);\n\n    let overlayEncoding = encoding;\n    if (stackProps) {\n      const {fieldChannel: stackFieldChannel, offset} = stackProps;\n      overlayEncoding = {\n        ...encoding,\n        [stackFieldChannel]: {\n          ...encoding[stackFieldChannel],\n          ...(offset ? {stack: offset} : {})\n        }\n      };\n    }\n\n    if (lineOverlay) {\n      layer.push({\n        ...(projection ? {projection} : {}),\n        mark: {\n          type: 'line',\n          ...pick(markDef, ['clip', 'interpolate', 'tension', 'tooltip']),\n          ...lineOverlay\n        },\n        encoding: overlayEncoding\n      });\n    }\n    if (pointOverlay) {\n      layer.push({\n        ...(projection ? {projection} : {}),\n        mark: {\n          type: 'point',\n          opacity: 1,\n          filled: true,\n          ...pick(markDef, ['clip', 'tooltip']),\n          ...pointOverlay\n        },\n        encoding: overlayEncoding\n      });\n    }\n\n    return normalize(\n      {\n        ...outerSpec,\n        layer\n      },\n      {\n        ...normParams,\n        config: dropLineAndPointFromConfig(config)\n      }\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}