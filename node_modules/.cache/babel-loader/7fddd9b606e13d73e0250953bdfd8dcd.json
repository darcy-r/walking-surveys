{"ast":null,"code":"import { COLOR, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef, isFieldDef } from '../../channeldef';\nimport { LEGEND_SCALE_CHANNELS } from '../../legend';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport { GEOJSON } from '../../type';\nimport { deleteNestedProperty, isEmpty, keys, varName } from '../../util';\nimport { mergeTitleComponent } from '../common';\nimport { guideEncodeEntry } from '../guide';\nimport { isUnitModel } from '../model';\nimport { parseGuideResolve } from '../resolve';\nimport { parseInteractiveLegend } from '../selection/legends';\nimport { defaultTieBreaker, makeImplicit, mergeValuesWithExplicit } from '../split';\nimport { LegendComponent, LEGEND_COMPONENT_PROPERTIES } from './component';\nimport { legendEncodeRules } from './encode';\nimport { getDirection, getLegendType, legendRules } from './properties';\nexport function parseLegend(model) {\n  const legendComponent = isUnitModel(model) ? parseUnitLegend(model) : parseNonUnitLegend(model);\n  model.component.legends = legendComponent;\n  return legendComponent;\n}\n\nfunction parseUnitLegend(model) {\n  const {\n    encoding\n  } = model;\n  const legendComponent = {};\n\n  for (const channel of [COLOR, ...LEGEND_SCALE_CHANNELS]) {\n    const def = getFieldOrDatumDef(encoding[channel]);\n\n    if (!def || !model.getScaleComponent(channel)) {\n      continue;\n    }\n\n    if (channel === SHAPE && isFieldDef(def) && def.type === GEOJSON) {\n      continue;\n    }\n\n    legendComponent[channel] = parseLegendForChannel(model, channel);\n  }\n\n  return legendComponent;\n}\n\nfunction getLegendDefWithScale(model, channel) {\n  const scale = model.scaleName(channel);\n\n  if (model.mark === 'trail') {\n    if (channel === 'color') {\n      // trail is a filled mark, but its default symbolType (\"stroke\") should use \"stroke\"\n      return {\n        stroke: scale\n      };\n    } else if (channel === 'size') {\n      return {\n        strokeWidth: scale\n      };\n    }\n  }\n\n  if (channel === 'color') {\n    return model.markDef.filled ? {\n      fill: scale\n    } : {\n      stroke: scale\n    };\n  }\n\n  return {\n    [channel]: scale\n  };\n} // eslint-disable-next-line @typescript-eslint/ban-types\n\n\nfunction isExplicit(value, property, legend, fieldDef) {\n  switch (property) {\n    case 'disable':\n      return legend !== undefined;\n    // if axis is specified or null/false, then its enable/disable state is explicit\n\n    case 'values':\n      // specified legend.values is already respected, but may get transformed.\n      return !!(legend === null || legend === void 0 ? void 0 : legend.values);\n\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (property === 'title' && value === (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.title)) {\n        return true;\n      }\n\n  } // Otherwise, things are explicit if the returned value matches the specified property\n\n\n  return value === (legend || {})[property];\n}\n\nexport function parseLegendForChannel(model, channel) {\n  var _a, _b, _c;\n\n  let legend = model.legend(channel);\n  const {\n    markDef,\n    encoding,\n    config\n  } = model;\n  const legendConfig = config.legend;\n  const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));\n  parseInteractiveLegend(model, channel, legendCmpt);\n  const disable = legend !== undefined ? !legend : legendConfig.disable;\n  legendCmpt.set('disable', disable, legend !== undefined);\n\n  if (disable) {\n    return legendCmpt;\n  }\n\n  legend = legend || {};\n  const scaleType = model.getScaleComponent(channel).get('type');\n  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n  const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined;\n  const orient = legend.orient || config.legend.orient || 'right';\n  const legendType = getLegendType({\n    legend,\n    channel,\n    timeUnit,\n    scaleType\n  });\n  const direction = getDirection({\n    legend,\n    legendType,\n    orient,\n    legendConfig\n  });\n  const ruleParams = {\n    legend,\n    channel,\n    model,\n    markDef,\n    encoding,\n    fieldOrDatumDef,\n    legendConfig,\n    config,\n    scaleType,\n    orient,\n    legendType,\n    direction\n  };\n\n  for (const property of LEGEND_COMPONENT_PROPERTIES) {\n    if (legendType === 'gradient' && property.startsWith('symbol') || legendType === 'symbol' && property.startsWith('gradient')) {\n      continue;\n    }\n\n    const value = property in legendRules ? legendRules[property](ruleParams) : legend[property];\n\n    if (value !== undefined) {\n      const explicit = isExplicit(value, property, legend, model.fieldDef(channel));\n\n      if (explicit || config.legend[property] === undefined) {\n        legendCmpt.set(property, value, explicit);\n      }\n    }\n  }\n\n  const legendEncoding = (_b = legend === null || legend === void 0 ? void 0 : legend.encoding) !== null && _b !== void 0 ? _b : {};\n  const selections = legendCmpt.get('selections');\n  const legendEncode = {};\n  const legendEncodeParams = {\n    fieldOrDatumDef,\n    model,\n    channel,\n    legendCmpt,\n    legendType\n  };\n\n  for (const part of ['labels', 'legend', 'title', 'symbols', 'gradient', 'entries']) {\n    const legendEncodingPart = guideEncodeEntry((_c = legendEncoding[part]) !== null && _c !== void 0 ? _c : {}, model);\n    const value = part in legendEncodeRules ? legendEncodeRules[part](legendEncodingPart, legendEncodeParams) // apply rule\n    : legendEncodingPart; // no rule -- just default values\n\n    if (value !== undefined && !isEmpty(value)) {\n      legendEncode[part] = Object.assign(Object.assign(Object.assign({}, (selections === null || selections === void 0 ? void 0 : selections.length) && isFieldDef(fieldOrDatumDef) ? {\n        name: `${varName(fieldOrDatumDef.field)}_legend_${part}`\n      } : {}), (selections === null || selections === void 0 ? void 0 : selections.length) ? {\n        interactive: !!selections\n      } : {}), {\n        update: value\n      });\n    }\n  }\n\n  if (!isEmpty(legendEncode)) {\n    legendCmpt.set('encode', legendEncode, !!(legend === null || legend === void 0 ? void 0 : legend.encoding));\n  }\n\n  return legendCmpt;\n}\n\nfunction parseNonUnitLegend(model) {\n  const {\n    legends,\n    resolve\n  } = model.component;\n\n  for (const child of model.children) {\n    parseLegend(child);\n\n    for (const channel of keys(child.component.legends)) {\n      resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);\n\n      if (resolve.legend[channel] === 'shared') {\n        // If the resolve says shared (and has not been overridden)\n        // We will try to merge and see if there is a conflict\n        legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);\n\n        if (!legends[channel]) {\n          // If merge returns nothing, there is a conflict so we cannot make the legend shared.\n          // Thus, mark legend as independent and remove the legend component.\n          resolve.legend[channel] = 'independent';\n          delete legends[channel];\n        }\n      }\n    }\n  }\n\n  for (const channel of keys(legends)) {\n    for (const child of model.children) {\n      if (!child.component.legends[channel]) {\n        // skip if the child does not have a particular legend\n        continue;\n      }\n\n      if (resolve.legend[channel] === 'shared') {\n        // After merging shared legend, make sure to remove legend from child\n        delete child.component.legends[channel];\n      }\n    }\n  }\n\n  return legends;\n}\n\nexport function mergeLegendComponent(mergedLegend, childLegend) {\n  var _a, _b, _c, _d;\n\n  if (!mergedLegend) {\n    return childLegend.clone();\n  }\n\n  const mergedOrient = mergedLegend.getWithExplicit('orient');\n  const childOrient = childLegend.getWithExplicit('orient');\n\n  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n    // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n    // Cannot merge due to inconsistent orient\n    return undefined;\n  }\n\n  let typeMerged = false; // Otherwise, let's merge\n\n  for (const prop of LEGEND_COMPONENT_PROPERTIES) {\n    const mergedValueWithExplicit = mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop), childLegend.getWithExplicit(prop), prop, 'legend', // Tie breaker function\n    (v1, v2) => {\n      switch (prop) {\n        case 'symbolType':\n          return mergeSymbolType(v1, v2);\n\n        case 'title':\n          return mergeTitleComponent(v1, v2);\n\n        case 'type':\n          // There are only two types. If we have different types, then prefer symbol over gradient.\n          typeMerged = true;\n          return makeImplicit('symbol');\n      }\n\n      return defaultTieBreaker(v1, v2, prop, 'legend');\n    });\n    mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);\n  }\n\n  if (typeMerged) {\n    if ((_b = (_a = mergedLegend.implicit) === null || _a === void 0 ? void 0 : _a.encode) === null || _b === void 0 ? void 0 : _b.gradient) {\n      deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);\n    }\n\n    if ((_d = (_c = mergedLegend.explicit) === null || _c === void 0 ? void 0 : _c.encode) === null || _d === void 0 ? void 0 : _d.gradient) {\n      deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);\n    }\n  }\n\n  return mergedLegend;\n}\n\nfunction mergeSymbolType(st1, st2) {\n  if (st2.value === 'circle') {\n    // prefer \"circle\" over \"stroke\"\n    return st2;\n  }\n\n  return st1;\n}","map":{"version":3,"mappings":"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","names":["COLOR","SHAPE","getFieldOrDatumDef","isFieldDef","LEGEND_SCALE_CHANNELS","normalizeTimeUnit","GEOJSON","deleteNestedProperty","isEmpty","keys","varName","mergeTitleComponent","guideEncodeEntry","isUnitModel","parseGuideResolve","parseInteractiveLegend","defaultTieBreaker","makeImplicit","mergeValuesWithExplicit","LegendComponent","LEGEND_COMPONENT_PROPERTIES","legendEncodeRules","getDirection","getLegendType","legendRules","parseLegend","model","legendComponent","parseUnitLegend","parseNonUnitLegend","component","legends","encoding","channel","def","getScaleComponent","type","parseLegendForChannel","getLegendDefWithScale","scale","scaleName","mark","stroke","strokeWidth","markDef","filled","fill","isExplicit","value","property","legend","fieldDef","undefined","values","title","config","legendConfig","legendCmpt","disable","set","scaleType","get","fieldOrDatumDef","timeUnit","_a","unit","orient","legendType","direction","ruleParams","startsWith","explicit","legendEncoding","_b","selections","legendEncode","legendEncodeParams","part","legendEncodingPart","_c","Object","length","name","field","interactive","update","resolve","child","children","mergeLegendComponent","mergedLegend","childLegend","clone","mergedOrient","getWithExplicit","childOrient","typeMerged","prop","mergedValueWithExplicit","v1","v2","mergeSymbolType","setWithExplicit","implicit","encode","gradient","_d","st1","st2"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/legend/parse.ts"],"sourcesContent":["import {Legend as VgLegend, LegendEncode} from 'vega';\nimport {COLOR, NonPositionScaleChannel, SHAPE} from '../../channel';\nimport {DatumDef, FieldDef, getFieldOrDatumDef, isFieldDef, MarkPropDatumDef, MarkPropFieldDef} from '../../channeldef';\nimport {LegendInternal, LEGEND_SCALE_CHANNELS} from '../../legend';\nimport {normalizeTimeUnit} from '../../timeunit';\nimport {GEOJSON} from '../../type';\nimport {deleteNestedProperty, isEmpty, keys, varName} from '../../util';\nimport {mergeTitleComponent} from '../common';\nimport {guideEncodeEntry} from '../guide';\nimport {isUnitModel, Model} from '../model';\nimport {parseGuideResolve} from '../resolve';\nimport {parseInteractiveLegend} from '../selection/legends';\nimport {defaultTieBreaker, Explicit, makeImplicit, mergeValuesWithExplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {LegendComponent, LegendComponentIndex, LegendComponentProps, LEGEND_COMPONENT_PROPERTIES} from './component';\nimport {LegendEncodeParams, legendEncodeRules} from './encode';\nimport {getDirection, getLegendType, LegendRuleParams, legendRules} from './properties';\n\nexport function parseLegend(model: Model) {\n  const legendComponent = isUnitModel(model) ? parseUnitLegend(model) : parseNonUnitLegend(model);\n  model.component.legends = legendComponent;\n  return legendComponent;\n}\n\nfunction parseUnitLegend(model: UnitModel): LegendComponentIndex {\n  const {encoding} = model;\n\n  const legendComponent: LegendComponentIndex = {};\n\n  for (const channel of [COLOR, ...LEGEND_SCALE_CHANNELS]) {\n    const def = getFieldOrDatumDef(encoding[channel]) as MarkPropFieldDef<string> | MarkPropDatumDef<string>;\n\n    if (!def || !model.getScaleComponent(channel)) {\n      continue;\n    }\n\n    if (channel === SHAPE && isFieldDef(def) && def.type === GEOJSON) {\n      continue;\n    }\n\n    legendComponent[channel] = parseLegendForChannel(model, channel);\n  }\n\n  return legendComponent;\n}\n\nfunction getLegendDefWithScale(model: UnitModel, channel: NonPositionScaleChannel): VgLegend {\n  const scale = model.scaleName(channel);\n  if (model.mark === 'trail') {\n    if (channel === 'color') {\n      // trail is a filled mark, but its default symbolType (\"stroke\") should use \"stroke\"\n      return {stroke: scale};\n    } else if (channel === 'size') {\n      return {strokeWidth: scale};\n    }\n  }\n\n  if (channel === 'color') {\n    return model.markDef.filled ? {fill: scale} : {stroke: scale};\n  }\n  return {[channel]: scale};\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isExplicit<T extends string | number | object | boolean>(\n  value: T,\n  property: keyof LegendComponentProps,\n  legend: LegendInternal,\n  fieldDef: FieldDef<string>\n) {\n  switch (property) {\n    case 'disable':\n      return legend !== undefined; // if axis is specified or null/false, then its enable/disable state is explicit\n    case 'values':\n      // specified legend.values is already respected, but may get transformed.\n      return !!legend?.values;\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (property === 'title' && value === fieldDef?.title) {\n        return true;\n      }\n  }\n  // Otherwise, things are explicit if the returned value matches the specified property\n  return value === (legend || {})[property];\n}\n\nexport function parseLegendForChannel(model: UnitModel, channel: NonPositionScaleChannel): LegendComponent {\n  let legend = model.legend(channel);\n\n  const {markDef, encoding, config} = model;\n  const legendConfig = config.legend;\n  const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));\n  parseInteractiveLegend(model, channel, legendCmpt);\n\n  const disable = legend !== undefined ? !legend : legendConfig.disable;\n  legendCmpt.set('disable', disable, legend !== undefined);\n  if (disable) {\n    return legendCmpt;\n  }\n\n  legend = legend || {};\n\n  const scaleType = model.getScaleComponent(channel).get('type');\n  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) as MarkPropFieldDef<string> | DatumDef;\n  const timeUnit = isFieldDef(fieldOrDatumDef) ? normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit : undefined;\n\n  const orient = legend.orient || config.legend.orient || 'right';\n  const legendType = getLegendType({legend, channel, timeUnit, scaleType});\n\n  const direction = getDirection({legend, legendType, orient, legendConfig});\n\n  const ruleParams: LegendRuleParams = {\n    legend,\n    channel,\n    model,\n    markDef,\n    encoding,\n    fieldOrDatumDef,\n    legendConfig,\n    config,\n    scaleType,\n    orient,\n    legendType,\n    direction\n  };\n\n  for (const property of LEGEND_COMPONENT_PROPERTIES) {\n    if (\n      (legendType === 'gradient' && property.startsWith('symbol')) ||\n      (legendType === 'symbol' && property.startsWith('gradient'))\n    ) {\n      continue;\n    }\n\n    const value = property in legendRules ? legendRules[property](ruleParams) : legend[property];\n    if (value !== undefined) {\n      const explicit = isExplicit(value, property, legend, model.fieldDef(channel));\n      if (explicit || config.legend[property] === undefined) {\n        legendCmpt.set(property, value, explicit);\n      }\n    }\n  }\n\n  const legendEncoding = legend?.encoding ?? {};\n  const selections = legendCmpt.get('selections');\n  const legendEncode: LegendEncode = {};\n\n  const legendEncodeParams: LegendEncodeParams = {fieldOrDatumDef, model, channel, legendCmpt, legendType};\n\n  for (const part of ['labels', 'legend', 'title', 'symbols', 'gradient', 'entries']) {\n    const legendEncodingPart = guideEncodeEntry(legendEncoding[part] ?? {}, model);\n\n    const value =\n      part in legendEncodeRules\n        ? legendEncodeRules[part](legendEncodingPart, legendEncodeParams) // apply rule\n        : legendEncodingPart; // no rule -- just default values\n\n    if (value !== undefined && !isEmpty(value)) {\n      legendEncode[part] = {\n        ...(selections?.length && isFieldDef(fieldOrDatumDef)\n          ? {name: `${varName(fieldOrDatumDef.field)}_legend_${part}`}\n          : {}),\n        ...(selections?.length ? {interactive: !!selections} : {}),\n        update: value\n      };\n    }\n  }\n\n  if (!isEmpty(legendEncode)) {\n    legendCmpt.set('encode', legendEncode, !!legend?.encoding);\n  }\n\n  return legendCmpt;\n}\n\nfunction parseNonUnitLegend(model: Model) {\n  const {legends, resolve} = model.component;\n\n  for (const child of model.children) {\n    parseLegend(child);\n\n    for (const channel of keys(child.component.legends)) {\n      resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);\n\n      if (resolve.legend[channel] === 'shared') {\n        // If the resolve says shared (and has not been overridden)\n        // We will try to merge and see if there is a conflict\n\n        legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);\n\n        if (!legends[channel]) {\n          // If merge returns nothing, there is a conflict so we cannot make the legend shared.\n          // Thus, mark legend as independent and remove the legend component.\n          resolve.legend[channel] = 'independent';\n          delete legends[channel];\n        }\n      }\n    }\n  }\n\n  for (const channel of keys(legends)) {\n    for (const child of model.children) {\n      if (!child.component.legends[channel]) {\n        // skip if the child does not have a particular legend\n        continue;\n      }\n\n      if (resolve.legend[channel] === 'shared') {\n        // After merging shared legend, make sure to remove legend from child\n        delete child.component.legends[channel];\n      }\n    }\n  }\n\n  return legends;\n}\n\nexport function mergeLegendComponent(mergedLegend: LegendComponent, childLegend: LegendComponent): LegendComponent {\n  if (!mergedLegend) {\n    return childLegend.clone();\n  }\n  const mergedOrient = mergedLegend.getWithExplicit('orient');\n  const childOrient = childLegend.getWithExplicit('orient');\n\n  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n    // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n    // Cannot merge due to inconsistent orient\n    return undefined;\n  }\n\n  let typeMerged = false;\n  // Otherwise, let's merge\n  for (const prop of LEGEND_COMPONENT_PROPERTIES) {\n    const mergedValueWithExplicit = mergeValuesWithExplicit<LegendComponentProps, any>(\n      mergedLegend.getWithExplicit(prop),\n      childLegend.getWithExplicit(prop),\n      prop,\n      'legend',\n\n      // Tie breaker function\n      (v1: Explicit<any>, v2: Explicit<any>): any => {\n        switch (prop) {\n          case 'symbolType':\n            return mergeSymbolType(v1, v2);\n          case 'title':\n            return mergeTitleComponent(v1, v2);\n          case 'type':\n            // There are only two types. If we have different types, then prefer symbol over gradient.\n            typeMerged = true;\n            return makeImplicit('symbol');\n        }\n        return defaultTieBreaker<LegendComponentProps, any>(v1, v2, prop, 'legend');\n      }\n    );\n    mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);\n  }\n  if (typeMerged) {\n    if (mergedLegend.implicit?.encode?.gradient) {\n      deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);\n    }\n    if (mergedLegend.explicit?.encode?.gradient) {\n      deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);\n    }\n  }\n\n  return mergedLegend;\n}\n\nfunction mergeSymbolType(st1: Explicit<string>, st2: Explicit<string>) {\n  if (st2.value === 'circle') {\n    // prefer \"circle\" over \"stroke\"\n    return st2;\n  }\n  return st1;\n}\n"]},"metadata":{},"sourceType":"module"}