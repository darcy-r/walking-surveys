{"ast":null,"code":"import { isScaleChannel } from '../../channel';\nimport { vgField as fieldRef } from '../../channeldef';\nimport { isPathMark } from '../../mark';\nimport { hasContinuousDomain } from '../../scale';\nimport { hash, keys } from '../../util';\nimport { getMarkPropOrConfig } from '../common';\nimport { DataFlowNode } from './dataflow';\nexport class FilterInvalidNode extends DataFlowNode {\n  constructor(parent, filter) {\n    super(parent);\n    this.filter = filter;\n  }\n\n  clone() {\n    return new FilterInvalidNode(null, Object.assign({}, this.filter));\n  }\n\n  static make(parent, model) {\n    const {\n      config,\n      mark,\n      markDef\n    } = model;\n    const invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n    if (invalid !== 'filter') {\n      return null;\n    }\n\n    const filter = model.reduceFieldDef((aggregator, fieldDef, channel) => {\n      const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);\n\n      if (scaleComponent) {\n        const scaleType = scaleComponent.get('type'); // While discrete domain scales can handle invalid values, continuous scales can't.\n        // Thus, for non-path marks, we have to filter null for scales with continuous domains.\n        // (For path marks, we will use \"defined\" property and skip these values instead.)\n\n        if (hasContinuousDomain(scaleType) && fieldDef.aggregate !== 'count' && !isPathMark(mark)) {\n          aggregator[fieldDef.field] = fieldDef; // we know that the fieldDef is a typed field def\n        }\n      }\n\n      return aggregator;\n    }, {});\n\n    if (!keys(filter).length) {\n      return null;\n    }\n\n    return new FilterInvalidNode(parent, filter);\n  }\n\n  dependentFields() {\n    return new Set(keys(this.filter));\n  }\n\n  producedFields() {\n    return new Set(); // filter does not produce any new fields\n  }\n\n  hash() {\n    return `FilterInvalid ${hash(this.filter)}`;\n  }\n  /**\n   * Create the VgTransforms for each of the filtered fields.\n   */\n\n\n  assemble() {\n    const filters = keys(this.filter).reduce((vegaFilters, field) => {\n      const fieldDef = this.filter[field];\n      const ref = fieldRef(fieldDef, {\n        expr: 'datum'\n      });\n\n      if (fieldDef !== null) {\n        if (fieldDef.type === 'temporal') {\n          vegaFilters.push(`(isDate(${ref}) || (isValid(${ref}) && isFinite(+${ref})))`);\n        } else if (fieldDef.type === 'quantitative') {\n          vegaFilters.push(`isValid(${ref})`);\n          vegaFilters.push(`isFinite(+${ref})`);\n        } else {// should never get here\n        }\n      }\n\n      return vegaFilters;\n    }, []);\n    return filters.length > 0 ? {\n      type: 'filter',\n      expr: filters.join(' && ')\n    } : null;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["isScaleChannel","vgField","fieldRef","isPathMark","hasContinuousDomain","hash","keys","getMarkPropOrConfig","DataFlowNode","FilterInvalidNode","constructor","parent","filter","clone","Object","make","model","config","mark","markDef","invalid","reduceFieldDef","aggregator","fieldDef","channel","scaleComponent","getScaleComponent","scaleType","get","aggregate","field","length","dependentFields","Set","producedFields","assemble","filters","reduce","vegaFilters","ref","expr","type","push","join"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/data/filterinvalid.ts"],"sourcesContent":["import {FilterTransform as VgFilterTransform} from 'vega';\nimport {isScaleChannel} from '../../channel';\nimport {TypedFieldDef, vgField as fieldRef} from '../../channeldef';\nimport {isPathMark} from '../../mark';\nimport {hasContinuousDomain} from '../../scale';\nimport {Dict, hash, keys} from '../../util';\nimport {getMarkPropOrConfig} from '../common';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\nexport class FilterInvalidNode extends DataFlowNode {\n  public clone() {\n    return new FilterInvalidNode(null, {...this.filter});\n  }\n\n  constructor(parent: DataFlowNode, public readonly filter: Dict<TypedFieldDef<string>>) {\n    super(parent);\n  }\n\n  public static make(parent: DataFlowNode, model: UnitModel): FilterInvalidNode {\n    const {config, mark, markDef} = model;\n\n    const invalid = getMarkPropOrConfig('invalid', markDef, config);\n    if (invalid !== 'filter') {\n      return null;\n    }\n\n    const filter = model.reduceFieldDef((aggregator: Dict<TypedFieldDef<string>>, fieldDef, channel) => {\n      const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);\n      if (scaleComponent) {\n        const scaleType = scaleComponent.get('type');\n\n        // While discrete domain scales can handle invalid values, continuous scales can't.\n        // Thus, for non-path marks, we have to filter null for scales with continuous domains.\n        // (For path marks, we will use \"defined\" property and skip these values instead.)\n        if (hasContinuousDomain(scaleType) && fieldDef.aggregate !== 'count' && !isPathMark(mark)) {\n          aggregator[fieldDef.field] = fieldDef as any; // we know that the fieldDef is a typed field def\n        }\n      }\n      return aggregator;\n    }, {} as Dict<TypedFieldDef<string>>);\n\n    if (!keys(filter).length) {\n      return null;\n    }\n\n    return new FilterInvalidNode(parent, filter);\n  }\n\n  public dependentFields() {\n    return new Set(keys(this.filter));\n  }\n\n  public producedFields() {\n    return new Set<string>(); // filter does not produce any new fields\n  }\n\n  public hash() {\n    return `FilterInvalid ${hash(this.filter)}`;\n  }\n\n  /**\n   * Create the VgTransforms for each of the filtered fields.\n   */\n  public assemble(): VgFilterTransform {\n    const filters = keys(this.filter).reduce((vegaFilters, field) => {\n      const fieldDef = this.filter[field];\n      const ref = fieldRef(fieldDef, {expr: 'datum'});\n\n      if (fieldDef !== null) {\n        if (fieldDef.type === 'temporal') {\n          vegaFilters.push(`(isDate(${ref}) || (isValid(${ref}) && isFinite(+${ref})))`);\n        } else if (fieldDef.type === 'quantitative') {\n          vegaFilters.push(`isValid(${ref})`);\n          vegaFilters.push(`isFinite(+${ref})`);\n        } else {\n          // should never get here\n        }\n      }\n      return vegaFilters;\n    }, [] as string[]);\n\n    return filters.length > 0\n      ? {\n          type: 'filter',\n          expr: filters.join(' && ')\n        }\n      : null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}