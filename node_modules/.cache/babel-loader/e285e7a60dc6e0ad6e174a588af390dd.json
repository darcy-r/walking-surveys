{"ast":null,"code":"import { isString } from 'vega-util';\nimport { initConfig } from '../config';\nimport * as log from '../log';\nimport { isLayerSpec, isUnitSpec } from '../spec';\nimport { deepEqual } from '../util';\nimport { CoreNormalizer } from './core';\nimport { SelectionCompatibilityNormalizer } from './selectioncompat';\nimport { TopLevelSelectionsNormalizer } from './toplevelselection';\nexport function normalize(spec, config) {\n  if (config === undefined) {\n    config = initConfig(spec.config);\n  }\n\n  const normalizedSpec = normalizeGenericSpec(spec, config);\n  const {\n    width,\n    height\n  } = spec;\n  const autosize = normalizeAutoSize(normalizedSpec, {\n    width,\n    height,\n    autosize: spec.autosize\n  }, config);\n  return Object.assign(Object.assign({}, normalizedSpec), autosize ? {\n    autosize\n  } : {});\n}\nconst coreNormalizer = new CoreNormalizer();\nconst selectionCompatNormalizer = new SelectionCompatibilityNormalizer();\nconst topLevelSelectionNormalizer = new TopLevelSelectionsNormalizer();\n/**\n * Decompose extended unit specs into composition of pure unit specs.\n * And push top-level selection definitions down to unit specs.\n */\n\nfunction normalizeGenericSpec(spec) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const normParams = {\n    config\n  };\n  return topLevelSelectionNormalizer.map(coreNormalizer.map(selectionCompatNormalizer.map(spec, normParams), normParams), normParams);\n}\n\nfunction _normalizeAutoSize(autosize) {\n  return isString(autosize) ? {\n    type: autosize\n  } : autosize !== null && autosize !== void 0 ? autosize : {};\n}\n/**\n * Normalize autosize and deal with width or height == \"container\".\n */\n\n\nexport function normalizeAutoSize(spec, sizeInfo, config) {\n  let {\n    width,\n    height\n  } = sizeInfo;\n  const isFitCompatible = isUnitSpec(spec) || isLayerSpec(spec);\n  const autosizeDefault = {};\n\n  if (!isFitCompatible) {\n    // If spec is not compatible with autosize == \"fit\", discard width/height == container\n    if (width == 'container') {\n      log.warn(log.message.containerSizeNonSingle('width'));\n      width = undefined;\n    }\n\n    if (height == 'container') {\n      log.warn(log.message.containerSizeNonSingle('height'));\n      height = undefined;\n    }\n  } else {\n    // Default autosize parameters to fit when width/height is \"container\"\n    if (width == 'container' && height == 'container') {\n      autosizeDefault.type = 'fit';\n      autosizeDefault.contains = 'padding';\n    } else if (width == 'container') {\n      autosizeDefault.type = 'fit-x';\n      autosizeDefault.contains = 'padding';\n    } else if (height == 'container') {\n      autosizeDefault.type = 'fit-y';\n      autosizeDefault.contains = 'padding';\n    }\n  }\n\n  const autosize = Object.assign(Object.assign(Object.assign({\n    type: 'pad'\n  }, autosizeDefault), config ? _normalizeAutoSize(config.autosize) : {}), _normalizeAutoSize(spec.autosize));\n\n  if (autosize.type === 'fit' && !isFitCompatible) {\n    log.warn(log.message.FIT_NON_SINGLE);\n    autosize.type = 'pad';\n  }\n\n  if (width == 'container' && !(autosize.type == 'fit' || autosize.type == 'fit-x')) {\n    log.warn(log.message.containerSizeNotCompatibleWithAutosize('width'));\n  }\n\n  if (height == 'container' && !(autosize.type == 'fit' || autosize.type == 'fit-y')) {\n    log.warn(log.message.containerSizeNotCompatibleWithAutosize('height'));\n  } // Delete autosize property if it's Vega's default\n\n\n  if (deepEqual(autosize, {\n    type: 'pad'\n  })) {\n    return undefined;\n  }\n\n  return autosize;\n}","map":{"version":3,"mappings":"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","names":["isString","initConfig","log","isLayerSpec","isUnitSpec","deepEqual","CoreNormalizer","SelectionCompatibilityNormalizer","TopLevelSelectionsNormalizer","normalize","spec","config","undefined","normalizedSpec","normalizeGenericSpec","width","height","autosize","normalizeAutoSize","coreNormalizer","selectionCompatNormalizer","topLevelSelectionNormalizer","normParams","map","_normalizeAutoSize","type","sizeInfo","isFitCompatible","autosizeDefault","warn","message","containerSizeNonSingle","contains","FIT_NON_SINGLE","containerSizeNotCompatibleWithAutosize"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/normalize/index.ts"],"sourcesContent":["import {SignalRef} from 'vega';\nimport {isString} from 'vega-util';\nimport {Field} from '../channeldef';\nimport {Config, initConfig} from '../config';\nimport * as log from '../log';\nimport {\n  FacetedUnitSpec,\n  isLayerSpec,\n  isUnitSpec,\n  LayoutSizeMixins,\n  NonNormalizedSpec,\n  NormalizedSpec,\n  RepeatSpec,\n  TopLevelSpec\n} from '../spec';\nimport {AutoSizeParams, AutosizeType, TopLevel} from '../spec/toplevel';\nimport {deepEqual} from '../util';\nimport {NormalizerParams} from './base';\nimport {CoreNormalizer} from './core';\nimport {SelectionCompatibilityNormalizer} from './selectioncompat';\nimport {TopLevelSelectionsNormalizer} from './toplevelselection';\n\nexport function normalize(\n  spec: TopLevelSpec & LayoutSizeMixins,\n  config?: Config<SignalRef>\n): TopLevel<NormalizedSpec> & LayoutSizeMixins {\n  if (config === undefined) {\n    config = initConfig(spec.config);\n  }\n\n  const normalizedSpec = normalizeGenericSpec(spec, config);\n\n  const {width, height} = spec;\n  const autosize = normalizeAutoSize(normalizedSpec, {width, height, autosize: spec.autosize}, config);\n\n  return {\n    ...normalizedSpec,\n    ...(autosize ? {autosize} : {})\n  };\n}\n\nconst coreNormalizer = new CoreNormalizer();\nconst selectionCompatNormalizer = new SelectionCompatibilityNormalizer();\nconst topLevelSelectionNormalizer = new TopLevelSelectionsNormalizer();\n\n/**\n * Decompose extended unit specs into composition of pure unit specs.\n * And push top-level selection definitions down to unit specs.\n */\nfunction normalizeGenericSpec(\n  spec: NonNormalizedSpec | FacetedUnitSpec<Field> | RepeatSpec,\n  config: Config<SignalRef> = {}\n) {\n  const normParams = {config};\n  return topLevelSelectionNormalizer.map(\n    coreNormalizer.map(selectionCompatNormalizer.map(spec, normParams), normParams),\n    normParams\n  );\n}\n\nfunction _normalizeAutoSize(autosize: AutosizeType | AutoSizeParams) {\n  return isString(autosize) ? {type: autosize} : autosize ?? {};\n}\n\n/**\n * Normalize autosize and deal with width or height == \"container\".\n */\nexport function normalizeAutoSize(\n  spec: TopLevel<NormalizedSpec>,\n  sizeInfo: {autosize: AutosizeType | AutoSizeParams} & LayoutSizeMixins,\n  config?: Config\n) {\n  let {width, height} = sizeInfo;\n\n  const isFitCompatible = isUnitSpec(spec) || isLayerSpec(spec);\n  const autosizeDefault: AutoSizeParams = {};\n\n  if (!isFitCompatible) {\n    // If spec is not compatible with autosize == \"fit\", discard width/height == container\n    if (width == 'container') {\n      log.warn(log.message.containerSizeNonSingle('width'));\n      width = undefined;\n    }\n    if (height == 'container') {\n      log.warn(log.message.containerSizeNonSingle('height'));\n      height = undefined;\n    }\n  } else {\n    // Default autosize parameters to fit when width/height is \"container\"\n    if (width == 'container' && height == 'container') {\n      autosizeDefault.type = 'fit';\n      autosizeDefault.contains = 'padding';\n    } else if (width == 'container') {\n      autosizeDefault.type = 'fit-x';\n      autosizeDefault.contains = 'padding';\n    } else if (height == 'container') {\n      autosizeDefault.type = 'fit-y';\n      autosizeDefault.contains = 'padding';\n    }\n  }\n\n  const autosize: AutoSizeParams = {\n    type: 'pad',\n    ...autosizeDefault,\n    ...(config ? _normalizeAutoSize(config.autosize) : {}),\n    ..._normalizeAutoSize(spec.autosize)\n  };\n\n  if (autosize.type === 'fit' && !isFitCompatible) {\n    log.warn(log.message.FIT_NON_SINGLE);\n    autosize.type = 'pad';\n  }\n\n  if (width == 'container' && !(autosize.type == 'fit' || autosize.type == 'fit-x')) {\n    log.warn(log.message.containerSizeNotCompatibleWithAutosize('width'));\n  }\n  if (height == 'container' && !(autosize.type == 'fit' || autosize.type == 'fit-y')) {\n    log.warn(log.message.containerSizeNotCompatibleWithAutosize('height'));\n  }\n\n  // Delete autosize property if it's Vega's default\n  if (deepEqual(autosize, {type: 'pad'})) {\n    return undefined;\n  }\n\n  return autosize;\n}\n\nexport type {NormalizerParams};\n"]},"metadata":{},"sourceType":"module"}