{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isArray } from 'vega-util';\nimport { COLUMN, FACET, ROW } from '../channel';\nimport { hasConditionalFieldOrDatumDef, isFieldOrDatumDef, isValueDef } from '../channeldef';\nimport { boxPlotNormalizer } from '../compositemark/boxplot';\nimport { errorBandNormalizer } from '../compositemark/errorband';\nimport { errorBarNormalizer } from '../compositemark/errorbar';\nimport { channelHasField } from '../encoding';\nimport * as log from '../log';\nimport { isFacetMapping } from '../spec/facet';\nimport { SpecMapper } from '../spec/map';\nimport { isLayerRepeatSpec } from '../spec/repeat';\nimport { isUnitSpec } from '../spec/unit';\nimport { isEmpty, keys, omit, varName } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { PathOverlayNormalizer } from './pathoverlay';\nimport { replaceRepeaterInEncoding, replaceRepeaterInFacet } from './repeater';\nimport { RuleForRangedLineNormalizer } from './ruleforrangedline';\nexport class CoreNormalizer extends SpecMapper {\n  constructor() {\n    super(...arguments);\n    this.nonFacetUnitNormalizers = [boxPlotNormalizer, errorBarNormalizer, errorBandNormalizer, new PathOverlayNormalizer(), new RuleForRangedLineNormalizer()];\n  }\n\n  map(spec, params) {\n    // Special handling for a faceted unit spec as it can return a facet spec, not just a layer or unit spec like a normal unit spec.\n    if (isUnitSpec(spec)) {\n      const hasRow = channelHasField(spec.encoding, ROW);\n      const hasColumn = channelHasField(spec.encoding, COLUMN);\n      const hasFacet = channelHasField(spec.encoding, FACET);\n\n      if (hasRow || hasColumn || hasFacet) {\n        return this.mapFacetedUnit(spec, params);\n      }\n    }\n\n    return super.map(spec, params);\n  } // This is for normalizing non-facet unit\n\n\n  mapUnit(spec, params) {\n    const {\n      parentEncoding,\n      parentProjection\n    } = params;\n    const encoding = replaceRepeaterInEncoding(spec.encoding, params.repeater);\n    const specWithReplacedEncoding = Object.assign(Object.assign({}, spec), encoding ? {\n      encoding\n    } : {});\n\n    if (parentEncoding || parentProjection) {\n      return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding, params);\n    }\n\n    const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);\n\n    for (const unitNormalizer of this.nonFacetUnitNormalizers) {\n      if (unitNormalizer.hasMatchingType(specWithReplacedEncoding, params.config)) {\n        return unitNormalizer.run(specWithReplacedEncoding, params, normalizeLayerOrUnit);\n      }\n    }\n\n    return specWithReplacedEncoding;\n  }\n\n  mapRepeat(spec, params) {\n    if (isLayerRepeatSpec(spec)) {\n      return this.mapLayerRepeat(spec, params);\n    } else {\n      return this.mapNonLayerRepeat(spec, params);\n    }\n  }\n\n  mapLayerRepeat(spec, params) {\n    const {\n      repeat,\n      spec: childSpec\n    } = spec,\n          rest = __rest(spec, [\"repeat\", \"spec\"]);\n\n    const {\n      row,\n      column,\n      layer\n    } = repeat;\n    const {\n      repeater = {},\n      repeaterPrefix = ''\n    } = params;\n\n    if (row || column) {\n      return this.mapRepeat(Object.assign(Object.assign({}, spec), {\n        repeat: Object.assign(Object.assign({}, row ? {\n          row\n        } : {}), column ? {\n          column\n        } : {}),\n        spec: {\n          repeat: {\n            layer\n          },\n          spec: childSpec\n        }\n      }), params);\n    } else {\n      return Object.assign(Object.assign({}, rest), {\n        layer: layer.map(layerValue => {\n          const childRepeater = Object.assign(Object.assign({}, repeater), {\n            layer: layerValue\n          });\n          const childName = `${(childSpec.name || '') + repeaterPrefix}child__layer_${varName(layerValue)}`;\n          const child = this.mapLayerOrUnit(childSpec, Object.assign(Object.assign({}, params), {\n            repeater: childRepeater,\n            repeaterPrefix: childName\n          }));\n          child.name = childName;\n          return child;\n        })\n      });\n    }\n  }\n\n  mapNonLayerRepeat(spec, params) {\n    var _a;\n\n    const {\n      repeat,\n      spec: childSpec,\n      data\n    } = spec,\n          remainingProperties = __rest(spec, [\"repeat\", \"spec\", \"data\"]);\n\n    if (!isArray(repeat) && spec.columns) {\n      // is repeat with row/column\n      spec = omit(spec, ['columns']);\n      log.warn(log.message.columnsNotSupportByRowCol('repeat'));\n    }\n\n    const concat = [];\n    const {\n      repeater = {},\n      repeaterPrefix = ''\n    } = params;\n    const row = !isArray(repeat) && repeat.row || [repeater ? repeater.row : null];\n    const column = !isArray(repeat) && repeat.column || [repeater ? repeater.column : null];\n    const repeatValues = isArray(repeat) && repeat || [repeater ? repeater.repeat : null]; // cross product\n\n    for (const repeatValue of repeatValues) {\n      for (const rowValue of row) {\n        for (const columnValue of column) {\n          const childRepeater = {\n            repeat: repeatValue,\n            row: rowValue,\n            column: columnValue,\n            layer: repeater.layer\n          };\n          const childName = (childSpec.name || '') + repeaterPrefix + 'child__' + (isArray(repeat) ? `${varName(repeatValue)}` : (repeat.row ? `row_${varName(rowValue)}` : '') + (repeat.column ? `column_${varName(columnValue)}` : ''));\n          const child = this.map(childSpec, Object.assign(Object.assign({}, params), {\n            repeater: childRepeater,\n            repeaterPrefix: childName\n          }));\n          child.name = childName; // we move data up\n\n          concat.push(omit(child, ['data']));\n        }\n      }\n    }\n\n    const columns = isArray(repeat) ? spec.columns : repeat.column ? repeat.column.length : 1;\n    return Object.assign(Object.assign({\n      data: (_a = childSpec.data) !== null && _a !== void 0 ? _a : data,\n      align: 'all'\n    }, remainingProperties), {\n      columns,\n      concat\n    });\n  }\n\n  mapFacet(spec, params) {\n    const {\n      facet\n    } = spec;\n\n    if (isFacetMapping(facet) && spec.columns) {\n      // is facet with row/column\n      spec = omit(spec, ['columns']);\n      log.warn(log.message.columnsNotSupportByRowCol('facet'));\n    }\n\n    return super.mapFacet(spec, params);\n  }\n\n  mapUnitWithParentEncodingOrProjection(spec, params) {\n    const {\n      encoding,\n      projection\n    } = spec;\n    const {\n      parentEncoding,\n      parentProjection,\n      config\n    } = params;\n    const mergedProjection = mergeProjection({\n      parentProjection,\n      projection\n    });\n    const mergedEncoding = mergeEncoding({\n      parentEncoding,\n      encoding: replaceRepeaterInEncoding(encoding, params.repeater)\n    });\n    return this.mapUnit(Object.assign(Object.assign(Object.assign({}, spec), mergedProjection ? {\n      projection: mergedProjection\n    } : {}), mergedEncoding ? {\n      encoding: mergedEncoding\n    } : {}), {\n      config\n    });\n  }\n\n  mapFacetedUnit(spec, normParams) {\n    // New encoding in the inside spec should not contain row / column\n    // as row/column should be moved to facet\n    const _a = spec.encoding,\n          {\n      row,\n      column,\n      facet\n    } = _a,\n          encoding = __rest(_a, [\"row\", \"column\", \"facet\"]); // Mark and encoding should be moved into the inner spec\n\n\n    const {\n      mark,\n      width,\n      projection,\n      height,\n      view,\n      params,\n      encoding: _\n    } = spec,\n          outerSpec = __rest(spec, [\"mark\", \"width\", \"projection\", \"height\", \"view\", \"params\", \"encoding\"]);\n\n    const {\n      facetMapping,\n      layout\n    } = this.getFacetMappingAndLayout({\n      row,\n      column,\n      facet\n    }, normParams);\n    const newEncoding = replaceRepeaterInEncoding(encoding, normParams.repeater);\n    return this.mapFacet(Object.assign(Object.assign(Object.assign({}, outerSpec), layout), {\n      // row / column has higher precedence than facet\n      facet: facetMapping,\n      spec: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, width ? {\n        width\n      } : {}), height ? {\n        height\n      } : {}), view ? {\n        view\n      } : {}), projection ? {\n        projection\n      } : {}), {\n        mark,\n        encoding: newEncoding\n      }), params ? {\n        params\n      } : {})\n    }), normParams);\n  }\n\n  getFacetMappingAndLayout(facets, params) {\n    var _a;\n\n    const {\n      row,\n      column,\n      facet\n    } = facets;\n\n    if (row || column) {\n      if (facet) {\n        log.warn(log.message.facetChannelDropped([...(row ? [ROW] : []), ...(column ? [COLUMN] : [])]));\n      }\n\n      const facetMapping = {};\n      const layout = {};\n\n      for (const channel of [ROW, COLUMN]) {\n        const def = facets[channel];\n\n        if (def) {\n          const {\n            align,\n            center,\n            spacing,\n            columns\n          } = def,\n                defWithoutLayout = __rest(def, [\"align\", \"center\", \"spacing\", \"columns\"]);\n\n          facetMapping[channel] = defWithoutLayout;\n\n          for (const prop of ['align', 'center', 'spacing']) {\n            if (def[prop] !== undefined) {\n              (_a = layout[prop]) !== null && _a !== void 0 ? _a : layout[prop] = {};\n              layout[prop][channel] = def[prop];\n            }\n          }\n        }\n      }\n\n      return {\n        facetMapping,\n        layout\n      };\n    } else {\n      const {\n        align,\n        center,\n        spacing,\n        columns\n      } = facet,\n            facetMapping = __rest(facet, [\"align\", \"center\", \"spacing\", \"columns\"]);\n\n      return {\n        facetMapping: replaceRepeaterInFacet(facetMapping, params.repeater),\n        layout: Object.assign(Object.assign(Object.assign(Object.assign({}, align ? {\n          align\n        } : {}), center ? {\n          center\n        } : {}), spacing ? {\n          spacing\n        } : {}), columns ? {\n          columns\n        } : {})\n      };\n    }\n  }\n\n  mapLayer(spec, _a) {\n    // Special handling for extended layer spec\n    var {\n      parentEncoding,\n      parentProjection\n    } = _a,\n        otherParams = __rest(_a, [\"parentEncoding\", \"parentProjection\"]);\n\n    const {\n      encoding,\n      projection\n    } = spec,\n          rest = __rest(spec, [\"encoding\", \"projection\"]);\n\n    const params = Object.assign(Object.assign({}, otherParams), {\n      parentEncoding: mergeEncoding({\n        parentEncoding,\n        encoding,\n        layer: true\n      }),\n      parentProjection: mergeProjection({\n        parentProjection,\n        projection\n      })\n    });\n    return super.mapLayer(rest, params);\n  }\n\n}\n\nfunction mergeEncoding(_ref) {\n  let {\n    parentEncoding,\n    encoding = {},\n    layer\n  } = _ref;\n  let merged = {};\n\n  if (parentEncoding) {\n    const channels = new Set([...keys(parentEncoding), ...keys(encoding)]);\n\n    for (const channel of channels) {\n      const channelDef = encoding[channel];\n      const parentChannelDef = parentEncoding[channel];\n\n      if (isFieldOrDatumDef(channelDef)) {\n        // Field/Datum Def can inherit properties from its parent\n        // Note that parentChannelDef doesn't have to be a field/datum def if the channelDef is already one.\n        const mergedChannelDef = Object.assign(Object.assign({}, parentChannelDef), channelDef);\n        merged[channel] = mergedChannelDef;\n      } else if (hasConditionalFieldOrDatumDef(channelDef)) {\n        merged[channel] = Object.assign(Object.assign({}, channelDef), {\n          condition: Object.assign(Object.assign({}, parentChannelDef), channelDef.condition)\n        });\n      } else if (channelDef || channelDef === null) {\n        merged[channel] = channelDef;\n      } else if (layer || isValueDef(parentChannelDef) || isSignalRef(parentChannelDef) || isFieldOrDatumDef(parentChannelDef) || isArray(parentChannelDef)) {\n        merged[channel] = parentChannelDef;\n      }\n    }\n  } else {\n    merged = encoding;\n  }\n\n  return !merged || isEmpty(merged) ? undefined : merged;\n}\n\nfunction mergeProjection(opt) {\n  const {\n    parentProjection,\n    projection\n  } = opt;\n\n  if (parentProjection && projection) {\n    log.warn(log.message.projectionOverridden({\n      parentProjection,\n      projection\n    }));\n  }\n\n  return projection !== null && projection !== void 0 ? projection : parentProjection;\n}","map":{"version":3,"mappings":"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","names":["isArray","COLUMN","FACET","ROW","hasConditionalFieldOrDatumDef","isFieldOrDatumDef","isValueDef","boxPlotNormalizer","errorBandNormalizer","errorBarNormalizer","channelHasField","log","isFacetMapping","SpecMapper","isLayerRepeatSpec","isUnitSpec","isEmpty","keys","omit","varName","isSignalRef","PathOverlayNormalizer","replaceRepeaterInEncoding","replaceRepeaterInFacet","RuleForRangedLineNormalizer","CoreNormalizer","constructor","map","spec","params","hasRow","encoding","hasColumn","hasFacet","mapFacetedUnit","mapUnit","parentEncoding","parentProjection","repeater","specWithReplacedEncoding","mapUnitWithParentEncodingOrProjection","normalizeLayerOrUnit","mapLayerOrUnit","bind","unitNormalizer","nonFacetUnitNormalizers","hasMatchingType","config","run","mapRepeat","mapLayerRepeat","mapNonLayerRepeat","repeat","childSpec","rest","row","column","layer","repeaterPrefix","Object","layerValue","childRepeater","childName","name","child","data","remainingProperties","columns","warn","message","columnsNotSupportByRowCol","concat","repeatValues","repeatValue","rowValue","columnValue","push","length","_a","align","mapFacet","facet","projection","mergedProjection","mergeProjection","mergedEncoding","mergeEncoding","normParams","mark","width","height","view","_","outerSpec","facetMapping","layout","getFacetMappingAndLayout","newEncoding","facets","facetChannelDropped","channel","def","center","spacing","defWithoutLayout","prop","undefined","mapLayer","otherParams","merged","channels","Set","channelDef","parentChannelDef","mergedChannelDef","condition","opt","projectionOverridden"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/normalize/core.ts"],"sourcesContent":["import {SignalRef} from 'vega';\nimport {isArray} from 'vega-util';\nimport {COLUMN, FACET, ROW} from '../channel';\nimport {Field, FieldName, hasConditionalFieldOrDatumDef, isFieldOrDatumDef, isValueDef} from '../channeldef';\nimport {SharedCompositeEncoding} from '../compositemark';\nimport {boxPlotNormalizer} from '../compositemark/boxplot';\nimport {errorBandNormalizer} from '../compositemark/errorband';\nimport {errorBarNormalizer} from '../compositemark/errorbar';\nimport {channelHasField, Encoding} from '../encoding';\nimport {ExprRef} from '../expr';\nimport * as log from '../log';\nimport {Projection} from '../projection';\nimport {FacetedUnitSpec, GenericSpec, LayerSpec, UnitSpec} from '../spec';\nimport {GenericCompositionLayoutWithColumns} from '../spec/base';\nimport {GenericConcatSpec} from '../spec/concat';\nimport {\n  FacetEncodingFieldDef,\n  FacetFieldDef,\n  FacetMapping,\n  GenericFacetSpec,\n  isFacetMapping,\n  NormalizedFacetSpec\n} from '../spec/facet';\nimport {NormalizedSpec} from '../spec/index';\nimport {NormalizedLayerSpec} from '../spec/layer';\nimport {SpecMapper} from '../spec/map';\nimport {isLayerRepeatSpec, LayerRepeatSpec, NonLayerRepeatSpec, RepeatSpec} from '../spec/repeat';\nimport {isUnitSpec, NormalizedUnitSpec} from '../spec/unit';\nimport {isEmpty, keys, omit, varName} from '../util';\nimport {isSignalRef} from '../vega.schema';\nimport {NonFacetUnitNormalizer, NormalizerParams} from './base';\nimport {PathOverlayNormalizer} from './pathoverlay';\nimport {replaceRepeaterInEncoding, replaceRepeaterInFacet} from './repeater';\nimport {RuleForRangedLineNormalizer} from './ruleforrangedline';\n\nexport class CoreNormalizer extends SpecMapper<NormalizerParams, FacetedUnitSpec<Field>, LayerSpec<Field>> {\n  private nonFacetUnitNormalizers: NonFacetUnitNormalizer<any>[] = [\n    boxPlotNormalizer,\n    errorBarNormalizer,\n    errorBandNormalizer,\n    new PathOverlayNormalizer(),\n    new RuleForRangedLineNormalizer()\n  ];\n\n  public map(spec: GenericSpec<FacetedUnitSpec<Field>, LayerSpec<Field>, RepeatSpec, Field>, params: NormalizerParams) {\n    // Special handling for a faceted unit spec as it can return a facet spec, not just a layer or unit spec like a normal unit spec.\n    if (isUnitSpec(spec)) {\n      const hasRow = channelHasField(spec.encoding, ROW);\n      const hasColumn = channelHasField(spec.encoding, COLUMN);\n      const hasFacet = channelHasField(spec.encoding, FACET);\n\n      if (hasRow || hasColumn || hasFacet) {\n        return this.mapFacetedUnit(spec, params);\n      }\n    }\n\n    return super.map(spec, params);\n  }\n\n  // This is for normalizing non-facet unit\n  public mapUnit(spec: UnitSpec<Field>, params: NormalizerParams): NormalizedUnitSpec | NormalizedLayerSpec {\n    const {parentEncoding, parentProjection} = params;\n\n    const encoding = replaceRepeaterInEncoding(spec.encoding, params.repeater);\n\n    const specWithReplacedEncoding = {\n      ...spec,\n      ...(encoding ? {encoding} : {})\n    };\n\n    if (parentEncoding || parentProjection) {\n      return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding, params);\n    }\n\n    const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);\n\n    for (const unitNormalizer of this.nonFacetUnitNormalizers) {\n      if (unitNormalizer.hasMatchingType(specWithReplacedEncoding, params.config)) {\n        return unitNormalizer.run(specWithReplacedEncoding, params, normalizeLayerOrUnit);\n      }\n    }\n\n    return specWithReplacedEncoding as NormalizedUnitSpec;\n  }\n\n  protected mapRepeat(\n    spec: RepeatSpec,\n    params: NormalizerParams\n  ): GenericConcatSpec<NormalizedSpec> | NormalizedLayerSpec {\n    if (isLayerRepeatSpec(spec)) {\n      return this.mapLayerRepeat(spec, params);\n    } else {\n      return this.mapNonLayerRepeat(spec, params);\n    }\n  }\n\n  private mapLayerRepeat(\n    spec: LayerRepeatSpec,\n    params: NormalizerParams\n  ): GenericConcatSpec<NormalizedSpec> | NormalizedLayerSpec {\n    const {repeat, spec: childSpec, ...rest} = spec;\n    const {row, column, layer} = repeat;\n\n    const {repeater = {}, repeaterPrefix = ''} = params;\n\n    if (row || column) {\n      return this.mapRepeat(\n        {\n          ...spec,\n          repeat: {\n            ...(row ? {row} : {}),\n            ...(column ? {column} : {})\n          },\n          spec: {\n            repeat: {layer},\n            spec: childSpec\n          }\n        },\n        params\n      );\n    } else {\n      return {\n        ...rest,\n        layer: layer.map(layerValue => {\n          const childRepeater = {\n            ...repeater,\n            layer: layerValue\n          };\n\n          const childName = `${(childSpec.name || '') + repeaterPrefix}child__layer_${varName(layerValue)}`;\n\n          const child = this.mapLayerOrUnit(childSpec, {...params, repeater: childRepeater, repeaterPrefix: childName});\n          child.name = childName;\n\n          return child;\n        })\n      };\n    }\n  }\n\n  private mapNonLayerRepeat(spec: NonLayerRepeatSpec, params: NormalizerParams): GenericConcatSpec<NormalizedSpec> {\n    const {repeat, spec: childSpec, data, ...remainingProperties} = spec;\n\n    if (!isArray(repeat) && spec.columns) {\n      // is repeat with row/column\n      spec = omit(spec, ['columns']);\n      log.warn(log.message.columnsNotSupportByRowCol('repeat'));\n    }\n\n    const concat: NormalizedSpec[] = [];\n\n    const {repeater = {}, repeaterPrefix = ''} = params;\n\n    const row = (!isArray(repeat) && repeat.row) || [repeater ? repeater.row : null];\n    const column = (!isArray(repeat) && repeat.column) || [repeater ? repeater.column : null];\n\n    const repeatValues = (isArray(repeat) && repeat) || [repeater ? repeater.repeat : null];\n\n    // cross product\n    for (const repeatValue of repeatValues) {\n      for (const rowValue of row) {\n        for (const columnValue of column) {\n          const childRepeater = {\n            repeat: repeatValue,\n            row: rowValue,\n            column: columnValue,\n            layer: repeater.layer\n          };\n\n          const childName =\n            (childSpec.name || '') +\n            repeaterPrefix +\n            'child__' +\n            (isArray(repeat)\n              ? `${varName(repeatValue)}`\n              : (repeat.row ? `row_${varName(rowValue)}` : '') +\n                (repeat.column ? `column_${varName(columnValue)}` : ''));\n\n          const child = this.map(childSpec, {...params, repeater: childRepeater, repeaterPrefix: childName});\n          child.name = childName;\n\n          // we move data up\n          concat.push(omit(child, ['data']) as NormalizedSpec);\n        }\n      }\n    }\n\n    const columns = isArray(repeat) ? spec.columns : repeat.column ? repeat.column.length : 1;\n    return {\n      data: childSpec.data ?? data, // data from child spec should have precedence\n      align: 'all',\n      ...remainingProperties,\n      columns,\n      concat\n    };\n  }\n\n  protected mapFacet(\n    spec: GenericFacetSpec<UnitSpec<Field>, LayerSpec<Field>, Field>,\n    params: NormalizerParams\n  ): GenericFacetSpec<NormalizedUnitSpec, NormalizedLayerSpec, FieldName> {\n    const {facet} = spec;\n\n    if (isFacetMapping(facet) && spec.columns) {\n      // is facet with row/column\n      spec = omit(spec, ['columns']);\n      log.warn(log.message.columnsNotSupportByRowCol('facet'));\n    }\n\n    return super.mapFacet(spec, params);\n  }\n\n  private mapUnitWithParentEncodingOrProjection(\n    spec: FacetedUnitSpec<Field>,\n    params: NormalizerParams\n  ): NormalizedUnitSpec | NormalizedLayerSpec {\n    const {encoding, projection} = spec;\n    const {parentEncoding, parentProjection, config} = params;\n    const mergedProjection = mergeProjection({parentProjection, projection});\n    const mergedEncoding = mergeEncoding({\n      parentEncoding,\n      encoding: replaceRepeaterInEncoding(encoding, params.repeater)\n    });\n\n    return this.mapUnit(\n      {\n        ...spec,\n        ...(mergedProjection ? {projection: mergedProjection} : {}),\n        ...(mergedEncoding ? {encoding: mergedEncoding} : {})\n      },\n      {config}\n    );\n  }\n\n  private mapFacetedUnit(spec: FacetedUnitSpec<Field>, normParams: NormalizerParams): NormalizedFacetSpec {\n    // New encoding in the inside spec should not contain row / column\n    // as row/column should be moved to facet\n    const {row, column, facet, ...encoding} = spec.encoding;\n\n    // Mark and encoding should be moved into the inner spec\n    const {mark, width, projection, height, view, params, encoding: _, ...outerSpec} = spec;\n\n    const {facetMapping, layout} = this.getFacetMappingAndLayout({row, column, facet}, normParams);\n\n    const newEncoding = replaceRepeaterInEncoding(encoding, normParams.repeater);\n\n    return this.mapFacet(\n      {\n        ...outerSpec,\n        ...layout,\n\n        // row / column has higher precedence than facet\n        facet: facetMapping,\n        spec: {\n          ...(width ? {width} : {}),\n          ...(height ? {height} : {}),\n          ...(view ? {view} : {}),\n          ...(projection ? {projection} : {}),\n          mark,\n          encoding: newEncoding,\n          ...(params ? {params} : {})\n        }\n      },\n      normParams\n    );\n  }\n\n  private getFacetMappingAndLayout(\n    facets: {\n      row: FacetEncodingFieldDef<Field>;\n      column: FacetEncodingFieldDef<Field>;\n      facet: FacetEncodingFieldDef<Field>;\n    },\n    params: NormalizerParams\n  ): {facetMapping: FacetMapping<FieldName> | FacetFieldDef<FieldName>; layout: GenericCompositionLayoutWithColumns} {\n    const {row, column, facet} = facets;\n\n    if (row || column) {\n      if (facet) {\n        log.warn(log.message.facetChannelDropped([...(row ? [ROW] : []), ...(column ? [COLUMN] : [])]));\n      }\n\n      const facetMapping = {};\n      const layout = {};\n\n      for (const channel of [ROW, COLUMN]) {\n        const def = facets[channel];\n        if (def) {\n          const {align, center, spacing, columns, ...defWithoutLayout} = def;\n          facetMapping[channel] = defWithoutLayout;\n\n          for (const prop of ['align', 'center', 'spacing'] as const) {\n            if (def[prop] !== undefined) {\n              layout[prop] ??= {};\n              layout[prop][channel] = def[prop];\n            }\n          }\n        }\n      }\n\n      return {facetMapping, layout};\n    } else {\n      const {align, center, spacing, columns, ...facetMapping} = facet;\n      return {\n        facetMapping: replaceRepeaterInFacet(facetMapping, params.repeater),\n        layout: {\n          ...(align ? {align} : {}),\n          ...(center ? {center} : {}),\n          ...(spacing ? {spacing} : {}),\n          ...(columns ? {columns} : {})\n        }\n      };\n    }\n  }\n\n  public mapLayer(\n    spec: LayerSpec<Field>,\n    {parentEncoding, parentProjection, ...otherParams}: NormalizerParams\n  ): NormalizedLayerSpec {\n    // Special handling for extended layer spec\n\n    const {encoding, projection, ...rest} = spec;\n    const params: NormalizerParams = {\n      ...otherParams,\n      parentEncoding: mergeEncoding({parentEncoding, encoding, layer: true}),\n      parentProjection: mergeProjection({parentProjection, projection})\n    };\n    return super.mapLayer(rest, params);\n  }\n}\n\nfunction mergeEncoding({\n  parentEncoding,\n  encoding = {},\n  layer\n}: {\n  parentEncoding: SharedCompositeEncoding<any>;\n  encoding: SharedCompositeEncoding<any> | Encoding<any>;\n  layer?: boolean;\n}): Encoding<any> {\n  let merged: any = {};\n  if (parentEncoding) {\n    const channels = new Set([...keys(parentEncoding), ...keys(encoding)]);\n    for (const channel of channels) {\n      const channelDef = encoding[channel];\n      const parentChannelDef = parentEncoding[channel];\n\n      if (isFieldOrDatumDef(channelDef)) {\n        // Field/Datum Def can inherit properties from its parent\n        // Note that parentChannelDef doesn't have to be a field/datum def if the channelDef is already one.\n        const mergedChannelDef = {\n          ...parentChannelDef,\n          ...channelDef\n        };\n        merged[channel] = mergedChannelDef;\n      } else if (hasConditionalFieldOrDatumDef(channelDef)) {\n        merged[channel] = {\n          ...channelDef,\n          condition: {\n            ...parentChannelDef,\n            ...channelDef.condition\n          }\n        };\n      } else if (channelDef || channelDef === null) {\n        merged[channel] = channelDef;\n      } else if (\n        layer ||\n        isValueDef(parentChannelDef) ||\n        isSignalRef(parentChannelDef) ||\n        isFieldOrDatumDef(parentChannelDef) ||\n        isArray(parentChannelDef)\n      ) {\n        merged[channel] = parentChannelDef;\n      }\n    }\n  } else {\n    merged = encoding;\n  }\n  return !merged || isEmpty(merged) ? undefined : merged;\n}\n\nfunction mergeProjection<ES extends ExprRef | SignalRef>(opt: {\n  parentProjection: Projection<ES>;\n  projection: Projection<ES>;\n}) {\n  const {parentProjection, projection} = opt;\n  if (parentProjection && projection) {\n    log.warn(log.message.projectionOverridden({parentProjection, projection}));\n  }\n  return projection ?? parentProjection;\n}\n"]},"metadata":{},"sourceType":"module"}