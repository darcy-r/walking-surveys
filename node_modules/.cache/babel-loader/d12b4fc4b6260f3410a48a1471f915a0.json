{"ast":null,"code":"import * as log from '../log';\nimport { deepEqual, duplicate, getFirstDefined, keys } from '../util';\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nexport class Split {\n  constructor() {\n    let explicit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let implicit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.explicit = explicit;\n    this.implicit = implicit;\n  }\n\n  clone() {\n    return new Split(duplicate(this.explicit), duplicate(this.implicit));\n  }\n\n  combine() {\n    return Object.assign(Object.assign({}, this.explicit), this.implicit);\n  }\n\n  get(key) {\n    // Explicit has higher precedence\n    return getFirstDefined(this.explicit[key], this.implicit[key]);\n  }\n\n  getWithExplicit(key) {\n    // Explicit has higher precedence\n    if (this.explicit[key] !== undefined) {\n      return {\n        explicit: true,\n        value: this.explicit[key]\n      };\n    } else if (this.implicit[key] !== undefined) {\n      return {\n        explicit: false,\n        value: this.implicit[key]\n      };\n    }\n\n    return {\n      explicit: false,\n      value: undefined\n    };\n  }\n\n  setWithExplicit(key, _ref) {\n    let {\n      value,\n      explicit\n    } = _ref;\n\n    if (value !== undefined) {\n      this.set(key, value, explicit);\n    }\n  }\n\n  set(key, value, explicit) {\n    delete this[explicit ? 'implicit' : 'explicit'][key];\n    this[explicit ? 'explicit' : 'implicit'][key] = value;\n    return this;\n  }\n\n  copyKeyFromSplit(key, _ref2) {\n    let {\n      explicit,\n      implicit\n    } = _ref2;\n\n    // Explicit has higher precedence\n    if (explicit[key] !== undefined) {\n      this.set(key, explicit[key], true);\n    } else if (implicit[key] !== undefined) {\n      this.set(key, implicit[key], false);\n    }\n  }\n\n  copyKeyFromObject(key, s) {\n    // Explicit has higher precedence\n    if (s[key] !== undefined) {\n      this.set(key, s[key], true);\n    }\n  }\n  /**\n   * Merge split object into this split object. Properties from the other split\n   * overwrite properties from this split.\n   */\n\n\n  copyAll(other) {\n    for (const key of keys(other.combine())) {\n      const val = other.getWithExplicit(key);\n      this.setWithExplicit(key, val);\n    }\n  }\n\n}\nexport function makeExplicit(value) {\n  return {\n    explicit: true,\n    value\n  };\n}\nexport function makeImplicit(value) {\n  return {\n    explicit: false,\n    value\n  };\n}\nexport function tieBreakByComparing(compare) {\n  return (v1, v2, property, propertyOf) => {\n    const diff = compare(v1.value, v2.value);\n\n    if (diff > 0) {\n      return v1;\n    } else if (diff < 0) {\n      return v2;\n    }\n\n    return defaultTieBreaker(v1, v2, property, propertyOf);\n  };\n}\nexport function defaultTieBreaker(v1, v2, property, propertyOf) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n  } // If equal score, prefer v1.\n\n\n  return v1;\n}\nexport function mergeValuesWithExplicit(v1, v2, property, propertyOf) {\n  let tieBreaker = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : defaultTieBreaker;\n\n  if (v1 === undefined || v1.value === undefined) {\n    // For first run\n    return v2;\n  }\n\n  if (v1.explicit && !v2.explicit) {\n    return v1;\n  } else if (v2.explicit && !v1.explicit) {\n    return v2;\n  } else if (deepEqual(v1.value, v2.value)) {\n    return v1;\n  } else {\n    return tieBreaker(v1, v2, property, propertyOf);\n  }\n}","map":{"version":3,"mappings":"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","names":["log","deepEqual","duplicate","getFirstDefined","keys","Split","constructor","explicit","implicit","clone","combine","get","key","getWithExplicit","undefined","value","setWithExplicit","set","copyKeyFromSplit","copyKeyFromObject","s","copyAll","other","val","makeExplicit","makeImplicit","tieBreakByComparing","compare","v1","v2","property","propertyOf","diff","defaultTieBreaker","warn","message","mergeConflictingProperty","mergeValuesWithExplicit","tieBreaker"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/split.ts"],"sourcesContent":["import * as log from '../log';\nimport {deepEqual, duplicate, getFirstDefined, keys} from '../util';\n\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport class Split<T extends object> {\n  constructor(public readonly explicit: Partial<T> = {}, public readonly implicit: Partial<T> = {}) {}\n\n  public clone() {\n    return new Split(duplicate(this.explicit), duplicate(this.implicit));\n  }\n\n  public combine(): Partial<T> {\n    return {\n      ...this.explicit, // Explicit properties comes first\n      ...this.implicit\n    };\n  }\n\n  public get<K extends keyof T>(key: K): T[K] {\n    // Explicit has higher precedence\n    return getFirstDefined(this.explicit[key], this.implicit[key]);\n  }\n\n  public getWithExplicit<K extends keyof T>(key: K): Explicit<T[K]> {\n    // Explicit has higher precedence\n    if (this.explicit[key] !== undefined) {\n      return {explicit: true, value: this.explicit[key]};\n    } else if (this.implicit[key] !== undefined) {\n      return {explicit: false, value: this.implicit[key]};\n    }\n    return {explicit: false, value: undefined};\n  }\n\n  public setWithExplicit<K extends keyof T>(key: K, {value, explicit}: Explicit<T[K]>) {\n    if (value !== undefined) {\n      this.set(key, value, explicit);\n    }\n  }\n\n  public set<K extends keyof T>(key: K, value: T[K], explicit: boolean) {\n    delete this[explicit ? 'implicit' : 'explicit'][key];\n    this[explicit ? 'explicit' : 'implicit'][key] = value;\n    return this;\n  }\n\n  public copyKeyFromSplit<S extends T>(key: keyof T, {explicit, implicit}: Split<S>) {\n    // Explicit has higher precedence\n    if (explicit[key] !== undefined) {\n      this.set(key, explicit[key], true);\n    } else if (implicit[key] !== undefined) {\n      this.set(key, implicit[key], false);\n    }\n  }\n  public copyKeyFromObject<S extends T>(key: keyof T, s: Partial<S>) {\n    // Explicit has higher precedence\n    if (s[key] !== undefined) {\n      this.set(key, s[key], true);\n    }\n  }\n\n  /**\n   * Merge split object into this split object. Properties from the other split\n   * overwrite properties from this split.\n   */\n  public copyAll(other: Split<T>) {\n    for (const key of keys(other.combine())) {\n      const val = other.getWithExplicit(key);\n      this.setWithExplicit(key, val);\n    }\n  }\n}\n\nexport interface Explicit<T> {\n  explicit: boolean;\n  value: T;\n}\n\nexport function makeExplicit<T>(value: T): Explicit<T> {\n  return {\n    explicit: true,\n    value\n  };\n}\n\nexport function makeImplicit<T>(value: T): Explicit<T> {\n  return {\n    explicit: false,\n    value\n  };\n}\n\nexport type SplitParentProperty = 'scale' | 'axis' | 'legend' | '';\n\nexport function tieBreakByComparing<S, T>(compare: (v1: T, v2: T) => number) {\n  return (\n    v1: Explicit<T>,\n    v2: Explicit<T>,\n    property: keyof S | never,\n    propertyOf: SplitParentProperty\n  ): Explicit<T> => {\n    const diff = compare(v1.value, v2.value);\n    if (diff > 0) {\n      return v1;\n    } else if (diff < 0) {\n      return v2;\n    }\n    return defaultTieBreaker<S, T>(v1, v2, property, propertyOf);\n  };\n}\n\nexport function defaultTieBreaker<S, T>(\n  v1: Explicit<T>,\n  v2: Explicit<T>,\n  property: keyof S,\n  propertyOf: SplitParentProperty\n) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n  }\n  // If equal score, prefer v1.\n  return v1;\n}\n\nexport function mergeValuesWithExplicit<S, T>(\n  v1: Explicit<T>,\n  v2: Explicit<T>,\n  property: keyof S,\n  propertyOf: SplitParentProperty,\n  tieBreaker: (\n    v1: Explicit<T>,\n    v2: Explicit<T>,\n    property: keyof S,\n    propertyOf: string\n  ) => Explicit<T> = defaultTieBreaker\n) {\n  if (v1 === undefined || v1.value === undefined) {\n    // For first run\n    return v2;\n  }\n\n  if (v1.explicit && !v2.explicit) {\n    return v1;\n  } else if (v2.explicit && !v1.explicit) {\n    return v2;\n  } else if (deepEqual(v1.value, v2.value)) {\n    return v1;\n  } else {\n    return tieBreaker(v1, v2, property, propertyOf);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}