{"ast":null,"code":"import { isNumber, isString } from 'vega-util';\nimport { isMinMaxOp } from '../../aggregate';\nimport { getMainRangeChannel } from '../../channel';\nimport { isFieldDef, isFieldOrDatumDefForTimeFormat, isScaleFieldDef, isTypedFieldDef } from '../../channeldef';\nimport { isGenerator } from '../../data';\nimport { isDateTime } from '../../datetime';\nimport * as log from '../../log';\nimport { forEachLeaf } from '../../logical';\nimport { isPathMark } from '../../mark';\nimport { isFieldEqualPredicate, isFieldGTEPredicate, isFieldGTPredicate, isFieldLTEPredicate, isFieldLTPredicate, isFieldOneOfPredicate, isFieldPredicate, isFieldRangePredicate } from '../../predicate';\nimport { isSortField } from '../../sort';\nimport { accessPathDepth, accessPathWithDatum, duplicate, hash, keys, removePathFromField } from '../../util';\nimport { signalRefOrValue } from '../common';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { Split } from '../split';\nimport { DataFlowNode } from './dataflow';\n/**\n * Remove quotes from a string.\n */\n\nfunction unquote(pattern) {\n  if (pattern.startsWith(\"'\") && pattern.endsWith(\"'\") || pattern.startsWith('\"') && pattern.endsWith('\"')) {\n    return pattern.slice(1, -1);\n  }\n\n  return pattern;\n}\n/**\n * @param field The field.\n * @param parse What to parse the field as.\n */\n\n\nfunction parseExpression(field, parse) {\n  const f = accessPathWithDatum(field);\n\n  if (parse === 'number') {\n    return `toNumber(${f})`;\n  } else if (parse === 'boolean') {\n    return `toBoolean(${f})`;\n  } else if (parse === 'string') {\n    return `toString(${f})`;\n  } else if (parse === 'date') {\n    return `toDate(${f})`;\n  } else if (parse === 'flatten') {\n    return f;\n  } else if (parse.startsWith('date:')) {\n    const specifier = unquote(parse.slice(5, parse.length));\n    return `timeParse(${f},'${specifier}')`;\n  } else if (parse.startsWith('utc:')) {\n    const specifier = unquote(parse.slice(4, parse.length));\n    return `utcParse(${f},'${specifier}')`;\n  } else {\n    log.warn(log.message.unrecognizedParse(parse));\n    return null;\n  }\n}\n\nexport function getImplicitFromFilterTransform(transform) {\n  const implicit = {};\n  forEachLeaf(transform.filter, filter => {\n    var _a;\n\n    if (isFieldPredicate(filter)) {\n      // Automatically add a parse node for filters with filter objects\n      let val = null; // For EqualFilter, just use the equal property.\n      // For RangeFilter and OneOfFilter, all array members should have\n      // the same type, so we only use the first one.\n\n      if (isFieldEqualPredicate(filter)) {\n        val = signalRefOrValue(filter.equal);\n      } else if (isFieldLTEPredicate(filter)) {\n        val = signalRefOrValue(filter.lte);\n      } else if (isFieldLTPredicate(filter)) {\n        val = signalRefOrValue(filter.lt);\n      } else if (isFieldGTPredicate(filter)) {\n        val = signalRefOrValue(filter.gt);\n      } else if (isFieldGTEPredicate(filter)) {\n        val = signalRefOrValue(filter.gte);\n      } else if (isFieldRangePredicate(filter)) {\n        val = filter.range[0];\n      } else if (isFieldOneOfPredicate(filter)) {\n        val = ((_a = filter.oneOf) !== null && _a !== void 0 ? _a : filter['in'])[0];\n      } // else -- for filter expression, we can't infer anything\n\n\n      if (val) {\n        if (isDateTime(val)) {\n          implicit[filter.field] = 'date';\n        } else if (isNumber(val)) {\n          implicit[filter.field] = 'number';\n        } else if (isString(val)) {\n          implicit[filter.field] = 'string';\n        }\n      }\n\n      if (filter.timeUnit) {\n        implicit[filter.field] = 'date';\n      }\n    }\n  });\n  return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\n\nexport function getImplicitFromEncoding(model) {\n  const implicit = {};\n\n  function add(fieldDef) {\n    if (isFieldOrDatumDefForTimeFormat(fieldDef)) {\n      implicit[fieldDef.field] = 'date';\n    } else if (fieldDef.type === 'quantitative' && isMinMaxOp(fieldDef.aggregate) // we need to parse numbers to support correct min and max\n    ) {\n      implicit[fieldDef.field] = 'number';\n    } else if (accessPathDepth(fieldDef.field) > 1) {\n      // For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.\n      // (Parsing numbers / dates already flattens numeric and temporal fields.)\n      if (!(fieldDef.field in implicit)) {\n        implicit[fieldDef.field] = 'flatten';\n      }\n    } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {\n      // Flatten fields that we sort by but that are not otherwise flattened.\n      if (!(fieldDef.sort.field in implicit)) {\n        implicit[fieldDef.sort.field] = 'flatten';\n      }\n    }\n  }\n\n  if (isUnitModel(model) || isFacetModel(model)) {\n    // Parse encoded fields\n    model.forEachFieldDef((fieldDef, channel) => {\n      if (isTypedFieldDef(fieldDef)) {\n        add(fieldDef);\n      } else {\n        const mainChannel = getMainRangeChannel(channel);\n        const mainFieldDef = model.fieldDef(mainChannel);\n        add(Object.assign(Object.assign({}, fieldDef), {\n          type: mainFieldDef.type\n        }));\n      }\n    });\n  } // Parse quantitative dimension fields of path marks as numbers so that we sort them correctly.\n\n\n  if (isUnitModel(model)) {\n    const {\n      mark,\n      markDef,\n      encoding\n    } = model;\n\n    if (isPathMark(mark) && // No need to sort by dimension if we have a connected scatterplot (order channel is present)\n    !model.encoding.order) {\n      const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n      const dimensionChannelDef = encoding[dimensionChannel];\n\n      if (isFieldDef(dimensionChannelDef) && dimensionChannelDef.type === 'quantitative' && !(dimensionChannelDef.field in implicit)) {\n        implicit[dimensionChannelDef.field] = 'number';\n      }\n    }\n  }\n\n  return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\n\nexport function getImplicitFromSelection(model) {\n  const implicit = {};\n\n  if (isUnitModel(model) && model.component.selection) {\n    for (const name of keys(model.component.selection)) {\n      const selCmpt = model.component.selection[name];\n\n      for (const proj of selCmpt.project.items) {\n        if (!proj.channel && accessPathDepth(proj.field) > 1) {\n          implicit[proj.field] = 'flatten';\n        }\n      }\n    }\n  }\n\n  return implicit;\n}\nexport class ParseNode extends DataFlowNode {\n  constructor(parent, parse) {\n    super(parent);\n    this._parse = parse;\n  }\n\n  clone() {\n    return new ParseNode(null, duplicate(this._parse));\n  }\n\n  hash() {\n    return `Parse ${hash(this._parse)}`;\n  }\n  /**\n   * Creates a parse node from a data.format.parse and updates ancestorParse.\n   */\n\n\n  static makeExplicit(parent, model, ancestorParse) {\n    var _a; // Custom parse\n\n\n    let explicit = {};\n    const data = model.data;\n\n    if (!isGenerator(data) && ((_a = data === null || data === void 0 ? void 0 : data.format) === null || _a === void 0 ? void 0 : _a.parse)) {\n      explicit = data.format.parse;\n    }\n\n    return this.makeWithAncestors(parent, explicit, {}, ancestorParse);\n  }\n  /**\n   * Creates a parse node from \"explicit\" parse and \"implicit\" parse and updates ancestorParse.\n   */\n\n\n  static makeWithAncestors(parent, explicit, implicit, ancestorParse) {\n    // We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as \"derived\"). We also don't need to flatten a field that has already been parsed.\n    for (const field of keys(implicit)) {\n      const parsedAs = ancestorParse.getWithExplicit(field);\n\n      if (parsedAs.value !== undefined) {\n        // We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.\n        if (parsedAs.explicit || parsedAs.value === implicit[field] || parsedAs.value === 'derived' || implicit[field] === 'flatten') {\n          delete implicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, implicit[field], parsedAs.value));\n        }\n      }\n    }\n\n    for (const field of keys(explicit)) {\n      const parsedAs = ancestorParse.get(field);\n\n      if (parsedAs !== undefined) {\n        // Don't parse a field again if it has been parsed with the same type already.\n        if (parsedAs === explicit[field]) {\n          delete explicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, explicit[field], parsedAs));\n        }\n      }\n    }\n\n    const parse = new Split(explicit, implicit); // add the format parse from this model so that children don't parse the same field again\n\n    ancestorParse.copyAll(parse); // copy only non-null parses\n\n    const p = {};\n\n    for (const key of keys(parse.combine())) {\n      const val = parse.get(key);\n\n      if (val !== null) {\n        p[key] = val;\n      }\n    }\n\n    if (keys(p).length === 0 || ancestorParse.parseNothing) {\n      return null;\n    }\n\n    return new ParseNode(parent, p);\n  }\n\n  get parse() {\n    return this._parse;\n  }\n\n  merge(other) {\n    this._parse = Object.assign(Object.assign({}, this._parse), other.parse);\n    other.remove();\n  }\n  /**\n   * Assemble an object for Vega's format.parse property.\n   */\n\n\n  assembleFormatParse() {\n    const formatParse = {};\n\n    for (const field of keys(this._parse)) {\n      const p = this._parse[field];\n\n      if (accessPathDepth(field) === 1) {\n        formatParse[field] = p;\n      }\n    }\n\n    return formatParse;\n  } // format parse depends and produces all fields in its parse\n\n\n  producedFields() {\n    return new Set(keys(this._parse));\n  }\n\n  dependentFields() {\n    return new Set(keys(this._parse));\n  }\n\n  assembleTransforms() {\n    let onlyNested = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return keys(this._parse).filter(field => onlyNested ? accessPathDepth(field) > 1 : true).map(field => {\n      const expr = parseExpression(field, this._parse[field]);\n\n      if (!expr) {\n        return null;\n      }\n\n      const formula = {\n        type: 'formula',\n        expr,\n        as: removePathFromField(field) // Vega output is always flattened\n\n      };\n      return formula;\n    }).filter(t => t !== null);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["isNumber","isString","isMinMaxOp","getMainRangeChannel","isFieldDef","isFieldOrDatumDefForTimeFormat","isScaleFieldDef","isTypedFieldDef","isGenerator","isDateTime","log","forEachLeaf","isPathMark","isFieldEqualPredicate","isFieldGTEPredicate","isFieldGTPredicate","isFieldLTEPredicate","isFieldLTPredicate","isFieldOneOfPredicate","isFieldPredicate","isFieldRangePredicate","isSortField","accessPathDepth","accessPathWithDatum","duplicate","hash","keys","removePathFromField","signalRefOrValue","isFacetModel","isUnitModel","Split","DataFlowNode","unquote","pattern","startsWith","endsWith","slice","parseExpression","field","parse","f","specifier","length","warn","message","unrecognizedParse","getImplicitFromFilterTransform","transform","implicit","filter","val","equal","lte","lt","gt","gte","range","oneOf","_a","timeUnit","getImplicitFromEncoding","model","add","fieldDef","type","aggregate","sort","forEachFieldDef","channel","mainChannel","mainFieldDef","mark","markDef","encoding","order","dimensionChannel","orient","dimensionChannelDef","getImplicitFromSelection","component","selection","name","selCmpt","proj","project","items","ParseNode","constructor","parent","_parse","clone","makeExplicit","ancestorParse","explicit","data","format","makeWithAncestors","parsedAs","getWithExplicit","value","undefined","differentParse","get","copyAll","p","key","combine","parseNothing","merge","other","Object","remove","assembleFormatParse","formatParse","producedFields","Set","dependentFields","assembleTransforms","onlyNested","map","expr","formula","as","t"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/data/formatparse.ts"],"sourcesContent":["import {FormulaTransform as VgFormulaTransform, SignalRef} from 'vega';\nimport {isNumber, isString} from 'vega-util';\nimport {AncestorParse} from '.';\nimport {isMinMaxOp} from '../../aggregate';\nimport {getMainRangeChannel, SingleDefChannel} from '../../channel';\nimport {\n  isFieldDef,\n  isFieldOrDatumDefForTimeFormat,\n  isScaleFieldDef,\n  isTypedFieldDef,\n  TypedFieldDef\n} from '../../channeldef';\nimport {isGenerator, Parse} from '../../data';\nimport {DateTime, isDateTime} from '../../datetime';\nimport * as log from '../../log';\nimport {forEachLeaf} from '../../logical';\nimport {isPathMark} from '../../mark';\nimport {\n  isFieldEqualPredicate,\n  isFieldGTEPredicate,\n  isFieldGTPredicate,\n  isFieldLTEPredicate,\n  isFieldLTPredicate,\n  isFieldOneOfPredicate,\n  isFieldPredicate,\n  isFieldRangePredicate\n} from '../../predicate';\nimport {isSortField} from '../../sort';\nimport {FilterTransform} from '../../transform';\nimport {accessPathDepth, accessPathWithDatum, Dict, duplicate, hash, keys, removePathFromField} from '../../util';\nimport {signalRefOrValue} from '../common';\nimport {isFacetModel, isUnitModel, Model} from '../model';\nimport {Split} from '../split';\nimport {DataFlowNode} from './dataflow';\n\n/**\n * Remove quotes from a string.\n */\nfunction unquote(pattern: string) {\n  if ((pattern.startsWith(\"'\") && pattern.endsWith(\"'\")) || (pattern.startsWith('\"') && pattern.endsWith('\"'))) {\n    return pattern.slice(1, -1);\n  }\n  return pattern;\n}\n\n/**\n * @param field The field.\n * @param parse What to parse the field as.\n */\nfunction parseExpression(field: string, parse: string): string {\n  const f = accessPathWithDatum(field);\n  if (parse === 'number') {\n    return `toNumber(${f})`;\n  } else if (parse === 'boolean') {\n    return `toBoolean(${f})`;\n  } else if (parse === 'string') {\n    return `toString(${f})`;\n  } else if (parse === 'date') {\n    return `toDate(${f})`;\n  } else if (parse === 'flatten') {\n    return f;\n  } else if (parse.startsWith('date:')) {\n    const specifier = unquote(parse.slice(5, parse.length));\n    return `timeParse(${f},'${specifier}')`;\n  } else if (parse.startsWith('utc:')) {\n    const specifier = unquote(parse.slice(4, parse.length));\n    return `utcParse(${f},'${specifier}')`;\n  } else {\n    log.warn(log.message.unrecognizedParse(parse));\n    return null;\n  }\n}\n\nexport function getImplicitFromFilterTransform(transform: FilterTransform) {\n  const implicit: Dict<string> = {};\n  forEachLeaf(transform.filter, filter => {\n    if (isFieldPredicate(filter)) {\n      // Automatically add a parse node for filters with filter objects\n      let val: string | number | boolean | DateTime | SignalRef = null;\n\n      // For EqualFilter, just use the equal property.\n      // For RangeFilter and OneOfFilter, all array members should have\n      // the same type, so we only use the first one.\n      if (isFieldEqualPredicate(filter)) {\n        val = signalRefOrValue(filter.equal);\n      } else if (isFieldLTEPredicate(filter)) {\n        val = signalRefOrValue(filter.lte);\n      } else if (isFieldLTPredicate(filter)) {\n        val = signalRefOrValue(filter.lt);\n      } else if (isFieldGTPredicate(filter)) {\n        val = signalRefOrValue(filter.gt);\n      } else if (isFieldGTEPredicate(filter)) {\n        val = signalRefOrValue(filter.gte);\n      } else if (isFieldRangePredicate(filter)) {\n        val = filter.range[0];\n      } else if (isFieldOneOfPredicate(filter)) {\n        val = (filter.oneOf ?? filter['in'])[0];\n      } // else -- for filter expression, we can't infer anything\n\n      if (val) {\n        if (isDateTime(val)) {\n          implicit[filter.field] = 'date';\n        } else if (isNumber(val)) {\n          implicit[filter.field] = 'number';\n        } else if (isString(val)) {\n          implicit[filter.field] = 'string';\n        }\n      }\n\n      if (filter.timeUnit) {\n        implicit[filter.field] = 'date';\n      }\n    }\n  });\n\n  return implicit;\n}\n\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\nexport function getImplicitFromEncoding(model: Model) {\n  const implicit: Dict<string> = {};\n\n  function add(fieldDef: TypedFieldDef<string>) {\n    if (isFieldOrDatumDefForTimeFormat(fieldDef)) {\n      implicit[fieldDef.field] = 'date';\n    } else if (\n      fieldDef.type === 'quantitative' &&\n      isMinMaxOp(fieldDef.aggregate) // we need to parse numbers to support correct min and max\n    ) {\n      implicit[fieldDef.field] = 'number';\n    } else if (accessPathDepth(fieldDef.field) > 1) {\n      // For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.\n      // (Parsing numbers / dates already flattens numeric and temporal fields.)\n      if (!(fieldDef.field in implicit)) {\n        implicit[fieldDef.field] = 'flatten';\n      }\n    } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {\n      // Flatten fields that we sort by but that are not otherwise flattened.\n      if (!(fieldDef.sort.field in implicit)) {\n        implicit[fieldDef.sort.field] = 'flatten';\n      }\n    }\n  }\n\n  if (isUnitModel(model) || isFacetModel(model)) {\n    // Parse encoded fields\n    model.forEachFieldDef((fieldDef, channel) => {\n      if (isTypedFieldDef(fieldDef)) {\n        add(fieldDef);\n      } else {\n        const mainChannel = getMainRangeChannel(channel);\n        const mainFieldDef = model.fieldDef(mainChannel as SingleDefChannel) as TypedFieldDef<string>;\n        add({\n          ...fieldDef,\n          type: mainFieldDef.type\n        });\n      }\n    });\n  }\n\n  // Parse quantitative dimension fields of path marks as numbers so that we sort them correctly.\n  if (isUnitModel(model)) {\n    const {mark, markDef, encoding} = model;\n    if (\n      isPathMark(mark) &&\n      // No need to sort by dimension if we have a connected scatterplot (order channel is present)\n      !model.encoding.order\n    ) {\n      const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n      const dimensionChannelDef = encoding[dimensionChannel];\n      if (\n        isFieldDef(dimensionChannelDef) &&\n        dimensionChannelDef.type === 'quantitative' &&\n        !(dimensionChannelDef.field in implicit)\n      ) {\n        implicit[dimensionChannelDef.field] = 'number';\n      }\n    }\n  }\n\n  return implicit;\n}\n\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\nexport function getImplicitFromSelection(model: Model) {\n  const implicit: Dict<string> = {};\n\n  if (isUnitModel(model) && model.component.selection) {\n    for (const name of keys(model.component.selection)) {\n      const selCmpt = model.component.selection[name];\n      for (const proj of selCmpt.project.items) {\n        if (!proj.channel && accessPathDepth(proj.field) > 1) {\n          implicit[proj.field] = 'flatten';\n        }\n      }\n    }\n  }\n\n  return implicit;\n}\n\nexport class ParseNode extends DataFlowNode {\n  private _parse: Parse;\n\n  public clone() {\n    return new ParseNode(null, duplicate(this._parse));\n  }\n\n  constructor(parent: DataFlowNode, parse: Parse) {\n    super(parent);\n\n    this._parse = parse;\n  }\n\n  public hash() {\n    return `Parse ${hash(this._parse)}`;\n  }\n\n  /**\n   * Creates a parse node from a data.format.parse and updates ancestorParse.\n   */\n  public static makeExplicit(parent: DataFlowNode, model: Model, ancestorParse: AncestorParse) {\n    // Custom parse\n    let explicit = {};\n    const data = model.data;\n    if (!isGenerator(data) && data?.format?.parse) {\n      explicit = data.format.parse;\n    }\n\n    return this.makeWithAncestors(parent, explicit, {}, ancestorParse);\n  }\n\n  /**\n   * Creates a parse node from \"explicit\" parse and \"implicit\" parse and updates ancestorParse.\n   */\n  public static makeWithAncestors(\n    parent: DataFlowNode,\n    explicit: Parse,\n    implicit: Parse,\n    ancestorParse: AncestorParse\n  ) {\n    // We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as \"derived\"). We also don't need to flatten a field that has already been parsed.\n    for (const field of keys(implicit)) {\n      const parsedAs = ancestorParse.getWithExplicit(field);\n      if (parsedAs.value !== undefined) {\n        // We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.\n        if (\n          parsedAs.explicit ||\n          parsedAs.value === implicit[field] ||\n          parsedAs.value === 'derived' ||\n          implicit[field] === 'flatten'\n        ) {\n          delete implicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, implicit[field], parsedAs.value));\n        }\n      }\n    }\n\n    for (const field of keys(explicit)) {\n      const parsedAs = ancestorParse.get(field);\n      if (parsedAs !== undefined) {\n        // Don't parse a field again if it has been parsed with the same type already.\n        if (parsedAs === explicit[field]) {\n          delete explicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, explicit[field], parsedAs));\n        }\n      }\n    }\n\n    const parse = new Split(explicit, implicit);\n\n    // add the format parse from this model so that children don't parse the same field again\n    ancestorParse.copyAll(parse);\n\n    // copy only non-null parses\n    const p: Dict<string> = {};\n    for (const key of keys(parse.combine())) {\n      const val = parse.get(key);\n      if (val !== null) {\n        p[key] = val;\n      }\n    }\n\n    if (keys(p).length === 0 || ancestorParse.parseNothing) {\n      return null;\n    }\n\n    return new ParseNode(parent, p);\n  }\n\n  public get parse() {\n    return this._parse;\n  }\n\n  public merge(other: ParseNode) {\n    this._parse = {...this._parse, ...other.parse};\n    other.remove();\n  }\n\n  /**\n   * Assemble an object for Vega's format.parse property.\n   */\n  public assembleFormatParse() {\n    const formatParse: Dict<string> = {};\n    for (const field of keys(this._parse)) {\n      const p = this._parse[field];\n      if (accessPathDepth(field) === 1) {\n        formatParse[field] = p;\n      }\n    }\n    return formatParse;\n  }\n\n  // format parse depends and produces all fields in its parse\n  public producedFields() {\n    return new Set(keys(this._parse));\n  }\n\n  public dependentFields() {\n    return new Set(keys(this._parse));\n  }\n\n  public assembleTransforms(onlyNested = false): VgFormulaTransform[] {\n    return keys(this._parse)\n      .filter(field => (onlyNested ? accessPathDepth(field) > 1 : true))\n      .map(field => {\n        const expr = parseExpression(field, this._parse[field]);\n        if (!expr) {\n          return null;\n        }\n\n        const formula: VgFormulaTransform = {\n          type: 'formula',\n          expr,\n          as: removePathFromField(field) // Vega output is always flattened\n        };\n        return formula;\n      })\n      .filter(t => t !== null);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}