{"ast":null,"code":"import { isString } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef, isDatumDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { GEOJSON } from '../../type';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class GeoJSONNode extends DataFlowNode {\n  constructor(parent, fields, geojson, signal) {\n    super(parent);\n    this.fields = fields;\n    this.geojson = geojson;\n    this.signal = signal;\n  }\n\n  clone() {\n    return new GeoJSONNode(null, duplicate(this.fields), this.geojson, this.signal);\n  }\n\n  static parseAll(parent, model) {\n    if (model.component.projection && !model.component.projection.isFit) {\n      return parent;\n    }\n\n    let geoJsonCounter = 0;\n\n    for (const coordinates of [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]]) {\n      const pair = coordinates.map(channel => {\n        const def = getFieldOrDatumDef(model.encoding[channel]);\n        return isFieldDef(def) ? def.field : isDatumDef(def) ? {\n          expr: `${def.datum}`\n        } : isValueDef(def) ? {\n          expr: `${def['value']}`\n        } : undefined;\n      });\n\n      if (pair[0] || pair[1]) {\n        parent = new GeoJSONNode(parent, pair, null, model.getName(`geojson_${geoJsonCounter++}`));\n      }\n    }\n\n    if (model.channelHasField(SHAPE)) {\n      const fieldDef = model.typedFieldDef(SHAPE);\n\n      if (fieldDef.type === GEOJSON) {\n        parent = new GeoJSONNode(parent, null, fieldDef.field, model.getName(`geojson_${geoJsonCounter++}`));\n      }\n    }\n\n    return parent;\n  }\n\n  dependentFields() {\n    var _a;\n\n    const fields = ((_a = this.fields) !== null && _a !== void 0 ? _a : []).filter(isString);\n    return new Set([...(this.geojson ? [this.geojson] : []), ...fields]);\n  }\n\n  producedFields() {\n    return new Set();\n  }\n\n  hash() {\n    return `GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`;\n  }\n\n  assemble() {\n    return [...(this.geojson ? [{\n      type: 'filter',\n      expr: `isValid(datum[\"${this.geojson}\"])`\n    }] : []), Object.assign(Object.assign(Object.assign({\n      type: 'geojson'\n    }, this.fields ? {\n      fields: this.fields\n    } : {}), this.geojson ? {\n      geojson: this.geojson\n    } : {}), {\n      signal: this.signal\n    })];\n  }\n\n}","map":{"version":3,"mappings":"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","names":["isString","LATITUDE","LATITUDE2","LONGITUDE","LONGITUDE2","SHAPE","getFieldOrDatumDef","isDatumDef","isFieldDef","isValueDef","GEOJSON","duplicate","hash","DataFlowNode","GeoJSONNode","constructor","parent","fields","geojson","signal","clone","parseAll","model","component","projection","isFit","geoJsonCounter","coordinates","pair","map","channel","def","encoding","field","expr","datum","undefined","getName","channelHasField","fieldDef","typedFieldDef","type","dependentFields","_a","filter","Set","producedFields","assemble"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/data/geojson.ts"],"sourcesContent":["import {Transforms as VgTransform, Vector2} from 'vega';\nimport {isString} from 'vega-util';\nimport {GeoPositionChannel, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE} from '../../channel';\nimport {getFieldOrDatumDef, isDatumDef, isFieldDef, isValueDef} from '../../channeldef';\nimport {GEOJSON} from '../../type';\nimport {duplicate, hash} from '../../util';\nimport {VgExprRef} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\nexport class GeoJSONNode extends DataFlowNode {\n  public clone() {\n    return new GeoJSONNode(null, duplicate(this.fields), this.geojson, this.signal);\n  }\n\n  public static parseAll(parent: DataFlowNode, model: UnitModel): DataFlowNode {\n    if (model.component.projection && !model.component.projection.isFit) {\n      return parent;\n    }\n\n    let geoJsonCounter = 0;\n\n    for (const coordinates of [\n      [LONGITUDE, LATITUDE],\n      [LONGITUDE2, LATITUDE2]\n    ] as Vector2<GeoPositionChannel>[]) {\n      const pair = coordinates.map(channel => {\n        const def = getFieldOrDatumDef(model.encoding[channel]);\n        return isFieldDef(def)\n          ? def.field\n          : isDatumDef(def)\n          ? {expr: `${def.datum}`}\n          : isValueDef(def)\n          ? {expr: `${def['value']}`}\n          : undefined;\n      }) as [GeoPositionChannel, GeoPositionChannel];\n\n      if (pair[0] || pair[1]) {\n        parent = new GeoJSONNode(parent, pair, null, model.getName(`geojson_${geoJsonCounter++}`));\n      }\n    }\n\n    if (model.channelHasField(SHAPE)) {\n      const fieldDef = model.typedFieldDef(SHAPE);\n      if (fieldDef.type === GEOJSON) {\n        parent = new GeoJSONNode(parent, null, fieldDef.field, model.getName(`geojson_${geoJsonCounter++}`));\n      }\n    }\n\n    return parent;\n  }\n\n  constructor(\n    parent: DataFlowNode,\n    private fields?: Vector2<string | VgExprRef>,\n    private geojson?: string,\n    private signal?: string\n  ) {\n    super(parent);\n  }\n\n  public dependentFields() {\n    const fields = (this.fields ?? []).filter(isString) as string[];\n    return new Set([...(this.geojson ? [this.geojson] : []), ...fields]);\n  }\n\n  public producedFields() {\n    return new Set<string>();\n  }\n\n  public hash() {\n    return `GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`;\n  }\n\n  public assemble(): VgTransform[] {\n    return [\n      ...(this.geojson\n        ? [\n            {\n              type: 'filter',\n              expr: `isValid(datum[\"${this.geojson}\"])`\n            } as const\n          ]\n        : []),\n      {\n        type: 'geojson',\n        ...(this.fields ? {fields: this.fields} : {}),\n        ...(this.geojson ? {geojson: this.geojson} : {}),\n        signal: this.signal\n      }\n    ];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}