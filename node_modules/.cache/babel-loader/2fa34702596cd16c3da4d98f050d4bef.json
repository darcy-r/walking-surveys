{"ast":null,"code":"import { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isXorY } from '../../../channel';\nimport { isFieldDef, isFieldOrDatumDef } from '../../../channeldef';\nimport { ScaleType } from '../../../scale';\nimport { contains } from '../../../util';\nimport { getMarkPropOrConfig } from '../../common';\nimport { positionOffset } from './offset';\nimport * as ref from './valueref';\n/**\n * Return encode for point (non-band) position channels.\n */\n\nexport function pointPosition(channel, model, _ref) {\n  let {\n    defaultPos,\n    vgChannel\n  } = _ref;\n  const {\n    encoding,\n    markDef,\n    config,\n    stack\n  } = model;\n  const channelDef = encoding[channel];\n  const channel2Def = encoding[getSecondaryRangeChannel(channel)];\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n  const {\n    offset,\n    offsetType\n  } = positionOffset({\n    channel,\n    markDef,\n    encoding,\n    model,\n    bandPosition: 0.5\n  }); // Get default position or position from mark def\n\n  const defaultRef = pointPositionDefaultRef({\n    model,\n    defaultPos,\n    channel,\n    scaleName,\n    scale\n  });\n  const valueRef = !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude) ? // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n  {\n    field: model.getName(channel)\n  } : positionRef({\n    channel,\n    channelDef,\n    channel2Def,\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef,\n    bandPosition: offsetType === 'encoding' ? 0 : undefined\n  });\n  return valueRef ? {\n    [vgChannel || channel]: valueRef\n  } : undefined;\n} // TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated. For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\n\nexport function positionRef(params) {\n  const {\n    channel,\n    channelDef,\n    scaleName,\n    stack,\n    offset,\n    markDef\n  } = params; // This isn't a part of midPoint because we use midPoint for non-position too\n\n  if (isFieldOrDatumDef(channelDef) && stack && channel === stack.fieldChannel) {\n    if (isFieldDef(channelDef)) {\n      let bandPosition = channelDef.bandPosition;\n\n      if (bandPosition === undefined && markDef.type === 'text' && (channel === 'radius' || channel === 'theta')) {\n        // theta and radius of text mark should use bandPosition = 0.5 by default\n        // so that labels for arc marks are centered automatically\n        bandPosition = 0.5;\n      }\n\n      if (bandPosition !== undefined) {\n        return ref.interpolatedSignalRef({\n          scaleName,\n          fieldOrDatumDef: channelDef,\n          startSuffix: 'start',\n          bandPosition,\n          offset\n        });\n      }\n    } // x or y use stack_end so that stacked line's point mark use stack_end too.\n\n\n    return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, {\n      suffix: 'end'\n    }, {\n      offset\n    });\n  }\n\n  return ref.midPointRefWithPositionInvalidTest(params);\n}\nexport function pointPositionDefaultRef(_ref2) {\n  let {\n    model,\n    defaultPos,\n    channel,\n    scaleName,\n    scale\n  } = _ref2;\n  const {\n    markDef,\n    config\n  } = model;\n  return () => {\n    const mainChannel = getMainRangeChannel(channel);\n    const vgChannel = getVgPositionChannel(channel);\n    const definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, {\n      vgChannel\n    });\n\n    if (definedValueOrConfig !== undefined) {\n      return ref.widthHeightValueOrSignalRef(channel, definedValueOrConfig);\n    }\n\n    switch (defaultPos) {\n      case 'zeroOrMin':\n      case 'zeroOrMax':\n        if (scaleName) {\n          const scaleType = scale.get('type');\n\n          if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {// Log scales cannot have zero.\n            // Zero in time scale is arbitrary, and does not affect ratio.\n            // (Time is an interval level of measurement, not ratio).\n            // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n          } else {\n            if (scale.domainDefinitelyIncludesZero()) {\n              return {\n                scale: scaleName,\n                value: 0\n              };\n            }\n          }\n        }\n\n        if (defaultPos === 'zeroOrMin') {\n          return mainChannel === 'y' ? {\n            field: {\n              group: 'height'\n            }\n          } : {\n            value: 0\n          };\n        } else {\n          // zeroOrMax\n          switch (mainChannel) {\n            case 'radius':\n              // max of radius is min(width, height) / 2\n              return {\n                signal: `min(${model.width.signal},${model.height.signal})/2`\n              };\n\n            case 'theta':\n              return {\n                signal: '2*PI'\n              };\n\n            case 'x':\n              return {\n                field: {\n                  group: 'width'\n                }\n              };\n\n            case 'y':\n              return {\n                value: 0\n              };\n          }\n        }\n\n        break;\n\n      case 'mid':\n        {\n          const sizeRef = model[getSizeChannel(channel)];\n          return Object.assign(Object.assign({}, sizeRef), {\n            mult: 0.5\n          });\n        }\n    } // defaultPos === null\n\n\n    return undefined;\n  };\n}","map":{"version":3,"mappings":"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","names":["getMainRangeChannel","getSecondaryRangeChannel","getSizeChannel","getVgPositionChannel","isXorY","isFieldDef","isFieldOrDatumDef","ScaleType","contains","getMarkPropOrConfig","positionOffset","ref","pointPosition","channel","model","defaultPos","vgChannel","encoding","markDef","config","stack","channelDef","channel2Def","scaleName","scale","getScaleComponent","offset","offsetType","bandPosition","defaultRef","pointPositionDefaultRef","valueRef","latitude","longitude","field","getName","positionRef","undefined","params","fieldChannel","type","interpolatedSignalRef","fieldOrDatumDef","startSuffix","valueRefForFieldOrDatumDef","suffix","midPointRefWithPositionInvalidTest","mainChannel","definedValueOrConfig","widthHeightValueOrSignalRef","scaleType","get","LOG","TIME","UTC","domainDefinitelyIncludesZero","value","group","signal","width","height","sizeRef","mult"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/mark/encode/position-point.ts"],"sourcesContent":["import {\n  getMainRangeChannel,\n  getSecondaryRangeChannel,\n  getSizeChannel,\n  getVgPositionChannel,\n  isXorY,\n  PolarPositionChannel,\n  PositionChannel\n} from '../../../channel';\nimport {isFieldDef, isFieldOrDatumDef, TypedFieldDef} from '../../../channeldef';\nimport {ScaleType} from '../../../scale';\nimport {contains} from '../../../util';\nimport {VgValueRef} from '../../../vega.schema';\nimport {getMarkPropOrConfig} from '../../common';\nimport {ScaleComponent} from '../../scale/component';\nimport {UnitModel} from '../../unit';\nimport {positionOffset} from './offset';\nimport * as ref from './valueref';\n\n/**\n * Return encode for point (non-band) position channels.\n */\nexport function pointPosition(\n  channel: 'x' | 'y' | 'theta' | 'radius',\n  model: UnitModel,\n  {\n    defaultPos,\n    vgChannel\n  }: {\n    defaultPos: 'mid' | 'zeroOrMin' | 'zeroOrMax' | null;\n    vgChannel?: 'x' | 'y' | 'xc' | 'yc';\n  }\n) {\n  const {encoding, markDef, config, stack} = model;\n\n  const channelDef = encoding[channel];\n  const channel2Def = encoding[getSecondaryRangeChannel(channel)];\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n\n  const {offset, offsetType} = positionOffset({\n    channel,\n    markDef,\n    encoding,\n    model,\n    bandPosition: 0.5\n  });\n\n  // Get default position or position from mark def\n  const defaultRef = pointPositionDefaultRef({\n    model,\n    defaultPos,\n    channel,\n    scaleName,\n    scale\n  });\n\n  const valueRef =\n    !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude)\n      ? // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n        {field: model.getName(channel)}\n      : positionRef({\n          channel,\n          channelDef,\n          channel2Def,\n          markDef,\n          config,\n          scaleName,\n          scale,\n          stack,\n          offset,\n          defaultRef,\n          bandPosition: offsetType === 'encoding' ? 0 : undefined\n        });\n\n  return valueRef ? {[vgChannel || channel]: valueRef} : undefined;\n}\n\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated. For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\nexport function positionRef(\n  params: ref.MidPointParams & {\n    channel: 'x' | 'y' | 'radius' | 'theta';\n  }\n): VgValueRef | VgValueRef[] {\n  const {channel, channelDef, scaleName, stack, offset, markDef} = params;\n\n  // This isn't a part of midPoint because we use midPoint for non-position too\n  if (isFieldOrDatumDef(channelDef) && stack && channel === stack.fieldChannel) {\n    if (isFieldDef(channelDef)) {\n      let bandPosition = channelDef.bandPosition;\n\n      if (bandPosition === undefined && markDef.type === 'text' && (channel === 'radius' || channel === 'theta')) {\n        // theta and radius of text mark should use bandPosition = 0.5 by default\n        // so that labels for arc marks are centered automatically\n        bandPosition = 0.5;\n      }\n\n      if (bandPosition !== undefined) {\n        return ref.interpolatedSignalRef({\n          scaleName,\n          fieldOrDatumDef: channelDef as TypedFieldDef<string>, // positionRef always have type\n          startSuffix: 'start',\n          bandPosition,\n          offset\n        });\n      }\n    }\n    // x or y use stack_end so that stacked line's point mark use stack_end too.\n    return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, {suffix: 'end'}, {offset});\n  }\n\n  return ref.midPointRefWithPositionInvalidTest(params);\n}\n\nexport function pointPositionDefaultRef({\n  model,\n  defaultPos,\n  channel,\n  scaleName,\n  scale\n}: {\n  model: UnitModel;\n  defaultPos: 'mid' | 'zeroOrMin' | 'zeroOrMax' | null;\n  channel: PositionChannel | PolarPositionChannel;\n  scaleName: string;\n  scale: ScaleComponent;\n}): () => VgValueRef {\n  const {markDef, config} = model;\n  return () => {\n    const mainChannel = getMainRangeChannel(channel);\n    const vgChannel = getVgPositionChannel(channel);\n\n    const definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, {vgChannel});\n    if (definedValueOrConfig !== undefined) {\n      return ref.widthHeightValueOrSignalRef(channel, definedValueOrConfig);\n    }\n\n    switch (defaultPos) {\n      case 'zeroOrMin':\n      case 'zeroOrMax':\n        if (scaleName) {\n          const scaleType = scale.get('type');\n          if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {\n            // Log scales cannot have zero.\n            // Zero in time scale is arbitrary, and does not affect ratio.\n            // (Time is an interval level of measurement, not ratio).\n            // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n          } else {\n            if (scale.domainDefinitelyIncludesZero()) {\n              return {\n                scale: scaleName,\n                value: 0\n              };\n            }\n          }\n        }\n\n        if (defaultPos === 'zeroOrMin') {\n          return mainChannel === 'y' ? {field: {group: 'height'}} : {value: 0};\n        } else {\n          // zeroOrMax\n          switch (mainChannel) {\n            case 'radius':\n              // max of radius is min(width, height) / 2\n              return {\n                signal: `min(${model.width.signal},${model.height.signal})/2`\n              };\n            case 'theta':\n              return {signal: '2*PI'};\n            case 'x':\n              return {field: {group: 'width'}};\n            case 'y':\n              return {value: 0};\n          }\n        }\n        break;\n      case 'mid': {\n        const sizeRef = model[getSizeChannel(channel)];\n        return {...sizeRef, mult: 0.5};\n      }\n    }\n    // defaultPos === null\n    return undefined;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}