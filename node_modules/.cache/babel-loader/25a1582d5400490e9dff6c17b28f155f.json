{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { array, isArray } from 'vega-util';\nimport { AXIS_PARTS, AXIS_PROPERTY_TYPE, CONDITIONAL_AXIS_PROP_INDEX, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { defaultTitle } from '../../channeldef';\nimport { isText } from '../../title';\nimport { contains, getFirstDefined, isEmpty, replaceAll } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { exprFromValueRefOrSignalRef } from '../common';\nimport { expression } from '../predicate';\n\nfunction assembleTitle(title, config) {\n  if (!title) {\n    return undefined;\n  }\n\n  if (isArray(title) && !isText(title)) {\n    return title.map(fieldDef => defaultTitle(fieldDef, config)).join(', ');\n  }\n\n  return title;\n}\n\nfunction setAxisEncode(axis, part, vgProp, vgRef) {\n  var _a, _b, _c;\n\n  var _d, _e;\n\n  (_a = axis.encode) !== null && _a !== void 0 ? _a : axis.encode = {};\n  (_b = (_d = axis.encode)[part]) !== null && _b !== void 0 ? _b : _d[part] = {};\n  (_c = (_e = axis.encode[part]).update) !== null && _c !== void 0 ? _c : _e.update = {}; // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n\n  axis.encode[part].update[vgProp] = vgRef;\n}\n\nexport function assembleAxis(axisCmpt, kind, config) {\n  let opt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n    header: false\n  };\n\n  var _a, _b;\n\n  const _c = axisCmpt.combine(),\n        {\n    disable,\n    orient,\n    scale,\n    labelExpr,\n    title,\n    zindex\n  } = _c,\n        axis = __rest(_c, [\"disable\", \"orient\", \"scale\", \"labelExpr\", \"title\", \"zindex\"]);\n\n  if (disable) {\n    return undefined;\n  }\n\n  for (const prop in axis) {\n    const propType = AXIS_PROPERTY_TYPE[prop];\n    const propValue = axis[prop];\n\n    if (propType && propType !== kind && propType !== 'both') {\n      // Remove properties that are not valid for this kind of axis\n      delete axis[prop];\n    } else if (isConditionalAxisValue(propValue)) {\n      // deal with conditional axis value\n      const {\n        condition\n      } = propValue,\n            valueOrSignalRef = __rest(propValue, [\"condition\"]);\n\n      const conditions = array(condition);\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n\n      if (propIndex) {\n        const {\n          vgProp,\n          part\n        } = propIndex; // If there is a corresponding Vega property for the channel,\n        // use Vega's custom axis encoding and delete the original axis property to avoid conflicts\n\n        const vgRef = [...conditions.map(c => {\n          const {\n            test\n          } = c,\n                valueOrSignalCRef = __rest(c, [\"test\"]);\n\n          return Object.assign({\n            test: expression(null, test)\n          }, valueOrSignalCRef);\n        }), valueOrSignalRef];\n        setAxisEncode(axis, part, vgProp, vgRef);\n        delete axis[prop];\n      } else if (propIndex === null) {\n        // If propIndex is null, this means we support conditional axis property by converting the condition to signal instead.\n        const signalRef = {\n          signal: conditions.map(c => {\n            const {\n              test\n            } = c,\n                  valueOrSignalCRef = __rest(c, [\"test\"]);\n\n            return `${expression(null, test)} ? ${exprFromValueRefOrSignalRef(valueOrSignalCRef)} : `;\n          }).join('') + exprFromValueRefOrSignalRef(valueOrSignalRef)\n        };\n        axis[prop] = signalRef;\n      }\n    } else if (isSignalRef(propValue)) {\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n\n      if (propIndex) {\n        const {\n          vgProp,\n          part\n        } = propIndex;\n        setAxisEncode(axis, part, vgProp, propValue);\n        delete axis[prop];\n      } // else do nothing since the property already supports signal\n\n    } // Do not pass labelAlign/Baseline = null to Vega since it won't pass the schema\n    // Note that we need to use null so the default labelAlign is preserved.\n\n\n    if (contains(['labelAlign', 'labelBaseline'], prop) && axis[prop] === null) {\n      delete axis[prop];\n    }\n  }\n\n  if (kind === 'grid') {\n    if (!axis.grid) {\n      return undefined;\n    } // Remove unnecessary encode block\n\n\n    if (axis.encode) {\n      // Only need to keep encode block for grid\n      const {\n        grid\n      } = axis.encode;\n      axis.encode = Object.assign({}, grid ? {\n        grid\n      } : {});\n\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n\n    return Object.assign(Object.assign({\n      scale,\n      orient\n    }, axis), {\n      domain: false,\n      labels: false,\n      aria: false,\n      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n      // would not affect gridAxis\n      maxExtent: 0,\n      minExtent: 0,\n      ticks: false,\n      zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n\n    });\n  } else {\n    // kind === 'main'\n    if (!opt.header && axisCmpt.mainExtracted) {\n      // if mainExtracted has been extracted to a separate facet\n      return undefined;\n    }\n\n    if (labelExpr !== undefined) {\n      let expr = labelExpr;\n\n      if (((_b = (_a = axis.encode) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b.update) && isSignalRef(axis.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n      }\n\n      setAxisEncode(axis, 'labels', 'text', {\n        signal: expr\n      });\n    }\n\n    if (axis.labelAlign === null) {\n      delete axis.labelAlign;\n    } // Remove unnecessary encode block\n\n\n    if (axis.encode) {\n      for (const part of AXIS_PARTS) {\n        if (!axisCmpt.hasAxisPart(part)) {\n          delete axis.encode[part];\n        }\n      }\n\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n\n    const titleString = assembleTitle(title, config);\n    return Object.assign(Object.assign(Object.assign(Object.assign({\n      scale,\n      orient,\n      grid: false\n    }, titleString ? {\n      title: titleString\n    } : {}), axis), config.aria === false ? {\n      aria: false\n    } : {}), {\n      zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n\n    });\n  }\n}\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\n\nexport function assembleAxisSignals(model) {\n  const {\n    axes\n  } = model.component;\n  const signals = [];\n\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    if (axes[channel]) {\n      for (const axis of axes[channel]) {\n        if (!axis.get('disable') && !axis.get('gridScale')) {\n          // If there is x-axis but no y-scale for gridScale, need to set height/width so x-axis can draw the grid with the right height. Same for y-axis and width.\n          const sizeType = channel === 'x' ? 'height' : 'width';\n          const update = model.getSizeSignalRef(sizeType).signal;\n\n          if (sizeType !== update) {\n            signals.push({\n              name: sizeType,\n              update\n            });\n          }\n        }\n      }\n    }\n  }\n\n  return signals;\n}\nexport function assembleAxes(axisComponents, config) {\n  const {\n    x = [],\n    y = []\n  } = axisComponents;\n  return [...x.map(a => assembleAxis(a, 'grid', config)), ...y.map(a => assembleAxis(a, 'grid', config)), ...x.map(a => assembleAxis(a, 'main', config)), ...y.map(a => assembleAxis(a, 'main', config))].filter(a => a); // filter undefined\n}","map":{"version":3,"mappings":"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","names":["array","isArray","AXIS_PARTS","AXIS_PROPERTY_TYPE","CONDITIONAL_AXIS_PROP_INDEX","isConditionalAxisValue","POSITION_SCALE_CHANNELS","defaultTitle","isText","contains","getFirstDefined","isEmpty","replaceAll","isSignalRef","exprFromValueRefOrSignalRef","expression","assembleTitle","title","config","undefined","map","fieldDef","join","setAxisEncode","axis","part","vgProp","vgRef","encode","_a","_b","_d","update","_c","_e","assembleAxis","axisCmpt","kind","opt","header","combine","disable","orient","scale","labelExpr","zindex","prop","propType","propValue","condition","valueOrSignalRef","conditions","propIndex","c","test","valueOrSignalCRef","signalRef","signal","grid","Object","domain","labels","aria","maxExtent","minExtent","ticks","mainExtracted","expr","text","labelAlign","hasAxisPart","titleString","assembleAxisSignals","model","axes","component","signals","channel","get","sizeType","getSizeSignalRef","push","name","assembleAxes","axisComponents","x","y","a","filter"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/axis/assemble.ts"],"sourcesContent":["import {Axis as VgAxis, AxisEncode, NewSignal, SignalRef, Text} from 'vega';\nimport {array, isArray} from 'vega-util';\nimport {AXIS_PARTS, AXIS_PROPERTY_TYPE, CONDITIONAL_AXIS_PROP_INDEX, isConditionalAxisValue} from '../../axis';\nimport {POSITION_SCALE_CHANNELS} from '../../channel';\nimport {defaultTitle, FieldDefBase} from '../../channeldef';\nimport {Config} from '../../config';\nimport {isText} from '../../title';\nimport {contains, getFirstDefined, isEmpty, replaceAll} from '../../util';\nimport {isSignalRef, VgEncodeChannel, VgValueRef} from '../../vega.schema';\nimport {exprFromValueRefOrSignalRef} from '../common';\nimport {Model} from '../model';\nimport {expression} from '../predicate';\nimport {AxisComponent, AxisComponentIndex} from './component';\n\nfunction assembleTitle(title: Text | FieldDefBase<string>[] | SignalRef, config: Config): Text | SignalRef {\n  if (!title) {\n    return undefined;\n  }\n  if (isArray(title) && !isText(title)) {\n    return title.map(fieldDef => defaultTitle(fieldDef, config)).join(', ');\n  }\n  return title;\n}\n\nfunction setAxisEncode(\n  axis: Omit<VgAxis, 'orient' | 'scale'>,\n  part: keyof AxisEncode,\n  vgProp: VgEncodeChannel,\n  vgRef: VgValueRef | readonly VgValueRef[]\n) {\n  axis.encode ??= {};\n  axis.encode[part] ??= {};\n  axis.encode[part].update ??= {};\n  // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n  (axis.encode[part].update[vgProp] as any) = vgRef;\n}\n\nexport function assembleAxis(\n  axisCmpt: AxisComponent,\n  kind: 'main' | 'grid',\n  config: Config<SignalRef>,\n  opt: {\n    header: boolean; // whether this is called via a header\n  } = {header: false}\n): VgAxis {\n  const {disable, orient, scale, labelExpr, title, zindex, ...axis} = axisCmpt.combine();\n\n  if (disable) {\n    return undefined;\n  }\n\n  for (const prop in axis) {\n    const propType = AXIS_PROPERTY_TYPE[prop];\n    const propValue = axis[prop];\n\n    if (propType && propType !== kind && propType !== 'both') {\n      // Remove properties that are not valid for this kind of axis\n      delete axis[prop];\n    } else if (isConditionalAxisValue<any, SignalRef>(propValue)) {\n      // deal with conditional axis value\n\n      const {condition, ...valueOrSignalRef} = propValue;\n      const conditions = array(condition);\n\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n      if (propIndex) {\n        const {vgProp, part} = propIndex;\n        // If there is a corresponding Vega property for the channel,\n        // use Vega's custom axis encoding and delete the original axis property to avoid conflicts\n\n        const vgRef = [\n          ...conditions.map(c => {\n            const {test, ...valueOrSignalCRef} = c;\n            return {\n              test: expression(null, test),\n              ...valueOrSignalCRef\n            };\n          }),\n          valueOrSignalRef\n        ];\n        setAxisEncode(axis, part, vgProp, vgRef);\n        delete axis[prop];\n      } else if (propIndex === null) {\n        // If propIndex is null, this means we support conditional axis property by converting the condition to signal instead.\n        const signalRef: SignalRef = {\n          signal:\n            conditions\n              .map(c => {\n                const {test, ...valueOrSignalCRef} = c;\n                return `${expression(null, test)} ? ${exprFromValueRefOrSignalRef(valueOrSignalCRef)} : `;\n              })\n              .join('') + exprFromValueRefOrSignalRef(valueOrSignalRef)\n        };\n        axis[prop] = signalRef;\n      }\n    } else if (isSignalRef(propValue)) {\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n      if (propIndex) {\n        const {vgProp, part} = propIndex;\n        setAxisEncode(axis, part, vgProp, propValue);\n        delete axis[prop];\n      } // else do nothing since the property already supports signal\n    }\n\n    // Do not pass labelAlign/Baseline = null to Vega since it won't pass the schema\n    // Note that we need to use null so the default labelAlign is preserved.\n    if (contains(['labelAlign', 'labelBaseline'], prop) && axis[prop] === null) {\n      delete axis[prop];\n    }\n  }\n\n  if (kind === 'grid') {\n    if (!axis.grid) {\n      return undefined;\n    }\n\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      // Only need to keep encode block for grid\n      const {grid} = axis.encode;\n      axis.encode = {\n        ...(grid ? {grid} : {})\n      };\n\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n\n    return {\n      scale,\n      orient,\n      ...axis,\n      domain: false,\n      labels: false,\n      aria: false, // always hide grid axis\n\n      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n      // would not affect gridAxis\n      maxExtent: 0,\n      minExtent: 0,\n      ticks: false,\n      zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n    };\n  } else {\n    // kind === 'main'\n\n    if (!opt.header && axisCmpt.mainExtracted) {\n      // if mainExtracted has been extracted to a separate facet\n      return undefined;\n    }\n\n    if (labelExpr !== undefined) {\n      let expr = labelExpr;\n      if (axis.encode?.labels?.update && isSignalRef(axis.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n      }\n      setAxisEncode(axis, 'labels', 'text', {signal: expr});\n    }\n\n    if (axis.labelAlign === null) {\n      delete axis.labelAlign;\n    }\n\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      for (const part of AXIS_PARTS) {\n        if (!axisCmpt.hasAxisPart(part)) {\n          delete axis.encode[part];\n        }\n      }\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n\n    const titleString = assembleTitle(title, config);\n\n    return {\n      scale,\n      orient,\n      grid: false,\n      ...(titleString ? {title: titleString} : {}),\n      ...axis,\n      ...(config.aria === false ? {aria: false} : {}),\n      zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n    };\n  }\n}\n\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\nexport function assembleAxisSignals(model: Model): NewSignal[] {\n  const {axes} = model.component;\n  const signals: NewSignal[] = [];\n\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    if (axes[channel]) {\n      for (const axis of axes[channel]) {\n        if (!axis.get('disable') && !axis.get('gridScale')) {\n          // If there is x-axis but no y-scale for gridScale, need to set height/width so x-axis can draw the grid with the right height. Same for y-axis and width.\n\n          const sizeType = channel === 'x' ? 'height' : 'width';\n          const update = model.getSizeSignalRef(sizeType).signal;\n\n          if (sizeType !== update) {\n            signals.push({\n              name: sizeType,\n              update\n            });\n          }\n        }\n      }\n    }\n  }\n  return signals;\n}\n\nexport function assembleAxes(axisComponents: AxisComponentIndex, config: Config<SignalRef>): VgAxis[] {\n  const {x = [], y = []} = axisComponents;\n  return [\n    ...x.map(a => assembleAxis(a, 'grid', config)),\n    ...y.map(a => assembleAxis(a, 'grid', config)),\n    ...x.map(a => assembleAxis(a, 'main', config)),\n    ...y.map(a => assembleAxis(a, 'main', config))\n  ].filter(a => a); // filter undefined\n}\n"]},"metadata":{},"sourceType":"module"}