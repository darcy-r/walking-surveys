{"ast":null,"code":"import { POSITION_SCALE_CHANNELS } from '../../../channel';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { fieldInvalidPredicate } from './valueref';\nexport function defined(model) {\n  const {\n    config,\n    markDef\n  } = model;\n  const invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid) {\n    const signal = allFieldsInvalidPredicate(model, {\n      channels: POSITION_SCALE_CHANNELS\n    });\n\n    if (signal) {\n      return {\n        defined: {\n          signal\n        }\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction allFieldsInvalidPredicate(model, _ref) {\n  let {\n    invalid = false,\n    channels\n  } = _ref;\n  const filterIndex = channels.reduce((aggregator, channel) => {\n    const scaleComponent = model.getScaleComponent(channel);\n\n    if (scaleComponent) {\n      const scaleType = scaleComponent.get('type');\n      const field = model.vgField(channel, {\n        expr: 'datum'\n      }); // While discrete domain scales can handle invalid values, continuous scales can't.\n\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n\n    return aggregator;\n  }, {});\n  const fields = keys(filterIndex);\n\n  if (fields.length > 0) {\n    const op = invalid ? '||' : '&&';\n    return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n  }\n\n  return undefined;\n}\n\nexport function valueIfDefined(prop, value) {\n  if (value !== undefined) {\n    return {\n      [prop]: signalOrValueRef(value)\n    };\n  }\n\n  return undefined;\n}","map":{"version":3,"mappings":"AAAA,SAAQA,uBAAR,QAAsC,kBAAtC;AAGA,SAAQC,mBAAR,QAAkC,gBAAlC;AACA,SAAcC,IAAd,QAAyB,eAAzB;AAEA,SAAQC,mBAAR,EAA6BC,gBAA7B,QAAoD,cAApD;AAEA,SAAQC,qBAAR,QAAoC,YAApC;AAEA,OAAM,SAAUC,OAAV,CAAkBC,KAAlB,EAAkC;EACtC,MAAM;IAACC,MAAD;IAASC;EAAT,IAAoBF,KAA1B;EAEA,MAAMG,OAAO,GAAGP,mBAAmB,CAAC,SAAD,EAAYM,OAAZ,EAAqBD,MAArB,CAAnC;;EACA,IAAIE,OAAJ,EAAa;IACX,MAAMC,MAAM,GAAGC,yBAAyB,CAACL,KAAD,EAAQ;MAACM,QAAQ,EAAEb;IAAX,CAAR,CAAxC;;IAEA,IAAIW,MAAJ,EAAY;MACV,OAAO;QAACL,OAAO,EAAE;UAACK;QAAD;MAAV,CAAP;IACD;EACF;;EACD,OAAO,EAAP;AACD;;AAED,SAASC,yBAAT,CACEL,KADF,QAE4E;EAAA,IAA1E;IAACG,OAAO,GAAG,KAAX;IAAkBG;EAAlB,CAA0E;EAE1E,MAAMC,WAAW,GAAGD,QAAQ,CAACE,MAAT,CAAgB,CAACC,UAAD,EAAyBC,OAAzB,KAAoC;IACtE,MAAMC,cAAc,GAAGX,KAAK,CAACY,iBAAN,CAAwBF,OAAxB,CAAvB;;IACA,IAAIC,cAAJ,EAAoB;MAClB,MAAME,SAAS,GAAGF,cAAc,CAACG,GAAf,CAAmB,MAAnB,CAAlB;MACA,MAAMC,KAAK,GAAGf,KAAK,CAACgB,OAAN,CAAcN,OAAd,EAAuB;QAACO,IAAI,EAAE;MAAP,CAAvB,CAAd,CAFkB,CAIlB;;MACA,IAAIF,KAAK,IAAIrB,mBAAmB,CAACmB,SAAD,CAAhC,EAA6C;QAC3CJ,UAAU,CAACM,KAAD,CAAV,GAAoB,IAApB;MACD;IACF;;IACD,OAAON,UAAP;EACD,CAZmB,EAYjB,EAZiB,CAApB;EAcA,MAAMS,MAAM,GAAGvB,IAAI,CAACY,WAAD,CAAnB;;EACA,IAAIW,MAAM,CAACC,MAAP,GAAgB,CAApB,EAAuB;IACrB,MAAMC,EAAE,GAAGjB,OAAO,GAAG,IAAH,GAAU,IAA5B;IACA,OAAOe,MAAM,CAACG,GAAP,CAAWN,KAAK,IAAIjB,qBAAqB,CAACiB,KAAD,EAAQZ,OAAR,CAAzC,EAA2DmB,IAA3D,CAAgE,IAAIF,EAAE,GAAtE,CAAP;EACD;;EACD,OAAOG,SAAP;AACD;;AAED,OAAM,SAAUC,cAAV,CAAyBC,IAAzB,EAAuCC,KAAvC,EAAmD;EACvD,IAAIA,KAAK,KAAKH,SAAd,EAAyB;IACvB,OAAO;MAAC,CAACE,IAAD,GAAQ5B,gBAAgB,CAAC6B,KAAD;IAAzB,CAAP;EACD;;EACD,OAAOH,SAAP;AACD","names":["POSITION_SCALE_CHANNELS","hasContinuousDomain","keys","getMarkPropOrConfig","signalOrValueRef","fieldInvalidPredicate","defined","model","config","markDef","invalid","signal","allFieldsInvalidPredicate","channels","filterIndex","reduce","aggregator","channel","scaleComponent","getScaleComponent","scaleType","get","field","vgField","expr","fields","length","op","map","join","undefined","valueIfDefined","prop","value"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/mark/encode/defined.ts"],"sourcesContent":["import {POSITION_SCALE_CHANNELS} from '../../../channel';\nimport {ScaleChannel} from '../../../channel';\nimport {Value} from '../../../channeldef';\nimport {hasContinuousDomain} from '../../../scale';\nimport {Dict, keys} from '../../../util';\nimport {VgEncodeEntry} from '../../../vega.schema';\nimport {getMarkPropOrConfig, signalOrValueRef} from '../../common';\nimport {UnitModel} from '../../unit';\nimport {fieldInvalidPredicate} from './valueref';\n\nexport function defined(model: UnitModel): VgEncodeEntry {\n  const {config, markDef} = model;\n\n  const invalid = getMarkPropOrConfig('invalid', markDef, config);\n  if (invalid) {\n    const signal = allFieldsInvalidPredicate(model, {channels: POSITION_SCALE_CHANNELS});\n\n    if (signal) {\n      return {defined: {signal}};\n    }\n  }\n  return {};\n}\n\nfunction allFieldsInvalidPredicate(\n  model: UnitModel,\n  {invalid = false, channels}: {invalid?: boolean; channels: ScaleChannel[]}\n) {\n  const filterIndex = channels.reduce((aggregator: Dict<true>, channel) => {\n    const scaleComponent = model.getScaleComponent(channel);\n    if (scaleComponent) {\n      const scaleType = scaleComponent.get('type');\n      const field = model.vgField(channel, {expr: 'datum'});\n\n      // While discrete domain scales can handle invalid values, continuous scales can't.\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n    return aggregator;\n  }, {});\n\n  const fields = keys(filterIndex);\n  if (fields.length > 0) {\n    const op = invalid ? '||' : '&&';\n    return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n  }\n  return undefined;\n}\n\nexport function valueIfDefined(prop: string, value: Value): VgEncodeEntry {\n  if (value !== undefined) {\n    return {[prop]: signalOrValueRef(value)};\n  }\n  return undefined;\n}\n"]},"metadata":{},"sourceType":"module"}