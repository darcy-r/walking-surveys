{"ast":null,"code":"import { permute, bisectLeft, bisectRight } from 'd3-array';\nimport { Transform } from 'vega-dataflow';\nimport { inherits } from 'vega-util';\n\nconst array8 = n => new Uint8Array(n);\n\nconst array16 = n => new Uint16Array(n);\n\nconst array32 = n => new Uint32Array(n);\n/**\n * Maintains CrossFilter state.\n */\n\n\nfunction Bitmaps() {\n  let width = 8,\n      data = [],\n      seen = array32(0),\n      curr = array(0, width),\n      prev = array(0, width);\n  return {\n    data: () => data,\n    seen: () => seen = lengthen(seen, data.length),\n\n    add(array) {\n      for (let i = 0, j = data.length, n = array.length, t; i < n; ++i) {\n        t = array[i];\n        t._index = j++;\n        data.push(t);\n      }\n    },\n\n    remove(num, map) {\n      // map: index -> boolean (true => remove)\n      const n = data.length,\n            copy = Array(n - num),\n            reindex = data; // reuse old data array for index map\n\n      let t, i, j; // seek forward to first removal\n\n      for (i = 0; !map[i] && i < n; ++i) {\n        copy[i] = data[i];\n        reindex[i] = i;\n      } // condense arrays\n\n\n      for (j = i; i < n; ++i) {\n        t = data[i];\n\n        if (!map[i]) {\n          reindex[i] = j;\n          curr[j] = curr[i];\n          prev[j] = prev[i];\n          copy[j] = t;\n          t._index = j++;\n        } else {\n          reindex[i] = -1;\n        }\n\n        curr[i] = 0; // clear unused bits\n      }\n\n      data = copy;\n      return reindex;\n    },\n\n    size: () => data.length,\n    curr: () => curr,\n    prev: () => prev,\n    reset: k => prev[k] = curr[k],\n    all: () => width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff,\n\n    set(k, one) {\n      curr[k] |= one;\n    },\n\n    clear(k, one) {\n      curr[k] &= ~one;\n    },\n\n    resize(n, m) {\n      const k = curr.length;\n\n      if (n > k || m > width) {\n        width = Math.max(m, width);\n        curr = array(n, width, curr);\n        prev = array(n, width);\n      }\n    }\n\n  };\n}\n\nfunction lengthen(array, length, copy) {\n  if (array.length >= length) return array;\n  copy = copy || new array.constructor(length);\n  copy.set(array);\n  return copy;\n}\n\nfunction array(n, m, array) {\n  const copy = (m < 0x101 ? array8 : m < 0x10001 ? array16 : array32)(n);\n  if (array) copy.set(array);\n  return copy;\n}\n\nfunction Dimension(index, i, query) {\n  const bit = 1 << i;\n  return {\n    one: bit,\n    zero: ~bit,\n    range: query.slice(),\n    bisect: index.bisect,\n    index: index.index,\n    size: index.size,\n\n    onAdd(added, curr) {\n      const dim = this,\n            range = dim.bisect(dim.range, added.value),\n            idx = added.index,\n            lo = range[0],\n            hi = range[1],\n            n1 = idx.length;\n      let i;\n\n      for (i = 0; i < lo; ++i) curr[idx[i]] |= bit;\n\n      for (i = hi; i < n1; ++i) curr[idx[i]] |= bit;\n\n      return dim;\n    }\n\n  };\n}\n/**\n * Maintains a list of values, sorted by key.\n */\n\n\nfunction SortedIndex() {\n  let index = array32(0),\n      value = [],\n      size = 0;\n\n  function insert(key, data, base) {\n    if (!data.length) return [];\n    const n0 = size,\n          n1 = data.length,\n          addi = array32(n1);\n    let addv = Array(n1),\n        oldv,\n        oldi,\n        i;\n\n    for (i = 0; i < n1; ++i) {\n      addv[i] = key(data[i]);\n      addi[i] = i;\n    }\n\n    addv = sort(addv, addi);\n\n    if (n0) {\n      oldv = value;\n      oldi = index;\n      value = Array(n0 + n1);\n      index = array32(n0 + n1);\n      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);\n    } else {\n      if (base > 0) for (i = 0; i < n1; ++i) {\n        addi[i] += base;\n      }\n      value = addv;\n      index = addi;\n    }\n\n    size = n0 + n1;\n    return {\n      index: addi,\n      value: addv\n    };\n  }\n\n  function remove(num, map) {\n    // map: index -> remove\n    const n = size;\n    let idx, i, j; // seek forward to first removal\n\n    for (i = 0; !map[index[i]] && i < n; ++i); // condense index and value arrays\n\n\n    for (j = i; i < n; ++i) {\n      if (!map[idx = index[i]]) {\n        index[j] = idx;\n        value[j] = value[i];\n        ++j;\n      }\n    }\n\n    size = n - num;\n  }\n\n  function reindex(map) {\n    for (let i = 0, n = size; i < n; ++i) {\n      index[i] = map[index[i]];\n    }\n  }\n\n  function bisect(range, array) {\n    let n;\n\n    if (array) {\n      n = array.length;\n    } else {\n      array = value;\n      n = size;\n    }\n\n    return [bisectLeft(array, range[0], 0, n), bisectRight(array, range[1], 0, n)];\n  }\n\n  return {\n    insert: insert,\n    remove: remove,\n    bisect: bisect,\n    reindex: reindex,\n    index: () => index,\n    size: () => size\n  };\n}\n\nfunction sort(values, index) {\n  values.sort.call(index, (a, b) => {\n    const x = values[a],\n          y = values[b];\n    return x < y ? -1 : x > y ? 1 : 0;\n  });\n  return permute(values, index);\n}\n\nfunction merge(base, value0, index0, n0, value1, index1, n1, value, index) {\n  let i0 = 0,\n      i1 = 0,\n      i;\n\n  for (i = 0; i0 < n0 && i1 < n1; ++i) {\n    if (value0[i0] < value1[i1]) {\n      value[i] = value0[i0];\n      index[i] = index0[i0++];\n    } else {\n      value[i] = value1[i1];\n      index[i] = index1[i1++] + base;\n    }\n  }\n\n  for (; i0 < n0; ++i0, ++i) {\n    value[i] = value0[i0];\n    index[i] = index0[i0];\n  }\n\n  for (; i1 < n1; ++i1, ++i) {\n    value[i] = value1[i1];\n    index[i] = index1[i1] + base;\n  }\n}\n/**\n * An indexed multi-dimensional filter.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n * @param {Array} params.query - An array of per-dimension range queries.\n */\n\n\nfunction CrossFilter(params) {\n  Transform.call(this, Bitmaps(), params);\n  this._indices = null;\n  this._dims = null;\n}\n\nCrossFilter.Definition = {\n  'type': 'CrossFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true\n  }, {\n    'name': 'query',\n    'type': 'array',\n    'array': true,\n    'required': true,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }]\n};\ninherits(CrossFilter, Transform, {\n  transform(_, pulse) {\n    if (!this._dims) {\n      return this.init(_, pulse);\n    } else {\n      var init = _.modified('fields') || _.fields.some(f => pulse.modified(f.fields));\n\n      return init ? this.reinit(_, pulse) : this.eval(_, pulse);\n    }\n  },\n\n  init(_, pulse) {\n    const fields = _.fields,\n          query = _.query,\n          indices = this._indices = {},\n          dims = this._dims = [],\n          m = query.length;\n    let i = 0,\n        key,\n        index; // instantiate indices and dimensions\n\n    for (; i < m; ++i) {\n      key = fields[i].fname;\n      index = indices[key] || (indices[key] = SortedIndex());\n      dims.push(Dimension(index, i, query[i]));\n    }\n\n    return this.eval(_, pulse);\n  },\n\n  reinit(_, pulse) {\n    const output = pulse.materialize().fork(),\n          fields = _.fields,\n          query = _.query,\n          indices = this._indices,\n          dims = this._dims,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(),\n          out = output.rem = output.add,\n          mod = output.mod,\n          m = query.length,\n          adds = {};\n    let add, index, key, mods, remMap, modMap, i, n, f; // set prev to current state\n\n    prev.set(curr); // if pulse has remove tuples, process them first\n\n    if (pulse.rem.length) {\n      remMap = this.remove(_, pulse, output);\n    } // if pulse has added tuples, add them to state\n\n\n    if (pulse.add.length) {\n      bits.add(pulse.add);\n    } // if pulse has modified tuples, create an index map\n\n\n    if (pulse.mod.length) {\n      modMap = {};\n\n      for (mods = pulse.mod, i = 0, n = mods.length; i < n; ++i) {\n        modMap[mods[i]._index] = 1;\n      }\n    } // re-initialize indices as needed, update curr bitmap\n\n\n    for (i = 0; i < m; ++i) {\n      f = fields[i];\n\n      if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n        key = f.fname;\n\n        if (!(add = adds[key])) {\n          indices[key] = index = SortedIndex();\n          adds[key] = add = index.insert(f, pulse.source, 0);\n        }\n\n        dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\n      }\n    } // visit each tuple\n    // if filter state changed, push index to add/rem\n    // else if in mod and passes a filter, push index to mod\n\n\n    for (i = 0, n = bits.data().length; i < n; ++i) {\n      if (remMap[i]) {\n        // skip if removed tuple\n        continue;\n      } else if (prev[i] !== curr[i]) {\n        // add if state changed\n        out.push(i);\n      } else if (modMap[i] && curr[i] !== all) {\n        // otherwise, pass mods through\n        mod.push(i);\n      }\n    }\n\n    bits.mask = (1 << m) - 1;\n    return output;\n  },\n\n  eval(_, pulse) {\n    const output = pulse.materialize().fork(),\n          m = this._dims.length;\n    let mask = 0;\n\n    if (pulse.rem.length) {\n      this.remove(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (_.modified('query') && !_.modified('fields')) {\n      mask |= this.update(_, pulse, output);\n    }\n\n    if (pulse.add.length) {\n      this.insert(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (pulse.mod.length) {\n      this.modify(pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    this.value.mask = mask;\n    return output;\n  },\n\n  insert(_, pulse, output) {\n    const tuples = pulse.add,\n          bits = this.value,\n          dims = this._dims,\n          indices = this._indices,\n          fields = _.fields,\n          adds = {},\n          out = output.add,\n          n = bits.size() + tuples.length,\n          m = dims.length;\n    let k = bits.size(),\n        j,\n        key,\n        add; // resize bitmaps and add tuples as needed\n\n    bits.resize(n, m);\n    bits.add(tuples);\n    const curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(); // add to dimensional indices\n\n    for (j = 0; j < m; ++j) {\n      key = fields[j].fname;\n      add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n      dims[j].onAdd(add, curr);\n    } // set previous filters, output if passes at least one filter\n\n\n    for (; k < n; ++k) {\n      prev[k] = all;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  modify(pulse, output) {\n    const out = output.mod,\n          bits = this.value,\n          curr = bits.curr(),\n          all = bits.all(),\n          tuples = pulse.mod;\n    let i, n, k;\n\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  remove(_, pulse, output) {\n    const indices = this._indices,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(),\n          map = {},\n          out = output.rem,\n          tuples = pulse.rem;\n    let i, n, k, f; // process tuples, output if passes at least one filter\n\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      map[k] = 1; // build index map\n\n      prev[k] = f = curr[k];\n      curr[k] = all;\n      if (f !== all) out.push(k);\n    } // remove from dimensional indices\n\n\n    for (k in indices) {\n      indices[k].remove(n, map);\n    }\n\n    this.reindex(pulse, n, map);\n    return map;\n  },\n\n  // reindex filters and indices after propagation completes\n  reindex(pulse, num, map) {\n    const indices = this._indices,\n          bits = this.value;\n    pulse.runAfter(() => {\n      const indexMap = bits.remove(num, map);\n\n      for (const key in indices) indices[key].reindex(indexMap);\n    });\n  },\n\n  update(_, pulse, output) {\n    const dims = this._dims,\n          query = _.query,\n          stamp = pulse.stamp,\n          m = dims.length;\n    let mask = 0,\n        i,\n        q; // survey how many queries have changed\n\n    output.filters = 0;\n\n    for (q = 0; q < m; ++q) {\n      if (_.modified('query', q)) {\n        i = q;\n        ++mask;\n      }\n    }\n\n    if (mask === 1) {\n      // only one query changed, use more efficient update\n      mask = dims[i].one;\n      this.incrementOne(dims[i], query[i], output.add, output.rem);\n    } else {\n      // multiple queries changed, perform full record keeping\n      for (q = 0, mask = 0; q < m; ++q) {\n        if (!_.modified('query', q)) continue;\n        mask |= dims[q].one;\n        this.incrementAll(dims[q], query[q], stamp, output.add);\n        output.rem = output.add; // duplicate add/rem for downstream resolve\n      }\n    }\n\n    return mask;\n  },\n\n  incrementAll(dim, query, stamp, out) {\n    const bits = this.value,\n          seen = bits.seen(),\n          curr = bits.curr(),\n          prev = bits.prev(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k; // Fast incremental update based on previous lo index.\n\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } // Fast incremental update based on previous hi index.\n\n\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    }\n\n    dim.range = query.slice();\n  },\n\n  incrementOne(dim, query, add, rem) {\n    const bits = this.value,\n          curr = bits.curr(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k; // Fast incremental update based on previous lo index.\n\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    } // Fast incremental update based on previous hi index.\n\n\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n\n    dim.range = query.slice();\n  }\n\n});\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\n\nfunction ResolveFilter(params) {\n  Transform.call(this, null, params);\n}\n\nResolveFilter.Definition = {\n  'type': 'ResolveFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'ignore',\n    'type': 'number',\n    'required': true,\n    'description': 'A bit mask indicating which filters to ignore.'\n  }, {\n    'name': 'filter',\n    'type': 'object',\n    'required': true,\n    'description': 'Per-tuple filter bitmaps from a CrossFilter transform.'\n  }]\n};\ninherits(ResolveFilter, Transform, {\n  transform(_, pulse) {\n    const ignore = ~(_.ignore || 0),\n          // bit mask where zeros -> dims to ignore\n    bitmap = _.filter,\n          mask = bitmap.mask; // exit early if no relevant filter changes\n\n    if ((mask & ignore) === 0) return pulse.StopPropagation;\n\n    const output = pulse.fork(pulse.ALL),\n          data = bitmap.data(),\n          curr = bitmap.curr(),\n          prev = bitmap.prev(),\n          pass = k => !(curr[k] & ignore) ? data[k] : null; // propagate all mod tuples that pass the filter\n\n\n    output.filter(output.MOD, pass); // determine add & rem tuples via filter functions\n    // for efficiency, we do *not* populate new arrays,\n    // instead we add filter functions applied downstream\n\n    if (!(mask & mask - 1)) {\n      // only one filter changed\n      output.filter(output.ADD, pass);\n      output.filter(output.REM, k => (curr[k] & ignore) === mask ? data[k] : null);\n    } else {\n      // multiple filters changed\n      output.filter(output.ADD, k => {\n        const c = curr[k] & ignore,\n              f = !c && c ^ prev[k] & ignore;\n        return f ? data[k] : null;\n      });\n      output.filter(output.REM, k => {\n        const c = curr[k] & ignore,\n              f = c && !(c ^ (c ^ prev[k] & ignore));\n        return f ? data[k] : null;\n      });\n    } // add filter to source data in case of reflow...\n\n\n    return output.filter(output.SOURCE, t => pass(t._index));\n  }\n\n});\nexport { CrossFilter as crossfilter, ResolveFilter as resolvefilter };","map":{"version":3,"names":["permute","bisectLeft","bisectRight","Transform","inherits","array8","n","Uint8Array","array16","Uint16Array","array32","Uint32Array","Bitmaps","width","data","seen","curr","array","prev","lengthen","length","add","i","j","t","_index","push","remove","num","map","copy","Array","reindex","size","reset","k","all","set","one","clear","resize","m","Math","max","constructor","Dimension","index","query","bit","zero","range","slice","bisect","onAdd","added","dim","value","idx","lo","hi","n1","SortedIndex","insert","key","base","n0","addi","addv","oldv","oldi","sort","merge","values","call","a","b","x","y","value0","index0","value1","index1","i0","i1","CrossFilter","params","_indices","_dims","Definition","transform","_","pulse","init","modified","fields","some","f","reinit","eval","indices","dims","fname","output","materialize","fork","bits","out","rem","mod","adds","mods","remMap","modMap","source","mask","update","modify","tuples","runAfter","indexMap","stamp","q","filters","incrementOne","incrementAll","old","lo1","hi1","lo0","hi0","min","ResolveFilter","ignore","bitmap","filter","StopPropagation","ALL","pass","MOD","ADD","REM","c","SOURCE","crossfilter","resolvefilter"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-crossfilter/build/vega-crossfilter.module.js"],"sourcesContent":["import { permute, bisectLeft, bisectRight } from 'd3-array';\nimport { Transform } from 'vega-dataflow';\nimport { inherits } from 'vega-util';\n\nconst array8 = n => new Uint8Array(n);\nconst array16 = n => new Uint16Array(n);\nconst array32 = n => new Uint32Array(n);\n\n/**\n * Maintains CrossFilter state.\n */\n\nfunction Bitmaps() {\n  let width = 8,\n      data = [],\n      seen = array32(0),\n      curr = array(0, width),\n      prev = array(0, width);\n  return {\n    data: () => data,\n    seen: () => seen = lengthen(seen, data.length),\n\n    add(array) {\n      for (let i = 0, j = data.length, n = array.length, t; i < n; ++i) {\n        t = array[i];\n        t._index = j++;\n        data.push(t);\n      }\n    },\n\n    remove(num, map) {\n      // map: index -> boolean (true => remove)\n      const n = data.length,\n            copy = Array(n - num),\n            reindex = data; // reuse old data array for index map\n\n      let t, i, j; // seek forward to first removal\n\n      for (i = 0; !map[i] && i < n; ++i) {\n        copy[i] = data[i];\n        reindex[i] = i;\n      } // condense arrays\n\n\n      for (j = i; i < n; ++i) {\n        t = data[i];\n\n        if (!map[i]) {\n          reindex[i] = j;\n          curr[j] = curr[i];\n          prev[j] = prev[i];\n          copy[j] = t;\n          t._index = j++;\n        } else {\n          reindex[i] = -1;\n        }\n\n        curr[i] = 0; // clear unused bits\n      }\n\n      data = copy;\n      return reindex;\n    },\n\n    size: () => data.length,\n    curr: () => curr,\n    prev: () => prev,\n    reset: k => prev[k] = curr[k],\n    all: () => width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff,\n\n    set(k, one) {\n      curr[k] |= one;\n    },\n\n    clear(k, one) {\n      curr[k] &= ~one;\n    },\n\n    resize(n, m) {\n      const k = curr.length;\n\n      if (n > k || m > width) {\n        width = Math.max(m, width);\n        curr = array(n, width, curr);\n        prev = array(n, width);\n      }\n    }\n\n  };\n}\n\nfunction lengthen(array, length, copy) {\n  if (array.length >= length) return array;\n  copy = copy || new array.constructor(length);\n  copy.set(array);\n  return copy;\n}\n\nfunction array(n, m, array) {\n  const copy = (m < 0x101 ? array8 : m < 0x10001 ? array16 : array32)(n);\n  if (array) copy.set(array);\n  return copy;\n}\n\nfunction Dimension (index, i, query) {\n  const bit = 1 << i;\n  return {\n    one: bit,\n    zero: ~bit,\n    range: query.slice(),\n    bisect: index.bisect,\n    index: index.index,\n    size: index.size,\n\n    onAdd(added, curr) {\n      const dim = this,\n            range = dim.bisect(dim.range, added.value),\n            idx = added.index,\n            lo = range[0],\n            hi = range[1],\n            n1 = idx.length;\n      let i;\n\n      for (i = 0; i < lo; ++i) curr[idx[i]] |= bit;\n\n      for (i = hi; i < n1; ++i) curr[idx[i]] |= bit;\n\n      return dim;\n    }\n\n  };\n}\n\n/**\n * Maintains a list of values, sorted by key.\n */\n\nfunction SortedIndex() {\n  let index = array32(0),\n      value = [],\n      size = 0;\n\n  function insert(key, data, base) {\n    if (!data.length) return [];\n    const n0 = size,\n          n1 = data.length,\n          addi = array32(n1);\n    let addv = Array(n1),\n        oldv,\n        oldi,\n        i;\n\n    for (i = 0; i < n1; ++i) {\n      addv[i] = key(data[i]);\n      addi[i] = i;\n    }\n\n    addv = sort(addv, addi);\n\n    if (n0) {\n      oldv = value;\n      oldi = index;\n      value = Array(n0 + n1);\n      index = array32(n0 + n1);\n      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);\n    } else {\n      if (base > 0) for (i = 0; i < n1; ++i) {\n        addi[i] += base;\n      }\n      value = addv;\n      index = addi;\n    }\n\n    size = n0 + n1;\n    return {\n      index: addi,\n      value: addv\n    };\n  }\n\n  function remove(num, map) {\n    // map: index -> remove\n    const n = size;\n    let idx, i, j; // seek forward to first removal\n\n    for (i = 0; !map[index[i]] && i < n; ++i); // condense index and value arrays\n\n\n    for (j = i; i < n; ++i) {\n      if (!map[idx = index[i]]) {\n        index[j] = idx;\n        value[j] = value[i];\n        ++j;\n      }\n    }\n\n    size = n - num;\n  }\n\n  function reindex(map) {\n    for (let i = 0, n = size; i < n; ++i) {\n      index[i] = map[index[i]];\n    }\n  }\n\n  function bisect(range, array) {\n    let n;\n\n    if (array) {\n      n = array.length;\n    } else {\n      array = value;\n      n = size;\n    }\n\n    return [bisectLeft(array, range[0], 0, n), bisectRight(array, range[1], 0, n)];\n  }\n\n  return {\n    insert: insert,\n    remove: remove,\n    bisect: bisect,\n    reindex: reindex,\n    index: () => index,\n    size: () => size\n  };\n}\n\nfunction sort(values, index) {\n  values.sort.call(index, (a, b) => {\n    const x = values[a],\n          y = values[b];\n    return x < y ? -1 : x > y ? 1 : 0;\n  });\n  return permute(values, index);\n}\n\nfunction merge(base, value0, index0, n0, value1, index1, n1, value, index) {\n  let i0 = 0,\n      i1 = 0,\n      i;\n\n  for (i = 0; i0 < n0 && i1 < n1; ++i) {\n    if (value0[i0] < value1[i1]) {\n      value[i] = value0[i0];\n      index[i] = index0[i0++];\n    } else {\n      value[i] = value1[i1];\n      index[i] = index1[i1++] + base;\n    }\n  }\n\n  for (; i0 < n0; ++i0, ++i) {\n    value[i] = value0[i0];\n    index[i] = index0[i0];\n  }\n\n  for (; i1 < n1; ++i1, ++i) {\n    value[i] = value1[i1];\n    index[i] = index1[i1] + base;\n  }\n}\n\n/**\n * An indexed multi-dimensional filter.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n * @param {Array} params.query - An array of per-dimension range queries.\n */\n\nfunction CrossFilter(params) {\n  Transform.call(this, Bitmaps(), params);\n  this._indices = null;\n  this._dims = null;\n}\nCrossFilter.Definition = {\n  'type': 'CrossFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true\n  }, {\n    'name': 'query',\n    'type': 'array',\n    'array': true,\n    'required': true,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }]\n};\ninherits(CrossFilter, Transform, {\n  transform(_, pulse) {\n    if (!this._dims) {\n      return this.init(_, pulse);\n    } else {\n      var init = _.modified('fields') || _.fields.some(f => pulse.modified(f.fields));\n\n      return init ? this.reinit(_, pulse) : this.eval(_, pulse);\n    }\n  },\n\n  init(_, pulse) {\n    const fields = _.fields,\n          query = _.query,\n          indices = this._indices = {},\n          dims = this._dims = [],\n          m = query.length;\n    let i = 0,\n        key,\n        index; // instantiate indices and dimensions\n\n    for (; i < m; ++i) {\n      key = fields[i].fname;\n      index = indices[key] || (indices[key] = SortedIndex());\n      dims.push(Dimension(index, i, query[i]));\n    }\n\n    return this.eval(_, pulse);\n  },\n\n  reinit(_, pulse) {\n    const output = pulse.materialize().fork(),\n          fields = _.fields,\n          query = _.query,\n          indices = this._indices,\n          dims = this._dims,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(),\n          out = output.rem = output.add,\n          mod = output.mod,\n          m = query.length,\n          adds = {};\n    let add, index, key, mods, remMap, modMap, i, n, f; // set prev to current state\n\n    prev.set(curr); // if pulse has remove tuples, process them first\n\n    if (pulse.rem.length) {\n      remMap = this.remove(_, pulse, output);\n    } // if pulse has added tuples, add them to state\n\n\n    if (pulse.add.length) {\n      bits.add(pulse.add);\n    } // if pulse has modified tuples, create an index map\n\n\n    if (pulse.mod.length) {\n      modMap = {};\n\n      for (mods = pulse.mod, i = 0, n = mods.length; i < n; ++i) {\n        modMap[mods[i]._index] = 1;\n      }\n    } // re-initialize indices as needed, update curr bitmap\n\n\n    for (i = 0; i < m; ++i) {\n      f = fields[i];\n\n      if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n        key = f.fname;\n\n        if (!(add = adds[key])) {\n          indices[key] = index = SortedIndex();\n          adds[key] = add = index.insert(f, pulse.source, 0);\n        }\n\n        dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\n      }\n    } // visit each tuple\n    // if filter state changed, push index to add/rem\n    // else if in mod and passes a filter, push index to mod\n\n\n    for (i = 0, n = bits.data().length; i < n; ++i) {\n      if (remMap[i]) {\n        // skip if removed tuple\n        continue;\n      } else if (prev[i] !== curr[i]) {\n        // add if state changed\n        out.push(i);\n      } else if (modMap[i] && curr[i] !== all) {\n        // otherwise, pass mods through\n        mod.push(i);\n      }\n    }\n\n    bits.mask = (1 << m) - 1;\n    return output;\n  },\n\n  eval(_, pulse) {\n    const output = pulse.materialize().fork(),\n          m = this._dims.length;\n    let mask = 0;\n\n    if (pulse.rem.length) {\n      this.remove(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (_.modified('query') && !_.modified('fields')) {\n      mask |= this.update(_, pulse, output);\n    }\n\n    if (pulse.add.length) {\n      this.insert(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (pulse.mod.length) {\n      this.modify(pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    this.value.mask = mask;\n    return output;\n  },\n\n  insert(_, pulse, output) {\n    const tuples = pulse.add,\n          bits = this.value,\n          dims = this._dims,\n          indices = this._indices,\n          fields = _.fields,\n          adds = {},\n          out = output.add,\n          n = bits.size() + tuples.length,\n          m = dims.length;\n    let k = bits.size(),\n        j,\n        key,\n        add; // resize bitmaps and add tuples as needed\n\n    bits.resize(n, m);\n    bits.add(tuples);\n    const curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(); // add to dimensional indices\n\n    for (j = 0; j < m; ++j) {\n      key = fields[j].fname;\n      add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n      dims[j].onAdd(add, curr);\n    } // set previous filters, output if passes at least one filter\n\n\n    for (; k < n; ++k) {\n      prev[k] = all;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  modify(pulse, output) {\n    const out = output.mod,\n          bits = this.value,\n          curr = bits.curr(),\n          all = bits.all(),\n          tuples = pulse.mod;\n    let i, n, k;\n\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  remove(_, pulse, output) {\n    const indices = this._indices,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(),\n          map = {},\n          out = output.rem,\n          tuples = pulse.rem;\n    let i, n, k, f; // process tuples, output if passes at least one filter\n\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      map[k] = 1; // build index map\n\n      prev[k] = f = curr[k];\n      curr[k] = all;\n      if (f !== all) out.push(k);\n    } // remove from dimensional indices\n\n\n    for (k in indices) {\n      indices[k].remove(n, map);\n    }\n\n    this.reindex(pulse, n, map);\n    return map;\n  },\n\n  // reindex filters and indices after propagation completes\n  reindex(pulse, num, map) {\n    const indices = this._indices,\n          bits = this.value;\n    pulse.runAfter(() => {\n      const indexMap = bits.remove(num, map);\n\n      for (const key in indices) indices[key].reindex(indexMap);\n    });\n  },\n\n  update(_, pulse, output) {\n    const dims = this._dims,\n          query = _.query,\n          stamp = pulse.stamp,\n          m = dims.length;\n    let mask = 0,\n        i,\n        q; // survey how many queries have changed\n\n    output.filters = 0;\n\n    for (q = 0; q < m; ++q) {\n      if (_.modified('query', q)) {\n        i = q;\n        ++mask;\n      }\n    }\n\n    if (mask === 1) {\n      // only one query changed, use more efficient update\n      mask = dims[i].one;\n      this.incrementOne(dims[i], query[i], output.add, output.rem);\n    } else {\n      // multiple queries changed, perform full record keeping\n      for (q = 0, mask = 0; q < m; ++q) {\n        if (!_.modified('query', q)) continue;\n        mask |= dims[q].one;\n        this.incrementAll(dims[q], query[q], stamp, output.add);\n        output.rem = output.add; // duplicate add/rem for downstream resolve\n      }\n    }\n\n    return mask;\n  },\n\n  incrementAll(dim, query, stamp, out) {\n    const bits = this.value,\n          seen = bits.seen(),\n          curr = bits.curr(),\n          prev = bits.prev(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k; // Fast incremental update based on previous lo index.\n\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } // Fast incremental update based on previous hi index.\n\n\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    }\n\n    dim.range = query.slice();\n  },\n\n  incrementOne(dim, query, add, rem) {\n    const bits = this.value,\n          curr = bits.curr(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k; // Fast incremental update based on previous lo index.\n\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    } // Fast incremental update based on previous hi index.\n\n\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n\n    dim.range = query.slice();\n  }\n\n});\n\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\n\nfunction ResolveFilter(params) {\n  Transform.call(this, null, params);\n}\nResolveFilter.Definition = {\n  'type': 'ResolveFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'ignore',\n    'type': 'number',\n    'required': true,\n    'description': 'A bit mask indicating which filters to ignore.'\n  }, {\n    'name': 'filter',\n    'type': 'object',\n    'required': true,\n    'description': 'Per-tuple filter bitmaps from a CrossFilter transform.'\n  }]\n};\ninherits(ResolveFilter, Transform, {\n  transform(_, pulse) {\n    const ignore = ~(_.ignore || 0),\n          // bit mask where zeros -> dims to ignore\n    bitmap = _.filter,\n          mask = bitmap.mask; // exit early if no relevant filter changes\n\n    if ((mask & ignore) === 0) return pulse.StopPropagation;\n\n    const output = pulse.fork(pulse.ALL),\n          data = bitmap.data(),\n          curr = bitmap.curr(),\n          prev = bitmap.prev(),\n          pass = k => !(curr[k] & ignore) ? data[k] : null; // propagate all mod tuples that pass the filter\n\n\n    output.filter(output.MOD, pass); // determine add & rem tuples via filter functions\n    // for efficiency, we do *not* populate new arrays,\n    // instead we add filter functions applied downstream\n\n    if (!(mask & mask - 1)) {\n      // only one filter changed\n      output.filter(output.ADD, pass);\n      output.filter(output.REM, k => (curr[k] & ignore) === mask ? data[k] : null);\n    } else {\n      // multiple filters changed\n      output.filter(output.ADD, k => {\n        const c = curr[k] & ignore,\n              f = !c && c ^ prev[k] & ignore;\n        return f ? data[k] : null;\n      });\n      output.filter(output.REM, k => {\n        const c = curr[k] & ignore,\n              f = c && !(c ^ (c ^ prev[k] & ignore));\n        return f ? data[k] : null;\n      });\n    } // add filter to source data in case of reflow...\n\n\n    return output.filter(output.SOURCE, t => pass(t._index));\n  }\n\n});\n\nexport { CrossFilter as crossfilter, ResolveFilter as resolvefilter };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}