{"ast":null,"code":"import { isBinned, isBinning } from '../../bin';\nimport { isContinuousFieldOrDatumDef, isFieldDef, isNumericDataDef } from '../../channeldef';\nimport { isAggregate } from '../../encoding';\nimport { replaceExprRef } from '../../expr';\nimport * as log from '../../log';\nimport { AREA, BAR, BAR_CORNER_RADIUS_INDEX as BAR_CORNER_RADIUS_END_INDEX, CIRCLE, IMAGE, LINE, POINT, RECT, RULE, SQUARE, TEXT, TICK } from '../../mark';\nimport { QUANTITATIVE, TEMPORAL } from '../../type';\nimport { contains, getFirstDefined } from '../../util';\nimport { getMarkConfig, getMarkPropOrConfig } from '../common';\nexport function initMarkdef(originalMarkDef, encoding, config) {\n  // FIXME: markDef expects that exprRefs are replaced recursively but replaceExprRef only replaces the top level\n  const markDef = replaceExprRef(originalMarkDef); // set orient, which can be overridden by rules as sometimes the specified orient is invalid.\n\n  const specifiedOrient = getMarkPropOrConfig('orient', markDef, config);\n  markDef.orient = orient(markDef.type, encoding, specifiedOrient);\n\n  if (specifiedOrient !== undefined && specifiedOrient !== markDef.orient) {\n    log.warn(log.message.orientOverridden(markDef.orient, specifiedOrient));\n  }\n\n  if (markDef.type === 'bar' && markDef.orient) {\n    const cornerRadiusEnd = getMarkPropOrConfig('cornerRadiusEnd', markDef, config);\n\n    if (cornerRadiusEnd !== undefined) {\n      const newProps = markDef.orient === 'horizontal' && encoding.x2 || markDef.orient === 'vertical' && encoding.y2 ? ['cornerRadius'] : BAR_CORNER_RADIUS_END_INDEX[markDef.orient];\n\n      for (const newProp of newProps) {\n        markDef[newProp] = cornerRadiusEnd;\n      }\n\n      if (markDef.cornerRadiusEnd !== undefined) {\n        delete markDef.cornerRadiusEnd; // no need to keep the original cap cornerRadius\n      }\n    }\n  } // set opacity and filled if not specified in mark config\n\n\n  const specifiedOpacity = getMarkPropOrConfig('opacity', markDef, config);\n\n  if (specifiedOpacity === undefined) {\n    markDef.opacity = opacity(markDef.type, encoding);\n  } // set cursor, which should be pointer if href channel is present unless otherwise specified\n\n\n  const specifiedCursor = getMarkPropOrConfig('cursor', markDef, config);\n\n  if (specifiedCursor === undefined) {\n    markDef.cursor = cursor(markDef, encoding, config);\n  }\n\n  return markDef;\n}\n\nfunction cursor(markDef, encoding, config) {\n  if (encoding.href || markDef.href || getMarkPropOrConfig('href', markDef, config)) {\n    return 'pointer';\n  }\n\n  return markDef.cursor;\n}\n\nfunction opacity(mark, encoding) {\n  if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n    // point-based marks\n    if (!isAggregate(encoding)) {\n      return 0.7;\n    }\n  }\n\n  return undefined;\n}\n\nexport function defaultFilled(markDef, config, _ref) {\n  let {\n    graticule\n  } = _ref;\n\n  if (graticule) {\n    return false;\n  }\n\n  const filledConfig = getMarkConfig('filled', markDef, config);\n  const mark = markDef.type;\n  return getFirstDefined(filledConfig, mark !== POINT && mark !== LINE && mark !== RULE);\n}\n\nfunction orient(mark, encoding, specifiedOrient) {\n  switch (mark) {\n    case POINT:\n    case CIRCLE:\n    case SQUARE:\n    case TEXT:\n    case RECT:\n    case IMAGE:\n      // orient is meaningless for these marks.\n      return undefined;\n  }\n\n  const {\n    x,\n    y,\n    x2,\n    y2\n  } = encoding;\n\n  switch (mark) {\n    case BAR:\n      if (isFieldDef(x) && (isBinned(x.bin) || isFieldDef(y) && y.aggregate && !x.aggregate)) {\n        return 'vertical';\n      }\n\n      if (isFieldDef(y) && (isBinned(y.bin) || isFieldDef(x) && x.aggregate && !y.aggregate)) {\n        return 'horizontal';\n      }\n\n      if (y2 || x2) {\n        // Ranged bar does not always have clear orientation, so we allow overriding\n        if (specifiedOrient) {\n          return specifiedOrient;\n        } // If y is range and x is non-range, non-bin Q, y is likely a prebinned field\n\n\n        if (!x2) {\n          if (isFieldDef(x) && x.type === QUANTITATIVE && !isBinning(x.bin) || isNumericDataDef(x)) {\n            return 'horizontal';\n          }\n        } // If x is range and y is non-range, non-bin Q, x is likely a prebinned field\n\n\n        if (!y2) {\n          if (isFieldDef(y) && y.type === QUANTITATIVE && !isBinning(y.bin) || isNumericDataDef(y)) {\n            return 'vertical';\n          }\n        }\n      }\n\n    // falls through\n\n    case RULE:\n      // return undefined for line segment rule and bar with both axis ranged\n      // we have to ignore the case that the data are already binned\n      if (x2 && !(isFieldDef(x) && isBinned(x.bin)) && y2 && !(isFieldDef(y) && isBinned(y.bin))) {\n        return undefined;\n      }\n\n    // falls through\n\n    case AREA:\n      // If there are range for both x and y, y (vertical) has higher precedence.\n      if (y2) {\n        if (isFieldDef(y) && isBinned(y.bin)) {\n          return 'horizontal';\n        } else {\n          return 'vertical';\n        }\n      } else if (x2) {\n        if (isFieldDef(x) && isBinned(x.bin)) {\n          return 'vertical';\n        } else {\n          return 'horizontal';\n        }\n      } else if (mark === RULE) {\n        if (x && !y) {\n          return 'vertical';\n        } else if (y && !x) {\n          return 'horizontal';\n        }\n      }\n\n    // falls through\n\n    case LINE:\n    case TICK:\n      {\n        // Tick is opposite to bar, line, area and never have ranged mark.\n        const xIsContinuous = isContinuousFieldOrDatumDef(x);\n        const yIsContinuous = isContinuousFieldOrDatumDef(y);\n\n        if (specifiedOrient) {\n          return specifiedOrient;\n        } else if (xIsContinuous && !yIsContinuous) {\n          return mark !== 'tick' ? 'horizontal' : 'vertical';\n        } else if (!xIsContinuous && yIsContinuous) {\n          return mark !== 'tick' ? 'vertical' : 'horizontal';\n        } else if (xIsContinuous && yIsContinuous) {\n          const xDef = x; // we can cast here since they are surely fieldDef\n\n          const yDef = y;\n          const xIsTemporal = xDef.type === TEMPORAL;\n          const yIsTemporal = yDef.type === TEMPORAL; // temporal without timeUnit is considered continuous, but better serves as dimension\n\n          if (xIsTemporal && !yIsTemporal) {\n            return mark !== 'tick' ? 'vertical' : 'horizontal';\n          } else if (!xIsTemporal && yIsTemporal) {\n            return mark !== 'tick' ? 'horizontal' : 'vertical';\n          }\n\n          if (!xDef.aggregate && yDef.aggregate) {\n            return mark !== 'tick' ? 'vertical' : 'horizontal';\n          } else if (xDef.aggregate && !yDef.aggregate) {\n            return mark !== 'tick' ? 'horizontal' : 'vertical';\n          }\n\n          return 'vertical';\n        } else {\n          return undefined;\n        }\n      }\n  }\n\n  return 'vertical';\n}","map":{"version":3,"mappings":"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","names":["isBinned","isBinning","isContinuousFieldOrDatumDef","isFieldDef","isNumericDataDef","isAggregate","replaceExprRef","log","AREA","BAR","BAR_CORNER_RADIUS_INDEX","BAR_CORNER_RADIUS_END_INDEX","CIRCLE","IMAGE","LINE","POINT","RECT","RULE","SQUARE","TEXT","TICK","QUANTITATIVE","TEMPORAL","contains","getFirstDefined","getMarkConfig","getMarkPropOrConfig","initMarkdef","originalMarkDef","encoding","config","markDef","specifiedOrient","orient","type","undefined","warn","message","orientOverridden","cornerRadiusEnd","newProps","x2","y2","newProp","specifiedOpacity","opacity","specifiedCursor","cursor","href","mark","defaultFilled","graticule","filledConfig","x","y","bin","aggregate","xIsContinuous","yIsContinuous","xDef","yDef","xIsTemporal","yIsTemporal"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/mark/init.ts"],"sourcesContent":["import {Orientation, SignalRef} from 'vega';\nimport {isBinned, isBinning} from '../../bin';\nimport {isContinuousFieldOrDatumDef, isFieldDef, isNumericDataDef, TypedFieldDef} from '../../channeldef';\nimport {Config} from '../../config';\nimport {Encoding, isAggregate} from '../../encoding';\nimport {replaceExprRef} from '../../expr';\nimport * as log from '../../log';\nimport {\n  AREA,\n  BAR,\n  BAR_CORNER_RADIUS_INDEX as BAR_CORNER_RADIUS_END_INDEX,\n  CIRCLE,\n  IMAGE,\n  LINE,\n  Mark,\n  MarkDef,\n  POINT,\n  RECT,\n  RULE,\n  SQUARE,\n  TEXT,\n  TICK\n} from '../../mark';\nimport {QUANTITATIVE, TEMPORAL} from '../../type';\nimport {contains, getFirstDefined} from '../../util';\nimport {getMarkConfig, getMarkPropOrConfig} from '../common';\n\nexport function initMarkdef(originalMarkDef: MarkDef, encoding: Encoding<string>, config: Config<SignalRef>) {\n  // FIXME: markDef expects that exprRefs are replaced recursively but replaceExprRef only replaces the top level\n  const markDef: MarkDef<Mark, SignalRef> = replaceExprRef(originalMarkDef) as any;\n\n  // set orient, which can be overridden by rules as sometimes the specified orient is invalid.\n  const specifiedOrient = getMarkPropOrConfig('orient', markDef, config);\n  markDef.orient = orient(markDef.type, encoding, specifiedOrient);\n  if (specifiedOrient !== undefined && specifiedOrient !== markDef.orient) {\n    log.warn(log.message.orientOverridden(markDef.orient, specifiedOrient));\n  }\n\n  if (markDef.type === 'bar' && markDef.orient) {\n    const cornerRadiusEnd = getMarkPropOrConfig('cornerRadiusEnd', markDef, config);\n    if (cornerRadiusEnd !== undefined) {\n      const newProps =\n        (markDef.orient === 'horizontal' && encoding.x2) || (markDef.orient === 'vertical' && encoding.y2)\n          ? ['cornerRadius']\n          : BAR_CORNER_RADIUS_END_INDEX[markDef.orient];\n\n      for (const newProp of newProps) {\n        markDef[newProp] = cornerRadiusEnd;\n      }\n\n      if (markDef.cornerRadiusEnd !== undefined) {\n        delete markDef.cornerRadiusEnd; // no need to keep the original cap cornerRadius\n      }\n    }\n  }\n\n  // set opacity and filled if not specified in mark config\n  const specifiedOpacity = getMarkPropOrConfig('opacity', markDef, config);\n  if (specifiedOpacity === undefined) {\n    markDef.opacity = opacity(markDef.type, encoding);\n  }\n\n  // set cursor, which should be pointer if href channel is present unless otherwise specified\n  const specifiedCursor = getMarkPropOrConfig('cursor', markDef, config);\n  if (specifiedCursor === undefined) {\n    markDef.cursor = cursor(markDef, encoding, config);\n  }\n\n  return markDef;\n}\n\nfunction cursor(markDef: MarkDef<Mark, SignalRef>, encoding: Encoding<string>, config: Config<SignalRef>) {\n  if (encoding.href || markDef.href || getMarkPropOrConfig('href', markDef, config)) {\n    return 'pointer';\n  }\n  return markDef.cursor;\n}\n\nfunction opacity(mark: Mark, encoding: Encoding<string>) {\n  if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n    // point-based marks\n    if (!isAggregate(encoding)) {\n      return 0.7;\n    }\n  }\n  return undefined;\n}\n\nexport function defaultFilled(markDef: MarkDef, config: Config<SignalRef>, {graticule}: {graticule: boolean}) {\n  if (graticule) {\n    return false;\n  }\n  const filledConfig = getMarkConfig('filled', markDef, config);\n  const mark = markDef.type;\n  return getFirstDefined(filledConfig, mark !== POINT && mark !== LINE && mark !== RULE);\n}\n\nfunction orient(mark: Mark, encoding: Encoding<string>, specifiedOrient: Orientation): Orientation {\n  switch (mark) {\n    case POINT:\n    case CIRCLE:\n    case SQUARE:\n    case TEXT:\n    case RECT:\n    case IMAGE:\n      // orient is meaningless for these marks.\n      return undefined;\n  }\n\n  const {x, y, x2, y2} = encoding;\n\n  switch (mark) {\n    case BAR:\n      if (isFieldDef(x) && (isBinned(x.bin) || (isFieldDef(y) && y.aggregate && !x.aggregate))) {\n        return 'vertical';\n      }\n      if (isFieldDef(y) && (isBinned(y.bin) || (isFieldDef(x) && x.aggregate && !y.aggregate))) {\n        return 'horizontal';\n      }\n      if (y2 || x2) {\n        // Ranged bar does not always have clear orientation, so we allow overriding\n        if (specifiedOrient) {\n          return specifiedOrient;\n        }\n\n        // If y is range and x is non-range, non-bin Q, y is likely a prebinned field\n        if (!x2) {\n          if ((isFieldDef(x) && x.type === QUANTITATIVE && !isBinning(x.bin)) || isNumericDataDef(x)) {\n            return 'horizontal';\n          }\n        }\n\n        // If x is range and y is non-range, non-bin Q, x is likely a prebinned field\n        if (!y2) {\n          if ((isFieldDef(y) && y.type === QUANTITATIVE && !isBinning(y.bin)) || isNumericDataDef(y)) {\n            return 'vertical';\n          }\n        }\n      }\n\n    // falls through\n    case RULE:\n      // return undefined for line segment rule and bar with both axis ranged\n      // we have to ignore the case that the data are already binned\n      if (x2 && !(isFieldDef(x) && isBinned(x.bin)) && y2 && !(isFieldDef(y) && isBinned(y.bin))) {\n        return undefined;\n      }\n\n    // falls through\n    case AREA:\n      // If there are range for both x and y, y (vertical) has higher precedence.\n      if (y2) {\n        if (isFieldDef(y) && isBinned(y.bin)) {\n          return 'horizontal';\n        } else {\n          return 'vertical';\n        }\n      } else if (x2) {\n        if (isFieldDef(x) && isBinned(x.bin)) {\n          return 'vertical';\n        } else {\n          return 'horizontal';\n        }\n      } else if (mark === RULE) {\n        if (x && !y) {\n          return 'vertical';\n        } else if (y && !x) {\n          return 'horizontal';\n        }\n      }\n\n    // falls through\n    case LINE:\n    case TICK: {\n      // Tick is opposite to bar, line, area and never have ranged mark.\n      const xIsContinuous = isContinuousFieldOrDatumDef(x);\n      const yIsContinuous = isContinuousFieldOrDatumDef(y);\n\n      if (specifiedOrient) {\n        return specifiedOrient;\n      } else if (xIsContinuous && !yIsContinuous) {\n        return mark !== 'tick' ? 'horizontal' : 'vertical';\n      } else if (!xIsContinuous && yIsContinuous) {\n        return mark !== 'tick' ? 'vertical' : 'horizontal';\n      } else if (xIsContinuous && yIsContinuous) {\n        const xDef = x as TypedFieldDef<string>; // we can cast here since they are surely fieldDef\n        const yDef = y as TypedFieldDef<string>;\n\n        const xIsTemporal = xDef.type === TEMPORAL;\n        const yIsTemporal = yDef.type === TEMPORAL;\n\n        // temporal without timeUnit is considered continuous, but better serves as dimension\n        if (xIsTemporal && !yIsTemporal) {\n          return mark !== 'tick' ? 'vertical' : 'horizontal';\n        } else if (!xIsTemporal && yIsTemporal) {\n          return mark !== 'tick' ? 'horizontal' : 'vertical';\n        }\n\n        if (!xDef.aggregate && yDef.aggregate) {\n          return mark !== 'tick' ? 'vertical' : 'horizontal';\n        } else if (xDef.aggregate && !yDef.aggregate) {\n          return mark !== 'tick' ? 'horizontal' : 'vertical';\n        }\n        return 'vertical';\n      } else {\n        return undefined;\n      }\n    }\n  }\n  return 'vertical';\n}\n"]},"metadata":{},"sourceType":"module"}