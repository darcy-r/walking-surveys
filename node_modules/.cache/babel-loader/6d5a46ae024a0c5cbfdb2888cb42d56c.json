{"ast":null,"code":"import { isBoolean, isObject } from 'vega-util';\nimport { COLOR, COLUMN, FILL, FILLOPACITY, OPACITY, ROW, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH } from './channel';\nimport { normalizeBin } from './channeldef';\nimport { entries, keys, varName } from './util';\n/**\n * Create a key for the bin configuration. Not for prebinned bin.\n */\n\nexport function binToString(bin) {\n  if (isBoolean(bin)) {\n    bin = normalizeBin(bin, undefined);\n  }\n\n  return 'bin' + keys(bin).map(p => isParameterExtent(bin[p]) ? varName(`_${p}_${entries(bin[p])}`) : varName(`_${p}_${bin[p]}`)).join('');\n}\n/**\n * Vega-Lite should bin the data.\n */\n\nexport function isBinning(bin) {\n  return bin === true || isBinParams(bin) && !bin.binned;\n}\n/**\n * The data is already binned and so Vega-Lite should not bin it again.\n */\n\nexport function isBinned(bin) {\n  return bin === 'binned' || isBinParams(bin) && bin.binned === true;\n}\nexport function isBinParams(bin) {\n  return isObject(bin);\n}\nexport function isParameterExtent(extent) {\n  return extent === null || extent === void 0 ? void 0 : extent['param'];\n}\nexport function autoMaxBins(channel) {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case SIZE:\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY: // Facets and Size shouldn't have too many bins\n    // We choose 6 like shape to simplify the rule [falls through]\n\n    case SHAPE:\n      return 6;\n    // Vega's \"shape\" has 6 distinct values\n\n    case STROKEDASH:\n      return 4;\n    // We only provide 5 different stroke dash values (but 4 is more effective)\n\n    default:\n      return 10;\n  }\n}","map":{"version":3,"mappings":"AAAA,SAAQA,SAAR,EAAmBC,QAAnB,QAAkC,WAAlC;AACA,SACEC,KADF,EAEEC,MAFF,EAIEC,IAJF,EAKEC,WALF,EAMEC,OANF,EAOEC,GAPF,EAQEC,KARF,EASEC,IATF,EAUEC,MAVF,EAWEC,UAXF,EAYEC,aAZF,EAaEC,WAbF,QAcO,WAdP;AAeA,SAAQC,YAAR,QAA2B,cAA3B;AAEA,SAAQC,OAAR,EAAiBC,IAAjB,EAAuBC,OAAvB,QAAqC,QAArC;AA0EA;;;;AAGA,OAAM,SAAUC,WAAV,CAAsBC,GAAtB,EAA2C;EAC/C,IAAInB,SAAS,CAACmB,GAAD,CAAb,EAAoB;IAClBA,GAAG,GAAGL,YAAY,CAACK,GAAD,EAAMC,SAAN,CAAlB;EACD;;EACD,OACE,QACAJ,IAAI,CAACG,GAAD,CAAJ,CACGE,GADH,CACOC,CAAC,IAAKC,iBAAiB,CAACJ,GAAG,CAACG,CAAD,CAAJ,CAAjB,GAA4BL,OAAO,CAAC,IAAIK,CAAC,IAAIP,OAAO,CAACI,GAAG,CAACG,CAAD,CAAJ,CAAQ,EAAzB,CAAnC,GAAkEL,OAAO,CAAC,IAAIK,CAAC,IAAIH,GAAG,CAACG,CAAD,CAAG,EAAhB,CADtF,EAEGE,IAFH,CAEQ,EAFR,CAFF;AAMD;AAED;;;;AAGA,OAAM,SAAUC,SAAV,CAAoBN,GAApB,EAAuD;EAC3D,OAAOA,GAAG,KAAK,IAAR,IAAiBO,WAAW,CAACP,GAAD,CAAX,IAAoB,CAACA,GAAG,CAACQ,MAAjD;AACD;AAED;;;;AAGA,OAAM,SAAUC,QAAV,CAAmBT,GAAnB,EAAsD;EAC1D,OAAOA,GAAG,KAAK,QAAR,IAAqBO,WAAW,CAACP,GAAD,CAAX,IAAoBA,GAAG,CAACQ,MAAJ,KAAe,IAA/D;AACD;AAED,OAAM,SAAUD,WAAV,CAAsBP,GAAtB,EAAyD;EAC7D,OAAOlB,QAAQ,CAACkB,GAAD,CAAf;AACD;AAED,OAAM,SAAUI,iBAAV,CAA4BM,MAA5B,EAA6C;EACjD,OAAOA,MAAM,SAAN,UAAM,WAAN,GAAM,MAAN,SAAM,CAAG,OAAH,CAAb;AACD;AAED,OAAM,SAAUC,WAAV,CAAsBC,OAAtB,EAA+C;EACnD,QAAQA,OAAR;IACE,KAAKxB,GAAL;IACA,KAAKJ,MAAL;IACA,KAAKM,IAAL;IACA,KAAKP,KAAL;IACA,KAAKE,IAAL;IACA,KAAKM,MAAL;IACA,KAAKG,WAAL;IACA,KAAKP,OAAL;IACA,KAAKD,WAAL;IACA,KAAKO,aAAL,CAVF,CAWE;IACA;;IACA,KAAKJ,KAAL;MACE,OAAO,CAAP;IAAU;;IACZ,KAAKG,UAAL;MACE,OAAO,CAAP;IAAU;;IACZ;MACE,OAAO,EAAP;EAlBJ;AAoBD","names":["isBoolean","isObject","COLOR","COLUMN","FILL","FILLOPACITY","OPACITY","ROW","SHAPE","SIZE","STROKE","STROKEDASH","STROKEOPACITY","STROKEWIDTH","normalizeBin","entries","keys","varName","binToString","bin","undefined","map","p","isParameterExtent","join","isBinning","isBinParams","binned","isBinned","extent","autoMaxBins","channel"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/bin.ts"],"sourcesContent":["import {isBoolean, isObject} from 'vega-util';\nimport {\n  COLOR,\n  COLUMN,\n  ExtendedChannel,\n  FILL,\n  FILLOPACITY,\n  OPACITY,\n  ROW,\n  SHAPE,\n  SIZE,\n  STROKE,\n  STROKEDASH,\n  STROKEOPACITY,\n  STROKEWIDTH\n} from './channel';\nimport {normalizeBin} from './channeldef';\nimport {ParameterExtent} from './selection';\nimport {entries, keys, varName} from './util';\n\nexport interface BaseBin {\n  /**\n   * The number base to use for automatic bin determination (default is base 10).\n   *\n   * __Default value:__ `10`\n   *\n   */\n  base?: number;\n  /**\n   * An exact step size to use between bins.\n   *\n   * __Note:__ If provided, options such as maxbins will be ignored.\n   */\n  step?: number;\n  /**\n   * An array of allowable step sizes to choose from.\n   * @minItems 1\n   */\n  steps?: number[];\n  /**\n   * A minimum allowable step size (particularly useful for integer values).\n   */\n  minstep?: number;\n  /**\n   * Scale factors indicating allowable subdivisions. The default value is [5, 2], which indicates that for base 10 numbers (the default base), the method may consider dividing bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given constraints.\n   *\n   * __Default value:__ `[5, 2]`\n   *\n   * @minItems 1\n   */\n  divide?: [number, number];\n  /**\n   * Maximum number of bins.\n   *\n   * __Default value:__ `6` for `row`, `column` and `shape` channels; `10` for other channels\n   *\n   * @minimum 2\n   */\n  maxbins?: number;\n  /**\n   * A value in the binned domain at which to anchor the bins, shifting the bin boundaries if necessary to ensure that a boundary aligns with the anchor value.\n   *\n   * __Default value:__ the minimum bin extent value\n   */\n  anchor?: number;\n  /**\n   * If true, attempts to make the bin boundaries use human-friendly boundaries, such as multiples of ten.\n   *\n   * __Default value:__ `true`\n   */\n  nice?: boolean;\n}\n\n/**\n * Binning properties or boolean flag for determining whether to bin data or not.\n */\nexport interface BinParams extends BaseBin {\n  /**\n   * A two-element (`[min, max]`) array indicating the range of desired bin values.\n   */\n  extent?: BinExtent; // VgBinTransform uses a different extent so we need to pull this out.\n\n  /**\n   * When set to `true`, Vega-Lite treats the input data as already binned.\n   */\n  binned?: boolean;\n}\n\nexport type Bin = boolean | BinParams | 'binned' | null;\n\nexport type BinExtent = [number, number] | ParameterExtent;\n\n/**\n * Create a key for the bin configuration. Not for prebinned bin.\n */\nexport function binToString(bin: BinParams | true) {\n  if (isBoolean(bin)) {\n    bin = normalizeBin(bin, undefined);\n  }\n  return (\n    'bin' +\n    keys(bin)\n      .map(p => (isParameterExtent(bin[p]) ? varName(`_${p}_${entries(bin[p])}`) : varName(`_${p}_${bin[p]}`)))\n      .join('')\n  );\n}\n\n/**\n * Vega-Lite should bin the data.\n */\nexport function isBinning(bin: BinParams | boolean | 'binned'): bin is BinParams | true {\n  return bin === true || (isBinParams(bin) && !bin.binned);\n}\n\n/**\n * The data is already binned and so Vega-Lite should not bin it again.\n */\nexport function isBinned(bin: BinParams | boolean | 'binned'): bin is 'binned' | BinParams {\n  return bin === 'binned' || (isBinParams(bin) && bin.binned === true);\n}\n\nexport function isBinParams(bin: BinParams | boolean | 'binned'): bin is BinParams {\n  return isObject(bin);\n}\n\nexport function isParameterExtent(extent: BinExtent): extent is ParameterExtent {\n  return extent?.['param'];\n}\n\nexport function autoMaxBins(channel?: ExtendedChannel): number {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case SIZE:\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    // Facets and Size shouldn't have too many bins\n    // We choose 6 like shape to simplify the rule [falls through]\n    case SHAPE:\n      return 6; // Vega's \"shape\" has 6 distinct values\n    case STROKEDASH:\n      return 4; // We only provide 5 different stroke dash values (but 4 is more effective)\n    default:\n      return 10;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}