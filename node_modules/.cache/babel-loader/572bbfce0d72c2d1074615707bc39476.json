{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isArray } from 'vega';\nimport { isBinParams } from '../bin';\nimport { isConditionalDef, isFieldDef, isScaleFieldDef } from '../channeldef';\nimport { normalizeLogicalComposition } from '../logical';\nimport { SpecMapper } from '../spec/map';\nimport { isBin, isFilter, isLookup } from '../transform';\nimport { duplicate, entries, vals } from '../util';\nexport class SelectionCompatibilityNormalizer extends SpecMapper {\n  map(spec, normParams) {\n    var _a, _b;\n\n    (_a = normParams.emptySelections) !== null && _a !== void 0 ? _a : normParams.emptySelections = {};\n    (_b = normParams.selectionPredicates) !== null && _b !== void 0 ? _b : normParams.selectionPredicates = {};\n    spec = normalizeTransforms(spec, normParams);\n    return super.map(spec, normParams);\n  }\n\n  mapLayerOrUnit(spec, normParams) {\n    spec = normalizeTransforms(spec, normParams);\n\n    if (spec.encoding) {\n      const encoding = {};\n\n      for (const [channel, enc] of entries(spec.encoding)) {\n        encoding[channel] = normalizeChannelDef(enc, normParams);\n      }\n\n      spec = Object.assign(Object.assign({}, spec), {\n        encoding\n      });\n    }\n\n    return super.mapLayerOrUnit(spec, normParams);\n  }\n\n  mapUnit(spec, normParams) {\n    const _a = spec,\n          {\n      selection\n    } = _a,\n          rest = __rest(_a, [\"selection\"]);\n\n    if (selection) {\n      return Object.assign(Object.assign({}, rest), {\n        params: entries(selection).map(_ref => {\n          let [name, selDef] = _ref;\n\n          var _a;\n\n          const _b = selDef,\n                {\n            init: value,\n            bind,\n            empty\n          } = _b,\n                select = __rest(_b, [\"init\", \"bind\", \"empty\"]);\n\n          if (select.type === 'single') {\n            select.type = 'point';\n            select.toggle = false;\n          } else if (select.type === 'multi') {\n            select.type = 'point';\n          } // Propagate emptiness forwards and backwards\n\n\n          normParams.emptySelections[name] = empty !== 'none';\n\n          for (const pred of vals((_a = normParams.selectionPredicates[name]) !== null && _a !== void 0 ? _a : {})) {\n            pred.empty = empty !== 'none';\n          }\n\n          return {\n            name,\n            value,\n            select,\n            bind\n          };\n        })\n      });\n    }\n\n    return spec;\n  }\n\n}\n\nfunction normalizeTransforms(spec, normParams) {\n  const {\n    transform: tx\n  } = spec,\n        rest = __rest(spec, [\"transform\"]);\n\n  if (tx) {\n    const transform = tx.map(t => {\n      if (isFilter(t)) {\n        return {\n          filter: normalizePredicate(t, normParams)\n        };\n      } else if (isBin(t) && isBinParams(t.bin)) {\n        return Object.assign(Object.assign({}, t), {\n          bin: normalizeBinExtent(t.bin)\n        });\n      } else if (isLookup(t)) {\n        const _a = t.from,\n              {\n          selection: param\n        } = _a,\n              from = __rest(_a, [\"selection\"]);\n\n        return param ? Object.assign(Object.assign({}, t), {\n          from: Object.assign({\n            param\n          }, from)\n        }) : t;\n      }\n\n      return t;\n    });\n    return Object.assign(Object.assign({}, rest), {\n      transform\n    });\n  }\n\n  return spec;\n}\n\nfunction normalizeChannelDef(obj, normParams) {\n  var _a, _b;\n\n  const enc = duplicate(obj);\n\n  if (isFieldDef(enc) && isBinParams(enc.bin)) {\n    enc.bin = normalizeBinExtent(enc.bin);\n  }\n\n  if (isScaleFieldDef(enc) && ((_b = (_a = enc.scale) === null || _a === void 0 ? void 0 : _a.domain) === null || _b === void 0 ? void 0 : _b.selection)) {\n    const _c = enc.scale.domain,\n          {\n      selection: param\n    } = _c,\n          domain = __rest(_c, [\"selection\"]);\n\n    enc.scale.domain = Object.assign(Object.assign({}, domain), param ? {\n      param\n    } : {});\n  }\n\n  if (isConditionalDef(enc)) {\n    if (isArray(enc.condition)) {\n      enc.condition = enc.condition.map(c => {\n        const {\n          selection,\n          param,\n          test\n        } = c,\n              cond = __rest(c, [\"selection\", \"param\", \"test\"]);\n\n        return param ? c : Object.assign(Object.assign({}, cond), {\n          test: normalizePredicate(c, normParams)\n        });\n      });\n    } else {\n      const _d = normalizeChannelDef(enc.condition, normParams),\n            {\n        selection,\n        param,\n        test\n      } = _d,\n            cond = __rest(_d, [\"selection\", \"param\", \"test\"]);\n\n      enc.condition = param ? enc.condition : Object.assign(Object.assign({}, cond), {\n        test: normalizePredicate(enc.condition, normParams)\n      });\n    }\n  }\n\n  return enc;\n}\n\nfunction normalizeBinExtent(bin) {\n  const ext = bin.extent;\n\n  if (ext === null || ext === void 0 ? void 0 : ext.selection) {\n    const {\n      selection: param\n    } = ext,\n          rest = __rest(ext, [\"selection\"]);\n\n    return Object.assign(Object.assign({}, bin), {\n      extent: Object.assign(Object.assign({}, rest), {\n        param\n      })\n    });\n  }\n\n  return bin;\n}\n\nfunction normalizePredicate(op, normParams) {\n  // Normalize old compositions of selection names (e.g., selection: {and: [\"one\", \"two\"]})\n  const normalizeSelectionComposition = o => {\n    return normalizeLogicalComposition(o, param => {\n      var _a, _b;\n\n      var _c;\n\n      const empty = (_a = normParams.emptySelections[param]) !== null && _a !== void 0 ? _a : true;\n      const pred = {\n        param,\n        empty\n      };\n      (_b = (_c = normParams.selectionPredicates)[param]) !== null && _b !== void 0 ? _b : _c[param] = [];\n      normParams.selectionPredicates[param].push(pred);\n      return pred;\n    });\n  };\n\n  return op.selection ? normalizeSelectionComposition(op.selection) : normalizeLogicalComposition(op.test || op.filter, o => o.selection ? normalizeSelectionComposition(o.selection) : o);\n}","map":{"version":3,"mappings":"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","names":["isArray","isBinParams","isConditionalDef","isFieldDef","isScaleFieldDef","normalizeLogicalComposition","SpecMapper","isBin","isFilter","isLookup","duplicate","entries","vals","SelectionCompatibilityNormalizer","map","spec","normParams","emptySelections","_a","selectionPredicates","_b","normalizeTransforms","mapLayerOrUnit","encoding","channel","enc","normalizeChannelDef","mapUnit","selection","rest","params","name","selDef","init","value","bind","empty","select","type","toggle","pred","transform","tx","t","filter","normalizePredicate","bin","normalizeBinExtent","from","param","Object","obj","scale","domain","_c","condition","c","test","cond","_d","ext","extent","op","normalizeSelectionComposition","o","push"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/normalize/selectioncompat.ts"],"sourcesContent":["import {isArray} from 'vega';\nimport {BinParams, isBinParams} from '../bin';\nimport {ChannelDef, Field, isConditionalDef, isFieldDef, isScaleFieldDef} from '../channeldef';\nimport {LogicalComposition, normalizeLogicalComposition} from '../logical';\nimport {FacetedUnitSpec, GenericSpec, LayerSpec, RepeatSpec, UnitSpec} from '../spec';\nimport {SpecMapper} from '../spec/map';\nimport {isBin, isFilter, isLookup} from '../transform';\nimport {duplicate, entries, vals} from '../util';\nimport {NormalizerParams} from './base';\n\nexport class SelectionCompatibilityNormalizer extends SpecMapper<\n  NormalizerParams,\n  FacetedUnitSpec<Field>,\n  LayerSpec<Field>,\n  UnitSpec<Field>\n> {\n  public map(\n    spec: GenericSpec<FacetedUnitSpec<Field>, LayerSpec<Field>, RepeatSpec, Field>,\n    normParams: NormalizerParams\n  ) {\n    normParams.emptySelections ??= {};\n    normParams.selectionPredicates ??= {};\n    spec = normalizeTransforms(spec, normParams);\n    return super.map(spec, normParams);\n  }\n\n  public mapLayerOrUnit(spec: FacetedUnitSpec<Field> | LayerSpec<Field>, normParams: NormalizerParams) {\n    spec = normalizeTransforms(spec, normParams);\n\n    if (spec.encoding) {\n      const encoding = {};\n      for (const [channel, enc] of entries(spec.encoding)) {\n        encoding[channel] = normalizeChannelDef(enc, normParams);\n      }\n\n      spec = {...spec, encoding};\n    }\n\n    return super.mapLayerOrUnit(spec, normParams);\n  }\n\n  public mapUnit(spec: UnitSpec<Field>, normParams: NormalizerParams) {\n    const {selection, ...rest} = spec as any;\n    if (selection) {\n      return {\n        ...rest,\n        params: entries(selection).map(([name, selDef]) => {\n          const {init: value, bind, empty, ...select} = selDef as any;\n          if (select.type === 'single') {\n            select.type = 'point';\n            select.toggle = false;\n          } else if (select.type === 'multi') {\n            select.type = 'point';\n          }\n\n          // Propagate emptiness forwards and backwards\n          normParams.emptySelections[name] = empty !== 'none';\n          for (const pred of vals(normParams.selectionPredicates[name] ?? {})) {\n            pred.empty = empty !== 'none';\n          }\n\n          return {name, value, select, bind};\n        })\n      };\n    }\n\n    return spec;\n  }\n}\n\nfunction normalizeTransforms(spec: any, normParams: NormalizerParams) {\n  const {transform: tx, ...rest} = spec;\n  if (tx) {\n    const transform = tx.map((t: any) => {\n      if (isFilter(t)) {\n        return {filter: normalizePredicate(t, normParams)};\n      } else if (isBin(t) && isBinParams(t.bin)) {\n        return {\n          ...t,\n          bin: normalizeBinExtent(t.bin)\n        };\n      } else if (isLookup(t)) {\n        const {selection: param, ...from} = t.from as any;\n        return param\n          ? {\n              ...t,\n              from: {param, ...from}\n            }\n          : t;\n      }\n      return t;\n    });\n\n    return {...rest, transform};\n  }\n\n  return spec;\n}\n\nfunction normalizeChannelDef(obj: any, normParams: NormalizerParams): ChannelDef {\n  const enc = duplicate(obj);\n\n  if (isFieldDef(enc) && isBinParams(enc.bin)) {\n    enc.bin = normalizeBinExtent(enc.bin);\n  }\n\n  if (isScaleFieldDef(enc) && (enc.scale?.domain as any)?.selection) {\n    const {selection: param, ...domain} = enc.scale.domain as any;\n    enc.scale.domain = {...domain, ...(param ? {param} : {})};\n  }\n\n  if (isConditionalDef(enc)) {\n    if (isArray(enc.condition)) {\n      enc.condition = enc.condition.map((c: any) => {\n        const {selection, param, test, ...cond} = c;\n        return param ? c : {...cond, test: normalizePredicate(c, normParams)};\n      });\n    } else {\n      const {selection, param, test, ...cond} = normalizeChannelDef(enc.condition, normParams) as any;\n      enc.condition = param\n        ? enc.condition\n        : {\n            ...cond,\n            test: normalizePredicate(enc.condition, normParams)\n          };\n    }\n  }\n\n  return enc;\n}\n\nfunction normalizeBinExtent(bin: BinParams): BinParams {\n  const ext = bin.extent as any;\n  if (ext?.selection) {\n    const {selection: param, ...rest} = ext;\n    return {...bin, extent: {...rest, param}};\n  }\n\n  return bin;\n}\n\nfunction normalizePredicate(op: any, normParams: NormalizerParams) {\n  // Normalize old compositions of selection names (e.g., selection: {and: [\"one\", \"two\"]})\n  const normalizeSelectionComposition = (o: LogicalComposition<string>) => {\n    return normalizeLogicalComposition(o, param => {\n      const empty = normParams.emptySelections[param] ?? true;\n      const pred = {param, empty};\n      normParams.selectionPredicates[param] ??= [];\n      normParams.selectionPredicates[param].push(pred);\n      return pred as any;\n    });\n  };\n\n  return op.selection\n    ? normalizeSelectionComposition(op.selection)\n    : normalizeLogicalComposition(op.test || op.filter, o =>\n        o.selection ? normalizeSelectionComposition(o.selection) : o\n      );\n}\n"]},"metadata":{},"sourceType":"module"}