{"ast":null,"code":"import { isScaleFieldDef, vgField } from '../../channeldef';\nimport { fieldFilterExpression } from '../../predicate';\nimport { isSortArray } from '../../sort';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nimport { getDependentFields } from './expressions';\nexport class CalculateNode extends DataFlowNode {\n  constructor(parent, transform) {\n    super(parent);\n    this.transform = transform;\n    this._dependentFields = getDependentFields(this.transform.calculate);\n  }\n\n  clone() {\n    return new CalculateNode(null, duplicate(this.transform));\n  }\n\n  static parseAllForSortIndex(parent, model) {\n    // get all the encoding with sort fields from model\n    model.forEachFieldDef((fieldDef, channel) => {\n      if (!isScaleFieldDef(fieldDef)) {\n        return;\n      }\n\n      if (isSortArray(fieldDef.sort)) {\n        const {\n          field,\n          timeUnit\n        } = fieldDef;\n        const sort = fieldDef.sort; // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n\n        const calculate = sort.map((sortValue, i) => {\n          return `${fieldFilterExpression({\n            field,\n            timeUnit,\n            equal: sortValue\n          })} ? ${i} : `;\n        }).join('') + sort.length;\n        parent = new CalculateNode(parent, {\n          calculate,\n          as: sortArrayIndexField(fieldDef, channel, {\n            forAs: true\n          })\n        });\n      }\n    });\n    return parent;\n  }\n\n  producedFields() {\n    return new Set([this.transform.as]);\n  }\n\n  dependentFields() {\n    return this._dependentFields;\n  }\n\n  assemble() {\n    return {\n      type: 'formula',\n      expr: this.transform.calculate,\n      as: this.transform.as\n    };\n  }\n\n  hash() {\n    return `Calculate ${hash(this.transform)}`;\n  }\n\n}\nexport function sortArrayIndexField(fieldDef, channel, opt) {\n  return vgField(fieldDef, Object.assign({\n    prefix: channel,\n    suffix: 'sort_index'\n  }, opt !== null && opt !== void 0 ? opt : {}));\n}","map":{"version":3,"mappings":"AAEA,SAAwBA,eAAxB,EAAwDC,OAAxD,QAAsE,kBAAtE;AAEA,SAAQC,qBAAR,QAAoC,iBAApC;AACA,SAAQC,WAAR,QAA0B,YAA1B;AAEA,SAAQC,SAAR,EAAmBC,IAAnB,QAA8B,YAA9B;AAEA,SAAQC,YAAR,QAA2B,YAA3B;AACA,SAAQC,kBAAR,QAAiC,eAAjC;AAEA,OAAM,MAAOC,aAAP,SAA6BF,YAA7B,CAAyC;EAO7CG,YAAYC,MAAZ,EAAmDC,SAAnD,EAAgF;IAC9E,MAAMD,MAAN;IADiD;IAGjD,KAAKE,gBAAL,GAAwBL,kBAAkB,CAAC,KAAKI,SAAL,CAAeE,SAAhB,CAA1C;EACD;;EARMC,KAAK;IACV,OAAO,IAAIN,aAAJ,CAAkB,IAAlB,EAAwBJ,SAAS,CAAC,KAAKO,SAAN,CAAjC,CAAP;EACD;;EAQiC,OAApBI,oBAAoB,CAACL,MAAD,EAAuBM,KAAvB,EAA4C;IAC5E;IACAA,KAAK,CAACC,eAAN,CAAsB,CAACC,QAAD,EAAkCC,OAAlC,KAA+D;MACnF,IAAI,CAACnB,eAAe,CAACkB,QAAD,CAApB,EAAgC;QAC9B;MACD;;MACD,IAAIf,WAAW,CAACe,QAAQ,CAACE,IAAV,CAAf,EAAgC;QAC9B,MAAM;UAACC,KAAD;UAAQC;QAAR,IAAoBJ,QAA1B;QACA,MAAME,IAAI,GAA6CF,QAAQ,CAACE,IAAhE,CAF8B,CAG9B;;QACA,MAAMP,SAAS,GACbO,IAAI,CACDG,GADH,CACO,CAACC,SAAD,EAAYC,CAAZ,KAAiB;UACpB,OAAO,GAAGvB,qBAAqB,CAAC;YAACmB,KAAD;YAAQC,QAAR;YAAkBI,KAAK,EAAEF;UAAzB,CAAD,CAAqC,MAAMC,CAAC,KAA3E;QACD,CAHH,EAIGE,IAJH,CAIQ,EAJR,IAIcP,IAAI,CAACQ,MALrB;QAOAlB,MAAM,GAAG,IAAIF,aAAJ,CAAkBE,MAAlB,EAA0B;UACjCG,SADiC;UAEjCgB,EAAE,EAAEC,mBAAmB,CAACZ,QAAD,EAAWC,OAAX,EAAoB;YAACY,KAAK,EAAE;UAAR,CAApB;QAFU,CAA1B,CAAT;MAID;IACF,CApBD;IAqBA,OAAOrB,MAAP;EACD;;EAEMsB,cAAc;IACnB,OAAO,IAAIC,GAAJ,CAAQ,CAAC,KAAKtB,SAAL,CAAekB,EAAhB,CAAR,CAAP;EACD;;EAEMK,eAAe;IACpB,OAAO,KAAKtB,gBAAZ;EACD;;EAEMuB,QAAQ;IACb,OAAO;MACLC,IAAI,EAAE,SADD;MAELC,IAAI,EAAE,KAAK1B,SAAL,CAAeE,SAFhB;MAGLgB,EAAE,EAAE,KAAKlB,SAAL,CAAekB;IAHd,CAAP;EAKD;;EAEMxB,IAAI;IACT,OAAO,aAAaA,IAAI,CAAC,KAAKM,SAAN,CAAgB,EAAxC;EACD;;AAzD4C;AA4D/C,OAAM,SAAUmB,mBAAV,CAA8BZ,QAA9B,EAA+DC,OAA/D,EAA0FmB,GAA1F,EAA8G;EAClH,OAAOrC,OAAO,CAACiB,QAAD,EAASqB;IAAGC,MAAM,EAAErB,OAAX;IAAoBsB,MAAM,EAAE;EAA5B,GAA8CH,GAAG,SAAH,OAAG,WAAH,SAAO,EAArD,CAAT,CAAd;AACD","names":["isScaleFieldDef","vgField","fieldFilterExpression","isSortArray","duplicate","hash","DataFlowNode","getDependentFields","CalculateNode","constructor","parent","transform","_dependentFields","calculate","clone","parseAllForSortIndex","model","forEachFieldDef","fieldDef","channel","sort","field","timeUnit","map","sortValue","i","equal","join","length","as","sortArrayIndexField","forAs","producedFields","Set","dependentFields","assemble","type","expr","opt","Object","prefix","suffix"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/data/calculate.ts"],"sourcesContent":["import {FormulaTransform as VgFormulaTransform} from 'vega';\nimport {SingleDefChannel} from '../../channel';\nimport {FieldRefOption, isScaleFieldDef, TypedFieldDef, vgField} from '../../channeldef';\nimport {DateTime} from '../../datetime';\nimport {fieldFilterExpression} from '../../predicate';\nimport {isSortArray} from '../../sort';\nimport {CalculateTransform} from '../../transform';\nimport {duplicate, hash} from '../../util';\nimport {ModelWithField} from '../model';\nimport {DataFlowNode} from './dataflow';\nimport {getDependentFields} from './expressions';\n\nexport class CalculateNode extends DataFlowNode {\n  private _dependentFields: Set<string>;\n\n  public clone() {\n    return new CalculateNode(null, duplicate(this.transform));\n  }\n\n  constructor(parent: DataFlowNode, private readonly transform: CalculateTransform) {\n    super(parent);\n\n    this._dependentFields = getDependentFields(this.transform.calculate);\n  }\n\n  public static parseAllForSortIndex(parent: DataFlowNode, model: ModelWithField) {\n    // get all the encoding with sort fields from model\n    model.forEachFieldDef((fieldDef: TypedFieldDef<string>, channel: SingleDefChannel) => {\n      if (!isScaleFieldDef(fieldDef)) {\n        return;\n      }\n      if (isSortArray(fieldDef.sort)) {\n        const {field, timeUnit} = fieldDef;\n        const sort: (number | string | boolean | DateTime)[] = fieldDef.sort;\n        // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n        const calculate =\n          sort\n            .map((sortValue, i) => {\n              return `${fieldFilterExpression({field, timeUnit, equal: sortValue})} ? ${i} : `;\n            })\n            .join('') + sort.length;\n\n        parent = new CalculateNode(parent, {\n          calculate,\n          as: sortArrayIndexField(fieldDef, channel, {forAs: true})\n        });\n      }\n    });\n    return parent;\n  }\n\n  public producedFields() {\n    return new Set([this.transform.as]);\n  }\n\n  public dependentFields() {\n    return this._dependentFields;\n  }\n\n  public assemble(): VgFormulaTransform {\n    return {\n      type: 'formula',\n      expr: this.transform.calculate,\n      as: this.transform.as\n    };\n  }\n\n  public hash() {\n    return `Calculate ${hash(this.transform)}`;\n  }\n}\n\nexport function sortArrayIndexField(fieldDef: TypedFieldDef<string>, channel: SingleDefChannel, opt?: FieldRefOption) {\n  return vgField(fieldDef, {prefix: channel, suffix: 'sort_index', ...(opt ?? {})});\n}\n"]},"metadata":{},"sourceType":"module"}