{"ast":null,"code":"import { hasOwnProperty } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport { replaceExprRef } from '../../expr';\nimport { PROJECTION_PROPERTIES } from '../../projection';\nimport { GEOJSON } from '../../type';\nimport { deepEqual, duplicate, every } from '../../util';\nimport { isUnitModel } from '../model';\nimport { ProjectionComponent } from './component';\nexport function parseProjection(model) {\n  model.component.projection = isUnitModel(model) ? parseUnitProjection(model) : parseNonUnitProjections(model);\n}\n\nfunction parseUnitProjection(model) {\n  var _a;\n\n  if (model.hasProjection) {\n    const proj = replaceExprRef(model.specifiedProjection);\n    const fit = !(proj && (proj.scale != null || proj.translate != null));\n    const size = fit ? [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')] : undefined;\n    const data = fit ? gatherFitData(model) : undefined;\n    const projComp = new ProjectionComponent(model.projectionName(true), Object.assign(Object.assign({}, (_a = replaceExprRef(model.config.projection)) !== null && _a !== void 0 ? _a : {}), proj !== null && proj !== void 0 ? proj : {}), size, data);\n\n    if (!projComp.get('type')) {\n      projComp.set('type', 'equalEarth', false);\n    }\n\n    return projComp;\n  }\n\n  return undefined;\n}\n\nfunction gatherFitData(model) {\n  const data = [];\n  const {\n    encoding\n  } = model;\n\n  for (const posssiblePair of [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]]) {\n    if (getFieldOrDatumDef(encoding[posssiblePair[0]]) || getFieldOrDatumDef(encoding[posssiblePair[1]])) {\n      data.push({\n        signal: model.getName(`geojson_${data.length}`)\n      });\n    }\n  }\n\n  if (model.channelHasField(SHAPE) && model.typedFieldDef(SHAPE).type === GEOJSON) {\n    data.push({\n      signal: model.getName(`geojson_${data.length}`)\n    });\n  }\n\n  if (data.length === 0) {\n    // main source is geojson, so we can just use that\n    data.push(model.requestDataName(DataSourceType.Main));\n  }\n\n  return data;\n}\n\nfunction mergeIfNoConflict(first, second) {\n  const allPropertiesShared = every(PROJECTION_PROPERTIES, prop => {\n    // neither has the property\n    if (!hasOwnProperty(first.explicit, prop) && !hasOwnProperty(second.explicit, prop)) {\n      return true;\n    } // both have property and an equal value for property\n\n\n    if (hasOwnProperty(first.explicit, prop) && hasOwnProperty(second.explicit, prop) && // some properties might be signals or objects and require hashing for comparison\n    deepEqual(first.get(prop), second.get(prop))) {\n      return true;\n    }\n\n    return false;\n  });\n  const size = deepEqual(first.size, second.size);\n\n  if (size) {\n    if (allPropertiesShared) {\n      return first;\n    } else if (deepEqual(first.explicit, {})) {\n      return second;\n    } else if (deepEqual(second.explicit, {})) {\n      return first;\n    }\n  } // if all properties don't match, let each unit spec have its own projection\n\n\n  return null;\n}\n\nfunction parseNonUnitProjections(model) {\n  if (model.children.length === 0) {\n    return undefined;\n  }\n\n  let nonUnitProjection; // parse all children first\n\n  for (const child of model.children) {\n    parseProjection(child);\n  } // analyze parsed projections, attempt to merge\n\n\n  const mergable = every(model.children, child => {\n    const projection = child.component.projection;\n\n    if (!projection) {\n      // child layer does not use a projection\n      return true;\n    } else if (!nonUnitProjection) {\n      // cached 'projection' is null, cache this one\n      nonUnitProjection = projection;\n      return true;\n    } else {\n      const merge = mergeIfNoConflict(nonUnitProjection, projection);\n\n      if (merge) {\n        nonUnitProjection = merge;\n      }\n\n      return !!merge;\n    }\n  }); // if cached one and all other children share the same projection,\n\n  if (nonUnitProjection && mergable) {\n    // so we can elevate it to the layer level\n    const name = model.projectionName(true);\n    const modelProjection = new ProjectionComponent(name, nonUnitProjection.specifiedProjection, nonUnitProjection.size, duplicate(nonUnitProjection.data)); // rename and assign all others as merged\n\n    for (const child of model.children) {\n      const projection = child.component.projection;\n\n      if (projection) {\n        if (projection.isFit) {\n          modelProjection.data.push(...child.component.projection.data);\n        }\n\n        child.renameProjection(projection.get('name'), name);\n        projection.merged = true;\n      }\n    }\n\n    return modelProjection;\n  }\n\n  return undefined;\n}","map":{"version":3,"mappings":"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","names":["hasOwnProperty","LATITUDE","LATITUDE2","LONGITUDE","LONGITUDE2","SHAPE","getFieldOrDatumDef","DataSourceType","replaceExprRef","PROJECTION_PROPERTIES","GEOJSON","deepEqual","duplicate","every","isUnitModel","ProjectionComponent","parseProjection","model","component","projection","parseUnitProjection","parseNonUnitProjections","hasProjection","proj","specifiedProjection","fit","scale","translate","size","getSizeSignalRef","undefined","data","gatherFitData","projComp","projectionName","Object","config","_a","get","set","encoding","posssiblePair","push","signal","getName","length","channelHasField","typedFieldDef","type","requestDataName","Main","mergeIfNoConflict","first","second","allPropertiesShared","prop","explicit","children","nonUnitProjection","child","mergable","merge","name","modelProjection","isFit","renameProjection","merged"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/projection/parse.ts"],"sourcesContent":["import {SignalRef} from 'vega';\nimport {hasOwnProperty} from 'vega-util';\nimport {LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE} from '../../channel';\nimport {getFieldOrDatumDef} from '../../channeldef';\nimport {DataSourceType} from '../../data';\nimport {replaceExprRef} from '../../expr';\nimport {PROJECTION_PROPERTIES} from '../../projection';\nimport {GEOJSON} from '../../type';\nimport {deepEqual, duplicate, every} from '../../util';\nimport {isUnitModel, Model} from '../model';\nimport {UnitModel} from '../unit';\nimport {ProjectionComponent} from './component';\n\nexport function parseProjection(model: Model) {\n  model.component.projection = isUnitModel(model) ? parseUnitProjection(model) : parseNonUnitProjections(model);\n}\n\nfunction parseUnitProjection(model: UnitModel): ProjectionComponent {\n  if (model.hasProjection) {\n    const proj = replaceExprRef(model.specifiedProjection);\n    const fit = !(proj && (proj.scale != null || proj.translate != null));\n    const size = fit ? [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')] : undefined;\n    const data = fit ? gatherFitData(model) : undefined;\n\n    const projComp = new ProjectionComponent(\n      model.projectionName(true),\n      {\n        ...(replaceExprRef(model.config.projection) ?? {}),\n        ...(proj ?? {})\n      },\n      size,\n      data\n    );\n\n    if (!projComp.get('type')) {\n      projComp.set('type', 'equalEarth', false);\n    }\n\n    return projComp;\n  }\n\n  return undefined;\n}\n\nfunction gatherFitData(model: UnitModel) {\n  const data: (SignalRef | string)[] = [];\n\n  const {encoding} = model;\n\n  for (const posssiblePair of [\n    [LONGITUDE, LATITUDE],\n    [LONGITUDE2, LATITUDE2]\n  ]) {\n    if (getFieldOrDatumDef(encoding[posssiblePair[0]]) || getFieldOrDatumDef(encoding[posssiblePair[1]])) {\n      data.push({\n        signal: model.getName(`geojson_${data.length}`)\n      });\n    }\n  }\n\n  if (model.channelHasField(SHAPE) && model.typedFieldDef(SHAPE).type === GEOJSON) {\n    data.push({\n      signal: model.getName(`geojson_${data.length}`)\n    });\n  }\n\n  if (data.length === 0) {\n    // main source is geojson, so we can just use that\n    data.push(model.requestDataName(DataSourceType.Main));\n  }\n\n  return data;\n}\n\nfunction mergeIfNoConflict(first: ProjectionComponent, second: ProjectionComponent): ProjectionComponent {\n  const allPropertiesShared = every(PROJECTION_PROPERTIES, prop => {\n    // neither has the property\n    if (!hasOwnProperty(first.explicit, prop) && !hasOwnProperty(second.explicit, prop)) {\n      return true;\n    }\n    // both have property and an equal value for property\n    if (\n      hasOwnProperty(first.explicit, prop) &&\n      hasOwnProperty(second.explicit, prop) &&\n      // some properties might be signals or objects and require hashing for comparison\n      deepEqual(first.get(prop), second.get(prop))\n    ) {\n      return true;\n    }\n    return false;\n  });\n\n  const size = deepEqual(first.size, second.size);\n  if (size) {\n    if (allPropertiesShared) {\n      return first;\n    } else if (deepEqual(first.explicit, {})) {\n      return second;\n    } else if (deepEqual(second.explicit, {})) {\n      return first;\n    }\n  }\n\n  // if all properties don't match, let each unit spec have its own projection\n  return null;\n}\n\nfunction parseNonUnitProjections(model: Model): ProjectionComponent {\n  if (model.children.length === 0) {\n    return undefined;\n  }\n\n  let nonUnitProjection: ProjectionComponent;\n\n  // parse all children first\n  for (const child of model.children) {\n    parseProjection(child);\n  }\n\n  // analyze parsed projections, attempt to merge\n  const mergable = every(model.children, child => {\n    const projection = child.component.projection;\n    if (!projection) {\n      // child layer does not use a projection\n      return true;\n    } else if (!nonUnitProjection) {\n      // cached 'projection' is null, cache this one\n      nonUnitProjection = projection;\n      return true;\n    } else {\n      const merge = mergeIfNoConflict(nonUnitProjection, projection);\n      if (merge) {\n        nonUnitProjection = merge;\n      }\n      return !!merge;\n    }\n  });\n\n  // if cached one and all other children share the same projection,\n  if (nonUnitProjection && mergable) {\n    // so we can elevate it to the layer level\n    const name = model.projectionName(true);\n    const modelProjection = new ProjectionComponent(\n      name,\n      nonUnitProjection.specifiedProjection,\n      nonUnitProjection.size,\n      duplicate(nonUnitProjection.data)\n    );\n\n    // rename and assign all others as merged\n    for (const child of model.children) {\n      const projection = child.component.projection;\n      if (projection) {\n        if (projection.isFit) {\n          modelProjection.data.push(...child.component.projection.data);\n        }\n        child.renameProjection(projection.get('name'), name);\n        projection.merged = true;\n      }\n    }\n\n    return modelProjection;\n  }\n\n  return undefined;\n}\n"]},"metadata":{},"sourceType":"module"}