{"ast":null,"code":"import { isString } from 'vega-util';\nimport { contains } from './util';\nconst AGGREGATE_OP_INDEX = {\n  argmax: 1,\n  argmin: 1,\n  average: 1,\n  count: 1,\n  distinct: 1,\n  product: 1,\n  max: 1,\n  mean: 1,\n  median: 1,\n  min: 1,\n  missing: 1,\n  q1: 1,\n  q3: 1,\n  ci0: 1,\n  ci1: 1,\n  stderr: 1,\n  stdev: 1,\n  stdevp: 1,\n  sum: 1,\n  valid: 1,\n  values: 1,\n  variance: 1,\n  variancep: 1\n};\nexport const MULTIDOMAIN_SORT_OP_INDEX = {\n  count: 1,\n  min: 1,\n  max: 1\n};\nexport function isArgminDef(a) {\n  return !!a && !!a['argmin'];\n}\nexport function isArgmaxDef(a) {\n  return !!a && !!a['argmax'];\n}\nexport function isAggregateOp(a) {\n  return isString(a) && !!AGGREGATE_OP_INDEX[a];\n}\nexport const COUNTING_OPS = new Set(['count', 'valid', 'missing', 'distinct']);\nexport function isCountingAggregateOp(aggregate) {\n  return isString(aggregate) && COUNTING_OPS.has(aggregate);\n}\nexport function isMinMaxOp(aggregate) {\n  return isString(aggregate) && contains(['min', 'max'], aggregate);\n}\n/** Additive-based aggregation operations. These can be applied to stack. */\n\nexport const SUM_OPS = new Set(['count', 'sum', 'distinct', 'valid', 'missing']);\n/**\n * Aggregation operators that always produce values within the range [domainMin, domainMax].\n */\n\nexport const SHARED_DOMAIN_OPS = new Set(['mean', 'average', 'median', 'q1', 'q3', 'min', 'max']);","map":{"version":3,"mappings":"AACA,SAAQA,QAAR,QAAuB,WAAvB;AAEA,SAAQC,QAAR,QAA6B,QAA7B;AAEA,MAAMC,kBAAkB,GAAsB;EAC5CC,MAAM,EAAE,CADoC;EAE5CC,MAAM,EAAE,CAFoC;EAG5CC,OAAO,EAAE,CAHmC;EAI5CC,KAAK,EAAE,CAJqC;EAK5CC,QAAQ,EAAE,CALkC;EAM5CC,OAAO,EAAE,CANmC;EAO5CC,GAAG,EAAE,CAPuC;EAQ5CC,IAAI,EAAE,CARsC;EAS5CC,MAAM,EAAE,CAToC;EAU5CC,GAAG,EAAE,CAVuC;EAW5CC,OAAO,EAAE,CAXmC;EAY5CC,EAAE,EAAE,CAZwC;EAa5CC,EAAE,EAAE,CAbwC;EAc5CC,GAAG,EAAE,CAduC;EAe5CC,GAAG,EAAE,CAfuC;EAgB5CC,MAAM,EAAE,CAhBoC;EAiB5CC,KAAK,EAAE,CAjBqC;EAkB5CC,MAAM,EAAE,CAlBoC;EAmB5CC,GAAG,EAAE,CAnBuC;EAoB5CC,KAAK,EAAE,CApBqC;EAqB5CC,MAAM,EAAE,CArBoC;EAsB5CC,QAAQ,EAAE,CAtBkC;EAuB5CC,SAAS,EAAE;AAvBiC,CAA9C;AA0BA,OAAO,MAAMC,yBAAyB,GAAG;EACvCpB,KAAK,EAAE,CADgC;EAEvCM,GAAG,EAAE,CAFkC;EAGvCH,GAAG,EAAE;AAHkC,CAAlC;AAkBP,OAAM,SAAUkB,WAAV,CAAsBC,CAAtB,EAA2C;EAC/C,OAAO,CAAC,CAACA,CAAF,IAAO,CAAC,CAACA,CAAC,CAAC,QAAD,CAAjB;AACD;AAED,OAAM,SAAUC,WAAV,CAAsBD,CAAtB,EAA2C;EAC/C,OAAO,CAAC,CAACA,CAAF,IAAO,CAAC,CAACA,CAAC,CAAC,QAAD,CAAjB;AACD;AAED,OAAM,SAAUE,aAAV,CAAwBF,CAAxB,EAAyD;EAC7D,OAAO5B,QAAQ,CAAC4B,CAAD,CAAR,IAAe,CAAC,CAAC1B,kBAAkB,CAAC0B,CAAD,CAA1C;AACD;AAED,OAAO,MAAMG,YAAY,GAAG,IAAIC,GAAJ,CAA2B,CACrD,OADqD,EAErD,OAFqD,EAGrD,SAHqD,EAIrD,UAJqD,CAA3B,CAArB;AAOP,OAAM,SAAUC,qBAAV,CAAgCC,SAAhC,EAA8D;EAClE,OAAOlC,QAAQ,CAACkC,SAAD,CAAR,IAAuBH,YAAY,CAACI,GAAb,CAAiBD,SAAjB,CAA9B;AACD;AAED,OAAM,SAAUE,UAAV,CAAqBF,SAArB,EAAmD;EACvD,OAAOlC,QAAQ,CAACkC,SAAD,CAAR,IAAuBjC,QAAQ,CAAC,CAAC,KAAD,EAAQ,KAAR,CAAD,EAAiBiC,SAAjB,CAAtC;AACD;AAED;;AACA,OAAO,MAAMG,OAAO,GAAG,IAAIL,GAAJ,CAA2B,CAChD,OADgD,EAEhD,KAFgD,EAGhD,UAHgD,EAIhD,OAJgD,EAKhD,SALgD,CAA3B,CAAhB;AAQP;;;;AAGA,OAAO,MAAMM,iBAAiB,GAAG,IAAIN,GAAJ,CAAqB,CACpD,MADoD,EAEpD,SAFoD,EAGpD,QAHoD,EAIpD,IAJoD,EAKpD,IALoD,EAMpD,KANoD,EAOpD,KAPoD,CAArB,CAA1B","names":["isString","contains","AGGREGATE_OP_INDEX","argmax","argmin","average","count","distinct","product","max","mean","median","min","missing","q1","q3","ci0","ci1","stderr","stdev","stdevp","sum","valid","values","variance","variancep","MULTIDOMAIN_SORT_OP_INDEX","isArgminDef","a","isArgmaxDef","isAggregateOp","COUNTING_OPS","Set","isCountingAggregateOp","aggregate","has","isMinMaxOp","SUM_OPS","SHARED_DOMAIN_OPS"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/aggregate.ts"],"sourcesContent":["import {AggregateOp} from 'vega';\nimport {isString} from 'vega-util';\nimport {FieldName} from './channeldef';\nimport {contains, Flag} from './util';\n\nconst AGGREGATE_OP_INDEX: Flag<AggregateOp> = {\n  argmax: 1,\n  argmin: 1,\n  average: 1,\n  count: 1,\n  distinct: 1,\n  product: 1,\n  max: 1,\n  mean: 1,\n  median: 1,\n  min: 1,\n  missing: 1,\n  q1: 1,\n  q3: 1,\n  ci0: 1,\n  ci1: 1,\n  stderr: 1,\n  stdev: 1,\n  stdevp: 1,\n  sum: 1,\n  valid: 1,\n  values: 1,\n  variance: 1,\n  variancep: 1\n};\n\nexport const MULTIDOMAIN_SORT_OP_INDEX = {\n  count: 1,\n  min: 1,\n  max: 1\n};\n\nexport interface ArgminDef {\n  argmin: FieldName;\n}\n\nexport interface ArgmaxDef {\n  argmax: FieldName;\n}\n\nexport type NonArgAggregateOp = Exclude<AggregateOp, 'argmin' | 'argmax'>;\n\nexport type Aggregate = NonArgAggregateOp | ArgmaxDef | ArgminDef;\n\nexport function isArgminDef(a: Aggregate | string): a is ArgminDef {\n  return !!a && !!a['argmin'];\n}\n\nexport function isArgmaxDef(a: Aggregate | string): a is ArgmaxDef {\n  return !!a && !!a['argmax'];\n}\n\nexport function isAggregateOp(a: string | ArgminDef | ArgmaxDef): a is AggregateOp {\n  return isString(a) && !!AGGREGATE_OP_INDEX[a];\n}\n\nexport const COUNTING_OPS = new Set<NonArgAggregateOp>([\n  'count',\n  'valid',\n  'missing',\n  'distinct'\n]) as ReadonlySet<NonArgAggregateOp>;\n\nexport function isCountingAggregateOp(aggregate?: string | Aggregate): boolean {\n  return isString(aggregate) && COUNTING_OPS.has(aggregate as any);\n}\n\nexport function isMinMaxOp(aggregate?: Aggregate | string): boolean {\n  return isString(aggregate) && contains(['min', 'max'], aggregate);\n}\n\n/** Additive-based aggregation operations. These can be applied to stack. */\nexport const SUM_OPS = new Set<NonArgAggregateOp>([\n  'count',\n  'sum',\n  'distinct',\n  'valid',\n  'missing'\n]) as ReadonlySet<NonArgAggregateOp>;\n\n/**\n * Aggregation operators that always produce values within the range [domainMin, domainMax].\n */\nexport const SHARED_DOMAIN_OPS = new Set<AggregateOp>([\n  'mean',\n  'average',\n  'median',\n  'q1',\n  'q3',\n  'min',\n  'max'\n]) as ReadonlySet<AggregateOp>;\n"]},"metadata":{},"sourceType":"module"}