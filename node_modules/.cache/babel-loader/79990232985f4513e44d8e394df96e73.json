{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW } from '../channel';\nimport { initFieldDef, vgField } from '../channeldef';\nimport { replaceExprRef } from '../expr';\nimport * as log from '../log';\nimport { hasDiscreteDomain } from '../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../sort';\nimport { isFacetMapping } from '../spec/facet';\nimport { keys } from '../util';\nimport { isVgRangeStep } from '../vega.schema';\nimport { buildModel } from './buildmodel';\nimport { assembleFacetData } from './data/assemble';\nimport { sortArrayIndexField } from './data/calculate';\nimport { parseData } from './data/parse';\nimport { assembleLabelTitle } from './header/assemble';\nimport { getHeaderChannel, getHeaderProperty } from './header/common';\nimport { HEADER_CHANNELS, HEADER_TYPES } from './header/component';\nimport { parseFacetHeaders } from './header/parse';\nimport { parseChildrenLayoutSize } from './layoutsize/parse';\nimport { ModelWithField } from './model';\nimport { assembleDomain, getFieldFromDomain } from './scale/domain';\nimport { assembleFacetSignals } from './selection/assemble';\nexport function facetSortFieldName(fieldDef, sort, opt) {\n  return vgField(sort, Object.assign({\n    suffix: `by_${vgField(fieldDef)}`\n  }, opt !== null && opt !== void 0 ? opt : {}));\n}\nexport class FacetModel extends ModelWithField {\n  constructor(spec, parent, parentGivenName, config) {\n    super(spec, 'facet', parent, parentGivenName, config, spec.resolve);\n    this.child = buildModel(spec.spec, this, this.getName('child'), undefined, config);\n    this.children = [this.child];\n    this.facet = this.initFacet(spec.facet);\n  }\n\n  initFacet(facet) {\n    // clone to prevent side effect to the original spec\n    if (!isFacetMapping(facet)) {\n      return {\n        facet: this.initFacetFieldDef(facet, 'facet')\n      };\n    }\n\n    const channels = keys(facet);\n    const normalizedFacet = {};\n\n    for (const channel of channels) {\n      if (![ROW, COLUMN].includes(channel)) {\n        // Drop unsupported channel\n        log.warn(log.message.incompatibleChannel(channel, 'facet'));\n        break;\n      }\n\n      const fieldDef = facet[channel];\n\n      if (fieldDef.field === undefined) {\n        log.warn(log.message.emptyFieldDef(fieldDef, channel));\n        break;\n      }\n\n      normalizedFacet[channel] = this.initFacetFieldDef(fieldDef, channel);\n    }\n\n    return normalizedFacet;\n  }\n\n  initFacetFieldDef(fieldDef, channel) {\n    // Cast because we call initFieldDef, which assumes general FieldDef.\n    // However, FacetFieldDef is a bit more constrained than the general FieldDef\n    const facetFieldDef = initFieldDef(fieldDef, channel);\n\n    if (facetFieldDef.header) {\n      facetFieldDef.header = replaceExprRef(facetFieldDef.header);\n    } else if (facetFieldDef.header === null) {\n      facetFieldDef.header = null;\n    }\n\n    return facetFieldDef;\n  }\n\n  channelHasField(channel) {\n    return !!this.facet[channel];\n  }\n\n  fieldDef(channel) {\n    return this.facet[channel];\n  }\n\n  parseData() {\n    this.component.data = parseData(this);\n    this.child.parseData();\n  }\n\n  parseLayoutSize() {\n    parseChildrenLayoutSize(this);\n  }\n\n  parseSelections() {\n    // As a facet has a single child, the selection components are the same.\n    // The child maintains its selections to assemble signals, which remain\n    // within its unit.\n    this.child.parseSelections();\n    this.component.selection = this.child.component.selection;\n  }\n\n  parseMarkGroup() {\n    this.child.parseMarkGroup();\n  }\n\n  parseAxesAndHeaders() {\n    this.child.parseAxesAndHeaders();\n    parseFacetHeaders(this);\n  }\n\n  assembleSelectionTopLevelSignals(signals) {\n    return this.child.assembleSelectionTopLevelSignals(signals);\n  }\n\n  assembleSignals() {\n    this.child.assembleSignals();\n    return [];\n  }\n\n  assembleSelectionData(data) {\n    return this.child.assembleSelectionData(data);\n  }\n\n  getHeaderLayoutMixins() {\n    var _a, _b, _c;\n\n    const layoutMixins = {};\n\n    for (const channel of FACET_CHANNELS) {\n      for (const headerType of HEADER_TYPES) {\n        const layoutHeaderComponent = this.component.layoutHeaders[channel];\n        const headerComponent = layoutHeaderComponent[headerType];\n        const {\n          facetFieldDef\n        } = layoutHeaderComponent;\n\n        if (facetFieldDef) {\n          const titleOrient = getHeaderProperty('titleOrient', facetFieldDef.header, this.config, channel);\n\n          if (['right', 'bottom'].includes(titleOrient)) {\n            const headerChannel = getHeaderChannel(channel, titleOrient);\n            (_a = layoutMixins.titleAnchor) !== null && _a !== void 0 ? _a : layoutMixins.titleAnchor = {};\n            layoutMixins.titleAnchor[headerChannel] = 'end';\n          }\n        }\n\n        if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent[0]) {\n          // set header/footerBand\n          const sizeType = channel === 'row' ? 'height' : 'width';\n          const bandType = headerType === 'header' ? 'headerBand' : 'footerBand';\n\n          if (channel !== 'facet' && !this.child.component.layoutSize.get(sizeType)) {\n            // If facet child does not have size signal, then apply headerBand\n            (_b = layoutMixins[bandType]) !== null && _b !== void 0 ? _b : layoutMixins[bandType] = {};\n            layoutMixins[bandType][channel] = 0.5;\n          }\n\n          if (layoutHeaderComponent.title) {\n            (_c = layoutMixins.offset) !== null && _c !== void 0 ? _c : layoutMixins.offset = {};\n            layoutMixins.offset[channel === 'row' ? 'rowTitle' : 'columnTitle'] = 10;\n          }\n        }\n      }\n    }\n\n    return layoutMixins;\n  }\n\n  assembleDefaultLayout() {\n    const {\n      column,\n      row\n    } = this.facet;\n    const columns = column ? this.columnDistinctSignal() : row ? 1 : undefined;\n    let align = 'all'; // Do not align the cells if the scale corresponding to the direction is indepent.\n    // We always align when we facet into both row and column.\n\n    if (!row && this.component.resolve.scale.x === 'independent') {\n      align = 'none';\n    } else if (!column && this.component.resolve.scale.y === 'independent') {\n      align = 'none';\n    }\n\n    return Object.assign(Object.assign(Object.assign({}, this.getHeaderLayoutMixins()), columns ? {\n      columns\n    } : {}), {\n      bounds: 'full',\n      align\n    });\n  }\n\n  assembleLayoutSignals() {\n    // FIXME(https://github.com/vega/vega-lite/issues/1193): this can be incorrect if we have independent scales.\n    return this.child.assembleLayoutSignals();\n  }\n\n  columnDistinctSignal() {\n    if (this.parent && this.parent instanceof FacetModel) {\n      // For nested facet, we will add columns to group mark instead\n      // See discussion in https://github.com/vega/vega/issues/952\n      // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n      return undefined;\n    } else {\n      // In facetNode.assemble(), the name is always this.getName('column') + '_layout'.\n      const facetLayoutDataName = this.getName('column_domain');\n      return {\n        signal: `length(data('${facetLayoutDataName}'))`\n      };\n    }\n  }\n\n  assembleGroupStyle() {\n    return undefined;\n  }\n\n  assembleGroup(signals) {\n    if (this.parent && this.parent instanceof FacetModel) {\n      // Provide number of columns for layout.\n      // See discussion in https://github.com/vega/vega/issues/952\n      // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n      return Object.assign(Object.assign({}, this.channelHasField('column') ? {\n        encode: {\n          update: {\n            // TODO(https://github.com/vega/vega-lite/issues/2759):\n            // Correct the signal for facet of concat of facet_column\n            columns: {\n              field: vgField(this.facet.column, {\n                prefix: 'distinct'\n              })\n            }\n          }\n        }\n      } : {}), super.assembleGroup(signals));\n    }\n\n    return super.assembleGroup(signals);\n  }\n  /**\n   * Aggregate cardinality for calculating size\n   */\n\n\n  getCardinalityAggregateForChild() {\n    const fields = [];\n    const ops = [];\n    const as = [];\n\n    if (this.child instanceof FacetModel) {\n      if (this.child.channelHasField('column')) {\n        const field = vgField(this.child.facet.column);\n        fields.push(field);\n        ops.push('distinct');\n        as.push(`distinct_${field}`);\n      }\n    } else {\n      for (const channel of POSITION_SCALE_CHANNELS) {\n        const childScaleComponent = this.child.component.scales[channel];\n\n        if (childScaleComponent && !childScaleComponent.merged) {\n          const type = childScaleComponent.get('type');\n          const range = childScaleComponent.get('range');\n\n          if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n            const domain = assembleDomain(this.child, channel);\n            const field = getFieldFromDomain(domain);\n\n            if (field) {\n              fields.push(field);\n              ops.push('distinct');\n              as.push(`distinct_${field}`);\n            } else {\n              log.warn(log.message.unknownField(channel));\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      fields,\n      ops,\n      as\n    };\n  }\n\n  assembleFacet() {\n    const {\n      name,\n      data\n    } = this.component.data.facetRoot;\n    const {\n      row,\n      column\n    } = this.facet;\n    const {\n      fields,\n      ops,\n      as\n    } = this.getCardinalityAggregateForChild();\n    const groupby = [];\n\n    for (const channel of FACET_CHANNELS) {\n      const fieldDef = this.facet[channel];\n\n      if (fieldDef) {\n        groupby.push(vgField(fieldDef));\n        const {\n          bin,\n          sort\n        } = fieldDef;\n\n        if (isBinning(bin)) {\n          groupby.push(vgField(fieldDef, {\n            binSuffix: 'end'\n          }));\n        }\n\n        if (isSortField(sort)) {\n          const {\n            field,\n            op = DEFAULT_SORT_OP\n          } = sort;\n          const outputName = facetSortFieldName(fieldDef, sort);\n\n          if (row && column) {\n            // For crossed facet, use pre-calculate field as it requires a different groupby\n            // For each calculated field, apply max and assign them to the same name as\n            // all values of the same group should be the same anyway.\n            fields.push(outputName);\n            ops.push('max');\n            as.push(outputName);\n          } else {\n            fields.push(field);\n            ops.push(op);\n            as.push(outputName);\n          }\n        } else if (isArray(sort)) {\n          const outputName = sortArrayIndexField(fieldDef, channel);\n          fields.push(outputName);\n          ops.push('max');\n          as.push(outputName);\n        }\n      }\n    }\n\n    const cross = !!row && !!column;\n    return Object.assign({\n      name,\n      data,\n      groupby\n    }, cross || fields.length > 0 ? {\n      aggregate: Object.assign(Object.assign({}, cross ? {\n        cross\n      } : {}), fields.length ? {\n        fields,\n        ops,\n        as\n      } : {})\n    } : {});\n  }\n\n  facetSortFields(channel) {\n    const {\n      facet\n    } = this;\n    const fieldDef = facet[channel];\n\n    if (fieldDef) {\n      if (isSortField(fieldDef.sort)) {\n        return [facetSortFieldName(fieldDef, fieldDef.sort, {\n          expr: 'datum'\n        })];\n      } else if (isArray(fieldDef.sort)) {\n        return [sortArrayIndexField(fieldDef, channel, {\n          expr: 'datum'\n        })];\n      }\n\n      return [vgField(fieldDef, {\n        expr: 'datum'\n      })];\n    }\n\n    return [];\n  }\n\n  facetSortOrder(channel) {\n    const {\n      facet\n    } = this;\n    const fieldDef = facet[channel];\n\n    if (fieldDef) {\n      const {\n        sort\n      } = fieldDef;\n      const order = (isSortField(sort) ? sort.order : !isArray(sort) && sort) || 'ascending';\n      return [order];\n    }\n\n    return [];\n  }\n\n  assembleLabelTitle() {\n    var _a;\n\n    const {\n      facet,\n      config\n    } = this;\n\n    if (facet.facet) {\n      // Facet always uses title to display labels\n      return assembleLabelTitle(facet.facet, 'facet', config);\n    }\n\n    const ORTHOGONAL_ORIENT = {\n      row: ['top', 'bottom'],\n      column: ['left', 'right']\n    };\n\n    for (const channel of HEADER_CHANNELS) {\n      if (facet[channel]) {\n        const labelOrient = getHeaderProperty('labelOrient', (_a = facet[channel]) === null || _a === void 0 ? void 0 : _a.header, config, channel);\n\n        if (ORTHOGONAL_ORIENT[channel].includes(labelOrient)) {\n          // Row/Column with orthogonal labelOrient must use title to display labels\n          return assembleLabelTitle(facet[channel], channel, config);\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  assembleMarks() {\n    const {\n      child\n    } = this; // If we facet by two dimensions, we need to add a cross operator to the aggregation\n    // so that we create all groups\n\n    const facetRoot = this.component.data.facetRoot;\n    const data = assembleFacetData(facetRoot);\n    const encodeEntry = child.assembleGroupEncodeEntry(false);\n    const title = this.assembleLabelTitle() || child.assembleTitle();\n    const style = child.assembleGroupStyle();\n    const markGroup = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n      name: this.getName('cell'),\n      type: 'group'\n    }, title ? {\n      title\n    } : {}), style ? {\n      style\n    } : {}), {\n      from: {\n        facet: this.assembleFacet()\n      },\n      // TODO: move this to after data\n      sort: {\n        field: FACET_CHANNELS.map(c => this.facetSortFields(c)).flat(),\n        order: FACET_CHANNELS.map(c => this.facetSortOrder(c)).flat()\n      }\n    }), data.length > 0 ? {\n      data\n    } : {}), encodeEntry ? {\n      encode: {\n        update: encodeEntry\n      }\n    } : {}), child.assembleGroup(assembleFacetSignals(this, [])));\n    return [markGroup];\n  }\n\n  getMapping() {\n    return this.facet;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["isArray","isBinning","COLUMN","FACET_CHANNELS","POSITION_SCALE_CHANNELS","ROW","initFieldDef","vgField","replaceExprRef","log","hasDiscreteDomain","DEFAULT_SORT_OP","isSortField","isFacetMapping","keys","isVgRangeStep","buildModel","assembleFacetData","sortArrayIndexField","parseData","assembleLabelTitle","getHeaderChannel","getHeaderProperty","HEADER_CHANNELS","HEADER_TYPES","parseFacetHeaders","parseChildrenLayoutSize","ModelWithField","assembleDomain","getFieldFromDomain","assembleFacetSignals","facetSortFieldName","fieldDef","sort","opt","Object","suffix","FacetModel","constructor","spec","parent","parentGivenName","config","resolve","child","getName","undefined","children","facet","initFacet","initFacetFieldDef","channels","normalizedFacet","channel","includes","warn","message","incompatibleChannel","field","emptyFieldDef","facetFieldDef","header","channelHasField","component","data","parseLayoutSize","parseSelections","selection","parseMarkGroup","parseAxesAndHeaders","assembleSelectionTopLevelSignals","signals","assembleSignals","assembleSelectionData","getHeaderLayoutMixins","layoutMixins","headerType","layoutHeaderComponent","layoutHeaders","headerComponent","titleOrient","headerChannel","titleAnchor","_a","sizeType","bandType","layoutSize","get","_b","title","offset","_c","assembleDefaultLayout","column","row","columns","columnDistinctSignal","align","scale","x","y","bounds","assembleLayoutSignals","facetLayoutDataName","signal","assembleGroupStyle","assembleGroup","encode","update","prefix","getCardinalityAggregateForChild","fields","ops","as","push","childScaleComponent","scales","merged","type","range","domain","unknownField","assembleFacet","name","facetRoot","groupby","bin","binSuffix","op","outputName","cross","length","aggregate","facetSortFields","expr","facetSortOrder","order","ORTHOGONAL_ORIENT","labelOrient","assembleMarks","encodeEntry","assembleGroupEncodeEntry","assembleTitle","style","markGroup","from","map","c","flat","getMapping"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/facet.ts"],"sourcesContent":["import {AggregateOp, LayoutAlign, NewSignal, SignalRef} from 'vega';\nimport {isArray} from 'vega-util';\nimport {isBinning} from '../bin';\nimport {COLUMN, ExtendedChannel, FacetChannel, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW} from '../channel';\nimport {FieldName, FieldRefOption, initFieldDef, TypedFieldDef, vgField} from '../channeldef';\nimport {Config} from '../config';\nimport {ExprRef, replaceExprRef} from '../expr';\nimport * as log from '../log';\nimport {hasDiscreteDomain} from '../scale';\nimport {DEFAULT_SORT_OP, EncodingSortField, isSortField, SortOrder} from '../sort';\nimport {NormalizedFacetSpec} from '../spec';\nimport {EncodingFacetMapping, FacetFieldDef, FacetMapping, isFacetMapping} from '../spec/facet';\nimport {keys} from '../util';\nimport {isVgRangeStep, VgData, VgLayout, VgMarkGroup} from '../vega.schema';\nimport {buildModel} from './buildmodel';\nimport {assembleFacetData} from './data/assemble';\nimport {sortArrayIndexField} from './data/calculate';\nimport {parseData} from './data/parse';\nimport {assembleLabelTitle} from './header/assemble';\nimport {getHeaderChannel, getHeaderProperty} from './header/common';\nimport {HEADER_CHANNELS, HEADER_TYPES} from './header/component';\nimport {parseFacetHeaders} from './header/parse';\nimport {parseChildrenLayoutSize} from './layoutsize/parse';\nimport {Model, ModelWithField} from './model';\nimport {assembleDomain, getFieldFromDomain} from './scale/domain';\nimport {assembleFacetSignals} from './selection/assemble';\n\nexport function facetSortFieldName(\n  fieldDef: FacetFieldDef<string>,\n  sort: EncodingSortField<string>,\n  opt?: FieldRefOption\n) {\n  return vgField(sort, {suffix: `by_${vgField(fieldDef)}`, ...(opt ?? {})});\n}\n\nexport class FacetModel extends ModelWithField {\n  public readonly facet: EncodingFacetMapping<string, SignalRef>;\n\n  public readonly child: Model;\n\n  public readonly children: Model[];\n\n  constructor(spec: NormalizedFacetSpec, parent: Model, parentGivenName: string, config: Config<SignalRef>) {\n    super(spec, 'facet', parent, parentGivenName, config, spec.resolve);\n\n    this.child = buildModel(spec.spec, this, this.getName('child'), undefined, config);\n    this.children = [this.child];\n\n    this.facet = this.initFacet(spec.facet);\n  }\n\n  private initFacet(\n    facet: FacetFieldDef<FieldName> | FacetMapping<FieldName>\n  ): EncodingFacetMapping<FieldName, SignalRef> {\n    // clone to prevent side effect to the original spec\n    if (!isFacetMapping(facet)) {\n      return {facet: this.initFacetFieldDef(facet, 'facet')};\n    }\n\n    const channels = keys(facet);\n    const normalizedFacet = {};\n    for (const channel of channels) {\n      if (![ROW, COLUMN].includes(channel)) {\n        // Drop unsupported channel\n        log.warn(log.message.incompatibleChannel(channel, 'facet'));\n        break;\n      }\n\n      const fieldDef = facet[channel];\n      if (fieldDef.field === undefined) {\n        log.warn(log.message.emptyFieldDef(fieldDef, channel));\n        break;\n      }\n\n      normalizedFacet[channel] = this.initFacetFieldDef(fieldDef, channel);\n    }\n\n    return normalizedFacet;\n  }\n\n  private initFacetFieldDef(fieldDef: FacetFieldDef<FieldName, ExprRef | SignalRef>, channel: FacetChannel) {\n    // Cast because we call initFieldDef, which assumes general FieldDef.\n    // However, FacetFieldDef is a bit more constrained than the general FieldDef\n    const facetFieldDef = initFieldDef(fieldDef, channel) as FacetFieldDef<FieldName, SignalRef>;\n    if (facetFieldDef.header) {\n      facetFieldDef.header = replaceExprRef(facetFieldDef.header);\n    } else if (facetFieldDef.header === null) {\n      facetFieldDef.header = null;\n    }\n    return facetFieldDef;\n  }\n\n  public channelHasField(channel: ExtendedChannel): boolean {\n    return !!this.facet[channel];\n  }\n\n  public fieldDef(channel: ExtendedChannel): TypedFieldDef<string> {\n    return this.facet[channel];\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n    this.child.parseData();\n  }\n\n  public parseLayoutSize() {\n    parseChildrenLayoutSize(this);\n  }\n\n  public parseSelections() {\n    // As a facet has a single child, the selection components are the same.\n    // The child maintains its selections to assemble signals, which remain\n    // within its unit.\n    this.child.parseSelections();\n    this.component.selection = this.child.component.selection;\n  }\n\n  public parseMarkGroup() {\n    this.child.parseMarkGroup();\n  }\n\n  public parseAxesAndHeaders() {\n    this.child.parseAxesAndHeaders();\n\n    parseFacetHeaders(this);\n  }\n\n  public assembleSelectionTopLevelSignals(signals: NewSignal[]): NewSignal[] {\n    return this.child.assembleSelectionTopLevelSignals(signals);\n  }\n\n  public assembleSignals(): NewSignal[] {\n    this.child.assembleSignals();\n    return [];\n  }\n\n  public assembleSelectionData(data: readonly VgData[]): readonly VgData[] {\n    return this.child.assembleSelectionData(data);\n  }\n\n  private getHeaderLayoutMixins(): VgLayout {\n    const layoutMixins: VgLayout = {};\n\n    for (const channel of FACET_CHANNELS) {\n      for (const headerType of HEADER_TYPES) {\n        const layoutHeaderComponent = this.component.layoutHeaders[channel];\n        const headerComponent = layoutHeaderComponent[headerType];\n\n        const {facetFieldDef} = layoutHeaderComponent;\n        if (facetFieldDef) {\n          const titleOrient = getHeaderProperty('titleOrient', facetFieldDef.header, this.config, channel);\n\n          if (['right', 'bottom'].includes(titleOrient)) {\n            const headerChannel = getHeaderChannel(channel, titleOrient);\n            layoutMixins.titleAnchor ??= {};\n            layoutMixins.titleAnchor[headerChannel] = 'end';\n          }\n        }\n\n        if (headerComponent?.[0]) {\n          // set header/footerBand\n          const sizeType = channel === 'row' ? 'height' : 'width';\n          const bandType = headerType === 'header' ? 'headerBand' : 'footerBand';\n          if (channel !== 'facet' && !this.child.component.layoutSize.get(sizeType)) {\n            // If facet child does not have size signal, then apply headerBand\n            layoutMixins[bandType] ??= {};\n            layoutMixins[bandType][channel] = 0.5;\n          }\n\n          if (layoutHeaderComponent.title) {\n            layoutMixins.offset ??= {};\n            layoutMixins.offset[channel === 'row' ? 'rowTitle' : 'columnTitle'] = 10;\n          }\n        }\n      }\n    }\n    return layoutMixins;\n  }\n\n  protected assembleDefaultLayout(): VgLayout {\n    const {column, row} = this.facet;\n\n    const columns = column ? this.columnDistinctSignal() : row ? 1 : undefined;\n\n    let align: LayoutAlign = 'all';\n\n    // Do not align the cells if the scale corresponding to the direction is indepent.\n    // We always align when we facet into both row and column.\n    if (!row && this.component.resolve.scale.x === 'independent') {\n      align = 'none';\n    } else if (!column && this.component.resolve.scale.y === 'independent') {\n      align = 'none';\n    }\n\n    return {\n      ...this.getHeaderLayoutMixins(),\n\n      ...(columns ? {columns} : {}),\n      bounds: 'full',\n      align\n    };\n  }\n\n  public assembleLayoutSignals(): NewSignal[] {\n    // FIXME(https://github.com/vega/vega-lite/issues/1193): this can be incorrect if we have independent scales.\n    return this.child.assembleLayoutSignals();\n  }\n\n  private columnDistinctSignal() {\n    if (this.parent && this.parent instanceof FacetModel) {\n      // For nested facet, we will add columns to group mark instead\n      // See discussion in https://github.com/vega/vega/issues/952\n      // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n      return undefined;\n    } else {\n      // In facetNode.assemble(), the name is always this.getName('column') + '_layout'.\n      const facetLayoutDataName = this.getName('column_domain');\n      return {signal: `length(data('${facetLayoutDataName}'))`};\n    }\n  }\n\n  public assembleGroupStyle(): string | string[] {\n    return undefined;\n  }\n\n  public assembleGroup(signals: NewSignal[]) {\n    if (this.parent && this.parent instanceof FacetModel) {\n      // Provide number of columns for layout.\n      // See discussion in https://github.com/vega/vega/issues/952\n      // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n      return {\n        ...(this.channelHasField('column')\n          ? {\n              encode: {\n                update: {\n                  // TODO(https://github.com/vega/vega-lite/issues/2759):\n                  // Correct the signal for facet of concat of facet_column\n                  columns: {field: vgField(this.facet.column, {prefix: 'distinct'})}\n                }\n              }\n            }\n          : {}),\n        ...super.assembleGroup(signals)\n      };\n    }\n    return super.assembleGroup(signals);\n  }\n\n  /**\n   * Aggregate cardinality for calculating size\n   */\n  private getCardinalityAggregateForChild() {\n    const fields: string[] = [];\n    const ops: AggregateOp[] = [];\n    const as: string[] = [];\n\n    if (this.child instanceof FacetModel) {\n      if (this.child.channelHasField('column')) {\n        const field = vgField(this.child.facet.column);\n        fields.push(field);\n        ops.push('distinct');\n        as.push(`distinct_${field}`);\n      }\n    } else {\n      for (const channel of POSITION_SCALE_CHANNELS) {\n        const childScaleComponent = this.child.component.scales[channel];\n        if (childScaleComponent && !childScaleComponent.merged) {\n          const type = childScaleComponent.get('type');\n          const range = childScaleComponent.get('range');\n\n          if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n            const domain = assembleDomain(this.child, channel);\n            const field = getFieldFromDomain(domain);\n            if (field) {\n              fields.push(field);\n              ops.push('distinct');\n              as.push(`distinct_${field}`);\n            } else {\n              log.warn(log.message.unknownField(channel));\n            }\n          }\n        }\n      }\n    }\n    return {fields, ops, as};\n  }\n\n  private assembleFacet() {\n    const {name, data} = this.component.data.facetRoot;\n    const {row, column} = this.facet;\n    const {fields, ops, as} = this.getCardinalityAggregateForChild();\n    const groupby: string[] = [];\n\n    for (const channel of FACET_CHANNELS) {\n      const fieldDef = this.facet[channel];\n      if (fieldDef) {\n        groupby.push(vgField(fieldDef));\n\n        const {bin, sort} = fieldDef;\n\n        if (isBinning(bin)) {\n          groupby.push(vgField(fieldDef, {binSuffix: 'end'}));\n        }\n\n        if (isSortField(sort)) {\n          const {field, op = DEFAULT_SORT_OP} = sort;\n          const outputName = facetSortFieldName(fieldDef, sort);\n          if (row && column) {\n            // For crossed facet, use pre-calculate field as it requires a different groupby\n            // For each calculated field, apply max and assign them to the same name as\n            // all values of the same group should be the same anyway.\n            fields.push(outputName);\n            ops.push('max');\n            as.push(outputName);\n          } else {\n            fields.push(field);\n            ops.push(op);\n            as.push(outputName);\n          }\n        } else if (isArray(sort)) {\n          const outputName = sortArrayIndexField(fieldDef, channel);\n          fields.push(outputName);\n          ops.push('max');\n          as.push(outputName);\n        }\n      }\n    }\n\n    const cross = !!row && !!column;\n\n    return {\n      name,\n      data,\n      groupby,\n      ...(cross || fields.length > 0\n        ? {\n            aggregate: {\n              ...(cross ? {cross} : {}),\n              ...(fields.length ? {fields, ops, as} : {})\n            }\n          }\n        : {})\n    };\n  }\n\n  private facetSortFields(channel: FacetChannel): string[] {\n    const {facet} = this;\n    const fieldDef = facet[channel];\n\n    if (fieldDef) {\n      if (isSortField(fieldDef.sort)) {\n        return [facetSortFieldName(fieldDef, fieldDef.sort, {expr: 'datum'})];\n      } else if (isArray(fieldDef.sort)) {\n        return [sortArrayIndexField(fieldDef, channel, {expr: 'datum'})];\n      }\n      return [vgField(fieldDef, {expr: 'datum'})];\n    }\n    return [];\n  }\n\n  private facetSortOrder(channel: FacetChannel): SortOrder[] {\n    const {facet} = this;\n    const fieldDef = facet[channel];\n    if (fieldDef) {\n      const {sort} = fieldDef;\n      const order = (isSortField(sort) ? sort.order : !isArray(sort) && sort) || 'ascending';\n      return [order];\n    }\n    return [];\n  }\n\n  private assembleLabelTitle() {\n    const {facet, config} = this;\n    if (facet.facet) {\n      // Facet always uses title to display labels\n      return assembleLabelTitle(facet.facet, 'facet', config);\n    }\n\n    const ORTHOGONAL_ORIENT = {\n      row: ['top', 'bottom'],\n      column: ['left', 'right']\n    };\n\n    for (const channel of HEADER_CHANNELS) {\n      if (facet[channel]) {\n        const labelOrient = getHeaderProperty('labelOrient', facet[channel]?.header, config, channel);\n        if (ORTHOGONAL_ORIENT[channel].includes(labelOrient)) {\n          // Row/Column with orthogonal labelOrient must use title to display labels\n          return assembleLabelTitle(facet[channel], channel, config);\n        }\n      }\n    }\n    return undefined;\n  }\n\n  public assembleMarks(): VgMarkGroup[] {\n    const {child} = this;\n\n    // If we facet by two dimensions, we need to add a cross operator to the aggregation\n    // so that we create all groups\n    const facetRoot = this.component.data.facetRoot;\n    const data = assembleFacetData(facetRoot);\n\n    const encodeEntry = child.assembleGroupEncodeEntry(false);\n\n    const title = this.assembleLabelTitle() || child.assembleTitle();\n    const style = child.assembleGroupStyle();\n\n    const markGroup = {\n      name: this.getName('cell'),\n      type: 'group',\n      ...(title ? {title} : {}),\n      ...(style ? {style} : {}),\n      from: {\n        facet: this.assembleFacet()\n      },\n      // TODO: move this to after data\n      sort: {\n        field: FACET_CHANNELS.map(c => this.facetSortFields(c)).flat(),\n        order: FACET_CHANNELS.map(c => this.facetSortOrder(c)).flat()\n      },\n      ...(data.length > 0 ? {data} : {}),\n      ...(encodeEntry ? {encode: {update: encodeEntry}} : {}),\n      ...child.assembleGroup(assembleFacetSignals(this, []))\n    };\n\n    return [markGroup];\n  }\n\n  protected getMapping() {\n    return this.facet;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}