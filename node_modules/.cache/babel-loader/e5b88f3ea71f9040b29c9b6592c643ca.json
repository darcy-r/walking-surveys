{"ast":null,"code":"import { Transform, isTuple, ingest, tupleid, stableCompare } from 'vega-dataflow';\nimport { inherits, error, array, one, truthy, hasOwnProperty } from 'vega-util';\nimport { hierarchy, pack, partition, stratify, tree, cluster, treemap, treemapBinary, treemapDice, treemapSlice, treemapSliceDice, treemapSquarify, treemapResquarify } from 'd3-hierarchy'; // Build lookup table mapping tuple keys to tree node instances\n\nfunction lookup(tree, key, filter) {\n  const map = {};\n  tree.each(node => {\n    const t = node.data;\n    if (filter(t)) map[key(t)] = node;\n  });\n  tree.lookup = map;\n  return tree;\n}\n/**\n * Nest tuples into a tree structure, grouped by key values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.keys - The key fields to nest by, in order.\n * @param {boolean} [params.generate=false] - A boolean flag indicating if\n *   non-leaf nodes generated by this transform should be included in the\n *   output. The default (false) includes only the input data (leaf nodes)\n *   in the data stream.\n */\n\n\nfunction Nest(params) {\n  Transform.call(this, null, params);\n}\n\nNest.Definition = {\n  'type': 'Nest',\n  'metadata': {\n    'treesource': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'keys',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'generate',\n    'type': 'boolean'\n  }]\n};\n\nconst children = n => n.values;\n\ninherits(Nest, Transform, {\n  transform(_, pulse) {\n    if (!pulse.source) {\n      error('Nest transform requires an upstream data source.');\n    }\n\n    var gen = _.generate,\n        mod = _.modified(),\n        out = pulse.clone(),\n        tree = this.value;\n\n    if (!tree || mod || pulse.changed()) {\n      // collect nodes to remove\n      if (tree) {\n        tree.each(node => {\n          if (node.children && isTuple(node.data)) {\n            out.rem.push(node.data);\n          }\n        });\n      } // generate new tree structure\n\n\n      this.value = tree = hierarchy({\n        values: array(_.keys).reduce((n, k) => {\n          n.key(k);\n          return n;\n        }, nest()).entries(out.source)\n      }, children); // collect nodes to add\n\n      if (gen) {\n        tree.each(node => {\n          if (node.children) {\n            node = ingest(node.data);\n            out.add.push(node);\n            out.source.push(node);\n          }\n        });\n      } // build lookup table\n\n\n      lookup(tree, tupleid, tupleid);\n    }\n\n    out.source.root = tree;\n    return out;\n  }\n\n});\n\nfunction nest() {\n  const keys = [],\n        nest = {\n    entries: array => entries(apply(array, 0), 0),\n    key: d => (keys.push(d), nest)\n  };\n\n  function apply(array, depth) {\n    if (depth >= keys.length) {\n      return array;\n    }\n\n    const n = array.length,\n          key = keys[depth++],\n          valuesByKey = {},\n          result = {};\n    let i = -1,\n        keyValue,\n        value,\n        values;\n\n    while (++i < n) {\n      keyValue = key(value = array[i]) + '';\n\n      if (values = valuesByKey[keyValue]) {\n        values.push(value);\n      } else {\n        valuesByKey[keyValue] = [value];\n      }\n    }\n\n    for (keyValue in valuesByKey) {\n      result[keyValue] = apply(valuesByKey[keyValue], depth);\n    }\n\n    return result;\n  }\n\n  function entries(map, depth) {\n    if (++depth > keys.length) return map;\n    const array = [];\n\n    for (const key in map) {\n      array.push({\n        key,\n        values: entries(map[key], depth)\n      });\n    }\n\n    return array;\n  }\n\n  return nest;\n}\n/**\n * Abstract class for tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\n\nfunction HierarchyLayout(params) {\n  Transform.call(this, null, params);\n}\n\nconst defaultSeparation = (a, b) => a.parent === b.parent ? 1 : 2;\n\ninherits(HierarchyLayout, Transform, {\n  transform(_, pulse) {\n    if (!pulse.source || !pulse.source.root) {\n      error(this.constructor.name + ' transform requires a backing tree data source.');\n    }\n\n    const layout = this.layout(_.method),\n          fields = this.fields,\n          root = pulse.source.root,\n          as = _.as || fields;\n    if (_.field) root.sum(_.field);else root.count();\n    if (_.sort) root.sort(stableCompare(_.sort, d => d.data));\n    setParams(layout, this.params, _);\n\n    if (layout.separation) {\n      layout.separation(_.separation !== false ? defaultSeparation : one);\n    }\n\n    try {\n      this.value = layout(root);\n    } catch (err) {\n      error(err);\n    }\n\n    root.each(node => setFields(node, fields, as));\n    return pulse.reflow(_.modified()).modifies(as).modifies('leaf');\n  }\n\n});\n\nfunction setParams(layout, params, _) {\n  for (let p, i = 0, n = params.length; i < n; ++i) {\n    p = params[i];\n    if (p in _) layout[p](_[p]);\n  }\n}\n\nfunction setFields(node, fields, as) {\n  const t = node.data,\n        n = fields.length - 1;\n\n  for (let i = 0; i < n; ++i) {\n    t[as[i]] = node[fields[i]];\n  }\n\n  t[as[n]] = node.children ? node.children.length : 0;\n}\n\nconst Output$3 = ['x', 'y', 'r', 'depth', 'children'];\n/**\n * Packed circle tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Pack(params) {\n  HierarchyLayout.call(this, params);\n}\n\nPack.Definition = {\n  'type': 'Pack',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'radius',\n    'type': 'field',\n    'default': null\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$3.length,\n    'default': Output$3\n  }]\n};\ninherits(Pack, HierarchyLayout, {\n  layout: pack,\n  params: ['radius', 'size', 'padding'],\n  fields: Output$3\n});\nconst Output$2 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\n/**\n * Partition tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Partition(params) {\n  HierarchyLayout.call(this, params);\n}\n\nPartition.Definition = {\n  'type': 'Partition',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'round',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$2.length,\n    'default': Output$2\n  }]\n};\ninherits(Partition, HierarchyLayout, {\n  layout: partition,\n  params: ['size', 'round', 'padding'],\n  fields: Output$2\n});\n/**\n * Stratify a collection of tuples into a tree structure based on\n * id and parent id fields.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.key - Unique key field for each tuple.\n * @param {function(object): *} params.parentKey - Field with key for parent tuple.\n */\n\nfunction Stratify(params) {\n  Transform.call(this, null, params);\n}\n\nStratify.Definition = {\n  'type': 'Stratify',\n  'metadata': {\n    'treesource': true\n  },\n  'params': [{\n    'name': 'key',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'parentKey',\n    'type': 'field',\n    'required': true\n  }]\n};\ninherits(Stratify, Transform, {\n  transform(_, pulse) {\n    if (!pulse.source) {\n      error('Stratify transform requires an upstream data source.');\n    }\n\n    let tree = this.value;\n\n    const mod = _.modified(),\n          out = pulse.fork(pulse.ALL).materialize(pulse.SOURCE),\n          run = !tree || mod || pulse.changed(pulse.ADD_REM) || pulse.modified(_.key.fields) || pulse.modified(_.parentKey.fields); // prevent upstream source pollution\n\n\n    out.source = out.source.slice();\n\n    if (run) {\n      tree = out.source.length ? lookup(stratify().id(_.key).parentId(_.parentKey)(out.source), _.key, truthy) : lookup(stratify()([{}]), _.key, _.key);\n    }\n\n    out.source.root = this.value = tree;\n    return out;\n  }\n\n});\nconst Layouts = {\n  tidy: tree,\n  cluster: cluster\n};\nconst Output$1 = ['x', 'y', 'depth', 'children'];\n/**\n * Tree layout. Depending on the method parameter, performs either\n * Reingold-Tilford 'tidy' layout or dendrogram 'cluster' layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction Tree(params) {\n  HierarchyLayout.call(this, params);\n}\n\nTree.Definition = {\n  'type': 'Tree',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'method',\n    'type': 'enum',\n    'default': 'tidy',\n    'values': ['tidy', 'cluster']\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'nodeSize',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'separation',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$1.length,\n    'default': Output$1\n  }]\n};\ninherits(Tree, HierarchyLayout, {\n  /**\n   * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.\n   */\n  layout(method) {\n    const m = method || 'tidy';\n    if (hasOwnProperty(Layouts, m)) return Layouts[m]();else error('Unrecognized Tree layout method: ' + m);\n  },\n\n  params: ['size', 'nodeSize'],\n  fields: Output$1\n});\n/**\n * Generate tuples representing links between tree nodes.\n * The resulting tuples will contain 'source' and 'target' fields,\n * which point to parent and child node tuples, respectively.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction TreeLinks(params) {\n  Transform.call(this, [], params);\n}\n\nTreeLinks.Definition = {\n  'type': 'TreeLinks',\n  'metadata': {\n    'tree': true,\n    'generates': true,\n    'changes': true\n  },\n  'params': []\n};\ninherits(TreeLinks, Transform, {\n  transform(_, pulse) {\n    const links = this.value,\n          tree = pulse.source && pulse.source.root,\n          out = pulse.fork(pulse.NO_SOURCE),\n          lut = {};\n    if (!tree) error('TreeLinks transform requires a tree data source.');\n\n    if (pulse.changed(pulse.ADD_REM)) {\n      // remove previous links\n      out.rem = links; // build lookup table of valid tuples\n\n      pulse.visit(pulse.SOURCE, t => lut[tupleid(t)] = 1); // generate links for all edges incident on valid tuples\n\n      tree.each(node => {\n        const t = node.data,\n              p = node.parent && node.parent.data;\n\n        if (p && lut[tupleid(t)] && lut[tupleid(p)]) {\n          out.add.push(ingest({\n            source: p,\n            target: t\n          }));\n        }\n      });\n      this.value = out.add;\n    } else if (pulse.changed(pulse.MOD)) {\n      // build lookup table of modified tuples\n      pulse.visit(pulse.MOD, t => lut[tupleid(t)] = 1); // gather links incident on modified tuples\n\n      links.forEach(link => {\n        if (lut[tupleid(link.source)] || lut[tupleid(link.target)]) {\n          out.mod.push(link);\n        }\n      });\n    }\n\n    return out;\n  }\n\n});\nconst Tiles = {\n  binary: treemapBinary,\n  dice: treemapDice,\n  slice: treemapSlice,\n  slicedice: treemapSliceDice,\n  squarify: treemapSquarify,\n  resquarify: treemapResquarify\n};\nconst Output = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\n/**\n * Treemap layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Treemap(params) {\n  HierarchyLayout.call(this, params);\n}\n\nTreemap.Definition = {\n  'type': 'Treemap',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'method',\n    'type': 'enum',\n    'default': 'squarify',\n    'values': ['squarify', 'resquarify', 'binary', 'dice', 'slice', 'slicedice']\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingInner',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingOuter',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingTop',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingRight',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingBottom',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingLeft',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'ratio',\n    'type': 'number',\n    'default': 1.618033988749895\n  }, {\n    'name': 'round',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output.length,\n    'default': Output\n  }]\n};\ninherits(Treemap, HierarchyLayout, {\n  /**\n   * Treemap layout generator. Adds 'method' and 'ratio' parameters\n   * to configure the underlying tile method.\n   */\n  layout() {\n    const x = treemap();\n\n    x.ratio = _ => {\n      const t = x.tile();\n      if (t.ratio) x.tile(t.ratio(_));\n    };\n\n    x.method = _ => {\n      if (hasOwnProperty(Tiles, _)) x.tile(Tiles[_]);else error('Unrecognized Treemap layout method: ' + _);\n    };\n\n    return x;\n  },\n\n  params: ['method', 'ratio', 'size', 'round', 'padding', 'paddingInner', 'paddingOuter', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'],\n  fields: Output\n});\nexport { Nest as nest, Pack as pack, Partition as partition, Stratify as stratify, Tree as tree, TreeLinks as treelinks, Treemap as treemap };","map":{"version":3,"names":["Transform","isTuple","ingest","tupleid","stableCompare","inherits","error","array","one","truthy","hasOwnProperty","hierarchy","pack","partition","stratify","tree","cluster","treemap","treemapBinary","treemapDice","treemapSlice","treemapSliceDice","treemapSquarify","treemapResquarify","lookup","key","filter","map","each","node","t","data","Nest","params","call","Definition","children","n","values","transform","_","pulse","source","gen","generate","mod","modified","out","clone","value","changed","rem","push","keys","reduce","k","nest","entries","add","root","apply","d","depth","length","valuesByKey","result","i","keyValue","HierarchyLayout","defaultSeparation","a","b","parent","constructor","name","layout","method","fields","as","field","sum","count","sort","setParams","separation","err","setFields","reflow","modifies","p","Output$3","Pack","Output$2","Partition","Stratify","fork","ALL","materialize","SOURCE","run","ADD_REM","parentKey","slice","id","parentId","Layouts","tidy","Output$1","Tree","m","TreeLinks","links","NO_SOURCE","lut","visit","target","MOD","forEach","link","Tiles","binary","dice","slicedice","squarify","resquarify","Output","Treemap","x","ratio","tile","treelinks"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-hierarchy/build/vega-hierarchy.module.js"],"sourcesContent":["import { Transform, isTuple, ingest, tupleid, stableCompare } from 'vega-dataflow';\nimport { inherits, error, array, one, truthy, hasOwnProperty } from 'vega-util';\nimport { hierarchy, pack, partition, stratify, tree, cluster, treemap, treemapBinary, treemapDice, treemapSlice, treemapSliceDice, treemapSquarify, treemapResquarify } from 'd3-hierarchy';\n\n// Build lookup table mapping tuple keys to tree node instances\nfunction lookup (tree, key, filter) {\n  const map = {};\n  tree.each(node => {\n    const t = node.data;\n    if (filter(t)) map[key(t)] = node;\n  });\n  tree.lookup = map;\n  return tree;\n}\n\n/**\n * Nest tuples into a tree structure, grouped by key values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.keys - The key fields to nest by, in order.\n * @param {boolean} [params.generate=false] - A boolean flag indicating if\n *   non-leaf nodes generated by this transform should be included in the\n *   output. The default (false) includes only the input data (leaf nodes)\n *   in the data stream.\n */\n\nfunction Nest(params) {\n  Transform.call(this, null, params);\n}\nNest.Definition = {\n  'type': 'Nest',\n  'metadata': {\n    'treesource': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'keys',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'generate',\n    'type': 'boolean'\n  }]\n};\n\nconst children = n => n.values;\n\ninherits(Nest, Transform, {\n  transform(_, pulse) {\n    if (!pulse.source) {\n      error('Nest transform requires an upstream data source.');\n    }\n\n    var gen = _.generate,\n        mod = _.modified(),\n        out = pulse.clone(),\n        tree = this.value;\n\n    if (!tree || mod || pulse.changed()) {\n      // collect nodes to remove\n      if (tree) {\n        tree.each(node => {\n          if (node.children && isTuple(node.data)) {\n            out.rem.push(node.data);\n          }\n        });\n      } // generate new tree structure\n\n\n      this.value = tree = hierarchy({\n        values: array(_.keys).reduce((n, k) => {\n          n.key(k);\n          return n;\n        }, nest()).entries(out.source)\n      }, children); // collect nodes to add\n\n      if (gen) {\n        tree.each(node => {\n          if (node.children) {\n            node = ingest(node.data);\n            out.add.push(node);\n            out.source.push(node);\n          }\n        });\n      } // build lookup table\n\n\n      lookup(tree, tupleid, tupleid);\n    }\n\n    out.source.root = tree;\n    return out;\n  }\n\n});\n\nfunction nest() {\n  const keys = [],\n        nest = {\n    entries: array => entries(apply(array, 0), 0),\n    key: d => (keys.push(d), nest)\n  };\n\n  function apply(array, depth) {\n    if (depth >= keys.length) {\n      return array;\n    }\n\n    const n = array.length,\n          key = keys[depth++],\n          valuesByKey = {},\n          result = {};\n    let i = -1,\n        keyValue,\n        value,\n        values;\n\n    while (++i < n) {\n      keyValue = key(value = array[i]) + '';\n\n      if (values = valuesByKey[keyValue]) {\n        values.push(value);\n      } else {\n        valuesByKey[keyValue] = [value];\n      }\n    }\n\n    for (keyValue in valuesByKey) {\n      result[keyValue] = apply(valuesByKey[keyValue], depth);\n    }\n\n    return result;\n  }\n\n  function entries(map, depth) {\n    if (++depth > keys.length) return map;\n    const array = [];\n\n    for (const key in map) {\n      array.push({\n        key,\n        values: entries(map[key], depth)\n      });\n    }\n\n    return array;\n  }\n\n  return nest;\n}\n\n/**\n * Abstract class for tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction HierarchyLayout(params) {\n  Transform.call(this, null, params);\n}\n\nconst defaultSeparation = (a, b) => a.parent === b.parent ? 1 : 2;\n\ninherits(HierarchyLayout, Transform, {\n  transform(_, pulse) {\n    if (!pulse.source || !pulse.source.root) {\n      error(this.constructor.name + ' transform requires a backing tree data source.');\n    }\n\n    const layout = this.layout(_.method),\n          fields = this.fields,\n          root = pulse.source.root,\n          as = _.as || fields;\n    if (_.field) root.sum(_.field);else root.count();\n    if (_.sort) root.sort(stableCompare(_.sort, d => d.data));\n    setParams(layout, this.params, _);\n\n    if (layout.separation) {\n      layout.separation(_.separation !== false ? defaultSeparation : one);\n    }\n\n    try {\n      this.value = layout(root);\n    } catch (err) {\n      error(err);\n    }\n\n    root.each(node => setFields(node, fields, as));\n    return pulse.reflow(_.modified()).modifies(as).modifies('leaf');\n  }\n\n});\n\nfunction setParams(layout, params, _) {\n  for (let p, i = 0, n = params.length; i < n; ++i) {\n    p = params[i];\n    if (p in _) layout[p](_[p]);\n  }\n}\n\nfunction setFields(node, fields, as) {\n  const t = node.data,\n        n = fields.length - 1;\n\n  for (let i = 0; i < n; ++i) {\n    t[as[i]] = node[fields[i]];\n  }\n\n  t[as[n]] = node.children ? node.children.length : 0;\n}\n\nconst Output$3 = ['x', 'y', 'r', 'depth', 'children'];\n/**\n * Packed circle tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Pack(params) {\n  HierarchyLayout.call(this, params);\n}\nPack.Definition = {\n  'type': 'Pack',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'radius',\n    'type': 'field',\n    'default': null\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$3.length,\n    'default': Output$3\n  }]\n};\ninherits(Pack, HierarchyLayout, {\n  layout: pack,\n  params: ['radius', 'size', 'padding'],\n  fields: Output$3\n});\n\nconst Output$2 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\n/**\n * Partition tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Partition(params) {\n  HierarchyLayout.call(this, params);\n}\nPartition.Definition = {\n  'type': 'Partition',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'round',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$2.length,\n    'default': Output$2\n  }]\n};\ninherits(Partition, HierarchyLayout, {\n  layout: partition,\n  params: ['size', 'round', 'padding'],\n  fields: Output$2\n});\n\n/**\n * Stratify a collection of tuples into a tree structure based on\n * id and parent id fields.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.key - Unique key field for each tuple.\n * @param {function(object): *} params.parentKey - Field with key for parent tuple.\n */\n\nfunction Stratify(params) {\n  Transform.call(this, null, params);\n}\nStratify.Definition = {\n  'type': 'Stratify',\n  'metadata': {\n    'treesource': true\n  },\n  'params': [{\n    'name': 'key',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'parentKey',\n    'type': 'field',\n    'required': true\n  }]\n};\ninherits(Stratify, Transform, {\n  transform(_, pulse) {\n    if (!pulse.source) {\n      error('Stratify transform requires an upstream data source.');\n    }\n\n    let tree = this.value;\n\n    const mod = _.modified(),\n          out = pulse.fork(pulse.ALL).materialize(pulse.SOURCE),\n          run = !tree || mod || pulse.changed(pulse.ADD_REM) || pulse.modified(_.key.fields) || pulse.modified(_.parentKey.fields); // prevent upstream source pollution\n\n\n    out.source = out.source.slice();\n\n    if (run) {\n      tree = out.source.length ? lookup(stratify().id(_.key).parentId(_.parentKey)(out.source), _.key, truthy) : lookup(stratify()([{}]), _.key, _.key);\n    }\n\n    out.source.root = this.value = tree;\n    return out;\n  }\n\n});\n\nconst Layouts = {\n  tidy: tree,\n  cluster: cluster\n};\nconst Output$1 = ['x', 'y', 'depth', 'children'];\n/**\n * Tree layout. Depending on the method parameter, performs either\n * Reingold-Tilford 'tidy' layout or dendrogram 'cluster' layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction Tree(params) {\n  HierarchyLayout.call(this, params);\n}\nTree.Definition = {\n  'type': 'Tree',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'method',\n    'type': 'enum',\n    'default': 'tidy',\n    'values': ['tidy', 'cluster']\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'nodeSize',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'separation',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$1.length,\n    'default': Output$1\n  }]\n};\ninherits(Tree, HierarchyLayout, {\n  /**\n   * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.\n   */\n  layout(method) {\n    const m = method || 'tidy';\n    if (hasOwnProperty(Layouts, m)) return Layouts[m]();else error('Unrecognized Tree layout method: ' + m);\n  },\n\n  params: ['size', 'nodeSize'],\n  fields: Output$1\n});\n\n/**\n * Generate tuples representing links between tree nodes.\n * The resulting tuples will contain 'source' and 'target' fields,\n * which point to parent and child node tuples, respectively.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction TreeLinks(params) {\n  Transform.call(this, [], params);\n}\nTreeLinks.Definition = {\n  'type': 'TreeLinks',\n  'metadata': {\n    'tree': true,\n    'generates': true,\n    'changes': true\n  },\n  'params': []\n};\ninherits(TreeLinks, Transform, {\n  transform(_, pulse) {\n    const links = this.value,\n          tree = pulse.source && pulse.source.root,\n          out = pulse.fork(pulse.NO_SOURCE),\n          lut = {};\n    if (!tree) error('TreeLinks transform requires a tree data source.');\n\n    if (pulse.changed(pulse.ADD_REM)) {\n      // remove previous links\n      out.rem = links; // build lookup table of valid tuples\n\n      pulse.visit(pulse.SOURCE, t => lut[tupleid(t)] = 1); // generate links for all edges incident on valid tuples\n\n      tree.each(node => {\n        const t = node.data,\n              p = node.parent && node.parent.data;\n\n        if (p && lut[tupleid(t)] && lut[tupleid(p)]) {\n          out.add.push(ingest({\n            source: p,\n            target: t\n          }));\n        }\n      });\n      this.value = out.add;\n    } else if (pulse.changed(pulse.MOD)) {\n      // build lookup table of modified tuples\n      pulse.visit(pulse.MOD, t => lut[tupleid(t)] = 1); // gather links incident on modified tuples\n\n      links.forEach(link => {\n        if (lut[tupleid(link.source)] || lut[tupleid(link.target)]) {\n          out.mod.push(link);\n        }\n      });\n    }\n\n    return out;\n  }\n\n});\n\nconst Tiles = {\n  binary: treemapBinary,\n  dice: treemapDice,\n  slice: treemapSlice,\n  slicedice: treemapSliceDice,\n  squarify: treemapSquarify,\n  resquarify: treemapResquarify\n};\nconst Output = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\n/**\n * Treemap layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Treemap(params) {\n  HierarchyLayout.call(this, params);\n}\nTreemap.Definition = {\n  'type': 'Treemap',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'method',\n    'type': 'enum',\n    'default': 'squarify',\n    'values': ['squarify', 'resquarify', 'binary', 'dice', 'slice', 'slicedice']\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingInner',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingOuter',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingTop',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingRight',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingBottom',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingLeft',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'ratio',\n    'type': 'number',\n    'default': 1.618033988749895\n  }, {\n    'name': 'round',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output.length,\n    'default': Output\n  }]\n};\ninherits(Treemap, HierarchyLayout, {\n  /**\n   * Treemap layout generator. Adds 'method' and 'ratio' parameters\n   * to configure the underlying tile method.\n   */\n  layout() {\n    const x = treemap();\n\n    x.ratio = _ => {\n      const t = x.tile();\n      if (t.ratio) x.tile(t.ratio(_));\n    };\n\n    x.method = _ => {\n      if (hasOwnProperty(Tiles, _)) x.tile(Tiles[_]);else error('Unrecognized Treemap layout method: ' + _);\n    };\n\n    return x;\n  },\n\n  params: ['method', 'ratio', 'size', 'round', 'padding', 'paddingInner', 'paddingOuter', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'],\n  fields: Output\n});\n\nexport { Nest as nest, Pack as pack, Partition as partition, Stratify as stratify, Tree as tree, TreeLinks as treelinks, Treemap as treemap };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}