{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { array, isArray, stringValue } from 'vega-util';\nimport { vgField } from '../channeldef';\nimport { isExprRef } from '../expr';\nimport { isText } from '../title';\nimport { deepEqual, getFirstDefined } from '../util';\nimport { isSignalRef } from '../vega.schema';\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\nexport function signalOrValueRefWithCondition(val) {\n  const condition = isArray(val.condition) ? val.condition.map(conditionalSignalRefOrValue) : conditionalSignalRefOrValue(val.condition);\n  return Object.assign(Object.assign({}, signalRefOrValue(val)), {\n    condition\n  });\n}\nexport function signalRefOrValue(value) {\n  if (isExprRef(value)) {\n    const {\n      expr\n    } = value,\n          rest = __rest(value, [\"expr\"]);\n\n    return Object.assign({\n      signal: expr\n    }, rest);\n  }\n\n  return value;\n}\nexport function conditionalSignalRefOrValue(value) {\n  if (isExprRef(value)) {\n    const {\n      expr\n    } = value,\n          rest = __rest(value, [\"expr\"]);\n\n    return Object.assign({\n      signal: expr\n    }, rest);\n  }\n\n  return value;\n}\nexport function signalOrValueRef(value) {\n  if (isExprRef(value)) {\n    const {\n      expr\n    } = value,\n          rest = __rest(value, [\"expr\"]);\n\n    return Object.assign({\n      signal: expr\n    }, rest);\n  }\n\n  if (isSignalRef(value)) {\n    return value;\n  }\n\n  return value !== undefined ? {\n    value\n  } : undefined;\n}\nexport function exprFromSignalRefOrValue(ref) {\n  if (isSignalRef(ref)) {\n    return ref.signal;\n  }\n\n  return stringValue(ref);\n}\nexport function exprFromValueRefOrSignalRef(ref) {\n  if (isSignalRef(ref)) {\n    return ref.signal;\n  }\n\n  return stringValue(ref.value);\n}\nexport function signalOrStringValue(v) {\n  if (isSignalRef(v)) {\n    return v.signal;\n  }\n\n  return v == null ? null : stringValue(v);\n}\nexport function applyMarkConfig(e, model, propsList) {\n  for (const property of propsList) {\n    const value = getMarkConfig(property, model.markDef, model.config);\n\n    if (value !== undefined) {\n      e[property] = signalOrValueRef(value);\n    }\n  }\n\n  return e;\n}\nexport function getStyles(mark) {\n  var _a;\n\n  return [].concat(mark.type, (_a = mark.style) !== null && _a !== void 0 ? _a : []);\n}\nexport function getMarkPropOrConfig(channel, mark, config) {\n  let opt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    vgChannel,\n    ignoreVgConfig\n  } = opt;\n\n  if (vgChannel && mark[vgChannel] !== undefined) {\n    return mark[vgChannel];\n  } else if (mark[channel] !== undefined) {\n    return mark[channel];\n  } else if (ignoreVgConfig && (!vgChannel || vgChannel === channel)) {\n    return undefined;\n  }\n\n  return getMarkConfig(channel, mark, config, opt);\n}\n/**\n * Return property value from style or mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\n\nexport function getMarkConfig(channel, mark, config) {\n  let {\n    vgChannel\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return getFirstDefined( // style config has highest precedence\n  vgChannel ? getMarkStyleConfig(channel, mark, config.style) : undefined, getMarkStyleConfig(channel, mark, config.style), // then mark-specific config\n  vgChannel ? config[mark.type][vgChannel] : undefined, config[mark.type][channel], // Need to cast because MarkDef doesn't perfectly match with AnyMarkConfig, but if the type isn't available, we'll get nothing here, which is fine\n  // If there is vgChannel, skip vl channel.\n  // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.\n  vgChannel ? config.mark[vgChannel] : config.mark[channel] // Need to cast for the same reason as above\n  );\n}\nexport function getMarkStyleConfig(prop, mark, styleConfigIndex) {\n  return getStyleConfig(prop, getStyles(mark), styleConfigIndex);\n}\nexport function getStyleConfig(p, styles, styleConfigIndex) {\n  styles = array(styles);\n  let value;\n\n  for (const style of styles) {\n    const styleConfig = styleConfigIndex[style];\n\n    if (styleConfig && styleConfig[p] !== undefined) {\n      value = styleConfig[p];\n    }\n  }\n\n  return value;\n}\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\n\nexport function sortParams(orderDef, fieldRefOption) {\n  return array(orderDef).reduce((s, orderChannelDef) => {\n    var _a;\n\n    s.field.push(vgField(orderChannelDef, fieldRefOption));\n    s.order.push((_a = orderChannelDef.sort) !== null && _a !== void 0 ? _a : 'ascending');\n    return s;\n  }, {\n    field: [],\n    order: []\n  });\n}\nexport function mergeTitleFieldDefs(f1, f2) {\n  const merged = [...f1];\n  f2.forEach(fdToMerge => {\n    for (const fieldDef1 of merged) {\n      // If already exists, no need to append to merged array\n      if (deepEqual(fieldDef1, fdToMerge)) {\n        return;\n      }\n    }\n\n    merged.push(fdToMerge);\n  });\n  return merged;\n}\nexport function mergeTitle(title1, title2) {\n  if (deepEqual(title1, title2) || !title2) {\n    // if titles are the same or title2 is falsy\n    return title1;\n  } else if (!title1) {\n    // if title1 is falsy\n    return title2;\n  } else {\n    return [...array(title1), ...array(title2)].join(', ');\n  }\n}\nexport function mergeTitleComponent(v1, v2) {\n  const v1Val = v1.value;\n  const v2Val = v2.value;\n\n  if (v1Val == null || v2Val === null) {\n    return {\n      explicit: v1.explicit,\n      value: null\n    };\n  } else if ((isText(v1Val) || isSignalRef(v1Val)) && (isText(v2Val) || isSignalRef(v2Val))) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitle(v1Val, v2Val)\n    };\n  } else if (isText(v1Val) || isSignalRef(v1Val)) {\n    return {\n      explicit: v1.explicit,\n      value: v1Val\n    };\n  } else if (isText(v2Val) || isSignalRef(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: v2Val\n    };\n  } else if (!isText(v1Val) && !isSignalRef(v1Val) && !isText(v2Val) && !isSignalRef(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitleFieldDefs(v1Val, v2Val)\n    };\n  }\n  /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n\n\n  throw new Error('It should never reach here');\n}","map":{"version":3,"mappings":"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","names":["array","isArray","stringValue","vgField","isExprRef","isText","deepEqual","getFirstDefined","isSignalRef","BIN_RANGE_DELIMITER","signalOrValueRefWithCondition","val","condition","map","conditionalSignalRefOrValue","signalRefOrValue","value","expr","rest","signal","signalOrValueRef","undefined","exprFromSignalRefOrValue","ref","exprFromValueRefOrSignalRef","signalOrStringValue","v","applyMarkConfig","e","model","propsList","property","getMarkConfig","markDef","config","getStyles","mark","concat","type","style","_a","getMarkPropOrConfig","channel","opt","vgChannel","ignoreVgConfig","getMarkStyleConfig","prop","styleConfigIndex","getStyleConfig","p","styles","styleConfig","sortParams","orderDef","fieldRefOption","reduce","s","orderChannelDef","field","push","order","sort","mergeTitleFieldDefs","f1","f2","merged","forEach","fdToMerge","fieldDef1","mergeTitle","title1","title2","join","mergeTitleComponent","v1","v2","v1Val","v2Val","explicit","Error"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/common.ts"],"sourcesContent":["import {ExprRef, SignalRef, Text} from 'vega';\nimport {array, isArray, stringValue} from 'vega-util';\nimport {AxisConfig, ConditionalAxisProperty} from '../axis';\nimport {\n  ConditionalPredicate,\n  DatumDef,\n  FieldDef,\n  FieldDefBase,\n  FieldRefOption,\n  OrderFieldDef,\n  Value,\n  ValueDef,\n  vgField\n} from '../channeldef';\nimport {Config, StyleConfigIndex} from '../config';\nimport {isExprRef} from '../expr';\nimport {Mark, MarkConfig, MarkDef} from '../mark';\nimport {SortFields} from '../sort';\nimport {isText} from '../title';\nimport {deepEqual, getFirstDefined} from '../util';\nimport {isSignalRef, VgEncodeChannel, VgEncodeEntry, VgValueRef} from '../vega.schema';\nimport {AxisComponentProps} from './axis/component';\nimport {Explicit} from './split';\nimport {UnitModel} from './unit';\n\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\n\nexport function signalOrValueRefWithCondition<V extends Value | number[]>(\n  val: ConditionalAxisProperty<V, SignalRef | ExprRef>\n): ConditionalAxisProperty<V, SignalRef> {\n  const condition = isArray(val.condition)\n    ? (val.condition as ConditionalPredicate<ValueDef<any> | ExprRef | SignalRef>[]).map(conditionalSignalRefOrValue)\n    : conditionalSignalRefOrValue(val.condition);\n\n  return {\n    ...signalRefOrValue<ValueDef<any>>(val),\n    condition\n  };\n}\n\nexport function signalRefOrValue<T>(value: T | SignalRef | ExprRef): T | SignalRef {\n  if (isExprRef(value)) {\n    const {expr, ...rest} = value;\n    return {signal: expr, ...rest};\n  }\n  return value;\n}\n\nexport function conditionalSignalRefOrValue<T extends FieldDef<any> | DatumDef | ValueDef<any>>(\n  value: ConditionalPredicate<T | ExprRef | SignalRef>\n): ConditionalPredicate<T | SignalRef> {\n  if (isExprRef(value)) {\n    const {expr, ...rest} = value;\n    return {signal: expr, ...rest};\n  }\n  return value;\n}\n\nexport function signalOrValueRef<T>(value: T | SignalRef | ExprRef): {value: T} | SignalRef {\n  if (isExprRef(value)) {\n    const {expr, ...rest} = value;\n    return {signal: expr, ...rest};\n  }\n  if (isSignalRef(value)) {\n    return value;\n  }\n  return value !== undefined ? {value} : undefined;\n}\n\nexport function exprFromSignalRefOrValue<T extends SignalRef>(ref: Value<T> | SignalRef): string {\n  if (isSignalRef(ref)) {\n    return ref.signal;\n  }\n  return stringValue(ref);\n}\nexport function exprFromValueRefOrSignalRef(ref: VgValueRef | SignalRef): string {\n  if (isSignalRef(ref)) {\n    return ref.signal;\n  }\n  return stringValue(ref.value);\n}\n\nexport function signalOrStringValue(v: SignalRef | any) {\n  if (isSignalRef(v)) {\n    return v.signal;\n  }\n  return v == null ? null : stringValue(v);\n}\n\nexport function applyMarkConfig(e: VgEncodeEntry, model: UnitModel, propsList: (keyof MarkConfig<any>)[]) {\n  for (const property of propsList) {\n    const value = getMarkConfig(property, model.markDef, model.config);\n    if (value !== undefined) {\n      e[property] = signalOrValueRef(value);\n    }\n  }\n  return e;\n}\n\nexport function getStyles(mark: MarkDef): string[] {\n  return [].concat(mark.type, mark.style ?? []);\n}\n\nexport function getMarkPropOrConfig<P extends keyof MarkDef, ES extends ExprRef | SignalRef>(\n  channel: P,\n  mark: MarkDef<Mark, ES>,\n  config: Config<SignalRef>,\n  opt: {\n    vgChannel?: VgEncodeChannel;\n    ignoreVgConfig?: boolean;\n  } = {}\n): MarkDef<Mark, ES>[P] {\n  const {vgChannel, ignoreVgConfig} = opt;\n  if (vgChannel && mark[vgChannel] !== undefined) {\n    return mark[vgChannel];\n  } else if (mark[channel] !== undefined) {\n    return mark[channel];\n  } else if (ignoreVgConfig && (!vgChannel || vgChannel === channel)) {\n    return undefined;\n  }\n\n  return getMarkConfig(channel, mark, config, opt);\n}\n\n/**\n * Return property value from style or mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\nexport function getMarkConfig<P extends keyof MarkDef, ES extends ExprRef | SignalRef>(\n  channel: P,\n  mark: MarkDef<Mark, ES>,\n  config: Config<SignalRef>,\n  {vgChannel}: {vgChannel?: VgEncodeChannel} = {}\n): MarkDef<Mark, ES>[P] {\n  return getFirstDefined<MarkDef<Mark, ES>[P]>(\n    // style config has highest precedence\n    vgChannel ? getMarkStyleConfig(channel, mark, config.style) : undefined,\n    getMarkStyleConfig(channel, mark, config.style),\n    // then mark-specific config\n    vgChannel ? config[mark.type][vgChannel] : undefined,\n\n    config[mark.type][channel as any], // Need to cast because MarkDef doesn't perfectly match with AnyMarkConfig, but if the type isn't available, we'll get nothing here, which is fine\n\n    // If there is vgChannel, skip vl channel.\n    // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.\n    vgChannel ? config.mark[vgChannel] : config.mark[channel as any] // Need to cast for the same reason as above\n  );\n}\n\nexport function getMarkStyleConfig<P extends keyof MarkDef, ES extends ExprRef | SignalRef>(\n  prop: P,\n  mark: MarkDef<Mark, ES>,\n  styleConfigIndex: StyleConfigIndex<SignalRef>\n) {\n  return getStyleConfig(prop, getStyles(mark), styleConfigIndex);\n}\n\nexport function getStyleConfig<P extends keyof MarkDef | keyof AxisConfig<SignalRef>>(\n  p: P,\n  styles: string | string[],\n  styleConfigIndex: StyleConfigIndex<SignalRef>\n) {\n  styles = array(styles);\n  let value;\n  for (const style of styles) {\n    const styleConfig = styleConfigIndex[style];\n\n    if (styleConfig && styleConfig[p as string] !== undefined) {\n      value = styleConfig[p as string];\n    }\n  }\n  return value;\n}\n\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\nexport function sortParams(\n  orderDef: OrderFieldDef<string> | OrderFieldDef<string>[],\n  fieldRefOption?: FieldRefOption\n): SortFields {\n  return array(orderDef).reduce(\n    (s, orderChannelDef) => {\n      s.field.push(vgField(orderChannelDef, fieldRefOption));\n      s.order.push(orderChannelDef.sort ?? 'ascending');\n      return s;\n    },\n    {field: [], order: []}\n  );\n}\n\nexport type AxisTitleComponent = AxisComponentProps['title'];\n\nexport function mergeTitleFieldDefs(f1: readonly FieldDefBase<string>[], f2: readonly FieldDefBase<string>[]) {\n  const merged = [...f1];\n\n  f2.forEach(fdToMerge => {\n    for (const fieldDef1 of merged) {\n      // If already exists, no need to append to merged array\n      if (deepEqual(fieldDef1, fdToMerge)) {\n        return;\n      }\n    }\n    merged.push(fdToMerge);\n  });\n  return merged;\n}\n\nexport function mergeTitle(title1: Text | SignalRef, title2: Text | SignalRef) {\n  if (deepEqual(title1, title2) || !title2) {\n    // if titles are the same or title2 is falsy\n    return title1;\n  } else if (!title1) {\n    // if title1 is falsy\n    return title2;\n  } else {\n    return [...array(title1), ...array(title2)].join(', ');\n  }\n}\n\nexport function mergeTitleComponent(v1: Explicit<AxisTitleComponent>, v2: Explicit<AxisTitleComponent>) {\n  const v1Val = v1.value;\n  const v2Val = v2.value;\n\n  if (v1Val == null || v2Val === null) {\n    return {\n      explicit: v1.explicit,\n      value: null\n    };\n  } else if ((isText(v1Val) || isSignalRef(v1Val)) && (isText(v2Val) || isSignalRef(v2Val))) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitle(v1Val, v2Val)\n    };\n  } else if (isText(v1Val) || isSignalRef(v1Val)) {\n    return {\n      explicit: v1.explicit,\n      value: v1Val\n    };\n  } else if (isText(v2Val) || isSignalRef(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: v2Val\n    };\n  } else if (!isText(v1Val) && !isSignalRef(v1Val) && !isText(v2Val) && !isSignalRef(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitleFieldDefs(v1Val, v2Val)\n    };\n  }\n  /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n  throw new Error('It should never reach here');\n}\n"]},"metadata":{},"sourceType":"module"}