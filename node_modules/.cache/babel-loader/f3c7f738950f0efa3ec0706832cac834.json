{"ast":null,"code":"import { Transform } from 'vega-dataflow';\nimport { Marks, boundClip, GroupItem, Item, Bounds, multiLineOffset, boundStroke } from 'vega-scenegraph';\nimport { inherits, peek, isObject } from 'vega-util';\nconst Top = 'top';\nconst Left = 'left';\nconst Right = 'right';\nconst Bottom = 'bottom';\nconst TopLeft = 'top-left';\nconst TopRight = 'top-right';\nconst BottomLeft = 'bottom-left';\nconst BottomRight = 'bottom-right';\nconst Start = 'start';\nconst Middle = 'middle';\nconst End = 'end';\nconst X = 'x';\nconst Y = 'y';\nconst Group = 'group';\nconst AxisRole = 'axis';\nconst TitleRole = 'title';\nconst FrameRole = 'frame';\nconst ScopeRole = 'scope';\nconst LegendRole = 'legend';\nconst RowHeader = 'row-header';\nconst RowFooter = 'row-footer';\nconst RowTitle = 'row-title';\nconst ColHeader = 'column-header';\nconst ColFooter = 'column-footer';\nconst ColTitle = 'column-title';\nconst Padding = 'padding';\nconst Symbols = 'symbol';\nconst Fit = 'fit';\nconst FitX = 'fit-x';\nconst FitY = 'fit-y';\nconst Pad = 'pad';\nconst None = 'none';\nconst All = 'all';\nconst Each = 'each';\nconst Flush = 'flush';\nconst Column = 'column';\nconst Row = 'row';\n/**\n * Calculate bounding boxes for scenegraph items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - The scenegraph mark instance to bound.\n */\n\nfunction Bound(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Bound, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow,\n          mark = _.mark,\n          type = mark.marktype,\n          entry = Marks[type],\n          bound = entry.bound;\n    let markBounds = mark.bounds,\n        rebound;\n\n    if (entry.nested) {\n      // multi-item marks have a single bounds instance\n      if (mark.items.length) view.dirty(mark.items[0]);\n      markBounds = boundItem(mark, bound);\n      mark.items.forEach(item => {\n        item.bounds.clear().union(markBounds);\n      });\n    } else if (type === Group || _.modified()) {\n      // operator parameters modified -> re-bound all items\n      // updates group bounds in response to modified group content\n      pulse.visit(pulse.MOD, item => view.dirty(item));\n      markBounds.clear();\n      mark.items.forEach(item => markBounds.union(boundItem(item, bound))); // force reflow for axes/legends/titles to propagate any layout changes\n\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          pulse.reflow();\n      }\n    } else {\n      // incrementally update bounds, re-bound mark as needed\n      rebound = pulse.changed(pulse.REM);\n      pulse.visit(pulse.ADD, item => {\n        markBounds.union(boundItem(item, bound));\n      });\n      pulse.visit(pulse.MOD, item => {\n        rebound = rebound || markBounds.alignsWith(item.bounds);\n        view.dirty(item);\n        markBounds.union(boundItem(item, bound));\n      });\n\n      if (rebound) {\n        markBounds.clear();\n        mark.items.forEach(item => markBounds.union(item.bounds));\n      }\n    } // ensure mark bounds do not exceed any clipping region\n\n\n    boundClip(mark);\n    return pulse.modifies('bounds');\n  }\n\n});\n\nfunction boundItem(item, bound, opt) {\n  return bound(item.bounds.clear(), item, opt);\n}\n\nconst COUNTER_NAME = ':vega_identifier:';\n/**\n * Adds a unique identifier to all added tuples.\n * This transform creates a new signal that serves as an id counter.\n * As a result, the id counter is shared across all instances of this\n * transform, generating unique ids across multiple data streams. In\n * addition, this signal value can be included in a snapshot of the\n * dataflow state, enabling correct resumption of id allocation.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.as - The field name for the generated identifier.\n */\n\nfunction Identifier(params) {\n  Transform.call(this, 0, params);\n}\n\nIdentifier.Definition = {\n  'type': 'Identifier',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'as',\n    'type': 'string',\n    'required': true\n  }]\n};\ninherits(Identifier, Transform, {\n  transform(_, pulse) {\n    const counter = getCounter(pulse.dataflow),\n          as = _.as;\n    let id = counter.value;\n    pulse.visit(pulse.ADD, t => t[as] = t[as] || ++id);\n    counter.set(this.value = id);\n    return pulse;\n  }\n\n});\n\nfunction getCounter(view) {\n  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));\n}\n/**\n * Bind scenegraph items to a scenegraph mark instance.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.markdef - The mark definition for creating the mark.\n *   This is an object of legal scenegraph mark properties which *must* include\n *   the 'marktype' property.\n */\n\n\nfunction Mark(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Mark, Transform, {\n  transform(_, pulse) {\n    let mark = this.value; // acquire mark on first invocation, bind context and group\n\n    if (!mark) {\n      mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup(_), _.index);\n      mark.group.context = _.context;\n      if (!_.context.group) _.context.group = mark.group;\n      mark.source = this.source; // point to upstream collector\n\n      mark.clip = _.clip;\n      mark.interactive = _.interactive;\n      this.value = mark;\n    } // initialize entering items\n\n\n    const Init = mark.marktype === Group ? GroupItem : Item;\n    pulse.visit(pulse.ADD, item => Init.call(item, mark)); // update clipping and/or interactive status\n\n    if (_.modified('clip') || _.modified('interactive')) {\n      mark.clip = _.clip;\n      mark.interactive = !!_.interactive;\n      mark.zdirty = true; // force scenegraph re-eval\n\n      pulse.reflow();\n    } // bind items array to scenegraph mark\n\n\n    mark.items = pulse.source;\n    return pulse;\n  }\n\n});\n\nfunction lookup(_) {\n  const g = _.groups,\n        p = _.parent;\n  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;\n}\n/**\n * Analyze items for overlap, changing opacity to hide items with\n * overlapping bounding boxes. This transform will preserve at least\n * two items (e.g., first and last) even if overlap persists.\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting items.\n * @param {object} [params.method] - The overlap removal method to apply.\n *   One of 'parity' (default, hide every other item until there is no\n *   more overlap) or 'greedy' (sequentially scan and hide and items that\n *   overlap with the last visible item).\n * @param {object} [params.boundScale] - A scale whose range should be used\n *   to bound the items. Items exceeding the bounds of the scale range\n *   will be treated as overlapping. If null or undefined, no bounds check\n *   will be applied.\n * @param {object} [params.boundOrient] - The orientation of the scale\n *   (top, bottom, left, or right) used to bound items. This parameter is\n *   ignored if boundScale is null or undefined.\n * @param {object} [params.boundTolerance] - The tolerance in pixels for\n *   bound inclusion testing (default 1). This specifies by how many pixels\n *   an item's bounds may exceed the scale range bounds and not be culled.\n * @constructor\n */\n\n\nfunction Overlap(params) {\n  Transform.call(this, null, params);\n}\n\nconst methods = {\n  parity: items => items.filter((item, i) => i % 2 ? item.opacity = 0 : 1),\n  greedy: (items, sep) => {\n    let a;\n    return items.filter((b, i) => !i || !intersect(a.bounds, b.bounds, sep) ? (a = b, 1) : b.opacity = 0);\n  }\n}; // compute bounding box intersection\n// including padding pixels of separation\n\nconst intersect = (a, b, sep) => sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);\n\nconst hasOverlap = (items, pad) => {\n  for (var i = 1, n = items.length, a = items[0].bounds, b; i < n; a = b, ++i) {\n    if (intersect(a, b = items[i].bounds, pad)) return true;\n  }\n};\n\nconst hasBounds = item => {\n  const b = item.bounds;\n  return b.width() > 1 && b.height() > 1;\n};\n\nconst boundTest = (scale, orient, tolerance) => {\n  var range = scale.range(),\n      b = new Bounds();\n\n  if (orient === Top || orient === Bottom) {\n    b.set(range[0], -Infinity, range[1], +Infinity);\n  } else {\n    b.set(-Infinity, range[0], +Infinity, range[1]);\n  }\n\n  b.expand(tolerance || 1);\n  return item => b.encloses(item.bounds);\n}; // reset all items to be fully opaque\n\n\nconst reset = source => {\n  source.forEach(item => item.opacity = 1);\n  return source;\n}; // add all tuples to mod, fork pulse if parameters were modified\n// fork prevents cross-stream tuple pollution (e.g., pulse from scale)\n\n\nconst reflow = (pulse, _) => pulse.reflow(_.modified()).modifies('opacity');\n\ninherits(Overlap, Transform, {\n  transform(_, pulse) {\n    const reduce = methods[_.method] || methods.parity,\n          sep = _.separation || 0;\n    let source = pulse.materialize(pulse.SOURCE).source,\n        items,\n        test;\n    if (!source || !source.length) return;\n\n    if (!_.method) {\n      // early exit if method is falsy\n      if (_.modified('method')) {\n        reset(source);\n        pulse = reflow(pulse, _);\n      }\n\n      return pulse;\n    } // skip labels with no content\n\n\n    source = source.filter(hasBounds); // early exit, nothing to do\n\n    if (!source.length) return;\n\n    if (_.sort) {\n      source = source.slice().sort(_.sort);\n    }\n\n    items = reset(source);\n    pulse = reflow(pulse, _);\n\n    if (items.length >= 3 && hasOverlap(items, sep)) {\n      do {\n        items = reduce(items, sep);\n      } while (items.length >= 3 && hasOverlap(items, sep));\n\n      if (items.length < 3 && !peek(source).opacity) {\n        if (items.length > 1) peek(items).opacity = 0;\n        peek(source).opacity = 1;\n      }\n    }\n\n    if (_.boundScale && _.boundTolerance >= 0) {\n      test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);\n      source.forEach(item => {\n        if (!test(item)) item.opacity = 0;\n      });\n    } // re-calculate mark bounds\n\n\n    const bounds = items[0].mark.bounds.clear();\n    source.forEach(item => {\n      if (item.opacity) bounds.union(item.bounds);\n    });\n    return pulse;\n  }\n\n});\n/**\n * Queue modified scenegraph items for rendering.\n * @constructor\n */\n\nfunction Render(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Render, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n    pulse.visit(pulse.ALL, item => view.dirty(item)); // set z-index dirty flag as needed\n\n    if (pulse.fields && pulse.fields['zindex']) {\n      const item = pulse.source && pulse.source[0];\n      if (item) item.mark.zdirty = true;\n    }\n  }\n\n});\nconst tempBounds = new Bounds();\n\nfunction set(item, property, value) {\n  return item[property] === value ? 0 : (item[property] = value, 1);\n}\n\nfunction isYAxis(mark) {\n  var orient = mark.items[0].orient;\n  return orient === Left || orient === Right;\n}\n\nfunction axisIndices(datum) {\n  let index = +datum.grid;\n  return [datum.ticks ? index++ : -1, // ticks index\n  datum.labels ? index++ : -1, // labels index\n  index + +datum.domain // title index\n  ];\n}\n\nfunction axisLayout(view, axis, width, height) {\n  var item = axis.items[0],\n      datum = item.datum,\n      delta = item.translate != null ? item.translate : 0.5,\n      orient = item.orient,\n      indices = axisIndices(datum),\n      range = item.range,\n      offset = item.offset,\n      position = item.position,\n      minExtent = item.minExtent,\n      maxExtent = item.maxExtent,\n      title = datum.title && item.items[indices[2]].items[0],\n      titlePadding = item.titlePadding,\n      bounds = item.bounds,\n      dl = title && multiLineOffset(title),\n      x = 0,\n      y = 0,\n      i,\n      s;\n  tempBounds.clear().union(bounds);\n  bounds.clear();\n  if ((i = indices[0]) > -1) bounds.union(item.items[i].bounds);\n  if ((i = indices[1]) > -1) bounds.union(item.items[i].bounds); // position axis group and title\n\n  switch (orient) {\n    case Top:\n      x = position || 0;\n      y = -offset;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));\n      bounds.add(0, -s).add(range, 0);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds);\n      break;\n\n    case Left:\n      x = -offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));\n      bounds.add(-s, 0).add(0, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds);\n      break;\n\n    case Right:\n      x = width + offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));\n      bounds.add(0, 0).add(s, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds);\n      break;\n\n    case Bottom:\n      x = position || 0;\n      y = height + offset;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));\n      bounds.add(0, 0).add(range, s);\n      if (title) axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds);\n      break;\n\n    default:\n      x = item.x;\n      y = item.y;\n  } // update bounds\n\n\n  boundStroke(bounds.translate(x, y), item);\n\n  if (set(item, 'x', x + delta) | set(item, 'y', y + delta)) {\n    item.bounds = tempBounds;\n    view.dirty(item);\n    item.bounds = bounds;\n    view.dirty(item);\n  }\n\n  return item.mark.bounds.clear().union(bounds);\n}\n\nfunction axisTitleLayout(view, title, offset, pad, dl, isYAxis, sign, bounds) {\n  const b = title.bounds;\n\n  if (title.auto) {\n    const v = sign * (offset + dl + pad);\n    let dx = 0,\n        dy = 0;\n    view.dirty(title);\n    isYAxis ? dx = (title.x || 0) - (title.x = v) : dy = (title.y || 0) - (title.y = v);\n    title.mark.bounds.clear().union(b.translate(-dx, -dy));\n    view.dirty(title);\n  }\n\n  bounds.union(b);\n}\n\nconst min = (a, b) => Math.floor(Math.min(a, b));\n\nconst max = (a, b) => Math.ceil(Math.max(a, b));\n\nfunction gridLayoutGroups(group) {\n  var groups = group.items,\n      n = groups.length,\n      i = 0,\n      mark,\n      items;\n  const views = {\n    marks: [],\n    rowheaders: [],\n    rowfooters: [],\n    colheaders: [],\n    colfooters: [],\n    rowtitle: null,\n    coltitle: null\n  }; // layout axes, gather legends, collect bounds\n\n  for (; i < n; ++i) {\n    mark = groups[i];\n    items = mark.items;\n\n    if (mark.marktype === Group) {\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          break;\n\n        case RowHeader:\n          views.rowheaders.push(...items);\n          break;\n\n        case RowFooter:\n          views.rowfooters.push(...items);\n          break;\n\n        case ColHeader:\n          views.colheaders.push(...items);\n          break;\n\n        case ColFooter:\n          views.colfooters.push(...items);\n          break;\n\n        case RowTitle:\n          views.rowtitle = items[0];\n          break;\n\n        case ColTitle:\n          views.coltitle = items[0];\n          break;\n\n        default:\n          views.marks.push(...items);\n      }\n    }\n  }\n\n  return views;\n}\n\nfunction bboxFlush(item) {\n  return new Bounds().set(0, 0, item.width || 0, item.height || 0);\n}\n\nfunction bboxFull(item) {\n  const b = item.bounds.clone();\n  return b.empty() ? b.set(0, 0, 0, 0) : b.translate(-(item.x || 0), -(item.y || 0));\n}\n\nfunction get(opt, key, d) {\n  const v = isObject(opt) ? opt[key] : opt;\n  return v != null ? v : d !== undefined ? d : 0;\n}\n\nfunction offsetValue(v) {\n  return v < 0 ? Math.ceil(-v) : 0;\n}\n\nfunction gridLayout(view, groups, opt) {\n  var dirty = !opt.nodirty,\n      bbox = opt.bounds === Flush ? bboxFlush : bboxFull,\n      bounds = tempBounds.set(0, 0, 0, 0),\n      alignCol = get(opt.align, Column),\n      alignRow = get(opt.align, Row),\n      padCol = get(opt.padding, Column),\n      padRow = get(opt.padding, Row),\n      ncols = opt.columns || groups.length,\n      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n      n = groups.length,\n      xOffset = Array(n),\n      xExtent = Array(ncols),\n      xMax = 0,\n      yOffset = Array(n),\n      yExtent = Array(nrows),\n      yMax = 0,\n      dx = Array(n),\n      dy = Array(n),\n      boxes = Array(n),\n      m,\n      i,\n      c,\n      r,\n      b,\n      g,\n      px,\n      py,\n      x,\n      y,\n      offset;\n\n  for (i = 0; i < ncols; ++i) xExtent[i] = 0;\n\n  for (i = 0; i < nrows; ++i) yExtent[i] = 0; // determine offsets for each group\n\n\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    b = boxes[i] = bbox(g);\n    g.x = g.x || 0;\n    dx[i] = 0;\n    g.y = g.y || 0;\n    dy[i] = 0;\n    c = i % ncols;\n    r = ~~(i / ncols);\n    xMax = Math.max(xMax, px = Math.ceil(b.x2));\n    yMax = Math.max(yMax, py = Math.ceil(b.y2));\n    xExtent[c] = Math.max(xExtent[c], px);\n    yExtent[r] = Math.max(yExtent[r], py);\n    xOffset[i] = padCol + offsetValue(b.x1);\n    yOffset[i] = padRow + offsetValue(b.y1);\n    if (dirty) view.dirty(groups[i]);\n  } // set initial alignment offsets\n\n\n  for (i = 0; i < n; ++i) {\n    if (i % ncols === 0) xOffset[i] = 0;\n    if (i < ncols) yOffset[i] = 0;\n  } // enforce column alignment constraints\n\n\n  if (alignCol === Each) {\n    for (c = 1; c < ncols; ++c) {\n      for (offset = 0, i = c; i < n; i += ncols) {\n        if (offset < xOffset[i]) offset = xOffset[i];\n      }\n\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] = offset + xExtent[c - 1];\n      }\n    }\n  } else if (alignCol === All) {\n    for (offset = 0, i = 0; i < n; ++i) {\n      if (i % ncols && offset < xOffset[i]) offset = xOffset[i];\n    }\n\n    for (i = 0; i < n; ++i) {\n      if (i % ncols) xOffset[i] = offset + xMax;\n    }\n  } else {\n    for (alignCol = false, c = 1; c < ncols; ++c) {\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] += xExtent[c - 1];\n      }\n    }\n  } // enforce row alignment constraints\n\n\n  if (alignRow === Each) {\n    for (r = 1; r < nrows; ++r) {\n      for (offset = 0, i = r * ncols, m = i + ncols; i < m; ++i) {\n        if (offset < yOffset[i]) offset = yOffset[i];\n      }\n\n      for (i = r * ncols; i < m; ++i) {\n        yOffset[i] = offset + yExtent[r - 1];\n      }\n    }\n  } else if (alignRow === All) {\n    for (offset = 0, i = ncols; i < n; ++i) {\n      if (offset < yOffset[i]) offset = yOffset[i];\n    }\n\n    for (i = ncols; i < n; ++i) {\n      yOffset[i] = offset + yMax;\n    }\n  } else {\n    for (alignRow = false, r = 1; r < nrows; ++r) {\n      for (i = r * ncols, m = i + ncols; i < m; ++i) {\n        yOffset[i] += yExtent[r - 1];\n      }\n    }\n  } // perform horizontal grid layout\n\n\n  for (x = 0, i = 0; i < n; ++i) {\n    x = xOffset[i] + (i % ncols ? x : 0);\n    dx[i] += x - groups[i].x;\n  } // perform vertical grid layout\n\n\n  for (c = 0; c < ncols; ++c) {\n    for (y = 0, i = c; i < n; i += ncols) {\n      y += yOffset[i];\n      dy[i] += y - groups[i].y;\n    }\n  } // perform horizontal centering\n\n\n  if (alignCol && get(opt.center, Column) && nrows > 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignCol === All ? xMax : xExtent[i % ncols];\n      x = b - boxes[i].x2 - groups[i].x - dx[i];\n      if (x > 0) dx[i] += x / 2;\n    }\n  } // perform vertical centering\n\n\n  if (alignRow && get(opt.center, Row) && ncols !== 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignRow === All ? yMax : yExtent[~~(i / ncols)];\n      y = b - boxes[i].y2 - groups[i].y - dy[i];\n      if (y > 0) dy[i] += y / 2;\n    }\n  } // position grid relative to anchor\n\n\n  for (i = 0; i < n; ++i) {\n    bounds.union(boxes[i].translate(dx[i], dy[i]));\n  }\n\n  x = get(opt.anchor, X);\n  y = get(opt.anchor, Y);\n\n  switch (get(opt.anchor, Column)) {\n    case End:\n      x -= bounds.width();\n      break;\n\n    case Middle:\n      x -= bounds.width() / 2;\n  }\n\n  switch (get(opt.anchor, Row)) {\n    case End:\n      y -= bounds.height();\n      break;\n\n    case Middle:\n      y -= bounds.height() / 2;\n  }\n\n  x = Math.round(x);\n  y = Math.round(y); // update mark positions, bounds, dirty\n\n  bounds.clear();\n\n  for (i = 0; i < n; ++i) {\n    groups[i].mark.bounds.clear();\n  }\n\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    g.x += dx[i] += x;\n    g.y += dy[i] += y;\n    bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));\n    if (dirty) view.dirty(g);\n  }\n\n  return bounds;\n}\n\nfunction trellisLayout(view, group, opt) {\n  var views = gridLayoutGroups(group),\n      groups = views.marks,\n      bbox = opt.bounds === Flush ? boundFlush : boundFull,\n      off = opt.offset,\n      ncols = opt.columns || groups.length,\n      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n      cells = nrows * ncols,\n      x,\n      y,\n      x2,\n      y2,\n      anchor,\n      band,\n      offset; // -- initial grid layout\n\n  const bounds = gridLayout(view, groups, opt);\n  if (bounds.empty()) bounds.set(0, 0, 0, 0); // empty grid\n  // -- layout grid headers and footers --\n  // perform row header layout\n\n  if (views.rowheaders) {\n    band = get(opt.headerBand, Row, null);\n    x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);\n  } // perform column header layout\n\n\n  if (views.colheaders) {\n    band = get(opt.headerBand, Column, null);\n    y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);\n  } // perform row footer layout\n\n\n  if (views.rowfooters) {\n    band = get(opt.footerBand, Row, null);\n    x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols - 1, ncols, 1, band);\n  } // perform column footer layout\n\n\n  if (views.colfooters) {\n    band = get(opt.footerBand, Column, null);\n    y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get(off, 'columnFooter'), max, 1, bbox, 'y2', cells - ncols, 1, ncols, band);\n  } // perform row title layout\n\n\n  if (views.rowtitle) {\n    anchor = get(opt.titleAnchor, Row);\n    offset = get(off, 'rowTitle');\n    offset = anchor === End ? x2 + offset : x - offset;\n    band = get(opt.titleBand, Row, 0.5);\n    layoutTitle(view, views.rowtitle, offset, 0, bounds, band);\n  } // perform column title layout\n\n\n  if (views.coltitle) {\n    anchor = get(opt.titleAnchor, Column);\n    offset = get(off, 'columnTitle');\n    offset = anchor === End ? y2 + offset : y - offset;\n    band = get(opt.titleBand, Column, 0.5);\n    layoutTitle(view, views.coltitle, offset, 1, bounds, band);\n  }\n}\n\nfunction boundFlush(item, field) {\n  return field === 'x1' ? item.x || 0 : field === 'y1' ? item.y || 0 : field === 'x2' ? (item.x || 0) + (item.width || 0) : field === 'y2' ? (item.y || 0) + (item.height || 0) : undefined;\n}\n\nfunction boundFull(item, field) {\n  return item.bounds[field];\n}\n\nfunction layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {\n  var n = groups.length,\n      init = 0,\n      edge = 0,\n      i,\n      j,\n      k,\n      m,\n      b,\n      h,\n      g,\n      x,\n      y; // if no groups, early exit and return 0\n\n  if (!n) return init; // compute margin\n\n  for (i = start; i < n; i += stride) {\n    if (groups[i]) init = agg(init, bound(groups[i], bf));\n  } // if no headers, return margin calculation\n\n\n  if (!headers.length) return init; // check if number of headers exceeds number of rows or columns\n\n  if (headers.length > limit) {\n    view.warn('Grid headers exceed limit: ' + limit);\n    headers = headers.slice(0, limit);\n  } // apply offset\n\n\n  init += offset; // clear mark bounds for all headers\n\n  for (j = 0, m = headers.length; j < m; ++j) {\n    view.dirty(headers[j]);\n    headers[j].mark.bounds.clear();\n  } // layout each header\n\n\n  for (i = start, j = 0, m = headers.length; j < m; ++j, i += stride) {\n    h = headers[j];\n    b = h.mark.bounds; // search for nearest group to align to\n    // necessary if table has empty cells\n\n    for (k = i; k >= 0 && (g = groups[k]) == null; k -= back); // assign coordinates and update bounds\n\n\n    if (isX) {\n      x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());\n      y = init;\n    } else {\n      x = init;\n      y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());\n    }\n\n    b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));\n    h.x = x;\n    h.y = y;\n    view.dirty(h); // update current edge of layout bounds\n\n    edge = agg(edge, b[bf]);\n  }\n\n  return edge;\n}\n\nfunction layoutTitle(view, g, offset, isX, bounds, band) {\n  if (!g) return;\n  view.dirty(g); // compute title coordinates\n\n  var x = offset,\n      y = offset;\n  isX ? x = Math.round(bounds.x1 + band * bounds.width()) : y = Math.round(bounds.y1 + band * bounds.height()); // assign coordinates and update bounds\n\n  g.bounds.translate(x - (g.x || 0), y - (g.y || 0));\n  g.mark.bounds.clear().union(g.bounds);\n  g.x = x;\n  g.y = y; // queue title for redraw\n\n  view.dirty(g);\n}\n\nfunction lookup$1(config, orient) {\n  const opt = config[orient] || {};\n  return (key, d) => opt[key] != null ? opt[key] : config[key] != null ? config[key] : d;\n} // if legends specify offset directly, use the maximum specified value\n\n\nfunction offsets(legends, value) {\n  let max = -Infinity;\n  legends.forEach(item => {\n    if (item.offset != null) max = Math.max(max, item.offset);\n  });\n  return max > -Infinity ? max : value;\n}\n\nfunction legendParams(g, orient, config, xb, yb, w, h) {\n  const _ = lookup$1(config, orient),\n        offset = offsets(g, _('offset', 0)),\n        anchor = _('anchor', Start),\n        mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;\n\n  const p = {\n    align: Each,\n    bounds: _('bounds', Flush),\n    columns: _('direction') === 'vertical' ? 1 : g.length,\n    padding: _('margin', 8),\n    center: _('center'),\n    nodirty: true\n  };\n\n  switch (orient) {\n    case Left:\n      p.anchor = {\n        x: Math.floor(xb.x1) - offset,\n        column: End,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n\n    case Right:\n      p.anchor = {\n        x: Math.ceil(xb.x2) + offset,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n\n    case Top:\n      p.anchor = {\n        y: Math.floor(yb.y1) - offset,\n        row: End,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n\n    case Bottom:\n      p.anchor = {\n        y: Math.ceil(yb.y2) + offset,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n\n    case TopLeft:\n      p.anchor = {\n        x: offset,\n        y: offset\n      };\n      break;\n\n    case TopRight:\n      p.anchor = {\n        x: w - offset,\n        y: offset,\n        column: End\n      };\n      break;\n\n    case BottomLeft:\n      p.anchor = {\n        x: offset,\n        y: h - offset,\n        row: End\n      };\n      break;\n\n    case BottomRight:\n      p.anchor = {\n        x: w - offset,\n        y: h - offset,\n        column: End,\n        row: End\n      };\n      break;\n  }\n\n  return p;\n}\n\nfunction legendLayout(view, legend) {\n  var item = legend.items[0],\n      datum = item.datum,\n      orient = item.orient,\n      bounds = item.bounds,\n      x = item.x,\n      y = item.y,\n      w,\n      h; // cache current bounds for later comparison\n\n  item._bounds ? item._bounds.clear().union(bounds) : item._bounds = bounds.clone();\n  bounds.clear(); // adjust legend to accommodate padding and title\n\n  legendGroupLayout(view, item, item.items[0].items[0]); // aggregate bounds to determine size, and include origin\n\n  bounds = legendBounds(item, bounds);\n  w = 2 * item.padding;\n  h = 2 * item.padding;\n\n  if (!bounds.empty()) {\n    w = Math.ceil(bounds.width() + w);\n    h = Math.ceil(bounds.height() + h);\n  }\n\n  if (datum.type === Symbols) {\n    legendEntryLayout(item.items[0].items[0].items[0].items);\n  }\n\n  if (orient !== None) {\n    item.x = x = 0;\n    item.y = y = 0;\n  }\n\n  item.width = w;\n  item.height = h;\n  boundStroke(bounds.set(x, y, x + w, y + h), item);\n  item.mark.bounds.clear().union(bounds);\n  return item;\n}\n\nfunction legendBounds(item, b) {\n  // aggregate item bounds\n  item.items.forEach(_ => b.union(_.bounds)); // anchor to legend origin\n\n  b.x1 = item.padding;\n  b.y1 = item.padding;\n  return b;\n}\n\nfunction legendGroupLayout(view, item, entry) {\n  var pad = item.padding,\n      ex = pad - entry.x,\n      ey = pad - entry.y;\n\n  if (!item.datum.title) {\n    if (ex || ey) translate(view, entry, ex, ey);\n  } else {\n    var title = item.items[1].items[0],\n        anchor = title.anchor,\n        tpad = item.titlePadding || 0,\n        tx = pad - title.x,\n        ty = pad - title.y;\n\n    switch (title.orient) {\n      case Left:\n        ex += Math.ceil(title.bounds.width()) + tpad;\n        break;\n\n      case Right:\n      case Bottom:\n        break;\n\n      default:\n        ey += title.bounds.height() + tpad;\n    }\n\n    if (ex || ey) translate(view, entry, ex, ey);\n\n    switch (title.orient) {\n      case Left:\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n\n      case Right:\n        tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n\n      case Bottom:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n        ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;\n        break;\n\n      default:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n    }\n\n    if (tx || ty) translate(view, title, tx, ty); // translate legend if title pushes into negative coordinates\n\n    if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {\n      translate(view, entry, -tx, 0);\n      translate(view, title, -tx, 0);\n    }\n  }\n}\n\nfunction legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {\n  const grad = item.datum.type !== 'symbol',\n        vgrad = title.datum.vgrad,\n        e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,\n        s = e.bounds[y ? 'y2' : 'x2'] - item.padding,\n        u = vgrad && lr ? s : 0,\n        v = vgrad && lr ? 0 : s,\n        o = y <= 0 ? 0 : multiLineOffset(title);\n  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s - o));\n}\n\nfunction translate(view, item, dx, dy) {\n  item.x += dx;\n  item.y += dy;\n  item.bounds.translate(dx, dy);\n  item.mark.bounds.translate(dx, dy);\n  view.dirty(item);\n}\n\nfunction legendEntryLayout(entries) {\n  // get max widths for each column\n  const widths = entries.reduce((w, g) => {\n    w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);\n    return w;\n  }, {}); // set dimensions of legend entry groups\n\n  entries.forEach(g => {\n    g.width = widths[g.column];\n    g.height = g.bounds.y2 - g.y;\n  });\n}\n\nfunction titleLayout(view, mark, width, height, viewBounds) {\n  var group = mark.items[0],\n      frame = group.frame,\n      orient = group.orient,\n      anchor = group.anchor,\n      offset = group.offset,\n      padding = group.padding,\n      title = group.items[0].items[0],\n      subtitle = group.items[1] && group.items[1].items[0],\n      end = orient === Left || orient === Right ? height : width,\n      start = 0,\n      x = 0,\n      y = 0,\n      sx = 0,\n      sy = 0,\n      pos;\n\n  if (frame !== Group) {\n    orient === Left ? (start = viewBounds.y2, end = viewBounds.y1) : orient === Right ? (start = viewBounds.y1, end = viewBounds.y2) : (start = viewBounds.x1, end = viewBounds.x2);\n  } else if (orient === Left) {\n    start = height, end = 0;\n  }\n\n  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;\n\n  if (subtitle && subtitle.text) {\n    // position subtitle\n    switch (orient) {\n      case Top:\n      case Bottom:\n        sy = title.bounds.height() + padding;\n        break;\n\n      case Left:\n        sx = title.bounds.width() + padding;\n        break;\n\n      case Right:\n        sx = -title.bounds.width() - padding;\n        break;\n    }\n\n    tempBounds.clear().union(subtitle.bounds);\n    tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));\n\n    if (set(subtitle, 'x', sx) | set(subtitle, 'y', sy)) {\n      view.dirty(subtitle);\n      subtitle.bounds.clear().union(tempBounds);\n      subtitle.mark.bounds.clear().union(tempBounds);\n      view.dirty(subtitle);\n    }\n\n    tempBounds.clear().union(subtitle.bounds);\n  } else {\n    tempBounds.clear();\n  }\n\n  tempBounds.union(title.bounds); // position title group\n\n  switch (orient) {\n    case Top:\n      x = pos;\n      y = viewBounds.y1 - tempBounds.height() - offset;\n      break;\n\n    case Left:\n      x = viewBounds.x1 - tempBounds.width() - offset;\n      y = pos;\n      break;\n\n    case Right:\n      x = viewBounds.x2 + tempBounds.width() + offset;\n      y = pos;\n      break;\n\n    case Bottom:\n      x = pos;\n      y = viewBounds.y2 + offset;\n      break;\n\n    default:\n      x = group.x;\n      y = group.y;\n  }\n\n  if (set(group, 'x', x) | set(group, 'y', y)) {\n    tempBounds.translate(x, y);\n    view.dirty(group);\n    group.bounds.clear().union(tempBounds);\n    mark.bounds.clear().union(tempBounds);\n    view.dirty(group);\n  }\n\n  return group.bounds;\n}\n/**\n * Layout view elements such as axes and legends.\n * Also performs size adjustments.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - Scenegraph mark of groups to layout.\n */\n\n\nfunction ViewLayout(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(ViewLayout, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n\n    _.mark.items.forEach(group => {\n      if (_.layout) trellisLayout(view, group, _.layout);\n      layoutGroup(view, group, _);\n    });\n\n    return shouldReflow(_.mark.group) ? pulse.reflow() : pulse;\n  }\n\n});\n\nfunction shouldReflow(group) {\n  // We typically should reflow if layout is invoked (#2568), as child items\n  // may have resized and reflow ensures group bounds are re-calculated.\n  // However, legend entries have a special exception to avoid instability.\n  // For example, if a selected legend symbol gains a stroke on hover,\n  // we don't want to re-position subsequent elements in the legend.\n  return group && group.mark.role !== 'legend-entry';\n}\n\nfunction layoutGroup(view, group, _) {\n  var items = group.items,\n      width = Math.max(0, group.width || 0),\n      height = Math.max(0, group.height || 0),\n      viewBounds = new Bounds().set(0, 0, width, height),\n      xBounds = viewBounds.clone(),\n      yBounds = viewBounds.clone(),\n      legends = [],\n      title,\n      mark,\n      orient,\n      b,\n      i,\n      n; // layout axes, gather legends, collect bounds\n\n  for (i = 0, n = items.length; i < n; ++i) {\n    mark = items[i];\n\n    switch (mark.role) {\n      case AxisRole:\n        b = isYAxis(mark) ? xBounds : yBounds;\n        b.union(axisLayout(view, mark, width, height));\n        break;\n\n      case TitleRole:\n        title = mark;\n        break;\n\n      case LegendRole:\n        legends.push(legendLayout(view, mark));\n        break;\n\n      case FrameRole:\n      case ScopeRole:\n      case RowHeader:\n      case RowFooter:\n      case RowTitle:\n      case ColHeader:\n      case ColFooter:\n      case ColTitle:\n        xBounds.union(mark.bounds);\n        yBounds.union(mark.bounds);\n        break;\n\n      default:\n        viewBounds.union(mark.bounds);\n    }\n  } // layout legends, adjust viewBounds\n\n\n  if (legends.length) {\n    // group legends by orient\n    const l = {};\n    legends.forEach(item => {\n      orient = item.orient || Right;\n      if (orient !== None) (l[orient] || (l[orient] = [])).push(item);\n    }); // perform grid layout for each orient group\n\n    for (const orient in l) {\n      const g = l[orient];\n      gridLayout(view, g, legendParams(g, orient, _.legends, xBounds, yBounds, width, height));\n    } // update view bounds\n\n\n    legends.forEach(item => {\n      const b = item.bounds;\n\n      if (!b.equals(item._bounds)) {\n        item.bounds = item._bounds;\n        view.dirty(item); // dirty previous location\n\n        item.bounds = b;\n        view.dirty(item);\n      }\n\n      if (_.autosize && _.autosize.type === Fit) {\n        // For autosize fit, incorporate the orthogonal dimension only.\n        // Legends that overrun the chart area will then be clipped;\n        // otherwise the chart area gets reduced to nothing!\n        switch (item.orient) {\n          case Left:\n          case Right:\n            viewBounds.add(b.x1, 0).add(b.x2, 0);\n            break;\n\n          case Top:\n          case Bottom:\n            viewBounds.add(0, b.y1).add(0, b.y2);\n        }\n      } else {\n        viewBounds.union(b);\n      }\n    });\n  } // combine bounding boxes\n\n\n  viewBounds.union(xBounds).union(yBounds); // layout title, adjust bounds\n\n  if (title) {\n    viewBounds.union(titleLayout(view, title, width, height, viewBounds));\n  } // override aggregated view bounds if content is clipped\n\n\n  if (group.clip) {\n    viewBounds.set(0, 0, group.width || 0, group.height || 0);\n  } // perform size adjustment\n\n\n  viewSizeLayout(view, group, viewBounds, _);\n}\n\nfunction viewSizeLayout(view, group, viewBounds, _) {\n  const auto = _.autosize || {},\n        type = auto.type;\n  if (view._autosize < 1 || !type) return;\n  let viewWidth = view._width,\n      viewHeight = view._height,\n      width = Math.max(0, group.width || 0),\n      left = Math.max(0, Math.ceil(-viewBounds.x1)),\n      height = Math.max(0, group.height || 0),\n      top = Math.max(0, Math.ceil(-viewBounds.y1));\n  const right = Math.max(0, Math.ceil(viewBounds.x2 - width)),\n        bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));\n\n  if (auto.contains === Padding) {\n    const padding = view.padding();\n    viewWidth -= padding.left + padding.right;\n    viewHeight -= padding.top + padding.bottom;\n  }\n\n  if (type === None) {\n    left = 0;\n    top = 0;\n    width = viewWidth;\n    height = viewHeight;\n  } else if (type === Fit) {\n    width = Math.max(0, viewWidth - left - right);\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === FitX) {\n    width = Math.max(0, viewWidth - left - right);\n    viewHeight = height + top + bottom;\n  } else if (type === FitY) {\n    viewWidth = width + left + right;\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === Pad) {\n    viewWidth = width + left + right;\n    viewHeight = height + top + bottom;\n  }\n\n  view._resizeView(viewWidth, viewHeight, width, height, [left, top], auto.resize);\n}\n\nexport { Bound as bound, Identifier as identifier, Mark as mark, Overlap as overlap, Render as render, ViewLayout as viewlayout };","map":{"version":3,"names":["Transform","Marks","boundClip","GroupItem","Item","Bounds","multiLineOffset","boundStroke","inherits","peek","isObject","Top","Left","Right","Bottom","TopLeft","TopRight","BottomLeft","BottomRight","Start","Middle","End","X","Y","Group","AxisRole","TitleRole","FrameRole","ScopeRole","LegendRole","RowHeader","RowFooter","RowTitle","ColHeader","ColFooter","ColTitle","Padding","Symbols","Fit","FitX","FitY","Pad","None","All","Each","Flush","Column","Row","Bound","params","call","transform","_","pulse","view","dataflow","mark","type","marktype","entry","bound","markBounds","bounds","rebound","nested","items","length","dirty","boundItem","forEach","item","clear","union","modified","visit","MOD","role","reflow","changed","REM","ADD","alignsWith","modifies","opt","COUNTER_NAME","Identifier","Definition","counter","getCounter","as","id","value","t","set","_signals","add","Mark","scenegraph","markdef","lookup","index","group","context","source","clip","interactive","Init","zdirty","g","groups","p","parent","size","get","Object","keys","object","Overlap","methods","parity","filter","i","opacity","greedy","sep","a","b","intersect","Math","max","x1","x2","y1","y2","hasOverlap","pad","n","hasBounds","width","height","boundTest","scale","orient","tolerance","range","Infinity","expand","encloses","reset","reduce","method","separation","materialize","SOURCE","test","sort","slice","boundScale","boundTolerance","boundOrient","Render","ALL","fields","tempBounds","property","isYAxis","axisIndices","datum","grid","ticks","labels","domain","axisLayout","axis","delta","translate","indices","offset","position","minExtent","maxExtent","title","titlePadding","dl","x","y","s","min","axisTitleLayout","sign","auto","v","dx","dy","floor","ceil","gridLayoutGroups","views","marks","rowheaders","rowfooters","colheaders","colfooters","rowtitle","coltitle","push","bboxFlush","bboxFull","clone","empty","key","d","undefined","offsetValue","gridLayout","nodirty","bbox","alignCol","align","alignRow","padCol","padding","padRow","ncols","columns","nrows","xOffset","Array","xExtent","xMax","yOffset","yExtent","yMax","boxes","m","c","r","px","py","center","anchor","round","trellisLayout","boundFlush","boundFull","off","cells","band","headerBand","layoutHeaders","footerBand","titleAnchor","titleBand","layoutTitle","field","headers","limit","agg","isX","bf","start","stride","back","init","edge","j","k","h","warn","lookup$1","config","offsets","legends","legendParams","xb","yb","w","mult","column","row","legendLayout","legend","_bounds","legendGroupLayout","legendBounds","legendEntryLayout","ex","ey","tpad","tx","ty","legendTitleOffset","lr","noBar","grad","vgrad","e","u","o","entries","widths","titleLayout","viewBounds","frame","subtitle","end","sx","sy","pos","text","ViewLayout","layout","layoutGroup","shouldReflow","xBounds","yBounds","l","equals","autosize","viewSizeLayout","_autosize","viewWidth","_width","viewHeight","_height","left","top","right","bottom","contains","_resizeView","resize","identifier","overlap","render","viewlayout"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-view-transforms/build/vega-view-transforms.module.js"],"sourcesContent":["import { Transform } from 'vega-dataflow';\nimport { Marks, boundClip, GroupItem, Item, Bounds, multiLineOffset, boundStroke } from 'vega-scenegraph';\nimport { inherits, peek, isObject } from 'vega-util';\n\nconst Top = 'top';\nconst Left = 'left';\nconst Right = 'right';\nconst Bottom = 'bottom';\nconst TopLeft = 'top-left';\nconst TopRight = 'top-right';\nconst BottomLeft = 'bottom-left';\nconst BottomRight = 'bottom-right';\nconst Start = 'start';\nconst Middle = 'middle';\nconst End = 'end';\nconst X = 'x';\nconst Y = 'y';\nconst Group = 'group';\nconst AxisRole = 'axis';\nconst TitleRole = 'title';\nconst FrameRole = 'frame';\nconst ScopeRole = 'scope';\nconst LegendRole = 'legend';\nconst RowHeader = 'row-header';\nconst RowFooter = 'row-footer';\nconst RowTitle = 'row-title';\nconst ColHeader = 'column-header';\nconst ColFooter = 'column-footer';\nconst ColTitle = 'column-title';\nconst Padding = 'padding';\nconst Symbols = 'symbol';\nconst Fit = 'fit';\nconst FitX = 'fit-x';\nconst FitY = 'fit-y';\nconst Pad = 'pad';\nconst None = 'none';\nconst All = 'all';\nconst Each = 'each';\nconst Flush = 'flush';\nconst Column = 'column';\nconst Row = 'row';\n\n/**\n * Calculate bounding boxes for scenegraph items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - The scenegraph mark instance to bound.\n */\n\nfunction Bound(params) {\n  Transform.call(this, null, params);\n}\ninherits(Bound, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow,\n          mark = _.mark,\n          type = mark.marktype,\n          entry = Marks[type],\n          bound = entry.bound;\n    let markBounds = mark.bounds,\n        rebound;\n\n    if (entry.nested) {\n      // multi-item marks have a single bounds instance\n      if (mark.items.length) view.dirty(mark.items[0]);\n      markBounds = boundItem(mark, bound);\n      mark.items.forEach(item => {\n        item.bounds.clear().union(markBounds);\n      });\n    } else if (type === Group || _.modified()) {\n      // operator parameters modified -> re-bound all items\n      // updates group bounds in response to modified group content\n      pulse.visit(pulse.MOD, item => view.dirty(item));\n      markBounds.clear();\n      mark.items.forEach(item => markBounds.union(boundItem(item, bound))); // force reflow for axes/legends/titles to propagate any layout changes\n\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          pulse.reflow();\n      }\n    } else {\n      // incrementally update bounds, re-bound mark as needed\n      rebound = pulse.changed(pulse.REM);\n      pulse.visit(pulse.ADD, item => {\n        markBounds.union(boundItem(item, bound));\n      });\n      pulse.visit(pulse.MOD, item => {\n        rebound = rebound || markBounds.alignsWith(item.bounds);\n        view.dirty(item);\n        markBounds.union(boundItem(item, bound));\n      });\n\n      if (rebound) {\n        markBounds.clear();\n        mark.items.forEach(item => markBounds.union(item.bounds));\n      }\n    } // ensure mark bounds do not exceed any clipping region\n\n\n    boundClip(mark);\n    return pulse.modifies('bounds');\n  }\n\n});\n\nfunction boundItem(item, bound, opt) {\n  return bound(item.bounds.clear(), item, opt);\n}\n\nconst COUNTER_NAME = ':vega_identifier:';\n/**\n * Adds a unique identifier to all added tuples.\n * This transform creates a new signal that serves as an id counter.\n * As a result, the id counter is shared across all instances of this\n * transform, generating unique ids across multiple data streams. In\n * addition, this signal value can be included in a snapshot of the\n * dataflow state, enabling correct resumption of id allocation.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.as - The field name for the generated identifier.\n */\n\nfunction Identifier(params) {\n  Transform.call(this, 0, params);\n}\nIdentifier.Definition = {\n  'type': 'Identifier',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'as',\n    'type': 'string',\n    'required': true\n  }]\n};\ninherits(Identifier, Transform, {\n  transform(_, pulse) {\n    const counter = getCounter(pulse.dataflow),\n          as = _.as;\n    let id = counter.value;\n    pulse.visit(pulse.ADD, t => t[as] = t[as] || ++id);\n    counter.set(this.value = id);\n    return pulse;\n  }\n\n});\n\nfunction getCounter(view) {\n  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));\n}\n\n/**\n * Bind scenegraph items to a scenegraph mark instance.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.markdef - The mark definition for creating the mark.\n *   This is an object of legal scenegraph mark properties which *must* include\n *   the 'marktype' property.\n */\n\nfunction Mark(params) {\n  Transform.call(this, null, params);\n}\ninherits(Mark, Transform, {\n  transform(_, pulse) {\n    let mark = this.value; // acquire mark on first invocation, bind context and group\n\n    if (!mark) {\n      mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup(_), _.index);\n      mark.group.context = _.context;\n      if (!_.context.group) _.context.group = mark.group;\n      mark.source = this.source; // point to upstream collector\n\n      mark.clip = _.clip;\n      mark.interactive = _.interactive;\n      this.value = mark;\n    } // initialize entering items\n\n\n    const Init = mark.marktype === Group ? GroupItem : Item;\n    pulse.visit(pulse.ADD, item => Init.call(item, mark)); // update clipping and/or interactive status\n\n    if (_.modified('clip') || _.modified('interactive')) {\n      mark.clip = _.clip;\n      mark.interactive = !!_.interactive;\n      mark.zdirty = true; // force scenegraph re-eval\n\n      pulse.reflow();\n    } // bind items array to scenegraph mark\n\n\n    mark.items = pulse.source;\n    return pulse;\n  }\n\n});\n\nfunction lookup(_) {\n  const g = _.groups,\n        p = _.parent;\n  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;\n}\n\n/**\n * Analyze items for overlap, changing opacity to hide items with\n * overlapping bounding boxes. This transform will preserve at least\n * two items (e.g., first and last) even if overlap persists.\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting items.\n * @param {object} [params.method] - The overlap removal method to apply.\n *   One of 'parity' (default, hide every other item until there is no\n *   more overlap) or 'greedy' (sequentially scan and hide and items that\n *   overlap with the last visible item).\n * @param {object} [params.boundScale] - A scale whose range should be used\n *   to bound the items. Items exceeding the bounds of the scale range\n *   will be treated as overlapping. If null or undefined, no bounds check\n *   will be applied.\n * @param {object} [params.boundOrient] - The orientation of the scale\n *   (top, bottom, left, or right) used to bound items. This parameter is\n *   ignored if boundScale is null or undefined.\n * @param {object} [params.boundTolerance] - The tolerance in pixels for\n *   bound inclusion testing (default 1). This specifies by how many pixels\n *   an item's bounds may exceed the scale range bounds and not be culled.\n * @constructor\n */\n\nfunction Overlap(params) {\n  Transform.call(this, null, params);\n}\nconst methods = {\n  parity: items => items.filter((item, i) => i % 2 ? item.opacity = 0 : 1),\n  greedy: (items, sep) => {\n    let a;\n    return items.filter((b, i) => !i || !intersect(a.bounds, b.bounds, sep) ? (a = b, 1) : b.opacity = 0);\n  }\n}; // compute bounding box intersection\n// including padding pixels of separation\n\nconst intersect = (a, b, sep) => sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);\n\nconst hasOverlap = (items, pad) => {\n  for (var i = 1, n = items.length, a = items[0].bounds, b; i < n; a = b, ++i) {\n    if (intersect(a, b = items[i].bounds, pad)) return true;\n  }\n};\n\nconst hasBounds = item => {\n  const b = item.bounds;\n  return b.width() > 1 && b.height() > 1;\n};\n\nconst boundTest = (scale, orient, tolerance) => {\n  var range = scale.range(),\n      b = new Bounds();\n\n  if (orient === Top || orient === Bottom) {\n    b.set(range[0], -Infinity, range[1], +Infinity);\n  } else {\n    b.set(-Infinity, range[0], +Infinity, range[1]);\n  }\n\n  b.expand(tolerance || 1);\n  return item => b.encloses(item.bounds);\n}; // reset all items to be fully opaque\n\n\nconst reset = source => {\n  source.forEach(item => item.opacity = 1);\n  return source;\n}; // add all tuples to mod, fork pulse if parameters were modified\n// fork prevents cross-stream tuple pollution (e.g., pulse from scale)\n\n\nconst reflow = (pulse, _) => pulse.reflow(_.modified()).modifies('opacity');\n\ninherits(Overlap, Transform, {\n  transform(_, pulse) {\n    const reduce = methods[_.method] || methods.parity,\n          sep = _.separation || 0;\n    let source = pulse.materialize(pulse.SOURCE).source,\n        items,\n        test;\n    if (!source || !source.length) return;\n\n    if (!_.method) {\n      // early exit if method is falsy\n      if (_.modified('method')) {\n        reset(source);\n        pulse = reflow(pulse, _);\n      }\n\n      return pulse;\n    } // skip labels with no content\n\n\n    source = source.filter(hasBounds); // early exit, nothing to do\n\n    if (!source.length) return;\n\n    if (_.sort) {\n      source = source.slice().sort(_.sort);\n    }\n\n    items = reset(source);\n    pulse = reflow(pulse, _);\n\n    if (items.length >= 3 && hasOverlap(items, sep)) {\n      do {\n        items = reduce(items, sep);\n      } while (items.length >= 3 && hasOverlap(items, sep));\n\n      if (items.length < 3 && !peek(source).opacity) {\n        if (items.length > 1) peek(items).opacity = 0;\n        peek(source).opacity = 1;\n      }\n    }\n\n    if (_.boundScale && _.boundTolerance >= 0) {\n      test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);\n      source.forEach(item => {\n        if (!test(item)) item.opacity = 0;\n      });\n    } // re-calculate mark bounds\n\n\n    const bounds = items[0].mark.bounds.clear();\n    source.forEach(item => {\n      if (item.opacity) bounds.union(item.bounds);\n    });\n    return pulse;\n  }\n\n});\n\n/**\n * Queue modified scenegraph items for rendering.\n * @constructor\n */\n\nfunction Render(params) {\n  Transform.call(this, null, params);\n}\ninherits(Render, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n    pulse.visit(pulse.ALL, item => view.dirty(item)); // set z-index dirty flag as needed\n\n    if (pulse.fields && pulse.fields['zindex']) {\n      const item = pulse.source && pulse.source[0];\n      if (item) item.mark.zdirty = true;\n    }\n  }\n\n});\n\nconst tempBounds = new Bounds();\nfunction set(item, property, value) {\n  return item[property] === value ? 0 : (item[property] = value, 1);\n}\n\nfunction isYAxis(mark) {\n  var orient = mark.items[0].orient;\n  return orient === Left || orient === Right;\n}\n\nfunction axisIndices(datum) {\n  let index = +datum.grid;\n  return [datum.ticks ? index++ : -1, // ticks index\n  datum.labels ? index++ : -1, // labels index\n  index + +datum.domain // title index\n  ];\n}\n\nfunction axisLayout(view, axis, width, height) {\n  var item = axis.items[0],\n      datum = item.datum,\n      delta = item.translate != null ? item.translate : 0.5,\n      orient = item.orient,\n      indices = axisIndices(datum),\n      range = item.range,\n      offset = item.offset,\n      position = item.position,\n      minExtent = item.minExtent,\n      maxExtent = item.maxExtent,\n      title = datum.title && item.items[indices[2]].items[0],\n      titlePadding = item.titlePadding,\n      bounds = item.bounds,\n      dl = title && multiLineOffset(title),\n      x = 0,\n      y = 0,\n      i,\n      s;\n  tempBounds.clear().union(bounds);\n  bounds.clear();\n  if ((i = indices[0]) > -1) bounds.union(item.items[i].bounds);\n  if ((i = indices[1]) > -1) bounds.union(item.items[i].bounds); // position axis group and title\n\n  switch (orient) {\n    case Top:\n      x = position || 0;\n      y = -offset;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));\n      bounds.add(0, -s).add(range, 0);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds);\n      break;\n\n    case Left:\n      x = -offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));\n      bounds.add(-s, 0).add(0, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds);\n      break;\n\n    case Right:\n      x = width + offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));\n      bounds.add(0, 0).add(s, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds);\n      break;\n\n    case Bottom:\n      x = position || 0;\n      y = height + offset;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));\n      bounds.add(0, 0).add(range, s);\n      if (title) axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds);\n      break;\n\n    default:\n      x = item.x;\n      y = item.y;\n  } // update bounds\n\n\n  boundStroke(bounds.translate(x, y), item);\n\n  if (set(item, 'x', x + delta) | set(item, 'y', y + delta)) {\n    item.bounds = tempBounds;\n    view.dirty(item);\n    item.bounds = bounds;\n    view.dirty(item);\n  }\n\n  return item.mark.bounds.clear().union(bounds);\n}\n\nfunction axisTitleLayout(view, title, offset, pad, dl, isYAxis, sign, bounds) {\n  const b = title.bounds;\n\n  if (title.auto) {\n    const v = sign * (offset + dl + pad);\n    let dx = 0,\n        dy = 0;\n    view.dirty(title);\n    isYAxis ? dx = (title.x || 0) - (title.x = v) : dy = (title.y || 0) - (title.y = v);\n    title.mark.bounds.clear().union(b.translate(-dx, -dy));\n    view.dirty(title);\n  }\n\n  bounds.union(b);\n}\n\nconst min = (a, b) => Math.floor(Math.min(a, b));\n\nconst max = (a, b) => Math.ceil(Math.max(a, b));\n\nfunction gridLayoutGroups(group) {\n  var groups = group.items,\n      n = groups.length,\n      i = 0,\n      mark,\n      items;\n  const views = {\n    marks: [],\n    rowheaders: [],\n    rowfooters: [],\n    colheaders: [],\n    colfooters: [],\n    rowtitle: null,\n    coltitle: null\n  }; // layout axes, gather legends, collect bounds\n\n  for (; i < n; ++i) {\n    mark = groups[i];\n    items = mark.items;\n\n    if (mark.marktype === Group) {\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          break;\n\n        case RowHeader:\n          views.rowheaders.push(...items);\n          break;\n\n        case RowFooter:\n          views.rowfooters.push(...items);\n          break;\n\n        case ColHeader:\n          views.colheaders.push(...items);\n          break;\n\n        case ColFooter:\n          views.colfooters.push(...items);\n          break;\n\n        case RowTitle:\n          views.rowtitle = items[0];\n          break;\n\n        case ColTitle:\n          views.coltitle = items[0];\n          break;\n\n        default:\n          views.marks.push(...items);\n      }\n    }\n  }\n\n  return views;\n}\n\nfunction bboxFlush(item) {\n  return new Bounds().set(0, 0, item.width || 0, item.height || 0);\n}\n\nfunction bboxFull(item) {\n  const b = item.bounds.clone();\n  return b.empty() ? b.set(0, 0, 0, 0) : b.translate(-(item.x || 0), -(item.y || 0));\n}\n\nfunction get(opt, key, d) {\n  const v = isObject(opt) ? opt[key] : opt;\n  return v != null ? v : d !== undefined ? d : 0;\n}\n\nfunction offsetValue(v) {\n  return v < 0 ? Math.ceil(-v) : 0;\n}\n\nfunction gridLayout(view, groups, opt) {\n  var dirty = !opt.nodirty,\n      bbox = opt.bounds === Flush ? bboxFlush : bboxFull,\n      bounds = tempBounds.set(0, 0, 0, 0),\n      alignCol = get(opt.align, Column),\n      alignRow = get(opt.align, Row),\n      padCol = get(opt.padding, Column),\n      padRow = get(opt.padding, Row),\n      ncols = opt.columns || groups.length,\n      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n      n = groups.length,\n      xOffset = Array(n),\n      xExtent = Array(ncols),\n      xMax = 0,\n      yOffset = Array(n),\n      yExtent = Array(nrows),\n      yMax = 0,\n      dx = Array(n),\n      dy = Array(n),\n      boxes = Array(n),\n      m,\n      i,\n      c,\n      r,\n      b,\n      g,\n      px,\n      py,\n      x,\n      y,\n      offset;\n\n  for (i = 0; i < ncols; ++i) xExtent[i] = 0;\n\n  for (i = 0; i < nrows; ++i) yExtent[i] = 0; // determine offsets for each group\n\n\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    b = boxes[i] = bbox(g);\n    g.x = g.x || 0;\n    dx[i] = 0;\n    g.y = g.y || 0;\n    dy[i] = 0;\n    c = i % ncols;\n    r = ~~(i / ncols);\n    xMax = Math.max(xMax, px = Math.ceil(b.x2));\n    yMax = Math.max(yMax, py = Math.ceil(b.y2));\n    xExtent[c] = Math.max(xExtent[c], px);\n    yExtent[r] = Math.max(yExtent[r], py);\n    xOffset[i] = padCol + offsetValue(b.x1);\n    yOffset[i] = padRow + offsetValue(b.y1);\n    if (dirty) view.dirty(groups[i]);\n  } // set initial alignment offsets\n\n\n  for (i = 0; i < n; ++i) {\n    if (i % ncols === 0) xOffset[i] = 0;\n    if (i < ncols) yOffset[i] = 0;\n  } // enforce column alignment constraints\n\n\n  if (alignCol === Each) {\n    for (c = 1; c < ncols; ++c) {\n      for (offset = 0, i = c; i < n; i += ncols) {\n        if (offset < xOffset[i]) offset = xOffset[i];\n      }\n\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] = offset + xExtent[c - 1];\n      }\n    }\n  } else if (alignCol === All) {\n    for (offset = 0, i = 0; i < n; ++i) {\n      if (i % ncols && offset < xOffset[i]) offset = xOffset[i];\n    }\n\n    for (i = 0; i < n; ++i) {\n      if (i % ncols) xOffset[i] = offset + xMax;\n    }\n  } else {\n    for (alignCol = false, c = 1; c < ncols; ++c) {\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] += xExtent[c - 1];\n      }\n    }\n  } // enforce row alignment constraints\n\n\n  if (alignRow === Each) {\n    for (r = 1; r < nrows; ++r) {\n      for (offset = 0, i = r * ncols, m = i + ncols; i < m; ++i) {\n        if (offset < yOffset[i]) offset = yOffset[i];\n      }\n\n      for (i = r * ncols; i < m; ++i) {\n        yOffset[i] = offset + yExtent[r - 1];\n      }\n    }\n  } else if (alignRow === All) {\n    for (offset = 0, i = ncols; i < n; ++i) {\n      if (offset < yOffset[i]) offset = yOffset[i];\n    }\n\n    for (i = ncols; i < n; ++i) {\n      yOffset[i] = offset + yMax;\n    }\n  } else {\n    for (alignRow = false, r = 1; r < nrows; ++r) {\n      for (i = r * ncols, m = i + ncols; i < m; ++i) {\n        yOffset[i] += yExtent[r - 1];\n      }\n    }\n  } // perform horizontal grid layout\n\n\n  for (x = 0, i = 0; i < n; ++i) {\n    x = xOffset[i] + (i % ncols ? x : 0);\n    dx[i] += x - groups[i].x;\n  } // perform vertical grid layout\n\n\n  for (c = 0; c < ncols; ++c) {\n    for (y = 0, i = c; i < n; i += ncols) {\n      y += yOffset[i];\n      dy[i] += y - groups[i].y;\n    }\n  } // perform horizontal centering\n\n\n  if (alignCol && get(opt.center, Column) && nrows > 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignCol === All ? xMax : xExtent[i % ncols];\n      x = b - boxes[i].x2 - groups[i].x - dx[i];\n      if (x > 0) dx[i] += x / 2;\n    }\n  } // perform vertical centering\n\n\n  if (alignRow && get(opt.center, Row) && ncols !== 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignRow === All ? yMax : yExtent[~~(i / ncols)];\n      y = b - boxes[i].y2 - groups[i].y - dy[i];\n      if (y > 0) dy[i] += y / 2;\n    }\n  } // position grid relative to anchor\n\n\n  for (i = 0; i < n; ++i) {\n    bounds.union(boxes[i].translate(dx[i], dy[i]));\n  }\n\n  x = get(opt.anchor, X);\n  y = get(opt.anchor, Y);\n\n  switch (get(opt.anchor, Column)) {\n    case End:\n      x -= bounds.width();\n      break;\n\n    case Middle:\n      x -= bounds.width() / 2;\n  }\n\n  switch (get(opt.anchor, Row)) {\n    case End:\n      y -= bounds.height();\n      break;\n\n    case Middle:\n      y -= bounds.height() / 2;\n  }\n\n  x = Math.round(x);\n  y = Math.round(y); // update mark positions, bounds, dirty\n\n  bounds.clear();\n\n  for (i = 0; i < n; ++i) {\n    groups[i].mark.bounds.clear();\n  }\n\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    g.x += dx[i] += x;\n    g.y += dy[i] += y;\n    bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));\n    if (dirty) view.dirty(g);\n  }\n\n  return bounds;\n}\nfunction trellisLayout(view, group, opt) {\n  var views = gridLayoutGroups(group),\n      groups = views.marks,\n      bbox = opt.bounds === Flush ? boundFlush : boundFull,\n      off = opt.offset,\n      ncols = opt.columns || groups.length,\n      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n      cells = nrows * ncols,\n      x,\n      y,\n      x2,\n      y2,\n      anchor,\n      band,\n      offset; // -- initial grid layout\n\n  const bounds = gridLayout(view, groups, opt);\n  if (bounds.empty()) bounds.set(0, 0, 0, 0); // empty grid\n  // -- layout grid headers and footers --\n  // perform row header layout\n\n  if (views.rowheaders) {\n    band = get(opt.headerBand, Row, null);\n    x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);\n  } // perform column header layout\n\n\n  if (views.colheaders) {\n    band = get(opt.headerBand, Column, null);\n    y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);\n  } // perform row footer layout\n\n\n  if (views.rowfooters) {\n    band = get(opt.footerBand, Row, null);\n    x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols - 1, ncols, 1, band);\n  } // perform column footer layout\n\n\n  if (views.colfooters) {\n    band = get(opt.footerBand, Column, null);\n    y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get(off, 'columnFooter'), max, 1, bbox, 'y2', cells - ncols, 1, ncols, band);\n  } // perform row title layout\n\n\n  if (views.rowtitle) {\n    anchor = get(opt.titleAnchor, Row);\n    offset = get(off, 'rowTitle');\n    offset = anchor === End ? x2 + offset : x - offset;\n    band = get(opt.titleBand, Row, 0.5);\n    layoutTitle(view, views.rowtitle, offset, 0, bounds, band);\n  } // perform column title layout\n\n\n  if (views.coltitle) {\n    anchor = get(opt.titleAnchor, Column);\n    offset = get(off, 'columnTitle');\n    offset = anchor === End ? y2 + offset : y - offset;\n    band = get(opt.titleBand, Column, 0.5);\n    layoutTitle(view, views.coltitle, offset, 1, bounds, band);\n  }\n}\n\nfunction boundFlush(item, field) {\n  return field === 'x1' ? item.x || 0 : field === 'y1' ? item.y || 0 : field === 'x2' ? (item.x || 0) + (item.width || 0) : field === 'y2' ? (item.y || 0) + (item.height || 0) : undefined;\n}\n\nfunction boundFull(item, field) {\n  return item.bounds[field];\n}\n\nfunction layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {\n  var n = groups.length,\n      init = 0,\n      edge = 0,\n      i,\n      j,\n      k,\n      m,\n      b,\n      h,\n      g,\n      x,\n      y; // if no groups, early exit and return 0\n\n  if (!n) return init; // compute margin\n\n  for (i = start; i < n; i += stride) {\n    if (groups[i]) init = agg(init, bound(groups[i], bf));\n  } // if no headers, return margin calculation\n\n\n  if (!headers.length) return init; // check if number of headers exceeds number of rows or columns\n\n  if (headers.length > limit) {\n    view.warn('Grid headers exceed limit: ' + limit);\n    headers = headers.slice(0, limit);\n  } // apply offset\n\n\n  init += offset; // clear mark bounds for all headers\n\n  for (j = 0, m = headers.length; j < m; ++j) {\n    view.dirty(headers[j]);\n    headers[j].mark.bounds.clear();\n  } // layout each header\n\n\n  for (i = start, j = 0, m = headers.length; j < m; ++j, i += stride) {\n    h = headers[j];\n    b = h.mark.bounds; // search for nearest group to align to\n    // necessary if table has empty cells\n\n    for (k = i; k >= 0 && (g = groups[k]) == null; k -= back); // assign coordinates and update bounds\n\n\n    if (isX) {\n      x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());\n      y = init;\n    } else {\n      x = init;\n      y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());\n    }\n\n    b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));\n    h.x = x;\n    h.y = y;\n    view.dirty(h); // update current edge of layout bounds\n\n    edge = agg(edge, b[bf]);\n  }\n\n  return edge;\n}\n\nfunction layoutTitle(view, g, offset, isX, bounds, band) {\n  if (!g) return;\n  view.dirty(g); // compute title coordinates\n\n  var x = offset,\n      y = offset;\n  isX ? x = Math.round(bounds.x1 + band * bounds.width()) : y = Math.round(bounds.y1 + band * bounds.height()); // assign coordinates and update bounds\n\n  g.bounds.translate(x - (g.x || 0), y - (g.y || 0));\n  g.mark.bounds.clear().union(g.bounds);\n  g.x = x;\n  g.y = y; // queue title for redraw\n\n  view.dirty(g);\n}\n\nfunction lookup$1(config, orient) {\n  const opt = config[orient] || {};\n  return (key, d) => opt[key] != null ? opt[key] : config[key] != null ? config[key] : d;\n} // if legends specify offset directly, use the maximum specified value\n\n\nfunction offsets(legends, value) {\n  let max = -Infinity;\n  legends.forEach(item => {\n    if (item.offset != null) max = Math.max(max, item.offset);\n  });\n  return max > -Infinity ? max : value;\n}\n\nfunction legendParams(g, orient, config, xb, yb, w, h) {\n  const _ = lookup$1(config, orient),\n        offset = offsets(g, _('offset', 0)),\n        anchor = _('anchor', Start),\n        mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;\n\n  const p = {\n    align: Each,\n    bounds: _('bounds', Flush),\n    columns: _('direction') === 'vertical' ? 1 : g.length,\n    padding: _('margin', 8),\n    center: _('center'),\n    nodirty: true\n  };\n\n  switch (orient) {\n    case Left:\n      p.anchor = {\n        x: Math.floor(xb.x1) - offset,\n        column: End,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n\n    case Right:\n      p.anchor = {\n        x: Math.ceil(xb.x2) + offset,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n\n    case Top:\n      p.anchor = {\n        y: Math.floor(yb.y1) - offset,\n        row: End,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n\n    case Bottom:\n      p.anchor = {\n        y: Math.ceil(yb.y2) + offset,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n\n    case TopLeft:\n      p.anchor = {\n        x: offset,\n        y: offset\n      };\n      break;\n\n    case TopRight:\n      p.anchor = {\n        x: w - offset,\n        y: offset,\n        column: End\n      };\n      break;\n\n    case BottomLeft:\n      p.anchor = {\n        x: offset,\n        y: h - offset,\n        row: End\n      };\n      break;\n\n    case BottomRight:\n      p.anchor = {\n        x: w - offset,\n        y: h - offset,\n        column: End,\n        row: End\n      };\n      break;\n  }\n\n  return p;\n}\nfunction legendLayout(view, legend) {\n  var item = legend.items[0],\n      datum = item.datum,\n      orient = item.orient,\n      bounds = item.bounds,\n      x = item.x,\n      y = item.y,\n      w,\n      h; // cache current bounds for later comparison\n\n  item._bounds ? item._bounds.clear().union(bounds) : item._bounds = bounds.clone();\n  bounds.clear(); // adjust legend to accommodate padding and title\n\n  legendGroupLayout(view, item, item.items[0].items[0]); // aggregate bounds to determine size, and include origin\n\n  bounds = legendBounds(item, bounds);\n  w = 2 * item.padding;\n  h = 2 * item.padding;\n\n  if (!bounds.empty()) {\n    w = Math.ceil(bounds.width() + w);\n    h = Math.ceil(bounds.height() + h);\n  }\n\n  if (datum.type === Symbols) {\n    legendEntryLayout(item.items[0].items[0].items[0].items);\n  }\n\n  if (orient !== None) {\n    item.x = x = 0;\n    item.y = y = 0;\n  }\n\n  item.width = w;\n  item.height = h;\n  boundStroke(bounds.set(x, y, x + w, y + h), item);\n  item.mark.bounds.clear().union(bounds);\n  return item;\n}\n\nfunction legendBounds(item, b) {\n  // aggregate item bounds\n  item.items.forEach(_ => b.union(_.bounds)); // anchor to legend origin\n\n  b.x1 = item.padding;\n  b.y1 = item.padding;\n  return b;\n}\n\nfunction legendGroupLayout(view, item, entry) {\n  var pad = item.padding,\n      ex = pad - entry.x,\n      ey = pad - entry.y;\n\n  if (!item.datum.title) {\n    if (ex || ey) translate(view, entry, ex, ey);\n  } else {\n    var title = item.items[1].items[0],\n        anchor = title.anchor,\n        tpad = item.titlePadding || 0,\n        tx = pad - title.x,\n        ty = pad - title.y;\n\n    switch (title.orient) {\n      case Left:\n        ex += Math.ceil(title.bounds.width()) + tpad;\n        break;\n\n      case Right:\n      case Bottom:\n        break;\n\n      default:\n        ey += title.bounds.height() + tpad;\n    }\n\n    if (ex || ey) translate(view, entry, ex, ey);\n\n    switch (title.orient) {\n      case Left:\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n\n      case Right:\n        tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n\n      case Bottom:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n        ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;\n        break;\n\n      default:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n    }\n\n    if (tx || ty) translate(view, title, tx, ty); // translate legend if title pushes into negative coordinates\n\n    if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {\n      translate(view, entry, -tx, 0);\n      translate(view, title, -tx, 0);\n    }\n  }\n}\n\nfunction legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {\n  const grad = item.datum.type !== 'symbol',\n        vgrad = title.datum.vgrad,\n        e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,\n        s = e.bounds[y ? 'y2' : 'x2'] - item.padding,\n        u = vgrad && lr ? s : 0,\n        v = vgrad && lr ? 0 : s,\n        o = y <= 0 ? 0 : multiLineOffset(title);\n  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s - o));\n}\n\nfunction translate(view, item, dx, dy) {\n  item.x += dx;\n  item.y += dy;\n  item.bounds.translate(dx, dy);\n  item.mark.bounds.translate(dx, dy);\n  view.dirty(item);\n}\n\nfunction legendEntryLayout(entries) {\n  // get max widths for each column\n  const widths = entries.reduce((w, g) => {\n    w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);\n    return w;\n  }, {}); // set dimensions of legend entry groups\n\n  entries.forEach(g => {\n    g.width = widths[g.column];\n    g.height = g.bounds.y2 - g.y;\n  });\n}\n\nfunction titleLayout(view, mark, width, height, viewBounds) {\n  var group = mark.items[0],\n      frame = group.frame,\n      orient = group.orient,\n      anchor = group.anchor,\n      offset = group.offset,\n      padding = group.padding,\n      title = group.items[0].items[0],\n      subtitle = group.items[1] && group.items[1].items[0],\n      end = orient === Left || orient === Right ? height : width,\n      start = 0,\n      x = 0,\n      y = 0,\n      sx = 0,\n      sy = 0,\n      pos;\n\n  if (frame !== Group) {\n    orient === Left ? (start = viewBounds.y2, end = viewBounds.y1) : orient === Right ? (start = viewBounds.y1, end = viewBounds.y2) : (start = viewBounds.x1, end = viewBounds.x2);\n  } else if (orient === Left) {\n    start = height, end = 0;\n  }\n\n  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;\n\n  if (subtitle && subtitle.text) {\n    // position subtitle\n    switch (orient) {\n      case Top:\n      case Bottom:\n        sy = title.bounds.height() + padding;\n        break;\n\n      case Left:\n        sx = title.bounds.width() + padding;\n        break;\n\n      case Right:\n        sx = -title.bounds.width() - padding;\n        break;\n    }\n\n    tempBounds.clear().union(subtitle.bounds);\n    tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));\n\n    if (set(subtitle, 'x', sx) | set(subtitle, 'y', sy)) {\n      view.dirty(subtitle);\n      subtitle.bounds.clear().union(tempBounds);\n      subtitle.mark.bounds.clear().union(tempBounds);\n      view.dirty(subtitle);\n    }\n\n    tempBounds.clear().union(subtitle.bounds);\n  } else {\n    tempBounds.clear();\n  }\n\n  tempBounds.union(title.bounds); // position title group\n\n  switch (orient) {\n    case Top:\n      x = pos;\n      y = viewBounds.y1 - tempBounds.height() - offset;\n      break;\n\n    case Left:\n      x = viewBounds.x1 - tempBounds.width() - offset;\n      y = pos;\n      break;\n\n    case Right:\n      x = viewBounds.x2 + tempBounds.width() + offset;\n      y = pos;\n      break;\n\n    case Bottom:\n      x = pos;\n      y = viewBounds.y2 + offset;\n      break;\n\n    default:\n      x = group.x;\n      y = group.y;\n  }\n\n  if (set(group, 'x', x) | set(group, 'y', y)) {\n    tempBounds.translate(x, y);\n    view.dirty(group);\n    group.bounds.clear().union(tempBounds);\n    mark.bounds.clear().union(tempBounds);\n    view.dirty(group);\n  }\n\n  return group.bounds;\n}\n\n/**\n * Layout view elements such as axes and legends.\n * Also performs size adjustments.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - Scenegraph mark of groups to layout.\n */\n\nfunction ViewLayout(params) {\n  Transform.call(this, null, params);\n}\ninherits(ViewLayout, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n\n    _.mark.items.forEach(group => {\n      if (_.layout) trellisLayout(view, group, _.layout);\n      layoutGroup(view, group, _);\n    });\n\n    return shouldReflow(_.mark.group) ? pulse.reflow() : pulse;\n  }\n\n});\n\nfunction shouldReflow(group) {\n  // We typically should reflow if layout is invoked (#2568), as child items\n  // may have resized and reflow ensures group bounds are re-calculated.\n  // However, legend entries have a special exception to avoid instability.\n  // For example, if a selected legend symbol gains a stroke on hover,\n  // we don't want to re-position subsequent elements in the legend.\n  return group && group.mark.role !== 'legend-entry';\n}\n\nfunction layoutGroup(view, group, _) {\n  var items = group.items,\n      width = Math.max(0, group.width || 0),\n      height = Math.max(0, group.height || 0),\n      viewBounds = new Bounds().set(0, 0, width, height),\n      xBounds = viewBounds.clone(),\n      yBounds = viewBounds.clone(),\n      legends = [],\n      title,\n      mark,\n      orient,\n      b,\n      i,\n      n; // layout axes, gather legends, collect bounds\n\n  for (i = 0, n = items.length; i < n; ++i) {\n    mark = items[i];\n\n    switch (mark.role) {\n      case AxisRole:\n        b = isYAxis(mark) ? xBounds : yBounds;\n        b.union(axisLayout(view, mark, width, height));\n        break;\n\n      case TitleRole:\n        title = mark;\n        break;\n\n      case LegendRole:\n        legends.push(legendLayout(view, mark));\n        break;\n\n      case FrameRole:\n      case ScopeRole:\n      case RowHeader:\n      case RowFooter:\n      case RowTitle:\n      case ColHeader:\n      case ColFooter:\n      case ColTitle:\n        xBounds.union(mark.bounds);\n        yBounds.union(mark.bounds);\n        break;\n\n      default:\n        viewBounds.union(mark.bounds);\n    }\n  } // layout legends, adjust viewBounds\n\n\n  if (legends.length) {\n    // group legends by orient\n    const l = {};\n    legends.forEach(item => {\n      orient = item.orient || Right;\n      if (orient !== None) (l[orient] || (l[orient] = [])).push(item);\n    }); // perform grid layout for each orient group\n\n    for (const orient in l) {\n      const g = l[orient];\n      gridLayout(view, g, legendParams(g, orient, _.legends, xBounds, yBounds, width, height));\n    } // update view bounds\n\n\n    legends.forEach(item => {\n      const b = item.bounds;\n\n      if (!b.equals(item._bounds)) {\n        item.bounds = item._bounds;\n        view.dirty(item); // dirty previous location\n\n        item.bounds = b;\n        view.dirty(item);\n      }\n\n      if (_.autosize && _.autosize.type === Fit) {\n        // For autosize fit, incorporate the orthogonal dimension only.\n        // Legends that overrun the chart area will then be clipped;\n        // otherwise the chart area gets reduced to nothing!\n        switch (item.orient) {\n          case Left:\n          case Right:\n            viewBounds.add(b.x1, 0).add(b.x2, 0);\n            break;\n\n          case Top:\n          case Bottom:\n            viewBounds.add(0, b.y1).add(0, b.y2);\n        }\n      } else {\n        viewBounds.union(b);\n      }\n    });\n  } // combine bounding boxes\n\n\n  viewBounds.union(xBounds).union(yBounds); // layout title, adjust bounds\n\n  if (title) {\n    viewBounds.union(titleLayout(view, title, width, height, viewBounds));\n  } // override aggregated view bounds if content is clipped\n\n\n  if (group.clip) {\n    viewBounds.set(0, 0, group.width || 0, group.height || 0);\n  } // perform size adjustment\n\n\n  viewSizeLayout(view, group, viewBounds, _);\n}\n\nfunction viewSizeLayout(view, group, viewBounds, _) {\n  const auto = _.autosize || {},\n        type = auto.type;\n  if (view._autosize < 1 || !type) return;\n  let viewWidth = view._width,\n      viewHeight = view._height,\n      width = Math.max(0, group.width || 0),\n      left = Math.max(0, Math.ceil(-viewBounds.x1)),\n      height = Math.max(0, group.height || 0),\n      top = Math.max(0, Math.ceil(-viewBounds.y1));\n  const right = Math.max(0, Math.ceil(viewBounds.x2 - width)),\n        bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));\n\n  if (auto.contains === Padding) {\n    const padding = view.padding();\n    viewWidth -= padding.left + padding.right;\n    viewHeight -= padding.top + padding.bottom;\n  }\n\n  if (type === None) {\n    left = 0;\n    top = 0;\n    width = viewWidth;\n    height = viewHeight;\n  } else if (type === Fit) {\n    width = Math.max(0, viewWidth - left - right);\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === FitX) {\n    width = Math.max(0, viewWidth - left - right);\n    viewHeight = height + top + bottom;\n  } else if (type === FitY) {\n    viewWidth = width + left + right;\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === Pad) {\n    viewWidth = width + left + right;\n    viewHeight = height + top + bottom;\n  }\n\n  view._resizeView(viewWidth, viewHeight, width, height, [left, top], auto.resize);\n}\n\nexport { Bound as bound, Identifier as identifier, Mark as mark, Overlap as overlap, Render as render, ViewLayout as viewlayout };\n"],"mappings":"AAAA,SAASA,SAAT,QAA0B,eAA1B;AACA,SAASC,KAAT,EAAgBC,SAAhB,EAA2BC,SAA3B,EAAsCC,IAAtC,EAA4CC,MAA5C,EAAoDC,eAApD,EAAqEC,WAArE,QAAwF,iBAAxF;AACA,SAASC,QAAT,EAAmBC,IAAnB,EAAyBC,QAAzB,QAAyC,WAAzC;AAEA,MAAMC,GAAG,GAAG,KAAZ;AACA,MAAMC,IAAI,GAAG,MAAb;AACA,MAAMC,KAAK,GAAG,OAAd;AACA,MAAMC,MAAM,GAAG,QAAf;AACA,MAAMC,OAAO,GAAG,UAAhB;AACA,MAAMC,QAAQ,GAAG,WAAjB;AACA,MAAMC,UAAU,GAAG,aAAnB;AACA,MAAMC,WAAW,GAAG,cAApB;AACA,MAAMC,KAAK,GAAG,OAAd;AACA,MAAMC,MAAM,GAAG,QAAf;AACA,MAAMC,GAAG,GAAG,KAAZ;AACA,MAAMC,CAAC,GAAG,GAAV;AACA,MAAMC,CAAC,GAAG,GAAV;AACA,MAAMC,KAAK,GAAG,OAAd;AACA,MAAMC,QAAQ,GAAG,MAAjB;AACA,MAAMC,SAAS,GAAG,OAAlB;AACA,MAAMC,SAAS,GAAG,OAAlB;AACA,MAAMC,SAAS,GAAG,OAAlB;AACA,MAAMC,UAAU,GAAG,QAAnB;AACA,MAAMC,SAAS,GAAG,YAAlB;AACA,MAAMC,SAAS,GAAG,YAAlB;AACA,MAAMC,QAAQ,GAAG,WAAjB;AACA,MAAMC,SAAS,GAAG,eAAlB;AACA,MAAMC,SAAS,GAAG,eAAlB;AACA,MAAMC,QAAQ,GAAG,cAAjB;AACA,MAAMC,OAAO,GAAG,SAAhB;AACA,MAAMC,OAAO,GAAG,QAAhB;AACA,MAAMC,GAAG,GAAG,KAAZ;AACA,MAAMC,IAAI,GAAG,OAAb;AACA,MAAMC,IAAI,GAAG,OAAb;AACA,MAAMC,GAAG,GAAG,KAAZ;AACA,MAAMC,IAAI,GAAG,MAAb;AACA,MAAMC,GAAG,GAAG,KAAZ;AACA,MAAMC,IAAI,GAAG,MAAb;AACA,MAAMC,KAAK,GAAG,OAAd;AACA,MAAMC,MAAM,GAAG,QAAf;AACA,MAAMC,GAAG,GAAG,KAAZ;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,KAAT,CAAeC,MAAf,EAAuB;EACrBjD,SAAS,CAACkD,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACDzC,QAAQ,CAACwC,KAAD,EAAQhD,SAAR,EAAmB;EACzBmD,SAAS,CAACC,CAAD,EAAIC,KAAJ,EAAW;IAClB,MAAMC,IAAI,GAAGD,KAAK,CAACE,QAAnB;IAAA,MACMC,IAAI,GAAGJ,CAAC,CAACI,IADf;IAAA,MAEMC,IAAI,GAAGD,IAAI,CAACE,QAFlB;IAAA,MAGMC,KAAK,GAAG1D,KAAK,CAACwD,IAAD,CAHnB;IAAA,MAIMG,KAAK,GAAGD,KAAK,CAACC,KAJpB;IAKA,IAAIC,UAAU,GAAGL,IAAI,CAACM,MAAtB;IAAA,IACIC,OADJ;;IAGA,IAAIJ,KAAK,CAACK,MAAV,EAAkB;MAChB;MACA,IAAIR,IAAI,CAACS,KAAL,CAAWC,MAAf,EAAuBZ,IAAI,CAACa,KAAL,CAAWX,IAAI,CAACS,KAAL,CAAW,CAAX,CAAX;MACvBJ,UAAU,GAAGO,SAAS,CAACZ,IAAD,EAAOI,KAAP,CAAtB;MACAJ,IAAI,CAACS,KAAL,CAAWI,OAAX,CAAmBC,IAAI,IAAI;QACzBA,IAAI,CAACR,MAAL,CAAYS,KAAZ,GAAoBC,KAApB,CAA0BX,UAA1B;MACD,CAFD;IAGD,CAPD,MAOO,IAAIJ,IAAI,KAAKjC,KAAT,IAAkB4B,CAAC,CAACqB,QAAF,EAAtB,EAAoC;MACzC;MACA;MACApB,KAAK,CAACqB,KAAN,CAAYrB,KAAK,CAACsB,GAAlB,EAAuBL,IAAI,IAAIhB,IAAI,CAACa,KAAL,CAAWG,IAAX,CAA/B;MACAT,UAAU,CAACU,KAAX;MACAf,IAAI,CAACS,KAAL,CAAWI,OAAX,CAAmBC,IAAI,IAAIT,UAAU,CAACW,KAAX,CAAiBJ,SAAS,CAACE,IAAD,EAAOV,KAAP,CAA1B,CAA3B,EALyC,CAK6B;;MAEtE,QAAQJ,IAAI,CAACoB,IAAb;QACE,KAAKnD,QAAL;QACA,KAAKI,UAAL;QACA,KAAKH,SAAL;UACE2B,KAAK,CAACwB,MAAN;MAJJ;IAMD,CAbM,MAaA;MACL;MACAd,OAAO,GAAGV,KAAK,CAACyB,OAAN,CAAczB,KAAK,CAAC0B,GAApB,CAAV;MACA1B,KAAK,CAACqB,KAAN,CAAYrB,KAAK,CAAC2B,GAAlB,EAAuBV,IAAI,IAAI;QAC7BT,UAAU,CAACW,KAAX,CAAiBJ,SAAS,CAACE,IAAD,EAAOV,KAAP,CAA1B;MACD,CAFD;MAGAP,KAAK,CAACqB,KAAN,CAAYrB,KAAK,CAACsB,GAAlB,EAAuBL,IAAI,IAAI;QAC7BP,OAAO,GAAGA,OAAO,IAAIF,UAAU,CAACoB,UAAX,CAAsBX,IAAI,CAACR,MAA3B,CAArB;QACAR,IAAI,CAACa,KAAL,CAAWG,IAAX;QACAT,UAAU,CAACW,KAAX,CAAiBJ,SAAS,CAACE,IAAD,EAAOV,KAAP,CAA1B;MACD,CAJD;;MAMA,IAAIG,OAAJ,EAAa;QACXF,UAAU,CAACU,KAAX;QACAf,IAAI,CAACS,KAAL,CAAWI,OAAX,CAAmBC,IAAI,IAAIT,UAAU,CAACW,KAAX,CAAiBF,IAAI,CAACR,MAAtB,CAA3B;MACD;IACF,CA7CiB,CA6ChB;;;IAGF5D,SAAS,CAACsD,IAAD,CAAT;IACA,OAAOH,KAAK,CAAC6B,QAAN,CAAe,QAAf,CAAP;EACD;;AAnDwB,CAAnB,CAAR;;AAuDA,SAASd,SAAT,CAAmBE,IAAnB,EAAyBV,KAAzB,EAAgCuB,GAAhC,EAAqC;EACnC,OAAOvB,KAAK,CAACU,IAAI,CAACR,MAAL,CAAYS,KAAZ,EAAD,EAAsBD,IAAtB,EAA4Ba,GAA5B,CAAZ;AACD;;AAED,MAAMC,YAAY,GAAG,mBAArB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,UAAT,CAAoBpC,MAApB,EAA4B;EAC1BjD,SAAS,CAACkD,IAAV,CAAe,IAAf,EAAqB,CAArB,EAAwBD,MAAxB;AACD;;AACDoC,UAAU,CAACC,UAAX,GAAwB;EACtB,QAAQ,YADc;EAEtB,YAAY;IACV,YAAY;EADF,CAFU;EAKtB,UAAU,CAAC;IACT,QAAQ,IADC;IAET,QAAQ,QAFC;IAGT,YAAY;EAHH,CAAD;AALY,CAAxB;AAWA9E,QAAQ,CAAC6E,UAAD,EAAarF,SAAb,EAAwB;EAC9BmD,SAAS,CAACC,CAAD,EAAIC,KAAJ,EAAW;IAClB,MAAMkC,OAAO,GAAGC,UAAU,CAACnC,KAAK,CAACE,QAAP,CAA1B;IAAA,MACMkC,EAAE,GAAGrC,CAAC,CAACqC,EADb;IAEA,IAAIC,EAAE,GAAGH,OAAO,CAACI,KAAjB;IACAtC,KAAK,CAACqB,KAAN,CAAYrB,KAAK,CAAC2B,GAAlB,EAAuBY,CAAC,IAAIA,CAAC,CAACH,EAAD,CAAD,GAAQG,CAAC,CAACH,EAAD,CAAD,IAAS,EAAEC,EAA/C;IACAH,OAAO,CAACM,GAAR,CAAY,KAAKF,KAAL,GAAaD,EAAzB;IACA,OAAOrC,KAAP;EACD;;AAR6B,CAAxB,CAAR;;AAYA,SAASmC,UAAT,CAAoBlC,IAApB,EAA0B;EACxB,OAAOA,IAAI,CAACwC,QAAL,CAAcV,YAAd,MAAgC9B,IAAI,CAACwC,QAAL,CAAcV,YAAd,IAA8B9B,IAAI,CAACyC,GAAL,CAAS,CAAT,CAA9D,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASC,IAAT,CAAc/C,MAAd,EAAsB;EACpBjD,SAAS,CAACkD,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACDzC,QAAQ,CAACwF,IAAD,EAAOhG,SAAP,EAAkB;EACxBmD,SAAS,CAACC,CAAD,EAAIC,KAAJ,EAAW;IAClB,IAAIG,IAAI,GAAG,KAAKmC,KAAhB,CADkB,CACK;;IAEvB,IAAI,CAACnC,IAAL,EAAW;MACTA,IAAI,GAAGH,KAAK,CAACE,QAAN,CAAe0C,UAAf,GAA4BzC,IAA5B,CAAiCJ,CAAC,CAAC8C,OAAnC,EAA4CC,MAAM,CAAC/C,CAAD,CAAlD,EAAuDA,CAAC,CAACgD,KAAzD,CAAP;MACA5C,IAAI,CAAC6C,KAAL,CAAWC,OAAX,GAAqBlD,CAAC,CAACkD,OAAvB;MACA,IAAI,CAAClD,CAAC,CAACkD,OAAF,CAAUD,KAAf,EAAsBjD,CAAC,CAACkD,OAAF,CAAUD,KAAV,GAAkB7C,IAAI,CAAC6C,KAAvB;MACtB7C,IAAI,CAAC+C,MAAL,GAAc,KAAKA,MAAnB,CAJS,CAIkB;;MAE3B/C,IAAI,CAACgD,IAAL,GAAYpD,CAAC,CAACoD,IAAd;MACAhD,IAAI,CAACiD,WAAL,GAAmBrD,CAAC,CAACqD,WAArB;MACA,KAAKd,KAAL,GAAanC,IAAb;IACD,CAZiB,CAYhB;;;IAGF,MAAMkD,IAAI,GAAGlD,IAAI,CAACE,QAAL,KAAkBlC,KAAlB,GAA0BrB,SAA1B,GAAsCC,IAAnD;IACAiD,KAAK,CAACqB,KAAN,CAAYrB,KAAK,CAAC2B,GAAlB,EAAuBV,IAAI,IAAIoC,IAAI,CAACxD,IAAL,CAAUoB,IAAV,EAAgBd,IAAhB,CAA/B,EAhBkB,CAgBqC;;IAEvD,IAAIJ,CAAC,CAACqB,QAAF,CAAW,MAAX,KAAsBrB,CAAC,CAACqB,QAAF,CAAW,aAAX,CAA1B,EAAqD;MACnDjB,IAAI,CAACgD,IAAL,GAAYpD,CAAC,CAACoD,IAAd;MACAhD,IAAI,CAACiD,WAAL,GAAmB,CAAC,CAACrD,CAAC,CAACqD,WAAvB;MACAjD,IAAI,CAACmD,MAAL,GAAc,IAAd,CAHmD,CAG/B;;MAEpBtD,KAAK,CAACwB,MAAN;IACD,CAxBiB,CAwBhB;;;IAGFrB,IAAI,CAACS,KAAL,GAAaZ,KAAK,CAACkD,MAAnB;IACA,OAAOlD,KAAP;EACD;;AA9BuB,CAAlB,CAAR;;AAkCA,SAAS8C,MAAT,CAAgB/C,CAAhB,EAAmB;EACjB,MAAMwD,CAAC,GAAGxD,CAAC,CAACyD,MAAZ;EAAA,MACMC,CAAC,GAAG1D,CAAC,CAAC2D,MADZ;EAEA,OAAOH,CAAC,IAAIA,CAAC,CAACI,IAAF,KAAW,CAAhB,GAAoBJ,CAAC,CAACK,GAAF,CAAMC,MAAM,CAACC,IAAP,CAAYP,CAAC,CAACQ,MAAd,EAAsB,CAAtB,CAAN,CAApB,GAAsDR,CAAC,IAAIE,CAAL,GAASF,CAAC,CAACT,MAAF,CAASW,CAAT,CAAT,GAAuB,IAApF;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASO,OAAT,CAAiBpE,MAAjB,EAAyB;EACvBjD,SAAS,CAACkD,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACD,MAAMqE,OAAO,GAAG;EACdC,MAAM,EAAEtD,KAAK,IAAIA,KAAK,CAACuD,MAAN,CAAa,CAAClD,IAAD,EAAOmD,CAAP,KAAaA,CAAC,GAAG,CAAJ,GAAQnD,IAAI,CAACoD,OAAL,GAAe,CAAvB,GAA2B,CAArD,CADH;EAEdC,MAAM,EAAE,CAAC1D,KAAD,EAAQ2D,GAAR,KAAgB;IACtB,IAAIC,CAAJ;IACA,OAAO5D,KAAK,CAACuD,MAAN,CAAa,CAACM,CAAD,EAAIL,CAAJ,KAAU,CAACA,CAAD,IAAM,CAACM,SAAS,CAACF,CAAC,CAAC/D,MAAH,EAAWgE,CAAC,CAAChE,MAAb,EAAqB8D,GAArB,CAAhB,IAA6CC,CAAC,GAAGC,CAAJ,EAAO,CAApD,IAAyDA,CAAC,CAACJ,OAAF,GAAY,CAA5F,CAAP;EACD;AALa,CAAhB,C,CAMG;AACH;;AAEA,MAAMK,SAAS,GAAG,CAACF,CAAD,EAAIC,CAAJ,EAAOF,GAAP,KAAeA,GAAG,GAAGI,IAAI,CAACC,GAAL,CAASH,CAAC,CAACI,EAAF,GAAOL,CAAC,CAACM,EAAlB,EAAsBN,CAAC,CAACK,EAAF,GAAOJ,CAAC,CAACK,EAA/B,EAAmCL,CAAC,CAACM,EAAF,GAAOP,CAAC,CAACQ,EAA5C,EAAgDR,CAAC,CAACO,EAAF,GAAON,CAAC,CAACO,EAAzD,CAAvC;;AAEA,MAAMC,UAAU,GAAG,CAACrE,KAAD,EAAQsE,GAAR,KAAgB;EACjC,KAAK,IAAId,CAAC,GAAG,CAAR,EAAWe,CAAC,GAAGvE,KAAK,CAACC,MAArB,EAA6B2D,CAAC,GAAG5D,KAAK,CAAC,CAAD,CAAL,CAASH,MAA1C,EAAkDgE,CAAvD,EAA0DL,CAAC,GAAGe,CAA9D,EAAiEX,CAAC,GAAGC,CAAJ,EAAO,EAAEL,CAA1E,EAA6E;IAC3E,IAAIM,SAAS,CAACF,CAAD,EAAIC,CAAC,GAAG7D,KAAK,CAACwD,CAAD,CAAL,CAAS3D,MAAjB,EAAyByE,GAAzB,CAAb,EAA4C,OAAO,IAAP;EAC7C;AACF,CAJD;;AAMA,MAAME,SAAS,GAAGnE,IAAI,IAAI;EACxB,MAAMwD,CAAC,GAAGxD,IAAI,CAACR,MAAf;EACA,OAAOgE,CAAC,CAACY,KAAF,KAAY,CAAZ,IAAiBZ,CAAC,CAACa,MAAF,KAAa,CAArC;AACD,CAHD;;AAKA,MAAMC,SAAS,GAAG,CAACC,KAAD,EAAQC,MAAR,EAAgBC,SAAhB,KAA8B;EAC9C,IAAIC,KAAK,GAAGH,KAAK,CAACG,KAAN,EAAZ;EAAA,IACIlB,CAAC,GAAG,IAAIzH,MAAJ,EADR;;EAGA,IAAIyI,MAAM,KAAKnI,GAAX,IAAkBmI,MAAM,KAAKhI,MAAjC,EAAyC;IACvCgH,CAAC,CAACjC,GAAF,CAAMmD,KAAK,CAAC,CAAD,CAAX,EAAgB,CAACC,QAAjB,EAA2BD,KAAK,CAAC,CAAD,CAAhC,EAAqC,CAACC,QAAtC;EACD,CAFD,MAEO;IACLnB,CAAC,CAACjC,GAAF,CAAM,CAACoD,QAAP,EAAiBD,KAAK,CAAC,CAAD,CAAtB,EAA2B,CAACC,QAA5B,EAAsCD,KAAK,CAAC,CAAD,CAA3C;EACD;;EAEDlB,CAAC,CAACoB,MAAF,CAASH,SAAS,IAAI,CAAtB;EACA,OAAOzE,IAAI,IAAIwD,CAAC,CAACqB,QAAF,CAAW7E,IAAI,CAACR,MAAhB,CAAf;AACD,CAZD,C,CAYG;;;AAGH,MAAMsF,KAAK,GAAG7C,MAAM,IAAI;EACtBA,MAAM,CAAClC,OAAP,CAAeC,IAAI,IAAIA,IAAI,CAACoD,OAAL,GAAe,CAAtC;EACA,OAAOnB,MAAP;AACD,CAHD,C,CAGG;AACH;;;AAGA,MAAM1B,MAAM,GAAG,CAACxB,KAAD,EAAQD,CAAR,KAAcC,KAAK,CAACwB,MAAN,CAAazB,CAAC,CAACqB,QAAF,EAAb,EAA2BS,QAA3B,CAAoC,SAApC,CAA7B;;AAEA1E,QAAQ,CAAC6G,OAAD,EAAUrH,SAAV,EAAqB;EAC3BmD,SAAS,CAACC,CAAD,EAAIC,KAAJ,EAAW;IAClB,MAAMgG,MAAM,GAAG/B,OAAO,CAAClE,CAAC,CAACkG,MAAH,CAAP,IAAqBhC,OAAO,CAACC,MAA5C;IAAA,MACMK,GAAG,GAAGxE,CAAC,CAACmG,UAAF,IAAgB,CAD5B;IAEA,IAAIhD,MAAM,GAAGlD,KAAK,CAACmG,WAAN,CAAkBnG,KAAK,CAACoG,MAAxB,EAAgClD,MAA7C;IAAA,IACItC,KADJ;IAAA,IAEIyF,IAFJ;IAGA,IAAI,CAACnD,MAAD,IAAW,CAACA,MAAM,CAACrC,MAAvB,EAA+B;;IAE/B,IAAI,CAACd,CAAC,CAACkG,MAAP,EAAe;MACb;MACA,IAAIlG,CAAC,CAACqB,QAAF,CAAW,QAAX,CAAJ,EAA0B;QACxB2E,KAAK,CAAC7C,MAAD,CAAL;QACAlD,KAAK,GAAGwB,MAAM,CAACxB,KAAD,EAAQD,CAAR,CAAd;MACD;;MAED,OAAOC,KAAP;IACD,CAhBiB,CAgBhB;;;IAGFkD,MAAM,GAAGA,MAAM,CAACiB,MAAP,CAAciB,SAAd,CAAT,CAnBkB,CAmBiB;;IAEnC,IAAI,CAAClC,MAAM,CAACrC,MAAZ,EAAoB;;IAEpB,IAAId,CAAC,CAACuG,IAAN,EAAY;MACVpD,MAAM,GAAGA,MAAM,CAACqD,KAAP,GAAeD,IAAf,CAAoBvG,CAAC,CAACuG,IAAtB,CAAT;IACD;;IAED1F,KAAK,GAAGmF,KAAK,CAAC7C,MAAD,CAAb;IACAlD,KAAK,GAAGwB,MAAM,CAACxB,KAAD,EAAQD,CAAR,CAAd;;IAEA,IAAIa,KAAK,CAACC,MAAN,IAAgB,CAAhB,IAAqBoE,UAAU,CAACrE,KAAD,EAAQ2D,GAAR,CAAnC,EAAiD;MAC/C,GAAG;QACD3D,KAAK,GAAGoF,MAAM,CAACpF,KAAD,EAAQ2D,GAAR,CAAd;MACD,CAFD,QAES3D,KAAK,CAACC,MAAN,IAAgB,CAAhB,IAAqBoE,UAAU,CAACrE,KAAD,EAAQ2D,GAAR,CAFxC;;MAIA,IAAI3D,KAAK,CAACC,MAAN,GAAe,CAAf,IAAoB,CAACzD,IAAI,CAAC8F,MAAD,CAAJ,CAAamB,OAAtC,EAA+C;QAC7C,IAAIzD,KAAK,CAACC,MAAN,GAAe,CAAnB,EAAsBzD,IAAI,CAACwD,KAAD,CAAJ,CAAYyD,OAAZ,GAAsB,CAAtB;QACtBjH,IAAI,CAAC8F,MAAD,CAAJ,CAAamB,OAAb,GAAuB,CAAvB;MACD;IACF;;IAED,IAAItE,CAAC,CAACyG,UAAF,IAAgBzG,CAAC,CAAC0G,cAAF,IAAoB,CAAxC,EAA2C;MACzCJ,IAAI,GAAGd,SAAS,CAACxF,CAAC,CAACyG,UAAH,EAAezG,CAAC,CAAC2G,WAAjB,EAA8B,CAAC3G,CAAC,CAAC0G,cAAjC,CAAhB;MACAvD,MAAM,CAAClC,OAAP,CAAeC,IAAI,IAAI;QACrB,IAAI,CAACoF,IAAI,CAACpF,IAAD,CAAT,EAAiBA,IAAI,CAACoD,OAAL,GAAe,CAAf;MAClB,CAFD;IAGD,CA9CiB,CA8ChB;;;IAGF,MAAM5D,MAAM,GAAGG,KAAK,CAAC,CAAD,CAAL,CAAST,IAAT,CAAcM,MAAd,CAAqBS,KAArB,EAAf;IACAgC,MAAM,CAAClC,OAAP,CAAeC,IAAI,IAAI;MACrB,IAAIA,IAAI,CAACoD,OAAT,EAAkB5D,MAAM,CAACU,KAAP,CAAaF,IAAI,CAACR,MAAlB;IACnB,CAFD;IAGA,OAAOT,KAAP;EACD;;AAvD0B,CAArB,CAAR;AA2DA;AACA;AACA;AACA;;AAEA,SAAS2G,MAAT,CAAgB/G,MAAhB,EAAwB;EACtBjD,SAAS,CAACkD,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACDzC,QAAQ,CAACwJ,MAAD,EAAShK,SAAT,EAAoB;EAC1BmD,SAAS,CAACC,CAAD,EAAIC,KAAJ,EAAW;IAClB,MAAMC,IAAI,GAAGD,KAAK,CAACE,QAAnB;IACAF,KAAK,CAACqB,KAAN,CAAYrB,KAAK,CAAC4G,GAAlB,EAAuB3F,IAAI,IAAIhB,IAAI,CAACa,KAAL,CAAWG,IAAX,CAA/B,EAFkB,CAEgC;;IAElD,IAAIjB,KAAK,CAAC6G,MAAN,IAAgB7G,KAAK,CAAC6G,MAAN,CAAa,QAAb,CAApB,EAA4C;MAC1C,MAAM5F,IAAI,GAAGjB,KAAK,CAACkD,MAAN,IAAgBlD,KAAK,CAACkD,MAAN,CAAa,CAAb,CAA7B;MACA,IAAIjC,IAAJ,EAAUA,IAAI,CAACd,IAAL,CAAUmD,MAAV,GAAmB,IAAnB;IACX;EACF;;AATyB,CAApB,CAAR;AAaA,MAAMwD,UAAU,GAAG,IAAI9J,MAAJ,EAAnB;;AACA,SAASwF,GAAT,CAAavB,IAAb,EAAmB8F,QAAnB,EAA6BzE,KAA7B,EAAoC;EAClC,OAAOrB,IAAI,CAAC8F,QAAD,CAAJ,KAAmBzE,KAAnB,GAA2B,CAA3B,IAAgCrB,IAAI,CAAC8F,QAAD,CAAJ,GAAiBzE,KAAjB,EAAwB,CAAxD,CAAP;AACD;;AAED,SAAS0E,OAAT,CAAiB7G,IAAjB,EAAuB;EACrB,IAAIsF,MAAM,GAAGtF,IAAI,CAACS,KAAL,CAAW,CAAX,EAAc6E,MAA3B;EACA,OAAOA,MAAM,KAAKlI,IAAX,IAAmBkI,MAAM,KAAKjI,KAArC;AACD;;AAED,SAASyJ,WAAT,CAAqBC,KAArB,EAA4B;EAC1B,IAAInE,KAAK,GAAG,CAACmE,KAAK,CAACC,IAAnB;EACA,OAAO,CAACD,KAAK,CAACE,KAAN,GAAcrE,KAAK,EAAnB,GAAwB,CAAC,CAA1B,EAA6B;EACpCmE,KAAK,CAACG,MAAN,GAAetE,KAAK,EAApB,GAAyB,CAAC,CADnB,EACsB;EAC7BA,KAAK,GAAG,CAACmE,KAAK,CAACI,MAFR,CAEe;EAFf,CAAP;AAID;;AAED,SAASC,UAAT,CAAoBtH,IAApB,EAA0BuH,IAA1B,EAAgCnC,KAAhC,EAAuCC,MAAvC,EAA+C;EAC7C,IAAIrE,IAAI,GAAGuG,IAAI,CAAC5G,KAAL,CAAW,CAAX,CAAX;EAAA,IACIsG,KAAK,GAAGjG,IAAI,CAACiG,KADjB;EAAA,IAEIO,KAAK,GAAGxG,IAAI,CAACyG,SAAL,IAAkB,IAAlB,GAAyBzG,IAAI,CAACyG,SAA9B,GAA0C,GAFtD;EAAA,IAGIjC,MAAM,GAAGxE,IAAI,CAACwE,MAHlB;EAAA,IAIIkC,OAAO,GAAGV,WAAW,CAACC,KAAD,CAJzB;EAAA,IAKIvB,KAAK,GAAG1E,IAAI,CAAC0E,KALjB;EAAA,IAMIiC,MAAM,GAAG3G,IAAI,CAAC2G,MANlB;EAAA,IAOIC,QAAQ,GAAG5G,IAAI,CAAC4G,QAPpB;EAAA,IAQIC,SAAS,GAAG7G,IAAI,CAAC6G,SARrB;EAAA,IASIC,SAAS,GAAG9G,IAAI,CAAC8G,SATrB;EAAA,IAUIC,KAAK,GAAGd,KAAK,CAACc,KAAN,IAAe/G,IAAI,CAACL,KAAL,CAAW+G,OAAO,CAAC,CAAD,CAAlB,EAAuB/G,KAAvB,CAA6B,CAA7B,CAV3B;EAAA,IAWIqH,YAAY,GAAGhH,IAAI,CAACgH,YAXxB;EAAA,IAYIxH,MAAM,GAAGQ,IAAI,CAACR,MAZlB;EAAA,IAaIyH,EAAE,GAAGF,KAAK,IAAI/K,eAAe,CAAC+K,KAAD,CAbjC;EAAA,IAcIG,CAAC,GAAG,CAdR;EAAA,IAeIC,CAAC,GAAG,CAfR;EAAA,IAgBIhE,CAhBJ;EAAA,IAiBIiE,CAjBJ;EAkBAvB,UAAU,CAAC5F,KAAX,GAAmBC,KAAnB,CAAyBV,MAAzB;EACAA,MAAM,CAACS,KAAP;EACA,IAAI,CAACkD,CAAC,GAAGuD,OAAO,CAAC,CAAD,CAAZ,IAAmB,CAAC,CAAxB,EAA2BlH,MAAM,CAACU,KAAP,CAAaF,IAAI,CAACL,KAAL,CAAWwD,CAAX,EAAc3D,MAA3B;EAC3B,IAAI,CAAC2D,CAAC,GAAGuD,OAAO,CAAC,CAAD,CAAZ,IAAmB,CAAC,CAAxB,EAA2BlH,MAAM,CAACU,KAAP,CAAaF,IAAI,CAACL,KAAL,CAAWwD,CAAX,EAAc3D,MAA3B,EAtBkB,CAsBkB;;EAE/D,QAAQgF,MAAR;IACE,KAAKnI,GAAL;MACE6K,CAAC,GAAGN,QAAQ,IAAI,CAAhB;MACAO,CAAC,GAAG,CAACR,MAAL;MACAS,CAAC,GAAG1D,IAAI,CAACC,GAAL,CAASkD,SAAT,EAAoBnD,IAAI,CAAC2D,GAAL,CAASP,SAAT,EAAoB,CAACtH,MAAM,CAACsE,EAA5B,CAApB,CAAJ;MACAtE,MAAM,CAACiC,GAAP,CAAW,CAAX,EAAc,CAAC2F,CAAf,EAAkB3F,GAAlB,CAAsBiD,KAAtB,EAA6B,CAA7B;MACA,IAAIqC,KAAJ,EAAWO,eAAe,CAACtI,IAAD,EAAO+H,KAAP,EAAcK,CAAd,EAAiBJ,YAAjB,EAA+BC,EAA/B,EAAmC,CAAnC,EAAsC,CAAC,CAAvC,EAA0CzH,MAA1C,CAAf;MACX;;IAEF,KAAKlD,IAAL;MACE4K,CAAC,GAAG,CAACP,MAAL;MACAQ,CAAC,GAAGP,QAAQ,IAAI,CAAhB;MACAQ,CAAC,GAAG1D,IAAI,CAACC,GAAL,CAASkD,SAAT,EAAoBnD,IAAI,CAAC2D,GAAL,CAASP,SAAT,EAAoB,CAACtH,MAAM,CAACoE,EAA5B,CAApB,CAAJ;MACApE,MAAM,CAACiC,GAAP,CAAW,CAAC2F,CAAZ,EAAe,CAAf,EAAkB3F,GAAlB,CAAsB,CAAtB,EAAyBiD,KAAzB;MACA,IAAIqC,KAAJ,EAAWO,eAAe,CAACtI,IAAD,EAAO+H,KAAP,EAAcK,CAAd,EAAiBJ,YAAjB,EAA+BC,EAA/B,EAAmC,CAAnC,EAAsC,CAAC,CAAvC,EAA0CzH,MAA1C,CAAf;MACX;;IAEF,KAAKjD,KAAL;MACE2K,CAAC,GAAG9C,KAAK,GAAGuC,MAAZ;MACAQ,CAAC,GAAGP,QAAQ,IAAI,CAAhB;MACAQ,CAAC,GAAG1D,IAAI,CAACC,GAAL,CAASkD,SAAT,EAAoBnD,IAAI,CAAC2D,GAAL,CAASP,SAAT,EAAoBtH,MAAM,CAACqE,EAA3B,CAApB,CAAJ;MACArE,MAAM,CAACiC,GAAP,CAAW,CAAX,EAAc,CAAd,EAAiBA,GAAjB,CAAqB2F,CAArB,EAAwB1C,KAAxB;MACA,IAAIqC,KAAJ,EAAWO,eAAe,CAACtI,IAAD,EAAO+H,KAAP,EAAcK,CAAd,EAAiBJ,YAAjB,EAA+BC,EAA/B,EAAmC,CAAnC,EAAsC,CAAtC,EAAyCzH,MAAzC,CAAf;MACX;;IAEF,KAAKhD,MAAL;MACE0K,CAAC,GAAGN,QAAQ,IAAI,CAAhB;MACAO,CAAC,GAAG9C,MAAM,GAAGsC,MAAb;MACAS,CAAC,GAAG1D,IAAI,CAACC,GAAL,CAASkD,SAAT,EAAoBnD,IAAI,CAAC2D,GAAL,CAASP,SAAT,EAAoBtH,MAAM,CAACuE,EAA3B,CAApB,CAAJ;MACAvE,MAAM,CAACiC,GAAP,CAAW,CAAX,EAAc,CAAd,EAAiBA,GAAjB,CAAqBiD,KAArB,EAA4B0C,CAA5B;MACA,IAAIL,KAAJ,EAAWO,eAAe,CAACtI,IAAD,EAAO+H,KAAP,EAAcK,CAAd,EAAiBJ,YAAjB,EAA+B,CAA/B,EAAkC,CAAlC,EAAqC,CAArC,EAAwCxH,MAAxC,CAAf;MACX;;IAEF;MACE0H,CAAC,GAAGlH,IAAI,CAACkH,CAAT;MACAC,CAAC,GAAGnH,IAAI,CAACmH,CAAT;EAnCJ,CAxB6C,CA4D3C;;;EAGFlL,WAAW,CAACuD,MAAM,CAACiH,SAAP,CAAiBS,CAAjB,EAAoBC,CAApB,CAAD,EAAyBnH,IAAzB,CAAX;;EAEA,IAAIuB,GAAG,CAACvB,IAAD,EAAO,GAAP,EAAYkH,CAAC,GAAGV,KAAhB,CAAH,GAA4BjF,GAAG,CAACvB,IAAD,EAAO,GAAP,EAAYmH,CAAC,GAAGX,KAAhB,CAAnC,EAA2D;IACzDxG,IAAI,CAACR,MAAL,GAAcqG,UAAd;IACA7G,IAAI,CAACa,KAAL,CAAWG,IAAX;IACAA,IAAI,CAACR,MAAL,GAAcA,MAAd;IACAR,IAAI,CAACa,KAAL,CAAWG,IAAX;EACD;;EAED,OAAOA,IAAI,CAACd,IAAL,CAAUM,MAAV,CAAiBS,KAAjB,GAAyBC,KAAzB,CAA+BV,MAA/B,CAAP;AACD;;AAED,SAAS8H,eAAT,CAAyBtI,IAAzB,EAA+B+H,KAA/B,EAAsCJ,MAAtC,EAA8C1C,GAA9C,EAAmDgD,EAAnD,EAAuDlB,OAAvD,EAAgEwB,IAAhE,EAAsE/H,MAAtE,EAA8E;EAC5E,MAAMgE,CAAC,GAAGuD,KAAK,CAACvH,MAAhB;;EAEA,IAAIuH,KAAK,CAACS,IAAV,EAAgB;IACd,MAAMC,CAAC,GAAGF,IAAI,IAAIZ,MAAM,GAAGM,EAAT,GAAchD,GAAlB,CAAd;IACA,IAAIyD,EAAE,GAAG,CAAT;IAAA,IACIC,EAAE,GAAG,CADT;IAEA3I,IAAI,CAACa,KAAL,CAAWkH,KAAX;IACAhB,OAAO,GAAG2B,EAAE,GAAG,CAACX,KAAK,CAACG,CAAN,IAAW,CAAZ,KAAkBH,KAAK,CAACG,CAAN,GAAUO,CAA5B,CAAR,GAAyCE,EAAE,GAAG,CAACZ,KAAK,CAACI,CAAN,IAAW,CAAZ,KAAkBJ,KAAK,CAACI,CAAN,GAAUM,CAA5B,CAArD;IACAV,KAAK,CAAC7H,IAAN,CAAWM,MAAX,CAAkBS,KAAlB,GAA0BC,KAA1B,CAAgCsD,CAAC,CAACiD,SAAF,CAAY,CAACiB,EAAb,EAAiB,CAACC,EAAlB,CAAhC;IACA3I,IAAI,CAACa,KAAL,CAAWkH,KAAX;EACD;;EAEDvH,MAAM,CAACU,KAAP,CAAasD,CAAb;AACD;;AAED,MAAM6D,GAAG,GAAG,CAAC9D,CAAD,EAAIC,CAAJ,KAAUE,IAAI,CAACkE,KAAL,CAAWlE,IAAI,CAAC2D,GAAL,CAAS9D,CAAT,EAAYC,CAAZ,CAAX,CAAtB;;AAEA,MAAMG,GAAG,GAAG,CAACJ,CAAD,EAAIC,CAAJ,KAAUE,IAAI,CAACmE,IAAL,CAAUnE,IAAI,CAACC,GAAL,CAASJ,CAAT,EAAYC,CAAZ,CAAV,CAAtB;;AAEA,SAASsE,gBAAT,CAA0B/F,KAA1B,EAAiC;EAC/B,IAAIQ,MAAM,GAAGR,KAAK,CAACpC,KAAnB;EAAA,IACIuE,CAAC,GAAG3B,MAAM,CAAC3C,MADf;EAAA,IAEIuD,CAAC,GAAG,CAFR;EAAA,IAGIjE,IAHJ;EAAA,IAIIS,KAJJ;EAKA,MAAMoI,KAAK,GAAG;IACZC,KAAK,EAAE,EADK;IAEZC,UAAU,EAAE,EAFA;IAGZC,UAAU,EAAE,EAHA;IAIZC,UAAU,EAAE,EAJA;IAKZC,UAAU,EAAE,EALA;IAMZC,QAAQ,EAAE,IANE;IAOZC,QAAQ,EAAE;EAPE,CAAd,CAN+B,CAc5B;;EAEH,OAAOnF,CAAC,GAAGe,CAAX,EAAc,EAAEf,CAAhB,EAAmB;IACjBjE,IAAI,GAAGqD,MAAM,CAACY,CAAD,CAAb;IACAxD,KAAK,GAAGT,IAAI,CAACS,KAAb;;IAEA,IAAIT,IAAI,CAACE,QAAL,KAAkBlC,KAAtB,EAA6B;MAC3B,QAAQgC,IAAI,CAACoB,IAAb;QACE,KAAKnD,QAAL;QACA,KAAKI,UAAL;QACA,KAAKH,SAAL;UACE;;QAEF,KAAKI,SAAL;UACEuK,KAAK,CAACE,UAAN,CAAiBM,IAAjB,CAAsB,GAAG5I,KAAzB;UACA;;QAEF,KAAKlC,SAAL;UACEsK,KAAK,CAACG,UAAN,CAAiBK,IAAjB,CAAsB,GAAG5I,KAAzB;UACA;;QAEF,KAAKhC,SAAL;UACEoK,KAAK,CAACI,UAAN,CAAiBI,IAAjB,CAAsB,GAAG5I,KAAzB;UACA;;QAEF,KAAK/B,SAAL;UACEmK,KAAK,CAACK,UAAN,CAAiBG,IAAjB,CAAsB,GAAG5I,KAAzB;UACA;;QAEF,KAAKjC,QAAL;UACEqK,KAAK,CAACM,QAAN,GAAiB1I,KAAK,CAAC,CAAD,CAAtB;UACA;;QAEF,KAAK9B,QAAL;UACEkK,KAAK,CAACO,QAAN,GAAiB3I,KAAK,CAAC,CAAD,CAAtB;UACA;;QAEF;UACEoI,KAAK,CAACC,KAAN,CAAYO,IAAZ,CAAiB,GAAG5I,KAApB;MA/BJ;IAiCD;EACF;;EAED,OAAOoI,KAAP;AACD;;AAED,SAASS,SAAT,CAAmBxI,IAAnB,EAAyB;EACvB,OAAO,IAAIjE,MAAJ,GAAawF,GAAb,CAAiB,CAAjB,EAAoB,CAApB,EAAuBvB,IAAI,CAACoE,KAAL,IAAc,CAArC,EAAwCpE,IAAI,CAACqE,MAAL,IAAe,CAAvD,CAAP;AACD;;AAED,SAASoE,QAAT,CAAkBzI,IAAlB,EAAwB;EACtB,MAAMwD,CAAC,GAAGxD,IAAI,CAACR,MAAL,CAAYkJ,KAAZ,EAAV;EACA,OAAOlF,CAAC,CAACmF,KAAF,KAAYnF,CAAC,CAACjC,GAAF,CAAM,CAAN,EAAS,CAAT,EAAY,CAAZ,EAAe,CAAf,CAAZ,GAAgCiC,CAAC,CAACiD,SAAF,CAAY,EAAEzG,IAAI,CAACkH,CAAL,IAAU,CAAZ,CAAZ,EAA4B,EAAElH,IAAI,CAACmH,CAAL,IAAU,CAAZ,CAA5B,CAAvC;AACD;;AAED,SAASxE,GAAT,CAAa9B,GAAb,EAAkB+H,GAAlB,EAAuBC,CAAvB,EAA0B;EACxB,MAAMpB,CAAC,GAAGrL,QAAQ,CAACyE,GAAD,CAAR,GAAgBA,GAAG,CAAC+H,GAAD,CAAnB,GAA2B/H,GAArC;EACA,OAAO4G,CAAC,IAAI,IAAL,GAAYA,CAAZ,GAAgBoB,CAAC,KAAKC,SAAN,GAAkBD,CAAlB,GAAsB,CAA7C;AACD;;AAED,SAASE,WAAT,CAAqBtB,CAArB,EAAwB;EACtB,OAAOA,CAAC,GAAG,CAAJ,GAAQ/D,IAAI,CAACmE,IAAL,CAAU,CAACJ,CAAX,CAAR,GAAwB,CAA/B;AACD;;AAED,SAASuB,UAAT,CAAoBhK,IAApB,EAA0BuD,MAA1B,EAAkC1B,GAAlC,EAAuC;EACrC,IAAIhB,KAAK,GAAG,CAACgB,GAAG,CAACoI,OAAjB;EAAA,IACIC,IAAI,GAAGrI,GAAG,CAACrB,MAAJ,KAAejB,KAAf,GAAuBiK,SAAvB,GAAmCC,QAD9C;EAAA,IAEIjJ,MAAM,GAAGqG,UAAU,CAACtE,GAAX,CAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAFb;EAAA,IAGI4H,QAAQ,GAAGxG,GAAG,CAAC9B,GAAG,CAACuI,KAAL,EAAY5K,MAAZ,CAHlB;EAAA,IAII6K,QAAQ,GAAG1G,GAAG,CAAC9B,GAAG,CAACuI,KAAL,EAAY3K,GAAZ,CAJlB;EAAA,IAKI6K,MAAM,GAAG3G,GAAG,CAAC9B,GAAG,CAAC0I,OAAL,EAAc/K,MAAd,CALhB;EAAA,IAMIgL,MAAM,GAAG7G,GAAG,CAAC9B,GAAG,CAAC0I,OAAL,EAAc9K,GAAd,CANhB;EAAA,IAOIgL,KAAK,GAAG5I,GAAG,CAAC6I,OAAJ,IAAenH,MAAM,CAAC3C,MAPlC;EAAA,IAQI+J,KAAK,GAAGF,KAAK,IAAI,CAAT,GAAa,CAAb,GAAiB/F,IAAI,CAACmE,IAAL,CAAUtF,MAAM,CAAC3C,MAAP,GAAgB6J,KAA1B,CAR7B;EAAA,IASIvF,CAAC,GAAG3B,MAAM,CAAC3C,MATf;EAAA,IAUIgK,OAAO,GAAGC,KAAK,CAAC3F,CAAD,CAVnB;EAAA,IAWI4F,OAAO,GAAGD,KAAK,CAACJ,KAAD,CAXnB;EAAA,IAYIM,IAAI,GAAG,CAZX;EAAA,IAaIC,OAAO,GAAGH,KAAK,CAAC3F,CAAD,CAbnB;EAAA,IAcI+F,OAAO,GAAGJ,KAAK,CAACF,KAAD,CAdnB;EAAA,IAeIO,IAAI,GAAG,CAfX;EAAA,IAgBIxC,EAAE,GAAGmC,KAAK,CAAC3F,CAAD,CAhBd;EAAA,IAiBIyD,EAAE,GAAGkC,KAAK,CAAC3F,CAAD,CAjBd;EAAA,IAkBIiG,KAAK,GAAGN,KAAK,CAAC3F,CAAD,CAlBjB;EAAA,IAmBIkG,CAnBJ;EAAA,IAoBIjH,CApBJ;EAAA,IAqBIkH,CArBJ;EAAA,IAsBIC,CAtBJ;EAAA,IAuBI9G,CAvBJ;EAAA,IAwBIlB,CAxBJ;EAAA,IAyBIiI,EAzBJ;EAAA,IA0BIC,EA1BJ;EAAA,IA2BItD,CA3BJ;EAAA,IA4BIC,CA5BJ;EAAA,IA6BIR,MA7BJ;;EA+BA,KAAKxD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGsG,KAAhB,EAAuB,EAAEtG,CAAzB,EAA4B2G,OAAO,CAAC3G,CAAD,CAAP,GAAa,CAAb;;EAE5B,KAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGwG,KAAhB,EAAuB,EAAExG,CAAzB,EAA4B8G,OAAO,CAAC9G,CAAD,CAAP,GAAa,CAAb,CAlCS,CAkCO;;;EAG5C,KAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGe,CAAhB,EAAmB,EAAEf,CAArB,EAAwB;IACtBb,CAAC,GAAGC,MAAM,CAACY,CAAD,CAAV;IACAK,CAAC,GAAG2G,KAAK,CAAChH,CAAD,CAAL,GAAW+F,IAAI,CAAC5G,CAAD,CAAnB;IACAA,CAAC,CAAC4E,CAAF,GAAM5E,CAAC,CAAC4E,CAAF,IAAO,CAAb;IACAQ,EAAE,CAACvE,CAAD,CAAF,GAAQ,CAAR;IACAb,CAAC,CAAC6E,CAAF,GAAM7E,CAAC,CAAC6E,CAAF,IAAO,CAAb;IACAQ,EAAE,CAACxE,CAAD,CAAF,GAAQ,CAAR;IACAkH,CAAC,GAAGlH,CAAC,GAAGsG,KAAR;IACAa,CAAC,GAAG,CAAC,EAAEnH,CAAC,GAAGsG,KAAN,CAAL;IACAM,IAAI,GAAGrG,IAAI,CAACC,GAAL,CAASoG,IAAT,EAAeQ,EAAE,GAAG7G,IAAI,CAACmE,IAAL,CAAUrE,CAAC,CAACK,EAAZ,CAApB,CAAP;IACAqG,IAAI,GAAGxG,IAAI,CAACC,GAAL,CAASuG,IAAT,EAAeM,EAAE,GAAG9G,IAAI,CAACmE,IAAL,CAAUrE,CAAC,CAACO,EAAZ,CAApB,CAAP;IACA+F,OAAO,CAACO,CAAD,CAAP,GAAa3G,IAAI,CAACC,GAAL,CAASmG,OAAO,CAACO,CAAD,CAAhB,EAAqBE,EAArB,CAAb;IACAN,OAAO,CAACK,CAAD,CAAP,GAAa5G,IAAI,CAACC,GAAL,CAASsG,OAAO,CAACK,CAAD,CAAhB,EAAqBE,EAArB,CAAb;IACAZ,OAAO,CAACzG,CAAD,CAAP,GAAamG,MAAM,GAAGP,WAAW,CAACvF,CAAC,CAACI,EAAH,CAAjC;IACAoG,OAAO,CAAC7G,CAAD,CAAP,GAAaqG,MAAM,GAAGT,WAAW,CAACvF,CAAC,CAACM,EAAH,CAAjC;IACA,IAAIjE,KAAJ,EAAWb,IAAI,CAACa,KAAL,CAAW0C,MAAM,CAACY,CAAD,CAAjB;EACZ,CArDoC,CAqDnC;;;EAGF,KAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGe,CAAhB,EAAmB,EAAEf,CAArB,EAAwB;IACtB,IAAIA,CAAC,GAAGsG,KAAJ,KAAc,CAAlB,EAAqBG,OAAO,CAACzG,CAAD,CAAP,GAAa,CAAb;IACrB,IAAIA,CAAC,GAAGsG,KAAR,EAAeO,OAAO,CAAC7G,CAAD,CAAP,GAAa,CAAb;EAChB,CA3DoC,CA2DnC;;;EAGF,IAAIgG,QAAQ,KAAK7K,IAAjB,EAAuB;IACrB,KAAK+L,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGZ,KAAhB,EAAuB,EAAEY,CAAzB,EAA4B;MAC1B,KAAK1D,MAAM,GAAG,CAAT,EAAYxD,CAAC,GAAGkH,CAArB,EAAwBlH,CAAC,GAAGe,CAA5B,EAA+Bf,CAAC,IAAIsG,KAApC,EAA2C;QACzC,IAAI9C,MAAM,GAAGiD,OAAO,CAACzG,CAAD,CAApB,EAAyBwD,MAAM,GAAGiD,OAAO,CAACzG,CAAD,CAAhB;MAC1B;;MAED,KAAKA,CAAC,GAAGkH,CAAT,EAAYlH,CAAC,GAAGe,CAAhB,EAAmBf,CAAC,IAAIsG,KAAxB,EAA+B;QAC7BG,OAAO,CAACzG,CAAD,CAAP,GAAawD,MAAM,GAAGmD,OAAO,CAACO,CAAC,GAAG,CAAL,CAA7B;MACD;IACF;EACF,CAVD,MAUO,IAAIlB,QAAQ,KAAK9K,GAAjB,EAAsB;IAC3B,KAAKsI,MAAM,GAAG,CAAT,EAAYxD,CAAC,GAAG,CAArB,EAAwBA,CAAC,GAAGe,CAA5B,EAA+B,EAAEf,CAAjC,EAAoC;MAClC,IAAIA,CAAC,GAAGsG,KAAJ,IAAa9C,MAAM,GAAGiD,OAAO,CAACzG,CAAD,CAAjC,EAAsCwD,MAAM,GAAGiD,OAAO,CAACzG,CAAD,CAAhB;IACvC;;IAED,KAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGe,CAAhB,EAAmB,EAAEf,CAArB,EAAwB;MACtB,IAAIA,CAAC,GAAGsG,KAAR,EAAeG,OAAO,CAACzG,CAAD,CAAP,GAAawD,MAAM,GAAGoD,IAAtB;IAChB;EACF,CARM,MAQA;IACL,KAAKZ,QAAQ,GAAG,KAAX,EAAkBkB,CAAC,GAAG,CAA3B,EAA8BA,CAAC,GAAGZ,KAAlC,EAAyC,EAAEY,CAA3C,EAA8C;MAC5C,KAAKlH,CAAC,GAAGkH,CAAT,EAAYlH,CAAC,GAAGe,CAAhB,EAAmBf,CAAC,IAAIsG,KAAxB,EAA+B;QAC7BG,OAAO,CAACzG,CAAD,CAAP,IAAc2G,OAAO,CAACO,CAAC,GAAG,CAAL,CAArB;MACD;IACF;EACF,CAtFoC,CAsFnC;;;EAGF,IAAIhB,QAAQ,KAAK/K,IAAjB,EAAuB;IACrB,KAAKgM,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGX,KAAhB,EAAuB,EAAEW,CAAzB,EAA4B;MAC1B,KAAK3D,MAAM,GAAG,CAAT,EAAYxD,CAAC,GAAGmH,CAAC,GAAGb,KAApB,EAA2BW,CAAC,GAAGjH,CAAC,GAAGsG,KAAxC,EAA+CtG,CAAC,GAAGiH,CAAnD,EAAsD,EAAEjH,CAAxD,EAA2D;QACzD,IAAIwD,MAAM,GAAGqD,OAAO,CAAC7G,CAAD,CAApB,EAAyBwD,MAAM,GAAGqD,OAAO,CAAC7G,CAAD,CAAhB;MAC1B;;MAED,KAAKA,CAAC,GAAGmH,CAAC,GAAGb,KAAb,EAAoBtG,CAAC,GAAGiH,CAAxB,EAA2B,EAAEjH,CAA7B,EAAgC;QAC9B6G,OAAO,CAAC7G,CAAD,CAAP,GAAawD,MAAM,GAAGsD,OAAO,CAACK,CAAC,GAAG,CAAL,CAA7B;MACD;IACF;EACF,CAVD,MAUO,IAAIjB,QAAQ,KAAKhL,GAAjB,EAAsB;IAC3B,KAAKsI,MAAM,GAAG,CAAT,EAAYxD,CAAC,GAAGsG,KAArB,EAA4BtG,CAAC,GAAGe,CAAhC,EAAmC,EAAEf,CAArC,EAAwC;MACtC,IAAIwD,MAAM,GAAGqD,OAAO,CAAC7G,CAAD,CAApB,EAAyBwD,MAAM,GAAGqD,OAAO,CAAC7G,CAAD,CAAhB;IAC1B;;IAED,KAAKA,CAAC,GAAGsG,KAAT,EAAgBtG,CAAC,GAAGe,CAApB,EAAuB,EAAEf,CAAzB,EAA4B;MAC1B6G,OAAO,CAAC7G,CAAD,CAAP,GAAawD,MAAM,GAAGuD,IAAtB;IACD;EACF,CARM,MAQA;IACL,KAAKb,QAAQ,GAAG,KAAX,EAAkBiB,CAAC,GAAG,CAA3B,EAA8BA,CAAC,GAAGX,KAAlC,EAAyC,EAAEW,CAA3C,EAA8C;MAC5C,KAAKnH,CAAC,GAAGmH,CAAC,GAAGb,KAAR,EAAeW,CAAC,GAAGjH,CAAC,GAAGsG,KAA5B,EAAmCtG,CAAC,GAAGiH,CAAvC,EAA0C,EAAEjH,CAA5C,EAA+C;QAC7C6G,OAAO,CAAC7G,CAAD,CAAP,IAAc8G,OAAO,CAACK,CAAC,GAAG,CAAL,CAArB;MACD;IACF;EACF,CAjHoC,CAiHnC;;;EAGF,KAAKpD,CAAC,GAAG,CAAJ,EAAO/D,CAAC,GAAG,CAAhB,EAAmBA,CAAC,GAAGe,CAAvB,EAA0B,EAAEf,CAA5B,EAA+B;IAC7B+D,CAAC,GAAG0C,OAAO,CAACzG,CAAD,CAAP,IAAcA,CAAC,GAAGsG,KAAJ,GAAYvC,CAAZ,GAAgB,CAA9B,CAAJ;IACAQ,EAAE,CAACvE,CAAD,CAAF,IAAS+D,CAAC,GAAG3E,MAAM,CAACY,CAAD,CAAN,CAAU+D,CAAvB;EACD,CAvHoC,CAuHnC;;;EAGF,KAAKmD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGZ,KAAhB,EAAuB,EAAEY,CAAzB,EAA4B;IAC1B,KAAKlD,CAAC,GAAG,CAAJ,EAAOhE,CAAC,GAAGkH,CAAhB,EAAmBlH,CAAC,GAAGe,CAAvB,EAA0Bf,CAAC,IAAIsG,KAA/B,EAAsC;MACpCtC,CAAC,IAAI6C,OAAO,CAAC7G,CAAD,CAAZ;MACAwE,EAAE,CAACxE,CAAD,CAAF,IAASgE,CAAC,GAAG5E,MAAM,CAACY,CAAD,CAAN,CAAUgE,CAAvB;IACD;EACF,CA/HoC,CA+HnC;;;EAGF,IAAIgC,QAAQ,IAAIxG,GAAG,CAAC9B,GAAG,CAAC4J,MAAL,EAAajM,MAAb,CAAf,IAAuCmL,KAAK,GAAG,CAAnD,EAAsD;IACpD,KAAKxG,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGe,CAAhB,EAAmB,EAAEf,CAArB,EAAwB;MACtBK,CAAC,GAAG2F,QAAQ,KAAK9K,GAAb,GAAmB0L,IAAnB,GAA0BD,OAAO,CAAC3G,CAAC,GAAGsG,KAAL,CAArC;MACAvC,CAAC,GAAG1D,CAAC,GAAG2G,KAAK,CAAChH,CAAD,CAAL,CAASU,EAAb,GAAkBtB,MAAM,CAACY,CAAD,CAAN,CAAU+D,CAA5B,GAAgCQ,EAAE,CAACvE,CAAD,CAAtC;MACA,IAAI+D,CAAC,GAAG,CAAR,EAAWQ,EAAE,CAACvE,CAAD,CAAF,IAAS+D,CAAC,GAAG,CAAb;IACZ;EACF,CAxIoC,CAwInC;;;EAGF,IAAImC,QAAQ,IAAI1G,GAAG,CAAC9B,GAAG,CAAC4J,MAAL,EAAahM,GAAb,CAAf,IAAoCgL,KAAK,KAAK,CAAlD,EAAqD;IACnD,KAAKtG,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGe,CAAhB,EAAmB,EAAEf,CAArB,EAAwB;MACtBK,CAAC,GAAG6F,QAAQ,KAAKhL,GAAb,GAAmB6L,IAAnB,GAA0BD,OAAO,CAAC,CAAC,EAAE9G,CAAC,GAAGsG,KAAN,CAAF,CAArC;MACAtC,CAAC,GAAG3D,CAAC,GAAG2G,KAAK,CAAChH,CAAD,CAAL,CAASY,EAAb,GAAkBxB,MAAM,CAACY,CAAD,CAAN,CAAUgE,CAA5B,GAAgCQ,EAAE,CAACxE,CAAD,CAAtC;MACA,IAAIgE,CAAC,GAAG,CAAR,EAAWQ,EAAE,CAACxE,CAAD,CAAF,IAASgE,CAAC,GAAG,CAAb;IACZ;EACF,CAjJoC,CAiJnC;;;EAGF,KAAKhE,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGe,CAAhB,EAAmB,EAAEf,CAArB,EAAwB;IACtB3D,MAAM,CAACU,KAAP,CAAaiK,KAAK,CAAChH,CAAD,CAAL,CAASsD,SAAT,CAAmBiB,EAAE,CAACvE,CAAD,CAArB,EAA0BwE,EAAE,CAACxE,CAAD,CAA5B,CAAb;EACD;;EAED+D,CAAC,GAAGvE,GAAG,CAAC9B,GAAG,CAAC6J,MAAL,EAAa1N,CAAb,CAAP;EACAmK,CAAC,GAAGxE,GAAG,CAAC9B,GAAG,CAAC6J,MAAL,EAAazN,CAAb,CAAP;;EAEA,QAAQ0F,GAAG,CAAC9B,GAAG,CAAC6J,MAAL,EAAalM,MAAb,CAAX;IACE,KAAKzB,GAAL;MACEmK,CAAC,IAAI1H,MAAM,CAAC4E,KAAP,EAAL;MACA;;IAEF,KAAKtH,MAAL;MACEoK,CAAC,IAAI1H,MAAM,CAAC4E,KAAP,KAAiB,CAAtB;EANJ;;EASA,QAAQzB,GAAG,CAAC9B,GAAG,CAAC6J,MAAL,EAAajM,GAAb,CAAX;IACE,KAAK1B,GAAL;MACEoK,CAAC,IAAI3H,MAAM,CAAC6E,MAAP,EAAL;MACA;;IAEF,KAAKvH,MAAL;MACEqK,CAAC,IAAI3H,MAAM,CAAC6E,MAAP,KAAkB,CAAvB;EANJ;;EASA6C,CAAC,GAAGxD,IAAI,CAACiH,KAAL,CAAWzD,CAAX,CAAJ;EACAC,CAAC,GAAGzD,IAAI,CAACiH,KAAL,CAAWxD,CAAX,CAAJ,CA9KqC,CA8KlB;;EAEnB3H,MAAM,CAACS,KAAP;;EAEA,KAAKkD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGe,CAAhB,EAAmB,EAAEf,CAArB,EAAwB;IACtBZ,MAAM,CAACY,CAAD,CAAN,CAAUjE,IAAV,CAAeM,MAAf,CAAsBS,KAAtB;EACD;;EAED,KAAKkD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGe,CAAhB,EAAmB,EAAEf,CAArB,EAAwB;IACtBb,CAAC,GAAGC,MAAM,CAACY,CAAD,CAAV;IACAb,CAAC,CAAC4E,CAAF,IAAOQ,EAAE,CAACvE,CAAD,CAAF,IAAS+D,CAAhB;IACA5E,CAAC,CAAC6E,CAAF,IAAOQ,EAAE,CAACxE,CAAD,CAAF,IAASgE,CAAhB;IACA3H,MAAM,CAACU,KAAP,CAAaoC,CAAC,CAACpD,IAAF,CAAOM,MAAP,CAAcU,KAAd,CAAoBoC,CAAC,CAAC9C,MAAF,CAASiH,SAAT,CAAmBiB,EAAE,CAACvE,CAAD,CAArB,EAA0BwE,EAAE,CAACxE,CAAD,CAA5B,CAApB,CAAb;IACA,IAAItD,KAAJ,EAAWb,IAAI,CAACa,KAAL,CAAWyC,CAAX;EACZ;;EAED,OAAO9C,MAAP;AACD;;AACD,SAASoL,aAAT,CAAuB5L,IAAvB,EAA6B+C,KAA7B,EAAoClB,GAApC,EAAyC;EACvC,IAAIkH,KAAK,GAAGD,gBAAgB,CAAC/F,KAAD,CAA5B;EAAA,IACIQ,MAAM,GAAGwF,KAAK,CAACC,KADnB;EAAA,IAEIkB,IAAI,GAAGrI,GAAG,CAACrB,MAAJ,KAAejB,KAAf,GAAuBsM,UAAvB,GAAoCC,SAF/C;EAAA,IAGIC,GAAG,GAAGlK,GAAG,CAAC8F,MAHd;EAAA,IAII8C,KAAK,GAAG5I,GAAG,CAAC6I,OAAJ,IAAenH,MAAM,CAAC3C,MAJlC;EAAA,IAKI+J,KAAK,GAAGF,KAAK,IAAI,CAAT,GAAa,CAAb,GAAiB/F,IAAI,CAACmE,IAAL,CAAUtF,MAAM,CAAC3C,MAAP,GAAgB6J,KAA1B,CAL7B;EAAA,IAMIuB,KAAK,GAAGrB,KAAK,GAAGF,KANpB;EAAA,IAOIvC,CAPJ;EAAA,IAQIC,CARJ;EAAA,IASItD,EATJ;EAAA,IAUIE,EAVJ;EAAA,IAWI2G,MAXJ;EAAA,IAYIO,IAZJ;EAAA,IAaItE,MAbJ,CADuC,CAc3B;;EAEZ,MAAMnH,MAAM,GAAGwJ,UAAU,CAAChK,IAAD,EAAOuD,MAAP,EAAe1B,GAAf,CAAzB;EACA,IAAIrB,MAAM,CAACmJ,KAAP,EAAJ,EAAoBnJ,MAAM,CAAC+B,GAAP,CAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAjBmB,CAiBK;EAC5C;EACA;;EAEA,IAAIwG,KAAK,CAACE,UAAV,EAAsB;IACpBgD,IAAI,GAAGtI,GAAG,CAAC9B,GAAG,CAACqK,UAAL,EAAiBzM,GAAjB,EAAsB,IAAtB,CAAV;IACAyI,CAAC,GAAGiE,aAAa,CAACnM,IAAD,EAAO+I,KAAK,CAACE,UAAb,EAAyB1F,MAAzB,EAAiCkH,KAAjC,EAAwCE,KAAxC,EAA+C,CAAChH,GAAG,CAACoI,GAAD,EAAM,WAAN,CAAnD,EAAuE1D,GAAvE,EAA4E,CAA5E,EAA+E6B,IAA/E,EAAqF,IAArF,EAA2F,CAA3F,EAA8FO,KAA9F,EAAqG,CAArG,EAAwGwB,IAAxG,CAAjB;EACD,CAxBsC,CAwBrC;;;EAGF,IAAIlD,KAAK,CAACI,UAAV,EAAsB;IACpB8C,IAAI,GAAGtI,GAAG,CAAC9B,GAAG,CAACqK,UAAL,EAAiB1M,MAAjB,EAAyB,IAAzB,CAAV;IACA2I,CAAC,GAAGgE,aAAa,CAACnM,IAAD,EAAO+I,KAAK,CAACI,UAAb,EAAyB5F,MAAzB,EAAiCkH,KAAjC,EAAwCA,KAAxC,EAA+C,CAAC9G,GAAG,CAACoI,GAAD,EAAM,cAAN,CAAnD,EAA0E1D,GAA1E,EAA+E,CAA/E,EAAkF6B,IAAlF,EAAwF,IAAxF,EAA8F,CAA9F,EAAiG,CAAjG,EAAoGO,KAApG,EAA2GwB,IAA3G,CAAjB;EACD,CA9BsC,CA8BrC;;;EAGF,IAAIlD,KAAK,CAACG,UAAV,EAAsB;IACpB+C,IAAI,GAAGtI,GAAG,CAAC9B,GAAG,CAACuK,UAAL,EAAiB3M,GAAjB,EAAsB,IAAtB,CAAV;IACAoF,EAAE,GAAGsH,aAAa,CAACnM,IAAD,EAAO+I,KAAK,CAACG,UAAb,EAAyB3F,MAAzB,EAAiCkH,KAAjC,EAAwCE,KAAxC,EAA+ChH,GAAG,CAACoI,GAAD,EAAM,WAAN,CAAlD,EAAsEpH,GAAtE,EAA2E,CAA3E,EAA8EuF,IAA9E,EAAoF,IAApF,EAA0FO,KAAK,GAAG,CAAlG,EAAqGA,KAArG,EAA4G,CAA5G,EAA+GwB,IAA/G,CAAlB;EACD,CApCsC,CAoCrC;;;EAGF,IAAIlD,KAAK,CAACK,UAAV,EAAsB;IACpB6C,IAAI,GAAGtI,GAAG,CAAC9B,GAAG,CAACuK,UAAL,EAAiB5M,MAAjB,EAAyB,IAAzB,CAAV;IACAuF,EAAE,GAAGoH,aAAa,CAACnM,IAAD,EAAO+I,KAAK,CAACK,UAAb,EAAyB7F,MAAzB,EAAiCkH,KAAjC,EAAwCA,KAAxC,EAA+C9G,GAAG,CAACoI,GAAD,EAAM,cAAN,CAAlD,EAAyEpH,GAAzE,EAA8E,CAA9E,EAAiFuF,IAAjF,EAAuF,IAAvF,EAA6F8B,KAAK,GAAGvB,KAArG,EAA4G,CAA5G,EAA+GA,KAA/G,EAAsHwB,IAAtH,CAAlB;EACD,CA1CsC,CA0CrC;;;EAGF,IAAIlD,KAAK,CAACM,QAAV,EAAoB;IAClBqC,MAAM,GAAG/H,GAAG,CAAC9B,GAAG,CAACwK,WAAL,EAAkB5M,GAAlB,CAAZ;IACAkI,MAAM,GAAGhE,GAAG,CAACoI,GAAD,EAAM,UAAN,CAAZ;IACApE,MAAM,GAAG+D,MAAM,KAAK3N,GAAX,GAAiB8G,EAAE,GAAG8C,MAAtB,GAA+BO,CAAC,GAAGP,MAA5C;IACAsE,IAAI,GAAGtI,GAAG,CAAC9B,GAAG,CAACyK,SAAL,EAAgB7M,GAAhB,EAAqB,GAArB,CAAV;IACA8M,WAAW,CAACvM,IAAD,EAAO+I,KAAK,CAACM,QAAb,EAAuB1B,MAAvB,EAA+B,CAA/B,EAAkCnH,MAAlC,EAA0CyL,IAA1C,CAAX;EACD,CAnDsC,CAmDrC;;;EAGF,IAAIlD,KAAK,CAACO,QAAV,EAAoB;IAClBoC,MAAM,GAAG/H,GAAG,CAAC9B,GAAG,CAACwK,WAAL,EAAkB7M,MAAlB,CAAZ;IACAmI,MAAM,GAAGhE,GAAG,CAACoI,GAAD,EAAM,aAAN,CAAZ;IACApE,MAAM,GAAG+D,MAAM,KAAK3N,GAAX,GAAiBgH,EAAE,GAAG4C,MAAtB,GAA+BQ,CAAC,GAAGR,MAA5C;IACAsE,IAAI,GAAGtI,GAAG,CAAC9B,GAAG,CAACyK,SAAL,EAAgB9M,MAAhB,EAAwB,GAAxB,CAAV;IACA+M,WAAW,CAACvM,IAAD,EAAO+I,KAAK,CAACO,QAAb,EAAuB3B,MAAvB,EAA+B,CAA/B,EAAkCnH,MAAlC,EAA0CyL,IAA1C,CAAX;EACD;AACF;;AAED,SAASJ,UAAT,CAAoB7K,IAApB,EAA0BwL,KAA1B,EAAiC;EAC/B,OAAOA,KAAK,KAAK,IAAV,GAAiBxL,IAAI,CAACkH,CAAL,IAAU,CAA3B,GAA+BsE,KAAK,KAAK,IAAV,GAAiBxL,IAAI,CAACmH,CAAL,IAAU,CAA3B,GAA+BqE,KAAK,KAAK,IAAV,GAAiB,CAACxL,IAAI,CAACkH,CAAL,IAAU,CAAX,KAAiBlH,IAAI,CAACoE,KAAL,IAAc,CAA/B,CAAjB,GAAqDoH,KAAK,KAAK,IAAV,GAAiB,CAACxL,IAAI,CAACmH,CAAL,IAAU,CAAX,KAAiBnH,IAAI,CAACqE,MAAL,IAAe,CAAhC,CAAjB,GAAsDyE,SAAhL;AACD;;AAED,SAASgC,SAAT,CAAmB9K,IAAnB,EAAyBwL,KAAzB,EAAgC;EAC9B,OAAOxL,IAAI,CAACR,MAAL,CAAYgM,KAAZ,CAAP;AACD;;AAED,SAASL,aAAT,CAAuBnM,IAAvB,EAA6ByM,OAA7B,EAAsClJ,MAAtC,EAA8CkH,KAA9C,EAAqDiC,KAArD,EAA4D/E,MAA5D,EAAoEgF,GAApE,EAAyEC,GAAzE,EAA8EtM,KAA9E,EAAqFuM,EAArF,EAAyFC,KAAzF,EAAgGC,MAAhG,EAAwGC,IAAxG,EAA8Gf,IAA9G,EAAoH;EAClH,IAAI/G,CAAC,GAAG3B,MAAM,CAAC3C,MAAf;EAAA,IACIqM,IAAI,GAAG,CADX;EAAA,IAEIC,IAAI,GAAG,CAFX;EAAA,IAGI/I,CAHJ;EAAA,IAIIgJ,CAJJ;EAAA,IAKIC,CALJ;EAAA,IAMIhC,CANJ;EAAA,IAOI5G,CAPJ;EAAA,IAQI6I,CARJ;EAAA,IASI/J,CATJ;EAAA,IAUI4E,CAVJ;EAAA,IAWIC,CAXJ,CADkH,CAY3G;;EAEP,IAAI,CAACjD,CAAL,EAAQ,OAAO+H,IAAP,CAd0G,CAc7F;;EAErB,KAAK9I,CAAC,GAAG2I,KAAT,EAAgB3I,CAAC,GAAGe,CAApB,EAAuBf,CAAC,IAAI4I,MAA5B,EAAoC;IAClC,IAAIxJ,MAAM,CAACY,CAAD,CAAV,EAAe8I,IAAI,GAAGN,GAAG,CAACM,IAAD,EAAO3M,KAAK,CAACiD,MAAM,CAACY,CAAD,CAAP,EAAY0I,EAAZ,CAAZ,CAAV;EAChB,CAlBiH,CAkBhH;;;EAGF,IAAI,CAACJ,OAAO,CAAC7L,MAAb,EAAqB,OAAOqM,IAAP,CArB6F,CAqBhF;;EAElC,IAAIR,OAAO,CAAC7L,MAAR,GAAiB8L,KAArB,EAA4B;IAC1B1M,IAAI,CAACsN,IAAL,CAAU,gCAAgCZ,KAA1C;IACAD,OAAO,GAAGA,OAAO,CAACnG,KAAR,CAAc,CAAd,EAAiBoG,KAAjB,CAAV;EACD,CA1BiH,CA0BhH;;;EAGFO,IAAI,IAAItF,MAAR,CA7BkH,CA6BlG;;EAEhB,KAAKwF,CAAC,GAAG,CAAJ,EAAO/B,CAAC,GAAGqB,OAAO,CAAC7L,MAAxB,EAAgCuM,CAAC,GAAG/B,CAApC,EAAuC,EAAE+B,CAAzC,EAA4C;IAC1CnN,IAAI,CAACa,KAAL,CAAW4L,OAAO,CAACU,CAAD,CAAlB;IACAV,OAAO,CAACU,CAAD,CAAP,CAAWjN,IAAX,CAAgBM,MAAhB,CAAuBS,KAAvB;EACD,CAlCiH,CAkChH;;;EAGF,KAAKkD,CAAC,GAAG2I,KAAJ,EAAWK,CAAC,GAAG,CAAf,EAAkB/B,CAAC,GAAGqB,OAAO,CAAC7L,MAAnC,EAA2CuM,CAAC,GAAG/B,CAA/C,EAAkD,EAAE+B,CAAF,EAAKhJ,CAAC,IAAI4I,MAA5D,EAAoE;IAClEM,CAAC,GAAGZ,OAAO,CAACU,CAAD,CAAX;IACA3I,CAAC,GAAG6I,CAAC,CAACnN,IAAF,CAAOM,MAAX,CAFkE,CAE/C;IACnB;;IAEA,KAAK4M,CAAC,GAAGjJ,CAAT,EAAYiJ,CAAC,IAAI,CAAL,IAAU,CAAC9J,CAAC,GAAGC,MAAM,CAAC6J,CAAD,CAAX,KAAmB,IAAzC,EAA+CA,CAAC,IAAIJ,IAApD,CAAyD,CALS,CAKP;;;IAG3D,IAAIJ,GAAJ,EAAS;MACP1E,CAAC,GAAG+D,IAAI,IAAI,IAAR,GAAe3I,CAAC,CAAC4E,CAAjB,GAAqBxD,IAAI,CAACiH,KAAL,CAAWrI,CAAC,CAAC9C,MAAF,CAASoE,EAAT,GAAcqH,IAAI,GAAG3I,CAAC,CAAC9C,MAAF,CAAS4E,KAAT,EAAhC,CAAzB;MACA+C,CAAC,GAAG8E,IAAJ;IACD,CAHD,MAGO;MACL/E,CAAC,GAAG+E,IAAJ;MACA9E,CAAC,GAAG8D,IAAI,IAAI,IAAR,GAAe3I,CAAC,CAAC6E,CAAjB,GAAqBzD,IAAI,CAACiH,KAAL,CAAWrI,CAAC,CAAC9C,MAAF,CAASsE,EAAT,GAAcmH,IAAI,GAAG3I,CAAC,CAAC9C,MAAF,CAAS6E,MAAT,EAAhC,CAAzB;IACD;;IAEDb,CAAC,CAACtD,KAAF,CAAQmM,CAAC,CAAC7M,MAAF,CAASiH,SAAT,CAAmBS,CAAC,IAAImF,CAAC,CAACnF,CAAF,IAAO,CAAX,CAApB,EAAmCC,CAAC,IAAIkF,CAAC,CAAClF,CAAF,IAAO,CAAX,CAApC,CAAR;IACAkF,CAAC,CAACnF,CAAF,GAAMA,CAAN;IACAmF,CAAC,CAAClF,CAAF,GAAMA,CAAN;IACAnI,IAAI,CAACa,KAAL,CAAWwM,CAAX,EAnBkE,CAmBnD;;IAEfH,IAAI,GAAGP,GAAG,CAACO,IAAD,EAAO1I,CAAC,CAACqI,EAAD,CAAR,CAAV;EACD;;EAED,OAAOK,IAAP;AACD;;AAED,SAASX,WAAT,CAAqBvM,IAArB,EAA2BsD,CAA3B,EAA8BqE,MAA9B,EAAsCiF,GAAtC,EAA2CpM,MAA3C,EAAmDyL,IAAnD,EAAyD;EACvD,IAAI,CAAC3I,CAAL,EAAQ;EACRtD,IAAI,CAACa,KAAL,CAAWyC,CAAX,EAFuD,CAExC;;EAEf,IAAI4E,CAAC,GAAGP,MAAR;EAAA,IACIQ,CAAC,GAAGR,MADR;EAEAiF,GAAG,GAAG1E,CAAC,GAAGxD,IAAI,CAACiH,KAAL,CAAWnL,MAAM,CAACoE,EAAP,GAAYqH,IAAI,GAAGzL,MAAM,CAAC4E,KAAP,EAA9B,CAAP,GAAuD+C,CAAC,GAAGzD,IAAI,CAACiH,KAAL,CAAWnL,MAAM,CAACsE,EAAP,GAAYmH,IAAI,GAAGzL,MAAM,CAAC6E,MAAP,EAA9B,CAA9D,CANuD,CAMuD;;EAE9G/B,CAAC,CAAC9C,MAAF,CAASiH,SAAT,CAAmBS,CAAC,IAAI5E,CAAC,CAAC4E,CAAF,IAAO,CAAX,CAApB,EAAmCC,CAAC,IAAI7E,CAAC,CAAC6E,CAAF,IAAO,CAAX,CAApC;EACA7E,CAAC,CAACpD,IAAF,CAAOM,MAAP,CAAcS,KAAd,GAAsBC,KAAtB,CAA4BoC,CAAC,CAAC9C,MAA9B;EACA8C,CAAC,CAAC4E,CAAF,GAAMA,CAAN;EACA5E,CAAC,CAAC6E,CAAF,GAAMA,CAAN,CAXuD,CAW9C;;EAETnI,IAAI,CAACa,KAAL,CAAWyC,CAAX;AACD;;AAED,SAASiK,QAAT,CAAkBC,MAAlB,EAA0BhI,MAA1B,EAAkC;EAChC,MAAM3D,GAAG,GAAG2L,MAAM,CAAChI,MAAD,CAAN,IAAkB,EAA9B;EACA,OAAO,CAACoE,GAAD,EAAMC,CAAN,KAAYhI,GAAG,CAAC+H,GAAD,CAAH,IAAY,IAAZ,GAAmB/H,GAAG,CAAC+H,GAAD,CAAtB,GAA8B4D,MAAM,CAAC5D,GAAD,CAAN,IAAe,IAAf,GAAsB4D,MAAM,CAAC5D,GAAD,CAA5B,GAAoCC,CAArF;AACD,C,CAAC;;;AAGF,SAAS4D,OAAT,CAAiBC,OAAjB,EAA0BrL,KAA1B,EAAiC;EAC/B,IAAIsC,GAAG,GAAG,CAACgB,QAAX;EACA+H,OAAO,CAAC3M,OAAR,CAAgBC,IAAI,IAAI;IACtB,IAAIA,IAAI,CAAC2G,MAAL,IAAe,IAAnB,EAAyBhD,GAAG,GAAGD,IAAI,CAACC,GAAL,CAASA,GAAT,EAAc3D,IAAI,CAAC2G,MAAnB,CAAN;EAC1B,CAFD;EAGA,OAAOhD,GAAG,GAAG,CAACgB,QAAP,GAAkBhB,GAAlB,GAAwBtC,KAA/B;AACD;;AAED,SAASsL,YAAT,CAAsBrK,CAAtB,EAAyBkC,MAAzB,EAAiCgI,MAAjC,EAAyCI,EAAzC,EAA6CC,EAA7C,EAAiDC,CAAjD,EAAoDT,CAApD,EAAuD;EACrD,MAAMvN,CAAC,GAAGyN,QAAQ,CAACC,MAAD,EAAShI,MAAT,CAAlB;EAAA,MACMmC,MAAM,GAAG8F,OAAO,CAACnK,CAAD,EAAIxD,CAAC,CAAC,QAAD,EAAW,CAAX,CAAL,CADtB;EAAA,MAEM4L,MAAM,GAAG5L,CAAC,CAAC,QAAD,EAAWjC,KAAX,CAFhB;EAAA,MAGMkQ,IAAI,GAAGrC,MAAM,KAAK3N,GAAX,GAAiB,CAAjB,GAAqB2N,MAAM,KAAK5N,MAAX,GAAoB,GAApB,GAA0B,CAH5D;;EAKA,MAAM0F,CAAC,GAAG;IACR4G,KAAK,EAAE9K,IADC;IAERkB,MAAM,EAAEV,CAAC,CAAC,QAAD,EAAWP,KAAX,CAFD;IAGRmL,OAAO,EAAE5K,CAAC,CAAC,WAAD,CAAD,KAAmB,UAAnB,GAAgC,CAAhC,GAAoCwD,CAAC,CAAC1C,MAHvC;IAIR2J,OAAO,EAAEzK,CAAC,CAAC,QAAD,EAAW,CAAX,CAJF;IAKR2L,MAAM,EAAE3L,CAAC,CAAC,QAAD,CALD;IAMRmK,OAAO,EAAE;EAND,CAAV;;EASA,QAAQzE,MAAR;IACE,KAAKlI,IAAL;MACEkG,CAAC,CAACkI,MAAF,GAAW;QACTxD,CAAC,EAAExD,IAAI,CAACkE,KAAL,CAAWgF,EAAE,CAAChJ,EAAd,IAAoB+C,MADd;QAETqG,MAAM,EAAEjQ,GAFC;QAGToK,CAAC,EAAE4F,IAAI,IAAIV,CAAC,IAAIO,EAAE,CAACvI,MAAH,KAAc,IAAIuI,EAAE,CAAC9I,EAA9B,CAHE;QAITmJ,GAAG,EAAEvC;MAJI,CAAX;MAMA;;IAEF,KAAKnO,KAAL;MACEiG,CAAC,CAACkI,MAAF,GAAW;QACTxD,CAAC,EAAExD,IAAI,CAACmE,IAAL,CAAU+E,EAAE,CAAC/I,EAAb,IAAmB8C,MADb;QAETQ,CAAC,EAAE4F,IAAI,IAAIV,CAAC,IAAIO,EAAE,CAACvI,MAAH,KAAc,IAAIuI,EAAE,CAAC9I,EAA9B,CAFE;QAGTmJ,GAAG,EAAEvC;MAHI,CAAX;MAKA;;IAEF,KAAKrO,GAAL;MACEmG,CAAC,CAACkI,MAAF,GAAW;QACTvD,CAAC,EAAEzD,IAAI,CAACkE,KAAL,CAAWiF,EAAE,CAAC/I,EAAd,IAAoB6C,MADd;QAETsG,GAAG,EAAElQ,GAFI;QAGTmK,CAAC,EAAE6F,IAAI,IAAID,CAAC,IAAID,EAAE,CAACzI,KAAH,KAAa,IAAIyI,EAAE,CAACjJ,EAA7B,CAHE;QAIToJ,MAAM,EAAEtC;MAJC,CAAX;MAMA;;IAEF,KAAKlO,MAAL;MACEgG,CAAC,CAACkI,MAAF,GAAW;QACTvD,CAAC,EAAEzD,IAAI,CAACmE,IAAL,CAAUgF,EAAE,CAAC9I,EAAb,IAAmB4C,MADb;QAETO,CAAC,EAAE6F,IAAI,IAAID,CAAC,IAAID,EAAE,CAACzI,KAAH,KAAa,IAAIyI,EAAE,CAACjJ,EAA7B,CAFE;QAGToJ,MAAM,EAAEtC;MAHC,CAAX;MAKA;;IAEF,KAAKjO,OAAL;MACE+F,CAAC,CAACkI,MAAF,GAAW;QACTxD,CAAC,EAAEP,MADM;QAETQ,CAAC,EAAER;MAFM,CAAX;MAIA;;IAEF,KAAKjK,QAAL;MACE8F,CAAC,CAACkI,MAAF,GAAW;QACTxD,CAAC,EAAE4F,CAAC,GAAGnG,MADE;QAETQ,CAAC,EAAER,MAFM;QAGTqG,MAAM,EAAEjQ;MAHC,CAAX;MAKA;;IAEF,KAAKJ,UAAL;MACE6F,CAAC,CAACkI,MAAF,GAAW;QACTxD,CAAC,EAAEP,MADM;QAETQ,CAAC,EAAEkF,CAAC,GAAG1F,MAFE;QAGTsG,GAAG,EAAElQ;MAHI,CAAX;MAKA;;IAEF,KAAKH,WAAL;MACE4F,CAAC,CAACkI,MAAF,GAAW;QACTxD,CAAC,EAAE4F,CAAC,GAAGnG,MADE;QAETQ,CAAC,EAAEkF,CAAC,GAAG1F,MAFE;QAGTqG,MAAM,EAAEjQ,GAHC;QAITkQ,GAAG,EAAElQ;MAJI,CAAX;MAMA;EAjEJ;;EAoEA,OAAOyF,CAAP;AACD;;AACD,SAAS0K,YAAT,CAAsBlO,IAAtB,EAA4BmO,MAA5B,EAAoC;EAClC,IAAInN,IAAI,GAAGmN,MAAM,CAACxN,KAAP,CAAa,CAAb,CAAX;EAAA,IACIsG,KAAK,GAAGjG,IAAI,CAACiG,KADjB;EAAA,IAEIzB,MAAM,GAAGxE,IAAI,CAACwE,MAFlB;EAAA,IAGIhF,MAAM,GAAGQ,IAAI,CAACR,MAHlB;EAAA,IAII0H,CAAC,GAAGlH,IAAI,CAACkH,CAJb;EAAA,IAKIC,CAAC,GAAGnH,IAAI,CAACmH,CALb;EAAA,IAMI2F,CANJ;EAAA,IAOIT,CAPJ,CADkC,CAQ3B;;EAEPrM,IAAI,CAACoN,OAAL,GAAepN,IAAI,CAACoN,OAAL,CAAanN,KAAb,GAAqBC,KAArB,CAA2BV,MAA3B,CAAf,GAAoDQ,IAAI,CAACoN,OAAL,GAAe5N,MAAM,CAACkJ,KAAP,EAAnE;EACAlJ,MAAM,CAACS,KAAP,GAXkC,CAWlB;;EAEhBoN,iBAAiB,CAACrO,IAAD,EAAOgB,IAAP,EAAaA,IAAI,CAACL,KAAL,CAAW,CAAX,EAAcA,KAAd,CAAoB,CAApB,CAAb,CAAjB,CAbkC,CAaqB;;EAEvDH,MAAM,GAAG8N,YAAY,CAACtN,IAAD,EAAOR,MAAP,CAArB;EACAsN,CAAC,GAAG,IAAI9M,IAAI,CAACuJ,OAAb;EACA8C,CAAC,GAAG,IAAIrM,IAAI,CAACuJ,OAAb;;EAEA,IAAI,CAAC/J,MAAM,CAACmJ,KAAP,EAAL,EAAqB;IACnBmE,CAAC,GAAGpJ,IAAI,CAACmE,IAAL,CAAUrI,MAAM,CAAC4E,KAAP,KAAiB0I,CAA3B,CAAJ;IACAT,CAAC,GAAG3I,IAAI,CAACmE,IAAL,CAAUrI,MAAM,CAAC6E,MAAP,KAAkBgI,CAA5B,CAAJ;EACD;;EAED,IAAIpG,KAAK,CAAC9G,IAAN,KAAepB,OAAnB,EAA4B;IAC1BwP,iBAAiB,CAACvN,IAAI,CAACL,KAAL,CAAW,CAAX,EAAcA,KAAd,CAAoB,CAApB,EAAuBA,KAAvB,CAA6B,CAA7B,EAAgCA,KAAjC,CAAjB;EACD;;EAED,IAAI6E,MAAM,KAAKpG,IAAf,EAAqB;IACnB4B,IAAI,CAACkH,CAAL,GAASA,CAAC,GAAG,CAAb;IACAlH,IAAI,CAACmH,CAAL,GAASA,CAAC,GAAG,CAAb;EACD;;EAEDnH,IAAI,CAACoE,KAAL,GAAa0I,CAAb;EACA9M,IAAI,CAACqE,MAAL,GAAcgI,CAAd;EACApQ,WAAW,CAACuD,MAAM,CAAC+B,GAAP,CAAW2F,CAAX,EAAcC,CAAd,EAAiBD,CAAC,GAAG4F,CAArB,EAAwB3F,CAAC,GAAGkF,CAA5B,CAAD,EAAiCrM,IAAjC,CAAX;EACAA,IAAI,CAACd,IAAL,CAAUM,MAAV,CAAiBS,KAAjB,GAAyBC,KAAzB,CAA+BV,MAA/B;EACA,OAAOQ,IAAP;AACD;;AAED,SAASsN,YAAT,CAAsBtN,IAAtB,EAA4BwD,CAA5B,EAA+B;EAC7B;EACAxD,IAAI,CAACL,KAAL,CAAWI,OAAX,CAAmBjB,CAAC,IAAI0E,CAAC,CAACtD,KAAF,CAAQpB,CAAC,CAACU,MAAV,CAAxB,EAF6B,CAEe;;EAE5CgE,CAAC,CAACI,EAAF,GAAO5D,IAAI,CAACuJ,OAAZ;EACA/F,CAAC,CAACM,EAAF,GAAO9D,IAAI,CAACuJ,OAAZ;EACA,OAAO/F,CAAP;AACD;;AAED,SAAS6J,iBAAT,CAA2BrO,IAA3B,EAAiCgB,IAAjC,EAAuCX,KAAvC,EAA8C;EAC5C,IAAI4E,GAAG,GAAGjE,IAAI,CAACuJ,OAAf;EAAA,IACIiE,EAAE,GAAGvJ,GAAG,GAAG5E,KAAK,CAAC6H,CADrB;EAAA,IAEIuG,EAAE,GAAGxJ,GAAG,GAAG5E,KAAK,CAAC8H,CAFrB;;EAIA,IAAI,CAACnH,IAAI,CAACiG,KAAL,CAAWc,KAAhB,EAAuB;IACrB,IAAIyG,EAAE,IAAIC,EAAV,EAAchH,SAAS,CAACzH,IAAD,EAAOK,KAAP,EAAcmO,EAAd,EAAkBC,EAAlB,CAAT;EACf,CAFD,MAEO;IACL,IAAI1G,KAAK,GAAG/G,IAAI,CAACL,KAAL,CAAW,CAAX,EAAcA,KAAd,CAAoB,CAApB,CAAZ;IAAA,IACI+K,MAAM,GAAG3D,KAAK,CAAC2D,MADnB;IAAA,IAEIgD,IAAI,GAAG1N,IAAI,CAACgH,YAAL,IAAqB,CAFhC;IAAA,IAGI2G,EAAE,GAAG1J,GAAG,GAAG8C,KAAK,CAACG,CAHrB;IAAA,IAII0G,EAAE,GAAG3J,GAAG,GAAG8C,KAAK,CAACI,CAJrB;;IAMA,QAAQJ,KAAK,CAACvC,MAAd;MACE,KAAKlI,IAAL;QACEkR,EAAE,IAAI9J,IAAI,CAACmE,IAAL,CAAUd,KAAK,CAACvH,MAAN,CAAa4E,KAAb,EAAV,IAAkCsJ,IAAxC;QACA;;MAEF,KAAKnR,KAAL;MACA,KAAKC,MAAL;QACE;;MAEF;QACEiR,EAAE,IAAI1G,KAAK,CAACvH,MAAN,CAAa6E,MAAb,KAAwBqJ,IAA9B;IAVJ;;IAaA,IAAIF,EAAE,IAAIC,EAAV,EAAchH,SAAS,CAACzH,IAAD,EAAOK,KAAP,EAAcmO,EAAd,EAAkBC,EAAlB,CAAT;;IAEd,QAAQ1G,KAAK,CAACvC,MAAd;MACE,KAAKlI,IAAL;QACEsR,EAAE,IAAIC,iBAAiB,CAAC7N,IAAD,EAAOX,KAAP,EAAc0H,KAAd,EAAqB2D,MAArB,EAA6B,CAA7B,EAAgC,CAAhC,CAAvB;QACA;;MAEF,KAAKnO,KAAL;QACEoR,EAAE,IAAIE,iBAAiB,CAAC7N,IAAD,EAAOX,KAAP,EAAc0H,KAAd,EAAqBhK,GAArB,EAA0B,CAA1B,EAA6B,CAA7B,CAAjB,GAAmD2Q,IAAzD;QACAE,EAAE,IAAIC,iBAAiB,CAAC7N,IAAD,EAAOX,KAAP,EAAc0H,KAAd,EAAqB2D,MAArB,EAA6B,CAA7B,EAAgC,CAAhC,CAAvB;QACA;;MAEF,KAAKlO,MAAL;QACEmR,EAAE,IAAIE,iBAAiB,CAAC7N,IAAD,EAAOX,KAAP,EAAc0H,KAAd,EAAqB2D,MAArB,EAA6B,CAA7B,EAAgC,CAAhC,CAAvB;QACAkD,EAAE,IAAIC,iBAAiB,CAAC7N,IAAD,EAAOX,KAAP,EAAc0H,KAAd,EAAqBhK,GAArB,EAA0B,CAAC,CAA3B,EAA8B,CAA9B,EAAiC,CAAjC,CAAjB,GAAuD2Q,IAA7D;QACA;;MAEF;QACEC,EAAE,IAAIE,iBAAiB,CAAC7N,IAAD,EAAOX,KAAP,EAAc0H,KAAd,EAAqB2D,MAArB,EAA6B,CAA7B,EAAgC,CAAhC,CAAvB;IAhBJ;;IAmBA,IAAIiD,EAAE,IAAIC,EAAV,EAAcnH,SAAS,CAACzH,IAAD,EAAO+H,KAAP,EAAc4G,EAAd,EAAkBC,EAAlB,CAAT,CAzCT,CAyCyC;;IAE9C,IAAI,CAACD,EAAE,GAAGjK,IAAI,CAACiH,KAAL,CAAW5D,KAAK,CAACvH,MAAN,CAAaoE,EAAb,GAAkBK,GAA7B,CAAN,IAA2C,CAA/C,EAAkD;MAChDwC,SAAS,CAACzH,IAAD,EAAOK,KAAP,EAAc,CAACsO,EAAf,EAAmB,CAAnB,CAAT;MACAlH,SAAS,CAACzH,IAAD,EAAO+H,KAAP,EAAc,CAAC4G,EAAf,EAAmB,CAAnB,CAAT;IACD;EACF;AACF;;AAED,SAASE,iBAAT,CAA2B7N,IAA3B,EAAiCX,KAAjC,EAAwC0H,KAAxC,EAA+C2D,MAA/C,EAAuDvD,CAAvD,EAA0D2G,EAA1D,EAA8DC,KAA9D,EAAqE;EACnE,MAAMC,IAAI,GAAGhO,IAAI,CAACiG,KAAL,CAAW9G,IAAX,KAAoB,QAAjC;EAAA,MACM8O,KAAK,GAAGlH,KAAK,CAACd,KAAN,CAAYgI,KAD1B;EAAA,MAEMC,CAAC,GAAGF,IAAI,KAAKF,EAAE,IAAI,CAACG,KAAZ,CAAJ,IAA0B,CAACF,KAA3B,GAAmC1O,KAAK,CAACM,KAAN,CAAY,CAAZ,CAAnC,GAAoDN,KAF9D;EAAA,MAGM+H,CAAC,GAAG8G,CAAC,CAAC1O,MAAF,CAAS2H,CAAC,GAAG,IAAH,GAAU,IAApB,IAA4BnH,IAAI,CAACuJ,OAH3C;EAAA,MAIM4E,CAAC,GAAGF,KAAK,IAAIH,EAAT,GAAc1G,CAAd,GAAkB,CAJ5B;EAAA,MAKMK,CAAC,GAAGwG,KAAK,IAAIH,EAAT,GAAc,CAAd,GAAkB1G,CAL5B;EAAA,MAMMgH,CAAC,GAAGjH,CAAC,IAAI,CAAL,GAAS,CAAT,GAAanL,eAAe,CAAC+K,KAAD,CANtC;EAOA,OAAOrD,IAAI,CAACiH,KAAL,CAAWD,MAAM,KAAK7N,KAAX,GAAmBsR,CAAnB,GAAuBzD,MAAM,KAAK3N,GAAX,GAAiB0K,CAAC,GAAG2G,CAArB,GAAyB,OAAOhH,CAAC,GAAGgH,CAAX,CAA3D,CAAP;AACD;;AAED,SAAS3H,SAAT,CAAmBzH,IAAnB,EAAyBgB,IAAzB,EAA+B0H,EAA/B,EAAmCC,EAAnC,EAAuC;EACrC3H,IAAI,CAACkH,CAAL,IAAUQ,EAAV;EACA1H,IAAI,CAACmH,CAAL,IAAUQ,EAAV;EACA3H,IAAI,CAACR,MAAL,CAAYiH,SAAZ,CAAsBiB,EAAtB,EAA0BC,EAA1B;EACA3H,IAAI,CAACd,IAAL,CAAUM,MAAV,CAAiBiH,SAAjB,CAA2BiB,EAA3B,EAA+BC,EAA/B;EACA3I,IAAI,CAACa,KAAL,CAAWG,IAAX;AACD;;AAED,SAASuN,iBAAT,CAA2Bc,OAA3B,EAAoC;EAClC;EACA,MAAMC,MAAM,GAAGD,OAAO,CAACtJ,MAAR,CAAe,CAAC+H,CAAD,EAAIxK,CAAJ,KAAU;IACtCwK,CAAC,CAACxK,CAAC,CAAC0K,MAAH,CAAD,GAActJ,IAAI,CAACC,GAAL,CAASrB,CAAC,CAAC9C,MAAF,CAASqE,EAAT,GAAcvB,CAAC,CAAC4E,CAAzB,EAA4B4F,CAAC,CAACxK,CAAC,CAAC0K,MAAH,CAAD,IAAe,CAA3C,CAAd;IACA,OAAOF,CAAP;EACD,CAHc,EAGZ,EAHY,CAAf,CAFkC,CAK1B;;EAERuB,OAAO,CAACtO,OAAR,CAAgBuC,CAAC,IAAI;IACnBA,CAAC,CAAC8B,KAAF,GAAUkK,MAAM,CAAChM,CAAC,CAAC0K,MAAH,CAAhB;IACA1K,CAAC,CAAC+B,MAAF,GAAW/B,CAAC,CAAC9C,MAAF,CAASuE,EAAT,GAAczB,CAAC,CAAC6E,CAA3B;EACD,CAHD;AAID;;AAED,SAASoH,WAAT,CAAqBvP,IAArB,EAA2BE,IAA3B,EAAiCkF,KAAjC,EAAwCC,MAAxC,EAAgDmK,UAAhD,EAA4D;EAC1D,IAAIzM,KAAK,GAAG7C,IAAI,CAACS,KAAL,CAAW,CAAX,CAAZ;EAAA,IACI8O,KAAK,GAAG1M,KAAK,CAAC0M,KADlB;EAAA,IAEIjK,MAAM,GAAGzC,KAAK,CAACyC,MAFnB;EAAA,IAGIkG,MAAM,GAAG3I,KAAK,CAAC2I,MAHnB;EAAA,IAII/D,MAAM,GAAG5E,KAAK,CAAC4E,MAJnB;EAAA,IAKI4C,OAAO,GAAGxH,KAAK,CAACwH,OALpB;EAAA,IAMIxC,KAAK,GAAGhF,KAAK,CAACpC,KAAN,CAAY,CAAZ,EAAeA,KAAf,CAAqB,CAArB,CANZ;EAAA,IAOI+O,QAAQ,GAAG3M,KAAK,CAACpC,KAAN,CAAY,CAAZ,KAAkBoC,KAAK,CAACpC,KAAN,CAAY,CAAZ,EAAeA,KAAf,CAAqB,CAArB,CAPjC;EAAA,IAQIgP,GAAG,GAAGnK,MAAM,KAAKlI,IAAX,IAAmBkI,MAAM,KAAKjI,KAA9B,GAAsC8H,MAAtC,GAA+CD,KARzD;EAAA,IASI0H,KAAK,GAAG,CATZ;EAAA,IAUI5E,CAAC,GAAG,CAVR;EAAA,IAWIC,CAAC,GAAG,CAXR;EAAA,IAYIyH,EAAE,GAAG,CAZT;EAAA,IAaIC,EAAE,GAAG,CAbT;EAAA,IAcIC,GAdJ;;EAgBA,IAAIL,KAAK,KAAKvR,KAAd,EAAqB;IACnBsH,MAAM,KAAKlI,IAAX,IAAmBwP,KAAK,GAAG0C,UAAU,CAACzK,EAAnB,EAAuB4K,GAAG,GAAGH,UAAU,CAAC1K,EAA3D,IAAiEU,MAAM,KAAKjI,KAAX,IAAoBuP,KAAK,GAAG0C,UAAU,CAAC1K,EAAnB,EAAuB6K,GAAG,GAAGH,UAAU,CAACzK,EAA5D,KAAmE+H,KAAK,GAAG0C,UAAU,CAAC5K,EAAnB,EAAuB+K,GAAG,GAAGH,UAAU,CAAC3K,EAA3G,CAAjE;EACD,CAFD,MAEO,IAAIW,MAAM,KAAKlI,IAAf,EAAqB;IAC1BwP,KAAK,GAAGzH,MAAR,EAAgBsK,GAAG,GAAG,CAAtB;EACD;;EAEDG,GAAG,GAAGpE,MAAM,KAAK7N,KAAX,GAAmBiP,KAAnB,GAA2BpB,MAAM,KAAK3N,GAAX,GAAiB4R,GAAjB,GAAuB,CAAC7C,KAAK,GAAG6C,GAAT,IAAgB,CAAxE;;EAEA,IAAID,QAAQ,IAAIA,QAAQ,CAACK,IAAzB,EAA+B;IAC7B;IACA,QAAQvK,MAAR;MACE,KAAKnI,GAAL;MACA,KAAKG,MAAL;QACEqS,EAAE,GAAG9H,KAAK,CAACvH,MAAN,CAAa6E,MAAb,KAAwBkF,OAA7B;QACA;;MAEF,KAAKjN,IAAL;QACEsS,EAAE,GAAG7H,KAAK,CAACvH,MAAN,CAAa4E,KAAb,KAAuBmF,OAA5B;QACA;;MAEF,KAAKhN,KAAL;QACEqS,EAAE,GAAG,CAAC7H,KAAK,CAACvH,MAAN,CAAa4E,KAAb,EAAD,GAAwBmF,OAA7B;QACA;IAZJ;;IAeA1D,UAAU,CAAC5F,KAAX,GAAmBC,KAAnB,CAAyBwO,QAAQ,CAAClP,MAAlC;IACAqG,UAAU,CAACY,SAAX,CAAqBmI,EAAE,IAAIF,QAAQ,CAACxH,CAAT,IAAc,CAAlB,CAAvB,EAA6C2H,EAAE,IAAIH,QAAQ,CAACvH,CAAT,IAAc,CAAlB,CAA/C;;IAEA,IAAI5F,GAAG,CAACmN,QAAD,EAAW,GAAX,EAAgBE,EAAhB,CAAH,GAAyBrN,GAAG,CAACmN,QAAD,EAAW,GAAX,EAAgBG,EAAhB,CAAhC,EAAqD;MACnD7P,IAAI,CAACa,KAAL,CAAW6O,QAAX;MACAA,QAAQ,CAAClP,MAAT,CAAgBS,KAAhB,GAAwBC,KAAxB,CAA8B2F,UAA9B;MACA6I,QAAQ,CAACxP,IAAT,CAAcM,MAAd,CAAqBS,KAArB,GAA6BC,KAA7B,CAAmC2F,UAAnC;MACA7G,IAAI,CAACa,KAAL,CAAW6O,QAAX;IACD;;IAED7I,UAAU,CAAC5F,KAAX,GAAmBC,KAAnB,CAAyBwO,QAAQ,CAAClP,MAAlC;EACD,CA5BD,MA4BO;IACLqG,UAAU,CAAC5F,KAAX;EACD;;EAED4F,UAAU,CAAC3F,KAAX,CAAiB6G,KAAK,CAACvH,MAAvB,EAzD0D,CAyD1B;;EAEhC,QAAQgF,MAAR;IACE,KAAKnI,GAAL;MACE6K,CAAC,GAAG4H,GAAJ;MACA3H,CAAC,GAAGqH,UAAU,CAAC1K,EAAX,GAAgB+B,UAAU,CAACxB,MAAX,EAAhB,GAAsCsC,MAA1C;MACA;;IAEF,KAAKrK,IAAL;MACE4K,CAAC,GAAGsH,UAAU,CAAC5K,EAAX,GAAgBiC,UAAU,CAACzB,KAAX,EAAhB,GAAqCuC,MAAzC;MACAQ,CAAC,GAAG2H,GAAJ;MACA;;IAEF,KAAKvS,KAAL;MACE2K,CAAC,GAAGsH,UAAU,CAAC3K,EAAX,GAAgBgC,UAAU,CAACzB,KAAX,EAAhB,GAAqCuC,MAAzC;MACAQ,CAAC,GAAG2H,GAAJ;MACA;;IAEF,KAAKtS,MAAL;MACE0K,CAAC,GAAG4H,GAAJ;MACA3H,CAAC,GAAGqH,UAAU,CAACzK,EAAX,GAAgB4C,MAApB;MACA;;IAEF;MACEO,CAAC,GAAGnF,KAAK,CAACmF,CAAV;MACAC,CAAC,GAAGpF,KAAK,CAACoF,CAAV;EAvBJ;;EA0BA,IAAI5F,GAAG,CAACQ,KAAD,EAAQ,GAAR,EAAamF,CAAb,CAAH,GAAqB3F,GAAG,CAACQ,KAAD,EAAQ,GAAR,EAAaoF,CAAb,CAA5B,EAA6C;IAC3CtB,UAAU,CAACY,SAAX,CAAqBS,CAArB,EAAwBC,CAAxB;IACAnI,IAAI,CAACa,KAAL,CAAWkC,KAAX;IACAA,KAAK,CAACvC,MAAN,CAAaS,KAAb,GAAqBC,KAArB,CAA2B2F,UAA3B;IACA3G,IAAI,CAACM,MAAL,CAAYS,KAAZ,GAAoBC,KAApB,CAA0B2F,UAA1B;IACA7G,IAAI,CAACa,KAAL,CAAWkC,KAAX;EACD;;EAED,OAAOA,KAAK,CAACvC,MAAb;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASwP,UAAT,CAAoBrQ,MAApB,EAA4B;EAC1BjD,SAAS,CAACkD,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2BD,MAA3B;AACD;;AACDzC,QAAQ,CAAC8S,UAAD,EAAatT,SAAb,EAAwB;EAC9BmD,SAAS,CAACC,CAAD,EAAIC,KAAJ,EAAW;IAClB,MAAMC,IAAI,GAAGD,KAAK,CAACE,QAAnB;;IAEAH,CAAC,CAACI,IAAF,CAAOS,KAAP,CAAaI,OAAb,CAAqBgC,KAAK,IAAI;MAC5B,IAAIjD,CAAC,CAACmQ,MAAN,EAAcrE,aAAa,CAAC5L,IAAD,EAAO+C,KAAP,EAAcjD,CAAC,CAACmQ,MAAhB,CAAb;MACdC,WAAW,CAAClQ,IAAD,EAAO+C,KAAP,EAAcjD,CAAd,CAAX;IACD,CAHD;;IAKA,OAAOqQ,YAAY,CAACrQ,CAAC,CAACI,IAAF,CAAO6C,KAAR,CAAZ,GAA6BhD,KAAK,CAACwB,MAAN,EAA7B,GAA8CxB,KAArD;EACD;;AAV6B,CAAxB,CAAR;;AAcA,SAASoQ,YAAT,CAAsBpN,KAAtB,EAA6B;EAC3B;EACA;EACA;EACA;EACA;EACA,OAAOA,KAAK,IAAIA,KAAK,CAAC7C,IAAN,CAAWoB,IAAX,KAAoB,cAApC;AACD;;AAED,SAAS4O,WAAT,CAAqBlQ,IAArB,EAA2B+C,KAA3B,EAAkCjD,CAAlC,EAAqC;EACnC,IAAIa,KAAK,GAAGoC,KAAK,CAACpC,KAAlB;EAAA,IACIyE,KAAK,GAAGV,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY5B,KAAK,CAACqC,KAAN,IAAe,CAA3B,CADZ;EAAA,IAEIC,MAAM,GAAGX,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY5B,KAAK,CAACsC,MAAN,IAAgB,CAA5B,CAFb;EAAA,IAGImK,UAAU,GAAG,IAAIzS,MAAJ,GAAawF,GAAb,CAAiB,CAAjB,EAAoB,CAApB,EAAuB6C,KAAvB,EAA8BC,MAA9B,CAHjB;EAAA,IAII+K,OAAO,GAAGZ,UAAU,CAAC9F,KAAX,EAJd;EAAA,IAKI2G,OAAO,GAAGb,UAAU,CAAC9F,KAAX,EALd;EAAA,IAMIgE,OAAO,GAAG,EANd;EAAA,IAOI3F,KAPJ;EAAA,IAQI7H,IARJ;EAAA,IASIsF,MATJ;EAAA,IAUIhB,CAVJ;EAAA,IAWIL,CAXJ;EAAA,IAYIe,CAZJ,CADmC,CAa5B;;EAEP,KAAKf,CAAC,GAAG,CAAJ,EAAOe,CAAC,GAAGvE,KAAK,CAACC,MAAtB,EAA8BuD,CAAC,GAAGe,CAAlC,EAAqC,EAAEf,CAAvC,EAA0C;IACxCjE,IAAI,GAAGS,KAAK,CAACwD,CAAD,CAAZ;;IAEA,QAAQjE,IAAI,CAACoB,IAAb;MACE,KAAKnD,QAAL;QACEqG,CAAC,GAAGuC,OAAO,CAAC7G,IAAD,CAAP,GAAgBkQ,OAAhB,GAA0BC,OAA9B;QACA7L,CAAC,CAACtD,KAAF,CAAQoG,UAAU,CAACtH,IAAD,EAAOE,IAAP,EAAakF,KAAb,EAAoBC,MAApB,CAAlB;QACA;;MAEF,KAAKjH,SAAL;QACE2J,KAAK,GAAG7H,IAAR;QACA;;MAEF,KAAK3B,UAAL;QACEmP,OAAO,CAACnE,IAAR,CAAa2E,YAAY,CAAClO,IAAD,EAAOE,IAAP,CAAzB;QACA;;MAEF,KAAK7B,SAAL;MACA,KAAKC,SAAL;MACA,KAAKE,SAAL;MACA,KAAKC,SAAL;MACA,KAAKC,QAAL;MACA,KAAKC,SAAL;MACA,KAAKC,SAAL;MACA,KAAKC,QAAL;QACEuR,OAAO,CAAClP,KAAR,CAAchB,IAAI,CAACM,MAAnB;QACA6P,OAAO,CAACnP,KAAR,CAAchB,IAAI,CAACM,MAAnB;QACA;;MAEF;QACEgP,UAAU,CAACtO,KAAX,CAAiBhB,IAAI,CAACM,MAAtB;IA3BJ;EA6BD,CA/CkC,CA+CjC;;;EAGF,IAAIkN,OAAO,CAAC9M,MAAZ,EAAoB;IAClB;IACA,MAAM0P,CAAC,GAAG,EAAV;IACA5C,OAAO,CAAC3M,OAAR,CAAgBC,IAAI,IAAI;MACtBwE,MAAM,GAAGxE,IAAI,CAACwE,MAAL,IAAejI,KAAxB;MACA,IAAIiI,MAAM,KAAKpG,IAAf,EAAqB,CAACkR,CAAC,CAAC9K,MAAD,CAAD,KAAc8K,CAAC,CAAC9K,MAAD,CAAD,GAAY,EAA1B,CAAD,EAAgC+D,IAAhC,CAAqCvI,IAArC;IACtB,CAHD,EAHkB,CAMd;;IAEJ,KAAK,MAAMwE,MAAX,IAAqB8K,CAArB,EAAwB;MACtB,MAAMhN,CAAC,GAAGgN,CAAC,CAAC9K,MAAD,CAAX;MACAwE,UAAU,CAAChK,IAAD,EAAOsD,CAAP,EAAUqK,YAAY,CAACrK,CAAD,EAAIkC,MAAJ,EAAY1F,CAAC,CAAC4N,OAAd,EAAuB0C,OAAvB,EAAgCC,OAAhC,EAAyCjL,KAAzC,EAAgDC,MAAhD,CAAtB,CAAV;IACD,CAXiB,CAWhB;;;IAGFqI,OAAO,CAAC3M,OAAR,CAAgBC,IAAI,IAAI;MACtB,MAAMwD,CAAC,GAAGxD,IAAI,CAACR,MAAf;;MAEA,IAAI,CAACgE,CAAC,CAAC+L,MAAF,CAASvP,IAAI,CAACoN,OAAd,CAAL,EAA6B;QAC3BpN,IAAI,CAACR,MAAL,GAAcQ,IAAI,CAACoN,OAAnB;QACApO,IAAI,CAACa,KAAL,CAAWG,IAAX,EAF2B,CAET;;QAElBA,IAAI,CAACR,MAAL,GAAcgE,CAAd;QACAxE,IAAI,CAACa,KAAL,CAAWG,IAAX;MACD;;MAED,IAAIlB,CAAC,CAAC0Q,QAAF,IAAc1Q,CAAC,CAAC0Q,QAAF,CAAWrQ,IAAX,KAAoBnB,GAAtC,EAA2C;QACzC;QACA;QACA;QACA,QAAQgC,IAAI,CAACwE,MAAb;UACE,KAAKlI,IAAL;UACA,KAAKC,KAAL;YACEiS,UAAU,CAAC/M,GAAX,CAAe+B,CAAC,CAACI,EAAjB,EAAqB,CAArB,EAAwBnC,GAAxB,CAA4B+B,CAAC,CAACK,EAA9B,EAAkC,CAAlC;YACA;;UAEF,KAAKxH,GAAL;UACA,KAAKG,MAAL;YACEgS,UAAU,CAAC/M,GAAX,CAAe,CAAf,EAAkB+B,CAAC,CAACM,EAApB,EAAwBrC,GAAxB,CAA4B,CAA5B,EAA+B+B,CAAC,CAACO,EAAjC;QARJ;MAUD,CAdD,MAcO;QACLyK,UAAU,CAACtO,KAAX,CAAiBsD,CAAjB;MACD;IACF,CA5BD;EA6BD,CA7FkC,CA6FjC;;;EAGFgL,UAAU,CAACtO,KAAX,CAAiBkP,OAAjB,EAA0BlP,KAA1B,CAAgCmP,OAAhC,EAhGmC,CAgGO;;EAE1C,IAAItI,KAAJ,EAAW;IACTyH,UAAU,CAACtO,KAAX,CAAiBqO,WAAW,CAACvP,IAAD,EAAO+H,KAAP,EAAc3C,KAAd,EAAqBC,MAArB,EAA6BmK,UAA7B,CAA5B;EACD,CApGkC,CAoGjC;;;EAGF,IAAIzM,KAAK,CAACG,IAAV,EAAgB;IACdsM,UAAU,CAACjN,GAAX,CAAe,CAAf,EAAkB,CAAlB,EAAqBQ,KAAK,CAACqC,KAAN,IAAe,CAApC,EAAuCrC,KAAK,CAACsC,MAAN,IAAgB,CAAvD;EACD,CAzGkC,CAyGjC;;;EAGFoL,cAAc,CAACzQ,IAAD,EAAO+C,KAAP,EAAcyM,UAAd,EAA0B1P,CAA1B,CAAd;AACD;;AAED,SAAS2Q,cAAT,CAAwBzQ,IAAxB,EAA8B+C,KAA9B,EAAqCyM,UAArC,EAAiD1P,CAAjD,EAAoD;EAClD,MAAM0I,IAAI,GAAG1I,CAAC,CAAC0Q,QAAF,IAAc,EAA3B;EAAA,MACMrQ,IAAI,GAAGqI,IAAI,CAACrI,IADlB;EAEA,IAAIH,IAAI,CAAC0Q,SAAL,GAAiB,CAAjB,IAAsB,CAACvQ,IAA3B,EAAiC;EACjC,IAAIwQ,SAAS,GAAG3Q,IAAI,CAAC4Q,MAArB;EAAA,IACIC,UAAU,GAAG7Q,IAAI,CAAC8Q,OADtB;EAAA,IAEI1L,KAAK,GAAGV,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY5B,KAAK,CAACqC,KAAN,IAAe,CAA3B,CAFZ;EAAA,IAGI2L,IAAI,GAAGrM,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACmE,IAAL,CAAU,CAAC2G,UAAU,CAAC5K,EAAtB,CAAZ,CAHX;EAAA,IAIIS,MAAM,GAAGX,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY5B,KAAK,CAACsC,MAAN,IAAgB,CAA5B,CAJb;EAAA,IAKI2L,GAAG,GAAGtM,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACmE,IAAL,CAAU,CAAC2G,UAAU,CAAC1K,EAAtB,CAAZ,CALV;EAMA,MAAMmM,KAAK,GAAGvM,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACmE,IAAL,CAAU2G,UAAU,CAAC3K,EAAX,GAAgBO,KAA1B,CAAZ,CAAd;EAAA,MACM8L,MAAM,GAAGxM,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACmE,IAAL,CAAU2G,UAAU,CAACzK,EAAX,GAAgBM,MAA1B,CAAZ,CADf;;EAGA,IAAImD,IAAI,CAAC2I,QAAL,KAAkBrS,OAAtB,EAA+B;IAC7B,MAAMyL,OAAO,GAAGvK,IAAI,CAACuK,OAAL,EAAhB;IACAoG,SAAS,IAAIpG,OAAO,CAACwG,IAAR,GAAexG,OAAO,CAAC0G,KAApC;IACAJ,UAAU,IAAItG,OAAO,CAACyG,GAAR,GAAczG,OAAO,CAAC2G,MAApC;EACD;;EAED,IAAI/Q,IAAI,KAAKf,IAAb,EAAmB;IACjB2R,IAAI,GAAG,CAAP;IACAC,GAAG,GAAG,CAAN;IACA5L,KAAK,GAAGuL,SAAR;IACAtL,MAAM,GAAGwL,UAAT;EACD,CALD,MAKO,IAAI1Q,IAAI,KAAKnB,GAAb,EAAkB;IACvBoG,KAAK,GAAGV,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYgM,SAAS,GAAGI,IAAZ,GAAmBE,KAA/B,CAAR;IACA5L,MAAM,GAAGX,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYkM,UAAU,GAAGG,GAAb,GAAmBE,MAA/B,CAAT;EACD,CAHM,MAGA,IAAI/Q,IAAI,KAAKlB,IAAb,EAAmB;IACxBmG,KAAK,GAAGV,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYgM,SAAS,GAAGI,IAAZ,GAAmBE,KAA/B,CAAR;IACAJ,UAAU,GAAGxL,MAAM,GAAG2L,GAAT,GAAeE,MAA5B;EACD,CAHM,MAGA,IAAI/Q,IAAI,KAAKjB,IAAb,EAAmB;IACxByR,SAAS,GAAGvL,KAAK,GAAG2L,IAAR,GAAeE,KAA3B;IACA5L,MAAM,GAAGX,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYkM,UAAU,GAAGG,GAAb,GAAmBE,MAA/B,CAAT;EACD,CAHM,MAGA,IAAI/Q,IAAI,KAAKhB,GAAb,EAAkB;IACvBwR,SAAS,GAAGvL,KAAK,GAAG2L,IAAR,GAAeE,KAA3B;IACAJ,UAAU,GAAGxL,MAAM,GAAG2L,GAAT,GAAeE,MAA5B;EACD;;EAEDlR,IAAI,CAACoR,WAAL,CAAiBT,SAAjB,EAA4BE,UAA5B,EAAwCzL,KAAxC,EAA+CC,MAA/C,EAAuD,CAAC0L,IAAD,EAAOC,GAAP,CAAvD,EAAoExI,IAAI,CAAC6I,MAAzE;AACD;;AAED,SAAS3R,KAAK,IAAIY,KAAlB,EAAyByB,UAAU,IAAIuP,UAAvC,EAAmD5O,IAAI,IAAIxC,IAA3D,EAAiE6D,OAAO,IAAIwN,OAA5E,EAAqF7K,MAAM,IAAI8K,MAA/F,EAAuGxB,UAAU,IAAIyB,UAArH"},"metadata":{},"sourceType":"module"}