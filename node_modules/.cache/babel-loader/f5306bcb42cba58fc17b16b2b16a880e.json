{"ast":null,"code":"import { Transform, ingest, tupleid, stableCompare } from 'vega-dataflow';\nimport { tickCount, tickFormat, validTicks, tickValues, SymbolLegend, labelFormat, labelValues, GradientLegend, scaleFraction, labelFraction, scale, isContinuous, Sequential, Linear, Time, UTC, Pow, Sqrt, Ordinal, scaleImplicit, Log, Symlog, isLogarithmic, BinOrdinal, bandSpace, isInterpolating, interpolateRange, quantizeInterpolator, interpolateColors, interpolate, Band, Point, scheme, Threshold, Quantile, Quantize, Diverging } from 'vega-scale';\nimport { inherits, isArray, error, fastmap, falsy, isFunction, constant, peek, one, toSet, isString, zoomLog, zoomPow, zoomSymlog, zoomLinear, stringValue } from 'vega-util';\nimport { sum, range } from 'd3-array';\nimport { interpolateRound, interpolate as interpolate$1 } from 'd3-interpolate';\n/**\n * Generates axis ticks for visualizing a spatial scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate ticks for.\n * @param {*} [params.count=10] - The approximate number of ticks, or\n *   desired tick interval, to use.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {function(*):string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid d3 4.0 format specifier.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\n\nfunction AxisTicks(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(AxisTicks, Transform, {\n  transform(_, pulse) {\n    if (this.value && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var locale = pulse.dataflow.locale(),\n        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        ticks = this.value,\n        scale = _.scale,\n        tally = _.count == null ? _.values ? _.values.length : 10 : _.count,\n        count = tickCount(scale, tally, _.minstep),\n        format = _.format || tickFormat(locale, scale, count, _.formatSpecifier, _.formatType, !!_.values),\n        values = _.values ? validTicks(scale, _.values, count) : tickValues(scale, count);\n    if (ticks) out.rem = ticks;\n    ticks = values.map((value, i) => ingest({\n      index: i / (values.length - 1 || 1),\n      value: value,\n      label: format(value)\n    }));\n\n    if (_.extra && ticks.length) {\n      // add an extra tick pegged to the initial domain value\n      // this is used to generate axes with 'binned' domains\n      ticks.push(ingest({\n        index: -1,\n        extra: {\n          value: ticks[0].value\n        },\n        label: ''\n      }));\n    }\n\n    out.source = ticks;\n    out.add = ticks;\n    this.value = ticks;\n    return out;\n  }\n\n});\n/**\n * Joins a set of data elements against a set of visual items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): object} [params.item] - An item generator function.\n * @param {function(object): *} [params.key] - The key field associating data and visual items.\n */\n\nfunction DataJoin(params) {\n  Transform.call(this, null, params);\n}\n\nfunction defaultItemCreate() {\n  return ingest({});\n}\n\nfunction newMap(key) {\n  const map = fastmap().test(t => t.exit);\n\n  map.lookup = t => map.get(key(t));\n\n  return map;\n}\n\ninherits(DataJoin, Transform, {\n  transform(_, pulse) {\n    var df = pulse.dataflow,\n        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        item = _.item || defaultItemCreate,\n        key = _.key || tupleid,\n        map = this.value; // prevent transient (e.g., hover) requests from\n    // cascading across marks derived from marks\n\n    if (isArray(out.encode)) {\n      out.encode = null;\n    }\n\n    if (map && (_.modified('key') || pulse.modified(key))) {\n      error('DataJoin does not support modified key function or fields.');\n    }\n\n    if (!map) {\n      pulse = pulse.addAll();\n      this.value = map = newMap(key);\n    }\n\n    pulse.visit(pulse.ADD, t => {\n      const k = key(t);\n      let x = map.get(k);\n\n      if (x) {\n        if (x.exit) {\n          map.empty--;\n          out.add.push(x);\n        } else {\n          out.mod.push(x);\n        }\n      } else {\n        x = item(t);\n        map.set(k, x);\n        out.add.push(x);\n      }\n\n      x.datum = t;\n      x.exit = false;\n    });\n    pulse.visit(pulse.MOD, t => {\n      const k = key(t),\n            x = map.get(k);\n\n      if (x) {\n        x.datum = t;\n        out.mod.push(x);\n      }\n    });\n    pulse.visit(pulse.REM, t => {\n      const k = key(t),\n            x = map.get(k);\n\n      if (t === x.datum && !x.exit) {\n        out.rem.push(x);\n        x.exit = true;\n        ++map.empty;\n      }\n    });\n    if (pulse.changed(pulse.ADD_MOD)) out.modifies('datum');\n\n    if (pulse.clean() || _.clean && map.empty > df.cleanThreshold) {\n      df.runAfter(map.clean);\n    }\n\n    return out;\n  }\n\n});\n/**\n * Invokes encoding functions for visual items.\n * @constructor\n * @param {object} params - The parameters to the encoding functions. This\n *   parameter object will be passed through to all invoked encoding functions.\n * @param {object} [params.mod=false] - Flag indicating if tuples in the input\n *   mod set that are unmodified by encoders should be included in the output.\n * @param {object} param.encoders - The encoding functions\n * @param {function(object, object): boolean} [param.encoders.update] - Update encoding set\n * @param {function(object, object): boolean} [param.encoders.enter] - Enter encoding set\n * @param {function(object, object): boolean} [param.encoders.exit] - Exit encoding set\n */\n\nfunction Encode(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Encode, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ADD_REM),\n        fmod = _.mod || false,\n        encoders = _.encoders,\n        encode = pulse.encode; // if an array, the encode directive includes additional sets\n    // that must be defined in order for the primary set to be invoked\n    // e.g., only run the update set if the hover set is defined\n\n    if (isArray(encode)) {\n      if (out.changed() || encode.every(e => encoders[e])) {\n        encode = encode[0];\n        out.encode = null; // consume targeted encode directive\n      } else {\n        return pulse.StopPropagation;\n      }\n    } // marshall encoder functions\n\n\n    var reenter = encode === 'enter',\n        update = encoders.update || falsy,\n        enter = encoders.enter || falsy,\n        exit = encoders.exit || falsy,\n        set = (encode && !reenter ? encoders[encode] : update) || falsy;\n\n    if (pulse.changed(pulse.ADD)) {\n      pulse.visit(pulse.ADD, t => {\n        enter(t, _);\n        update(t, _);\n      });\n      out.modifies(enter.output);\n      out.modifies(update.output);\n\n      if (set !== falsy && set !== update) {\n        pulse.visit(pulse.ADD, t => {\n          set(t, _);\n        });\n        out.modifies(set.output);\n      }\n    }\n\n    if (pulse.changed(pulse.REM) && exit !== falsy) {\n      pulse.visit(pulse.REM, t => {\n        exit(t, _);\n      });\n      out.modifies(exit.output);\n    }\n\n    if (reenter || set !== falsy) {\n      const flag = pulse.MOD | (_.modified() ? pulse.REFLOW : 0);\n\n      if (reenter) {\n        pulse.visit(flag, t => {\n          const mod = enter(t, _) || fmod;\n          if (set(t, _) || mod) out.mod.push(t);\n        });\n        if (out.mod.length) out.modifies(enter.output);\n      } else {\n        pulse.visit(flag, t => {\n          if (set(t, _) || fmod) out.mod.push(t);\n        });\n      }\n\n      if (out.mod.length) out.modifies(set.output);\n    }\n\n    return out.changed() ? out : pulse.StopPropagation;\n  }\n\n});\n/**\n * Generates legend entries for visualizing a scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate items for.\n * @param {*} [params.count=5] - The approximate number of items, or\n *   desired tick interval, to use.\n * @param {*} [params.limit] - The maximum number of entries to\n *   include in a symbol legend.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid D3 format specifier string.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\n\nfunction LegendEntries(params) {\n  Transform.call(this, [], params);\n}\n\ninherits(LegendEntries, Transform, {\n  transform(_, pulse) {\n    if (this.value != null && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var locale = pulse.dataflow.locale(),\n        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        items = this.value,\n        type = _.type || SymbolLegend,\n        scale = _.scale,\n        limit = +_.limit,\n        count = tickCount(scale, _.count == null ? 5 : _.count, _.minstep),\n        lskip = !!_.values || type === SymbolLegend,\n        format = _.format || labelFormat(locale, scale, count, type, _.formatSpecifier, _.formatType, lskip),\n        values = _.values || labelValues(scale, count),\n        domain,\n        fraction,\n        size,\n        offset,\n        ellipsis;\n    if (items) out.rem = items;\n\n    if (type === SymbolLegend) {\n      if (limit && values.length > limit) {\n        pulse.dataflow.warn('Symbol legend count exceeds limit, filtering items.');\n        items = values.slice(0, limit - 1);\n        ellipsis = true;\n      } else {\n        items = values;\n      }\n\n      if (isFunction(size = _.size)) {\n        // if first value maps to size zero, remove from list (vega#717)\n        if (!_.values && scale(items[0]) === 0) {\n          items = items.slice(1);\n        } // compute size offset for legend entries\n\n\n        offset = items.reduce((max, value) => Math.max(max, size(value, _)), 0);\n      } else {\n        size = constant(offset = size || 8);\n      }\n\n      items = items.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, items),\n        value: value,\n        offset: offset,\n        size: size(value, _)\n      }));\n\n      if (ellipsis) {\n        ellipsis = values[items.length];\n        items.push(ingest({\n          index: items.length,\n          label: \"\\u2026\".concat(values.length - items.length, \" entries\"),\n          value: ellipsis,\n          offset: offset,\n          size: size(ellipsis, _)\n        }));\n      }\n    } else if (type === GradientLegend) {\n      domain = scale.domain(), fraction = scaleFraction(scale, domain[0], peek(domain)); // if automatic label generation produces 2 or fewer values,\n      // use the domain end points instead (fixes vega/vega#1364)\n\n      if (values.length < 3 && !_.values && domain[0] !== peek(domain)) {\n        values = [domain[0], peek(domain)];\n      }\n\n      items = values.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc: fraction(value)\n      }));\n    } else {\n      size = values.length - 1;\n      fraction = labelFraction(scale);\n      items = values.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc: index ? fraction(value) : 0,\n        perc2: index === size ? 1 : fraction(values[index + 1])\n      }));\n    }\n\n    out.source = items;\n    out.add = items;\n    this.value = items;\n    return out;\n  }\n\n});\n\nconst sourceX = t => t.source.x;\n\nconst sourceY = t => t.source.y;\n\nconst targetX = t => t.target.x;\n\nconst targetY = t => t.target.y;\n/**\n * Layout paths linking source and target elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\n\nfunction LinkPath(params) {\n  Transform.call(this, {}, params);\n}\n\nLinkPath.Definition = {\n  'type': 'LinkPath',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'sourceX',\n    'type': 'field',\n    'default': 'source.x'\n  }, {\n    'name': 'sourceY',\n    'type': 'field',\n    'default': 'source.y'\n  }, {\n    'name': 'targetX',\n    'type': 'field',\n    'default': 'target.x'\n  }, {\n    'name': 'targetY',\n    'type': 'field',\n    'default': 'target.y'\n  }, {\n    'name': 'orient',\n    'type': 'enum',\n    'default': 'vertical',\n    'values': ['horizontal', 'vertical', 'radial']\n  }, {\n    'name': 'shape',\n    'type': 'enum',\n    'default': 'line',\n    'values': ['line', 'arc', 'curve', 'diagonal', 'orthogonal']\n  }, {\n    'name': 'require',\n    'type': 'signal'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'path'\n  }]\n};\ninherits(LinkPath, Transform, {\n  transform(_, pulse) {\n    var sx = _.sourceX || sourceX,\n        sy = _.sourceY || sourceY,\n        tx = _.targetX || targetX,\n        ty = _.targetY || targetY,\n        as = _.as || 'path',\n        orient = _.orient || 'vertical',\n        shape = _.shape || 'line',\n        path = Paths.get(shape + '-' + orient) || Paths.get(shape);\n\n    if (!path) {\n      error('LinkPath unsupported type: ' + _.shape + (_.orient ? '-' + _.orient : ''));\n    }\n\n    pulse.visit(pulse.SOURCE, t => {\n      t[as] = path(sx(t), sy(t), tx(t), ty(t));\n    });\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n\n});\n\nconst line = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'L' + tx + ',' + ty;\n\nconst lineR = (sa, sr, ta, tr) => line(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n\nconst arc = (sx, sy, tx, ty) => {\n  var dx = tx - sx,\n      dy = ty - sy,\n      rr = Math.sqrt(dx * dx + dy * dy) / 2,\n      ra = 180 * Math.atan2(dy, dx) / Math.PI;\n  return 'M' + sx + ',' + sy + 'A' + rr + ',' + rr + ' ' + ra + ' 0 1' + ' ' + tx + ',' + ty;\n};\n\nconst arcR = (sa, sr, ta, tr) => arc(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n\nconst curve = (sx, sy, tx, ty) => {\n  const dx = tx - sx,\n        dy = ty - sy,\n        ix = 0.2 * (dx + dy),\n        iy = 0.2 * (dy - dx);\n  return 'M' + sx + ',' + sy + 'C' + (sx + ix) + ',' + (sy + iy) + ' ' + (tx + iy) + ',' + (ty - ix) + ' ' + tx + ',' + ty;\n};\n\nconst curveR = (sa, sr, ta, tr) => curve(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n\nconst orthoX = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'V' + ty + 'H' + tx;\n\nconst orthoY = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'H' + tx + 'V' + ty;\n\nconst orthoR = (sa, sr, ta, tr) => {\n  const sc = Math.cos(sa),\n        ss = Math.sin(sa),\n        tc = Math.cos(ta),\n        ts = Math.sin(ta),\n        sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n  return 'M' + sr * sc + ',' + sr * ss + 'A' + sr + ',' + sr + ' 0 0,' + (sf ? 1 : 0) + ' ' + sr * tc + ',' + sr * ts + 'L' + tr * tc + ',' + tr * ts;\n};\n\nconst diagonalX = (sx, sy, tx, ty) => {\n  const m = (sx + tx) / 2;\n  return 'M' + sx + ',' + sy + 'C' + m + ',' + sy + ' ' + m + ',' + ty + ' ' + tx + ',' + ty;\n};\n\nconst diagonalY = (sx, sy, tx, ty) => {\n  const m = (sy + ty) / 2;\n  return 'M' + sx + ',' + sy + 'C' + sx + ',' + m + ' ' + tx + ',' + m + ' ' + tx + ',' + ty;\n};\n\nconst diagonalR = (sa, sr, ta, tr) => {\n  const sc = Math.cos(sa),\n        ss = Math.sin(sa),\n        tc = Math.cos(ta),\n        ts = Math.sin(ta),\n        mr = (sr + tr) / 2;\n  return 'M' + sr * sc + ',' + sr * ss + 'C' + mr * sc + ',' + mr * ss + ' ' + mr * tc + ',' + mr * ts + ' ' + tr * tc + ',' + tr * ts;\n};\n\nconst Paths = fastmap({\n  'line': line,\n  'line-radial': lineR,\n  'arc': arc,\n  'arc-radial': arcR,\n  'curve': curve,\n  'curve-radial': curveR,\n  'orthogonal-horizontal': orthoX,\n  'orthogonal-vertical': orthoY,\n  'orthogonal-radial': orthoR,\n  'diagonal-horizontal': diagonalX,\n  'diagonal-vertical': diagonalY,\n  'diagonal-radial': diagonalR\n});\n/**\n * Pie and donut chart layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size pie segments.\n * @param {number} [params.startAngle=0] - The start angle (in radians) of the layout.\n * @param {number} [params.endAngle=2π] - The end angle (in radians) of the layout.\n * @param {boolean} [params.sort] - Boolean flag for sorting sectors by value.\n */\n\nfunction Pie(params) {\n  Transform.call(this, null, params);\n}\n\nPie.Definition = {\n  'type': 'Pie',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'startAngle',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'endAngle',\n    'type': 'number',\n    'default': 6.283185307179586\n  }, {\n    'name': 'sort',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['startAngle', 'endAngle']\n  }]\n};\ninherits(Pie, Transform, {\n  transform(_, pulse) {\n    var as = _.as || ['startAngle', 'endAngle'],\n        startAngle = as[0],\n        endAngle = as[1],\n        field = _.field || one,\n        start = _.startAngle || 0,\n        stop = _.endAngle != null ? _.endAngle : 2 * Math.PI,\n        data = pulse.source,\n        values = data.map(field),\n        n = values.length,\n        a = start,\n        k = (stop - start) / sum(values),\n        index = range(n),\n        i,\n        t,\n        v;\n\n    if (_.sort) {\n      index.sort((a, b) => values[a] - values[b]);\n    }\n\n    for (i = 0; i < n; ++i) {\n      v = values[index[i]];\n      t = data[index[i]];\n      t[startAngle] = a;\n      t[endAngle] = a += v * k;\n    }\n\n    this.value = values;\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n\n});\nconst DEFAULT_COUNT = 5;\n\nfunction includeZero(scale) {\n  const type = scale.type;\n  return !scale.bins && (type === Linear || type === Pow || type === Sqrt);\n}\n\nfunction includePad(type) {\n  return isContinuous(type) && type !== Sequential;\n}\n\nconst SKIP = toSet(['set', 'modified', 'clear', 'type', 'scheme', 'schemeExtent', 'schemeCount', 'domain', 'domainMin', 'domainMid', 'domainMax', 'domainRaw', 'domainImplicit', 'nice', 'zero', 'bins', 'range', 'rangeStep', 'round', 'reverse', 'interpolate', 'interpolateGamma']);\n/**\n * Maintains a scale function mapping data values to visual channels.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction Scale(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\n\ninherits(Scale, Transform, {\n  transform(_, pulse) {\n    var df = pulse.dataflow,\n        scale$1 = this.value,\n        key = scaleKey(_);\n\n    if (!scale$1 || key !== scale$1.type) {\n      this.value = scale$1 = scale(key)();\n    }\n\n    for (key in _) if (!SKIP[key]) {\n      // padding is a scale property for band/point but not others\n      if (key === 'padding' && includePad(scale$1.type)) continue; // invoke scale property setter, raise warning if not found\n\n      isFunction(scale$1[key]) ? scale$1[key](_[key]) : df.warn('Unsupported scale property: ' + key);\n    }\n\n    configureRange(scale$1, _, configureBins(scale$1, _, configureDomain(scale$1, _, df)));\n    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n  }\n\n});\n\nfunction scaleKey(_) {\n  var t = _.type,\n      d = '',\n      n; // backwards compatibility pre Vega 5.\n\n  if (t === Sequential) return Sequential + '-' + Linear;\n\n  if (isContinuousColor(_)) {\n    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;\n    d = n === 2 ? Sequential + '-' : n === 3 ? Diverging + '-' : '';\n  }\n\n  return (d + t || Linear).toLowerCase();\n}\n\nfunction isContinuousColor(_) {\n  const t = _.type;\n  return isContinuous(t) && t !== Time && t !== UTC && (_.scheme || _.range && _.range.length && _.range.every(isString));\n}\n\nfunction configureDomain(scale, _, df) {\n  // check raw domain, if provided use that and exit early\n  const raw = rawDomain(scale, _.domainRaw, df);\n  if (raw > -1) return raw;\n  var domain = _.domain,\n      type = scale.type,\n      zero = _.zero || _.zero === undefined && includeZero(scale),\n      n,\n      mid;\n  if (!domain) return 0; // adjust continuous domain for minimum pixel padding\n\n  if (includePad(type) && _.padding && domain[0] !== peek(domain)) {\n    domain = padDomain(type, domain, _.range, _.padding, _.exponent, _.constant);\n  } // adjust domain based on zero, min, max settings\n\n\n  if (zero || _.domainMin != null || _.domainMax != null || _.domainMid != null) {\n    n = (domain = domain.slice()).length - 1 || 1;\n\n    if (zero) {\n      if (domain[0] > 0) domain[0] = 0;\n      if (domain[n] < 0) domain[n] = 0;\n    }\n\n    if (_.domainMin != null) domain[0] = _.domainMin;\n    if (_.domainMax != null) domain[n] = _.domainMax;\n\n    if (_.domainMid != null) {\n      mid = _.domainMid;\n      const i = mid > domain[n] ? n + 1 : mid < domain[0] ? 0 : n;\n      if (i !== n) df.warn('Scale domainMid exceeds domain min or max.', mid);\n      domain.splice(i, 0, mid);\n    }\n  } // set the scale domain\n\n\n  scale.domain(domainCheck(type, domain, df)); // if ordinal scale domain is defined, prevent implicit\n  // domain construction as side-effect of scale lookup\n\n  if (type === Ordinal) {\n    scale.unknown(_.domainImplicit ? scaleImplicit : undefined);\n  } // perform 'nice' adjustment as requested\n\n\n  if (_.nice && scale.nice) {\n    scale.nice(_.nice !== true && tickCount(scale, _.nice) || null);\n  } // return the cardinality of the domain\n\n\n  return domain.length;\n}\n\nfunction rawDomain(scale, raw, df) {\n  if (raw) {\n    scale.domain(domainCheck(scale.type, raw, df));\n    return raw.length;\n  } else {\n    return -1;\n  }\n}\n\nfunction padDomain(type, domain, range, pad, exponent, constant) {\n  var span = Math.abs(peek(range) - range[0]),\n      frac = span / (span - 2 * pad),\n      d = type === Log ? zoomLog(domain, null, frac) : type === Sqrt ? zoomPow(domain, null, frac, 0.5) : type === Pow ? zoomPow(domain, null, frac, exponent || 1) : type === Symlog ? zoomSymlog(domain, null, frac, constant || 1) : zoomLinear(domain, null, frac);\n  domain = domain.slice();\n  domain[0] = d[0];\n  domain[domain.length - 1] = d[1];\n  return domain;\n}\n\nfunction domainCheck(type, domain, df) {\n  if (isLogarithmic(type)) {\n    // sum signs of domain values\n    // if all pos or all neg, abs(sum) === domain.length\n    var s = Math.abs(domain.reduce((s, v) => s + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));\n\n    if (s !== domain.length) {\n      df.warn('Log scale domain includes zero: ' + stringValue(domain));\n    }\n  }\n\n  return domain;\n}\n\nfunction configureBins(scale, _, count) {\n  let bins = _.bins;\n\n  if (bins && !isArray(bins)) {\n    // generate bin boundary array\n    const domain = scale.domain(),\n          lo = domain[0],\n          hi = peek(domain),\n          step = bins.step;\n    let start = bins.start == null ? lo : bins.start,\n        stop = bins.stop == null ? hi : bins.stop;\n    if (!step) error('Scale bins parameter missing step property.');\n    if (start < lo) start = step * Math.ceil(lo / step);\n    if (stop > hi) stop = step * Math.floor(hi / step);\n    bins = range(start, stop + step / 2, step);\n  }\n\n  if (bins) {\n    // assign bin boundaries to scale instance\n    scale.bins = bins;\n  } else if (scale.bins) {\n    // no current bins, remove bins if previously set\n    delete scale.bins;\n  } // special handling for bin-ordinal scales\n\n\n  if (scale.type === BinOrdinal) {\n    if (!bins) {\n      // the domain specifies the bins\n      scale.bins = scale.domain();\n    } else if (!_.domain && !_.domainRaw) {\n      // the bins specify the domain\n      scale.domain(bins);\n      count = bins.length;\n    }\n  } // return domain cardinality\n\n\n  return count;\n}\n\nfunction configureRange(scale, _, count) {\n  var type = scale.type,\n      round = _.round || false,\n      range = _.range; // if range step specified, calculate full range extent\n\n  if (_.rangeStep != null) {\n    range = configureRangeStep(type, _, count);\n  } // else if a range scheme is defined, use that\n  else if (_.scheme) {\n    range = configureScheme(type, _, count);\n\n    if (isFunction(range)) {\n      if (scale.interpolator) {\n        return scale.interpolator(range);\n      } else {\n        error(\"Scale type \".concat(type, \" does not support interpolating color schemes.\"));\n      }\n    }\n  } // given a range array for an interpolating scale, convert to interpolator\n\n\n  if (range && isInterpolating(type)) {\n    return scale.interpolator(interpolateColors(flip(range, _.reverse), _.interpolate, _.interpolateGamma));\n  } // configure rounding / interpolation\n\n\n  if (range && _.interpolate && scale.interpolate) {\n    scale.interpolate(interpolate(_.interpolate, _.interpolateGamma));\n  } else if (isFunction(scale.round)) {\n    scale.round(round);\n  } else if (isFunction(scale.rangeRound)) {\n    scale.interpolate(round ? interpolateRound : interpolate$1);\n  }\n\n  if (range) scale.range(flip(range, _.reverse));\n}\n\nfunction configureRangeStep(type, _, count) {\n  if (type !== Band && type !== Point) {\n    error('Only band and point scales support rangeStep.');\n  } // calculate full range based on requested step size and padding\n\n\n  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0,\n      inner = type === Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;\n  return [0, _.rangeStep * bandSpace(count, inner, outer)];\n}\n\nfunction configureScheme(type, _, count) {\n  var extent = _.schemeExtent,\n      name,\n      scheme$1;\n\n  if (isArray(_.scheme)) {\n    scheme$1 = interpolateColors(_.scheme, _.interpolate, _.interpolateGamma);\n  } else {\n    name = _.scheme.toLowerCase();\n    scheme$1 = scheme(name);\n    if (!scheme$1) error(\"Unrecognized scheme name: \".concat(_.scheme));\n  } // determine size for potential discrete range\n\n\n  count = type === Threshold ? count + 1 : type === BinOrdinal ? count - 1 : type === Quantile || type === Quantize ? +_.schemeCount || DEFAULT_COUNT : count; // adjust and/or quantize scheme as appropriate\n\n  return isInterpolating(type) ? adjustScheme(scheme$1, extent, _.reverse) : isFunction(scheme$1) ? quantizeInterpolator(adjustScheme(scheme$1, extent), count) : type === Ordinal ? scheme$1 : scheme$1.slice(0, count);\n}\n\nfunction adjustScheme(scheme, extent, reverse) {\n  return isFunction(scheme) && (extent || reverse) ? interpolateRange(scheme, flip(extent || [0, 1], reverse)) : scheme;\n}\n\nfunction flip(array, reverse) {\n  return reverse ? array.slice().reverse() : array;\n}\n/**\n * Sorts scenegraph items in the pulse source array.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting tuples.\n */\n\n\nfunction SortItems(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(SortItems, Transform, {\n  transform(_, pulse) {\n    const mod = _.modified('sort') || pulse.changed(pulse.ADD) || pulse.modified(_.sort.fields) || pulse.modified('datum');\n    if (mod) pulse.source.sort(stableCompare(_.sort));\n    this.modified(mod);\n    return pulse;\n  }\n\n});\nconst Zero = 'zero',\n      Center = 'center',\n      Normalize = 'normalize',\n      DefOutput = ['y0', 'y1'];\n/**\n * Stack layout for visualization elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to stack.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {function(object,object): number} [params.sort] - A comparator for stack sorting.\n * @param {string} [offset='zero'] - Stack baseline offset. One of 'zero', 'center', 'normalize'.\n */\n\nfunction Stack(params) {\n  Transform.call(this, null, params);\n}\n\nStack.Definition = {\n  'type': 'Stack',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'offset',\n    'type': 'enum',\n    'default': Zero,\n    'values': [Zero, Center, Normalize]\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': DefOutput\n  }]\n};\ninherits(Stack, Transform, {\n  transform(_, pulse) {\n    var as = _.as || DefOutput,\n        y0 = as[0],\n        y1 = as[1],\n        sort = stableCompare(_.sort),\n        field = _.field || one,\n        stack = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero,\n        groups,\n        i,\n        n,\n        max; // partition, sum, and sort the stack groups\n\n    groups = partition(pulse.source, _.groupby, sort, field); // compute stack layouts per group\n\n    for (i = 0, n = groups.length, max = groups.max; i < n; ++i) {\n      stack(groups[i], max, field, y0, y1);\n    }\n\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n\n});\n\nfunction stackCenter(group, max, field, y0, y1) {\n  var last = (max - group.sum) / 2,\n      m = group.length,\n      j = 0,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last += Math.abs(field(t));\n  }\n}\n\nfunction stackNormalize(group, max, field, y0, y1) {\n  var scale = 1 / group.sum,\n      last = 0,\n      m = group.length,\n      j = 0,\n      v = 0,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last = scale * (v += Math.abs(field(t)));\n  }\n}\n\nfunction stackZero(group, max, field, y0, y1) {\n  var lastPos = 0,\n      lastNeg = 0,\n      m = group.length,\n      j = 0,\n      v,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    v = +field(t);\n\n    if (v < 0) {\n      t[y0] = lastNeg;\n      t[y1] = lastNeg += v;\n    } else {\n      t[y0] = lastPos;\n      t[y1] = lastPos += v;\n    }\n  }\n}\n\nfunction partition(data, groupby, sort, field) {\n  var groups = [],\n      get = f => f(t),\n      map,\n      i,\n      n,\n      m,\n      t,\n      k,\n      g,\n      s,\n      max; // partition data points into stack groups\n\n\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n\n      if (!g) {\n        map[k] = g = [];\n        groups.push(g);\n      }\n\n      g.push(t);\n    }\n  } // compute sums of groups, sort groups as needed\n\n\n  for (k = 0, max = 0, m = groups.length; k < m; ++k) {\n    g = groups[k];\n\n    for (i = 0, s = 0, n = g.length; i < n; ++i) {\n      s += Math.abs(field(g[i]));\n    }\n\n    g.sum = s;\n    if (s > max) max = s;\n    if (sort) g.sort(sort);\n  }\n\n  groups.max = max;\n  return groups;\n}\n\nexport { AxisTicks as axisticks, DataJoin as datajoin, Encode as encode, LegendEntries as legendentries, LinkPath as linkpath, Pie as pie, Scale as scale, SortItems as sortitems, Stack as stack };","map":{"version":3,"names":["Transform","ingest","tupleid","stableCompare","tickCount","tickFormat","validTicks","tickValues","SymbolLegend","labelFormat","labelValues","GradientLegend","scaleFraction","labelFraction","scale","isContinuous","Sequential","Linear","Time","UTC","Pow","Sqrt","Ordinal","scaleImplicit","Log","Symlog","isLogarithmic","BinOrdinal","bandSpace","isInterpolating","interpolateRange","quantizeInterpolator","interpolateColors","interpolate","Band","Point","scheme","Threshold","Quantile","Quantize","Diverging","inherits","isArray","error","fastmap","falsy","isFunction","constant","peek","one","toSet","isString","zoomLog","zoomPow","zoomSymlog","zoomLinear","stringValue","sum","range","interpolateRound","interpolate$1","AxisTicks","params","call","transform","_","pulse","value","modified","StopPropagation","locale","dataflow","out","fork","NO_SOURCE","NO_FIELDS","ticks","tally","count","values","length","minstep","format","formatSpecifier","formatType","rem","map","i","index","label","extra","push","source","add","DataJoin","defaultItemCreate","newMap","key","test","t","exit","lookup","get","df","item","encode","addAll","visit","ADD","k","x","empty","mod","set","datum","MOD","REM","changed","ADD_MOD","modifies","clean","cleanThreshold","runAfter","Encode","ADD_REM","fmod","encoders","every","e","reenter","update","enter","output","flag","REFLOW","LegendEntries","items","type","limit","lskip","domain","fraction","size","offset","ellipsis","warn","slice","reduce","max","Math","concat","perc","perc2","sourceX","sourceY","y","targetX","target","targetY","LinkPath","Definition","sx","sy","tx","ty","as","orient","shape","path","Paths","SOURCE","reflow","line","lineR","sa","sr","ta","tr","cos","sin","arc","dx","dy","rr","sqrt","ra","atan2","PI","arcR","curve","ix","iy","curveR","orthoX","orthoY","orthoR","sc","ss","tc","ts","sf","abs","diagonalX","m","diagonalY","diagonalR","mr","Pie","startAngle","endAngle","field","start","stop","data","n","a","v","sort","b","DEFAULT_COUNT","includeZero","bins","includePad","SKIP","Scale","scale$1","scaleKey","configureRange","configureBins","configureDomain","d","isContinuousColor","rawDomain","domainMid","toLowerCase","raw","domainRaw","zero","undefined","mid","padding","padDomain","exponent","domainMin","domainMax","splice","domainCheck","unknown","domainImplicit","nice","pad","span","frac","s","lo","hi","step","ceil","floor","round","rangeStep","configureRangeStep","configureScheme","interpolator","flip","reverse","interpolateGamma","rangeRound","outer","paddingOuter","inner","paddingInner","extent","schemeExtent","name","scheme$1","schemeCount","adjustScheme","array","SortItems","fields","Zero","Center","Normalize","DefOutput","Stack","y0","y1","stack","stackCenter","stackNormalize","stackZero","groups","partition","groupby","group","last","j","lastPos","lastNeg","f","g","axisticks","datajoin","legendentries","linkpath","pie","sortitems"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-encode/build/vega-encode.module.js"],"sourcesContent":["import { Transform, ingest, tupleid, stableCompare } from 'vega-dataflow';\nimport { tickCount, tickFormat, validTicks, tickValues, SymbolLegend, labelFormat, labelValues, GradientLegend, scaleFraction, labelFraction, scale, isContinuous, Sequential, Linear, Time, UTC, Pow, Sqrt, Ordinal, scaleImplicit, Log, Symlog, isLogarithmic, BinOrdinal, bandSpace, isInterpolating, interpolateRange, quantizeInterpolator, interpolateColors, interpolate, Band, Point, scheme, Threshold, Quantile, Quantize, Diverging } from 'vega-scale';\nimport { inherits, isArray, error, fastmap, falsy, isFunction, constant, peek, one, toSet, isString, zoomLog, zoomPow, zoomSymlog, zoomLinear, stringValue } from 'vega-util';\nimport { sum, range } from 'd3-array';\nimport { interpolateRound, interpolate as interpolate$1 } from 'd3-interpolate';\n\n/**\n * Generates axis ticks for visualizing a spatial scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate ticks for.\n * @param {*} [params.count=10] - The approximate number of ticks, or\n *   desired tick interval, to use.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {function(*):string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid d3 4.0 format specifier.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\n\nfunction AxisTicks(params) {\n  Transform.call(this, null, params);\n}\ninherits(AxisTicks, Transform, {\n  transform(_, pulse) {\n    if (this.value && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var locale = pulse.dataflow.locale(),\n        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        ticks = this.value,\n        scale = _.scale,\n        tally = _.count == null ? _.values ? _.values.length : 10 : _.count,\n        count = tickCount(scale, tally, _.minstep),\n        format = _.format || tickFormat(locale, scale, count, _.formatSpecifier, _.formatType, !!_.values),\n        values = _.values ? validTicks(scale, _.values, count) : tickValues(scale, count);\n    if (ticks) out.rem = ticks;\n    ticks = values.map((value, i) => ingest({\n      index: i / (values.length - 1 || 1),\n      value: value,\n      label: format(value)\n    }));\n\n    if (_.extra && ticks.length) {\n      // add an extra tick pegged to the initial domain value\n      // this is used to generate axes with 'binned' domains\n      ticks.push(ingest({\n        index: -1,\n        extra: {\n          value: ticks[0].value\n        },\n        label: ''\n      }));\n    }\n\n    out.source = ticks;\n    out.add = ticks;\n    this.value = ticks;\n    return out;\n  }\n\n});\n\n/**\n * Joins a set of data elements against a set of visual items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): object} [params.item] - An item generator function.\n * @param {function(object): *} [params.key] - The key field associating data and visual items.\n */\n\nfunction DataJoin(params) {\n  Transform.call(this, null, params);\n}\n\nfunction defaultItemCreate() {\n  return ingest({});\n}\n\nfunction newMap(key) {\n  const map = fastmap().test(t => t.exit);\n\n  map.lookup = t => map.get(key(t));\n\n  return map;\n}\n\ninherits(DataJoin, Transform, {\n  transform(_, pulse) {\n    var df = pulse.dataflow,\n        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        item = _.item || defaultItemCreate,\n        key = _.key || tupleid,\n        map = this.value; // prevent transient (e.g., hover) requests from\n    // cascading across marks derived from marks\n\n    if (isArray(out.encode)) {\n      out.encode = null;\n    }\n\n    if (map && (_.modified('key') || pulse.modified(key))) {\n      error('DataJoin does not support modified key function or fields.');\n    }\n\n    if (!map) {\n      pulse = pulse.addAll();\n      this.value = map = newMap(key);\n    }\n\n    pulse.visit(pulse.ADD, t => {\n      const k = key(t);\n      let x = map.get(k);\n\n      if (x) {\n        if (x.exit) {\n          map.empty--;\n          out.add.push(x);\n        } else {\n          out.mod.push(x);\n        }\n      } else {\n        x = item(t);\n        map.set(k, x);\n        out.add.push(x);\n      }\n\n      x.datum = t;\n      x.exit = false;\n    });\n    pulse.visit(pulse.MOD, t => {\n      const k = key(t),\n            x = map.get(k);\n\n      if (x) {\n        x.datum = t;\n        out.mod.push(x);\n      }\n    });\n    pulse.visit(pulse.REM, t => {\n      const k = key(t),\n            x = map.get(k);\n\n      if (t === x.datum && !x.exit) {\n        out.rem.push(x);\n        x.exit = true;\n        ++map.empty;\n      }\n    });\n    if (pulse.changed(pulse.ADD_MOD)) out.modifies('datum');\n\n    if (pulse.clean() || _.clean && map.empty > df.cleanThreshold) {\n      df.runAfter(map.clean);\n    }\n\n    return out;\n  }\n\n});\n\n/**\n * Invokes encoding functions for visual items.\n * @constructor\n * @param {object} params - The parameters to the encoding functions. This\n *   parameter object will be passed through to all invoked encoding functions.\n * @param {object} [params.mod=false] - Flag indicating if tuples in the input\n *   mod set that are unmodified by encoders should be included in the output.\n * @param {object} param.encoders - The encoding functions\n * @param {function(object, object): boolean} [param.encoders.update] - Update encoding set\n * @param {function(object, object): boolean} [param.encoders.enter] - Enter encoding set\n * @param {function(object, object): boolean} [param.encoders.exit] - Exit encoding set\n */\n\nfunction Encode(params) {\n  Transform.call(this, null, params);\n}\ninherits(Encode, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ADD_REM),\n        fmod = _.mod || false,\n        encoders = _.encoders,\n        encode = pulse.encode; // if an array, the encode directive includes additional sets\n    // that must be defined in order for the primary set to be invoked\n    // e.g., only run the update set if the hover set is defined\n\n    if (isArray(encode)) {\n      if (out.changed() || encode.every(e => encoders[e])) {\n        encode = encode[0];\n        out.encode = null; // consume targeted encode directive\n      } else {\n        return pulse.StopPropagation;\n      }\n    } // marshall encoder functions\n\n\n    var reenter = encode === 'enter',\n        update = encoders.update || falsy,\n        enter = encoders.enter || falsy,\n        exit = encoders.exit || falsy,\n        set = (encode && !reenter ? encoders[encode] : update) || falsy;\n\n    if (pulse.changed(pulse.ADD)) {\n      pulse.visit(pulse.ADD, t => {\n        enter(t, _);\n        update(t, _);\n      });\n      out.modifies(enter.output);\n      out.modifies(update.output);\n\n      if (set !== falsy && set !== update) {\n        pulse.visit(pulse.ADD, t => {\n          set(t, _);\n        });\n        out.modifies(set.output);\n      }\n    }\n\n    if (pulse.changed(pulse.REM) && exit !== falsy) {\n      pulse.visit(pulse.REM, t => {\n        exit(t, _);\n      });\n      out.modifies(exit.output);\n    }\n\n    if (reenter || set !== falsy) {\n      const flag = pulse.MOD | (_.modified() ? pulse.REFLOW : 0);\n\n      if (reenter) {\n        pulse.visit(flag, t => {\n          const mod = enter(t, _) || fmod;\n          if (set(t, _) || mod) out.mod.push(t);\n        });\n        if (out.mod.length) out.modifies(enter.output);\n      } else {\n        pulse.visit(flag, t => {\n          if (set(t, _) || fmod) out.mod.push(t);\n        });\n      }\n\n      if (out.mod.length) out.modifies(set.output);\n    }\n\n    return out.changed() ? out : pulse.StopPropagation;\n  }\n\n});\n\n/**\n * Generates legend entries for visualizing a scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate items for.\n * @param {*} [params.count=5] - The approximate number of items, or\n *   desired tick interval, to use.\n * @param {*} [params.limit] - The maximum number of entries to\n *   include in a symbol legend.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid D3 format specifier string.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\n\nfunction LegendEntries(params) {\n  Transform.call(this, [], params);\n}\ninherits(LegendEntries, Transform, {\n  transform(_, pulse) {\n    if (this.value != null && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var locale = pulse.dataflow.locale(),\n        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        items = this.value,\n        type = _.type || SymbolLegend,\n        scale = _.scale,\n        limit = +_.limit,\n        count = tickCount(scale, _.count == null ? 5 : _.count, _.minstep),\n        lskip = !!_.values || type === SymbolLegend,\n        format = _.format || labelFormat(locale, scale, count, type, _.formatSpecifier, _.formatType, lskip),\n        values = _.values || labelValues(scale, count),\n        domain,\n        fraction,\n        size,\n        offset,\n        ellipsis;\n    if (items) out.rem = items;\n\n    if (type === SymbolLegend) {\n      if (limit && values.length > limit) {\n        pulse.dataflow.warn('Symbol legend count exceeds limit, filtering items.');\n        items = values.slice(0, limit - 1);\n        ellipsis = true;\n      } else {\n        items = values;\n      }\n\n      if (isFunction(size = _.size)) {\n        // if first value maps to size zero, remove from list (vega#717)\n        if (!_.values && scale(items[0]) === 0) {\n          items = items.slice(1);\n        } // compute size offset for legend entries\n\n\n        offset = items.reduce((max, value) => Math.max(max, size(value, _)), 0);\n      } else {\n        size = constant(offset = size || 8);\n      }\n\n      items = items.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, items),\n        value: value,\n        offset: offset,\n        size: size(value, _)\n      }));\n\n      if (ellipsis) {\n        ellipsis = values[items.length];\n        items.push(ingest({\n          index: items.length,\n          label: \"\\u2026\".concat(values.length - items.length, \" entries\"),\n          value: ellipsis,\n          offset: offset,\n          size: size(ellipsis, _)\n        }));\n      }\n    } else if (type === GradientLegend) {\n      domain = scale.domain(), fraction = scaleFraction(scale, domain[0], peek(domain)); // if automatic label generation produces 2 or fewer values,\n      // use the domain end points instead (fixes vega/vega#1364)\n\n      if (values.length < 3 && !_.values && domain[0] !== peek(domain)) {\n        values = [domain[0], peek(domain)];\n      }\n\n      items = values.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc: fraction(value)\n      }));\n    } else {\n      size = values.length - 1;\n      fraction = labelFraction(scale);\n      items = values.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc: index ? fraction(value) : 0,\n        perc2: index === size ? 1 : fraction(values[index + 1])\n      }));\n    }\n\n    out.source = items;\n    out.add = items;\n    this.value = items;\n    return out;\n  }\n\n});\n\nconst sourceX = t => t.source.x;\n\nconst sourceY = t => t.source.y;\n\nconst targetX = t => t.target.x;\n\nconst targetY = t => t.target.y;\n/**\n * Layout paths linking source and target elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\n\nfunction LinkPath(params) {\n  Transform.call(this, {}, params);\n}\nLinkPath.Definition = {\n  'type': 'LinkPath',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'sourceX',\n    'type': 'field',\n    'default': 'source.x'\n  }, {\n    'name': 'sourceY',\n    'type': 'field',\n    'default': 'source.y'\n  }, {\n    'name': 'targetX',\n    'type': 'field',\n    'default': 'target.x'\n  }, {\n    'name': 'targetY',\n    'type': 'field',\n    'default': 'target.y'\n  }, {\n    'name': 'orient',\n    'type': 'enum',\n    'default': 'vertical',\n    'values': ['horizontal', 'vertical', 'radial']\n  }, {\n    'name': 'shape',\n    'type': 'enum',\n    'default': 'line',\n    'values': ['line', 'arc', 'curve', 'diagonal', 'orthogonal']\n  }, {\n    'name': 'require',\n    'type': 'signal'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'path'\n  }]\n};\ninherits(LinkPath, Transform, {\n  transform(_, pulse) {\n    var sx = _.sourceX || sourceX,\n        sy = _.sourceY || sourceY,\n        tx = _.targetX || targetX,\n        ty = _.targetY || targetY,\n        as = _.as || 'path',\n        orient = _.orient || 'vertical',\n        shape = _.shape || 'line',\n        path = Paths.get(shape + '-' + orient) || Paths.get(shape);\n\n    if (!path) {\n      error('LinkPath unsupported type: ' + _.shape + (_.orient ? '-' + _.orient : ''));\n    }\n\n    pulse.visit(pulse.SOURCE, t => {\n      t[as] = path(sx(t), sy(t), tx(t), ty(t));\n    });\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n\n});\n\nconst line = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'L' + tx + ',' + ty;\n\nconst lineR = (sa, sr, ta, tr) => line(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n\nconst arc = (sx, sy, tx, ty) => {\n  var dx = tx - sx,\n      dy = ty - sy,\n      rr = Math.sqrt(dx * dx + dy * dy) / 2,\n      ra = 180 * Math.atan2(dy, dx) / Math.PI;\n  return 'M' + sx + ',' + sy + 'A' + rr + ',' + rr + ' ' + ra + ' 0 1' + ' ' + tx + ',' + ty;\n};\n\nconst arcR = (sa, sr, ta, tr) => arc(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n\nconst curve = (sx, sy, tx, ty) => {\n  const dx = tx - sx,\n        dy = ty - sy,\n        ix = 0.2 * (dx + dy),\n        iy = 0.2 * (dy - dx);\n  return 'M' + sx + ',' + sy + 'C' + (sx + ix) + ',' + (sy + iy) + ' ' + (tx + iy) + ',' + (ty - ix) + ' ' + tx + ',' + ty;\n};\n\nconst curveR = (sa, sr, ta, tr) => curve(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n\nconst orthoX = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'V' + ty + 'H' + tx;\n\nconst orthoY = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'H' + tx + 'V' + ty;\n\nconst orthoR = (sa, sr, ta, tr) => {\n  const sc = Math.cos(sa),\n        ss = Math.sin(sa),\n        tc = Math.cos(ta),\n        ts = Math.sin(ta),\n        sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n  return 'M' + sr * sc + ',' + sr * ss + 'A' + sr + ',' + sr + ' 0 0,' + (sf ? 1 : 0) + ' ' + sr * tc + ',' + sr * ts + 'L' + tr * tc + ',' + tr * ts;\n};\n\nconst diagonalX = (sx, sy, tx, ty) => {\n  const m = (sx + tx) / 2;\n  return 'M' + sx + ',' + sy + 'C' + m + ',' + sy + ' ' + m + ',' + ty + ' ' + tx + ',' + ty;\n};\n\nconst diagonalY = (sx, sy, tx, ty) => {\n  const m = (sy + ty) / 2;\n  return 'M' + sx + ',' + sy + 'C' + sx + ',' + m + ' ' + tx + ',' + m + ' ' + tx + ',' + ty;\n};\n\nconst diagonalR = (sa, sr, ta, tr) => {\n  const sc = Math.cos(sa),\n        ss = Math.sin(sa),\n        tc = Math.cos(ta),\n        ts = Math.sin(ta),\n        mr = (sr + tr) / 2;\n  return 'M' + sr * sc + ',' + sr * ss + 'C' + mr * sc + ',' + mr * ss + ' ' + mr * tc + ',' + mr * ts + ' ' + tr * tc + ',' + tr * ts;\n};\n\nconst Paths = fastmap({\n  'line': line,\n  'line-radial': lineR,\n  'arc': arc,\n  'arc-radial': arcR,\n  'curve': curve,\n  'curve-radial': curveR,\n  'orthogonal-horizontal': orthoX,\n  'orthogonal-vertical': orthoY,\n  'orthogonal-radial': orthoR,\n  'diagonal-horizontal': diagonalX,\n  'diagonal-vertical': diagonalY,\n  'diagonal-radial': diagonalR\n});\n\n/**\n * Pie and donut chart layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size pie segments.\n * @param {number} [params.startAngle=0] - The start angle (in radians) of the layout.\n * @param {number} [params.endAngle=2π] - The end angle (in radians) of the layout.\n * @param {boolean} [params.sort] - Boolean flag for sorting sectors by value.\n */\n\nfunction Pie(params) {\n  Transform.call(this, null, params);\n}\nPie.Definition = {\n  'type': 'Pie',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'startAngle',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'endAngle',\n    'type': 'number',\n    'default': 6.283185307179586\n  }, {\n    'name': 'sort',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['startAngle', 'endAngle']\n  }]\n};\ninherits(Pie, Transform, {\n  transform(_, pulse) {\n    var as = _.as || ['startAngle', 'endAngle'],\n        startAngle = as[0],\n        endAngle = as[1],\n        field = _.field || one,\n        start = _.startAngle || 0,\n        stop = _.endAngle != null ? _.endAngle : 2 * Math.PI,\n        data = pulse.source,\n        values = data.map(field),\n        n = values.length,\n        a = start,\n        k = (stop - start) / sum(values),\n        index = range(n),\n        i,\n        t,\n        v;\n\n    if (_.sort) {\n      index.sort((a, b) => values[a] - values[b]);\n    }\n\n    for (i = 0; i < n; ++i) {\n      v = values[index[i]];\n      t = data[index[i]];\n      t[startAngle] = a;\n      t[endAngle] = a += v * k;\n    }\n\n    this.value = values;\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n\n});\n\nconst DEFAULT_COUNT = 5;\n\nfunction includeZero(scale) {\n  const type = scale.type;\n  return !scale.bins && (type === Linear || type === Pow || type === Sqrt);\n}\n\nfunction includePad(type) {\n  return isContinuous(type) && type !== Sequential;\n}\n\nconst SKIP = toSet(['set', 'modified', 'clear', 'type', 'scheme', 'schemeExtent', 'schemeCount', 'domain', 'domainMin', 'domainMid', 'domainMax', 'domainRaw', 'domainImplicit', 'nice', 'zero', 'bins', 'range', 'rangeStep', 'round', 'reverse', 'interpolate', 'interpolateGamma']);\n/**\n * Maintains a scale function mapping data values to visual channels.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction Scale(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\ninherits(Scale, Transform, {\n  transform(_, pulse) {\n    var df = pulse.dataflow,\n        scale$1 = this.value,\n        key = scaleKey(_);\n\n    if (!scale$1 || key !== scale$1.type) {\n      this.value = scale$1 = scale(key)();\n    }\n\n    for (key in _) if (!SKIP[key]) {\n      // padding is a scale property for band/point but not others\n      if (key === 'padding' && includePad(scale$1.type)) continue; // invoke scale property setter, raise warning if not found\n\n      isFunction(scale$1[key]) ? scale$1[key](_[key]) : df.warn('Unsupported scale property: ' + key);\n    }\n\n    configureRange(scale$1, _, configureBins(scale$1, _, configureDomain(scale$1, _, df)));\n    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n  }\n\n});\n\nfunction scaleKey(_) {\n  var t = _.type,\n      d = '',\n      n; // backwards compatibility pre Vega 5.\n\n  if (t === Sequential) return Sequential + '-' + Linear;\n\n  if (isContinuousColor(_)) {\n    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;\n    d = n === 2 ? Sequential + '-' : n === 3 ? Diverging + '-' : '';\n  }\n\n  return (d + t || Linear).toLowerCase();\n}\n\nfunction isContinuousColor(_) {\n  const t = _.type;\n  return isContinuous(t) && t !== Time && t !== UTC && (_.scheme || _.range && _.range.length && _.range.every(isString));\n}\n\nfunction configureDomain(scale, _, df) {\n  // check raw domain, if provided use that and exit early\n  const raw = rawDomain(scale, _.domainRaw, df);\n  if (raw > -1) return raw;\n  var domain = _.domain,\n      type = scale.type,\n      zero = _.zero || _.zero === undefined && includeZero(scale),\n      n,\n      mid;\n  if (!domain) return 0; // adjust continuous domain for minimum pixel padding\n\n  if (includePad(type) && _.padding && domain[0] !== peek(domain)) {\n    domain = padDomain(type, domain, _.range, _.padding, _.exponent, _.constant);\n  } // adjust domain based on zero, min, max settings\n\n\n  if (zero || _.domainMin != null || _.domainMax != null || _.domainMid != null) {\n    n = (domain = domain.slice()).length - 1 || 1;\n\n    if (zero) {\n      if (domain[0] > 0) domain[0] = 0;\n      if (domain[n] < 0) domain[n] = 0;\n    }\n\n    if (_.domainMin != null) domain[0] = _.domainMin;\n    if (_.domainMax != null) domain[n] = _.domainMax;\n\n    if (_.domainMid != null) {\n      mid = _.domainMid;\n      const i = mid > domain[n] ? n + 1 : mid < domain[0] ? 0 : n;\n      if (i !== n) df.warn('Scale domainMid exceeds domain min or max.', mid);\n      domain.splice(i, 0, mid);\n    }\n  } // set the scale domain\n\n\n  scale.domain(domainCheck(type, domain, df)); // if ordinal scale domain is defined, prevent implicit\n  // domain construction as side-effect of scale lookup\n\n  if (type === Ordinal) {\n    scale.unknown(_.domainImplicit ? scaleImplicit : undefined);\n  } // perform 'nice' adjustment as requested\n\n\n  if (_.nice && scale.nice) {\n    scale.nice(_.nice !== true && tickCount(scale, _.nice) || null);\n  } // return the cardinality of the domain\n\n\n  return domain.length;\n}\n\nfunction rawDomain(scale, raw, df) {\n  if (raw) {\n    scale.domain(domainCheck(scale.type, raw, df));\n    return raw.length;\n  } else {\n    return -1;\n  }\n}\n\nfunction padDomain(type, domain, range, pad, exponent, constant) {\n  var span = Math.abs(peek(range) - range[0]),\n      frac = span / (span - 2 * pad),\n      d = type === Log ? zoomLog(domain, null, frac) : type === Sqrt ? zoomPow(domain, null, frac, 0.5) : type === Pow ? zoomPow(domain, null, frac, exponent || 1) : type === Symlog ? zoomSymlog(domain, null, frac, constant || 1) : zoomLinear(domain, null, frac);\n  domain = domain.slice();\n  domain[0] = d[0];\n  domain[domain.length - 1] = d[1];\n  return domain;\n}\n\nfunction domainCheck(type, domain, df) {\n  if (isLogarithmic(type)) {\n    // sum signs of domain values\n    // if all pos or all neg, abs(sum) === domain.length\n    var s = Math.abs(domain.reduce((s, v) => s + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));\n\n    if (s !== domain.length) {\n      df.warn('Log scale domain includes zero: ' + stringValue(domain));\n    }\n  }\n\n  return domain;\n}\n\nfunction configureBins(scale, _, count) {\n  let bins = _.bins;\n\n  if (bins && !isArray(bins)) {\n    // generate bin boundary array\n    const domain = scale.domain(),\n          lo = domain[0],\n          hi = peek(domain),\n          step = bins.step;\n    let start = bins.start == null ? lo : bins.start,\n        stop = bins.stop == null ? hi : bins.stop;\n    if (!step) error('Scale bins parameter missing step property.');\n    if (start < lo) start = step * Math.ceil(lo / step);\n    if (stop > hi) stop = step * Math.floor(hi / step);\n    bins = range(start, stop + step / 2, step);\n  }\n\n  if (bins) {\n    // assign bin boundaries to scale instance\n    scale.bins = bins;\n  } else if (scale.bins) {\n    // no current bins, remove bins if previously set\n    delete scale.bins;\n  } // special handling for bin-ordinal scales\n\n\n  if (scale.type === BinOrdinal) {\n    if (!bins) {\n      // the domain specifies the bins\n      scale.bins = scale.domain();\n    } else if (!_.domain && !_.domainRaw) {\n      // the bins specify the domain\n      scale.domain(bins);\n      count = bins.length;\n    }\n  } // return domain cardinality\n\n\n  return count;\n}\n\nfunction configureRange(scale, _, count) {\n  var type = scale.type,\n      round = _.round || false,\n      range = _.range; // if range step specified, calculate full range extent\n\n  if (_.rangeStep != null) {\n    range = configureRangeStep(type, _, count);\n  } // else if a range scheme is defined, use that\n  else if (_.scheme) {\n    range = configureScheme(type, _, count);\n\n    if (isFunction(range)) {\n      if (scale.interpolator) {\n        return scale.interpolator(range);\n      } else {\n        error(\"Scale type \".concat(type, \" does not support interpolating color schemes.\"));\n      }\n    }\n  } // given a range array for an interpolating scale, convert to interpolator\n\n\n  if (range && isInterpolating(type)) {\n    return scale.interpolator(interpolateColors(flip(range, _.reverse), _.interpolate, _.interpolateGamma));\n  } // configure rounding / interpolation\n\n\n  if (range && _.interpolate && scale.interpolate) {\n    scale.interpolate(interpolate(_.interpolate, _.interpolateGamma));\n  } else if (isFunction(scale.round)) {\n    scale.round(round);\n  } else if (isFunction(scale.rangeRound)) {\n    scale.interpolate(round ? interpolateRound : interpolate$1);\n  }\n\n  if (range) scale.range(flip(range, _.reverse));\n}\n\nfunction configureRangeStep(type, _, count) {\n  if (type !== Band && type !== Point) {\n    error('Only band and point scales support rangeStep.');\n  } // calculate full range based on requested step size and padding\n\n\n  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0,\n      inner = type === Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;\n  return [0, _.rangeStep * bandSpace(count, inner, outer)];\n}\n\nfunction configureScheme(type, _, count) {\n  var extent = _.schemeExtent,\n      name,\n      scheme$1;\n\n  if (isArray(_.scheme)) {\n    scheme$1 = interpolateColors(_.scheme, _.interpolate, _.interpolateGamma);\n  } else {\n    name = _.scheme.toLowerCase();\n    scheme$1 = scheme(name);\n    if (!scheme$1) error(\"Unrecognized scheme name: \".concat(_.scheme));\n  } // determine size for potential discrete range\n\n\n  count = type === Threshold ? count + 1 : type === BinOrdinal ? count - 1 : type === Quantile || type === Quantize ? +_.schemeCount || DEFAULT_COUNT : count; // adjust and/or quantize scheme as appropriate\n\n  return isInterpolating(type) ? adjustScheme(scheme$1, extent, _.reverse) : isFunction(scheme$1) ? quantizeInterpolator(adjustScheme(scheme$1, extent), count) : type === Ordinal ? scheme$1 : scheme$1.slice(0, count);\n}\n\nfunction adjustScheme(scheme, extent, reverse) {\n  return isFunction(scheme) && (extent || reverse) ? interpolateRange(scheme, flip(extent || [0, 1], reverse)) : scheme;\n}\n\nfunction flip(array, reverse) {\n  return reverse ? array.slice().reverse() : array;\n}\n\n/**\n * Sorts scenegraph items in the pulse source array.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting tuples.\n */\n\nfunction SortItems(params) {\n  Transform.call(this, null, params);\n}\ninherits(SortItems, Transform, {\n  transform(_, pulse) {\n    const mod = _.modified('sort') || pulse.changed(pulse.ADD) || pulse.modified(_.sort.fields) || pulse.modified('datum');\n    if (mod) pulse.source.sort(stableCompare(_.sort));\n    this.modified(mod);\n    return pulse;\n  }\n\n});\n\nconst Zero = 'zero',\n      Center = 'center',\n      Normalize = 'normalize',\n      DefOutput = ['y0', 'y1'];\n/**\n * Stack layout for visualization elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to stack.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {function(object,object): number} [params.sort] - A comparator for stack sorting.\n * @param {string} [offset='zero'] - Stack baseline offset. One of 'zero', 'center', 'normalize'.\n */\n\nfunction Stack(params) {\n  Transform.call(this, null, params);\n}\nStack.Definition = {\n  'type': 'Stack',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'offset',\n    'type': 'enum',\n    'default': Zero,\n    'values': [Zero, Center, Normalize]\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': DefOutput\n  }]\n};\ninherits(Stack, Transform, {\n  transform(_, pulse) {\n    var as = _.as || DefOutput,\n        y0 = as[0],\n        y1 = as[1],\n        sort = stableCompare(_.sort),\n        field = _.field || one,\n        stack = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero,\n        groups,\n        i,\n        n,\n        max; // partition, sum, and sort the stack groups\n\n    groups = partition(pulse.source, _.groupby, sort, field); // compute stack layouts per group\n\n    for (i = 0, n = groups.length, max = groups.max; i < n; ++i) {\n      stack(groups[i], max, field, y0, y1);\n    }\n\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n\n});\n\nfunction stackCenter(group, max, field, y0, y1) {\n  var last = (max - group.sum) / 2,\n      m = group.length,\n      j = 0,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last += Math.abs(field(t));\n  }\n}\n\nfunction stackNormalize(group, max, field, y0, y1) {\n  var scale = 1 / group.sum,\n      last = 0,\n      m = group.length,\n      j = 0,\n      v = 0,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last = scale * (v += Math.abs(field(t)));\n  }\n}\n\nfunction stackZero(group, max, field, y0, y1) {\n  var lastPos = 0,\n      lastNeg = 0,\n      m = group.length,\n      j = 0,\n      v,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    v = +field(t);\n\n    if (v < 0) {\n      t[y0] = lastNeg;\n      t[y1] = lastNeg += v;\n    } else {\n      t[y0] = lastPos;\n      t[y1] = lastPos += v;\n    }\n  }\n}\n\nfunction partition(data, groupby, sort, field) {\n  var groups = [],\n      get = f => f(t),\n      map,\n      i,\n      n,\n      m,\n      t,\n      k,\n      g,\n      s,\n      max; // partition data points into stack groups\n\n\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n\n      if (!g) {\n        map[k] = g = [];\n        groups.push(g);\n      }\n\n      g.push(t);\n    }\n  } // compute sums of groups, sort groups as needed\n\n\n  for (k = 0, max = 0, m = groups.length; k < m; ++k) {\n    g = groups[k];\n\n    for (i = 0, s = 0, n = g.length; i < n; ++i) {\n      s += Math.abs(field(g[i]));\n    }\n\n    g.sum = s;\n    if (s > max) max = s;\n    if (sort) g.sort(sort);\n  }\n\n  groups.max = max;\n  return groups;\n}\n\nexport { AxisTicks as axisticks, DataJoin as datajoin, Encode as encode, LegendEntries as legendentries, LinkPath as linkpath, Pie as pie, Scale as scale, SortItems as sortitems, Stack as stack };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}