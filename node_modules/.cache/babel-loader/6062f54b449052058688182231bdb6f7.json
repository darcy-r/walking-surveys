{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { array, isArray } from 'vega-util';\nimport { isArgmaxDef, isArgminDef } from './aggregate';\nimport { isBinned, isBinning } from './bin';\nimport { ANGLE, CHANNELS, COLOR, DESCRIPTION, DETAIL, FILL, FILLOPACITY, getMainChannelFromOffsetChannel, getOffsetScaleChannel, HREF, isChannel, isNonPositionScaleChannel, isSecondaryRangeChannel, isXorY, isXorYOffset, KEY, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, OPACITY, ORDER, RADIUS, RADIUS2, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, supportMark, TEXT, THETA, THETA2, TOOLTIP, UNIT_CHANNELS, URL, X, X2, XOFFSET, Y, Y2, YOFFSET } from './channel';\nimport { binRequiresRange, getFieldDef, getGuide, hasConditionalFieldDef, hasConditionalFieldOrDatumDef, initChannelDef, initFieldDef, isConditionalDef, isDatumDef, isFieldDef, isTypedFieldDef, isValueDef, title, vgField } from './channeldef';\nimport * as log from './log';\nimport { isContinuous, isDiscrete, QUANTITATIVE, TEMPORAL } from './type';\nimport { keys, some } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function channelHasField(encoding, channel) {\n  const channelDef = encoding && encoding[channel];\n\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, fieldDef => !!fieldDef.field);\n    } else {\n      return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);\n    }\n  }\n\n  return false;\n}\nexport function channelHasFieldOrDatum(encoding, channel) {\n  const channelDef = encoding && encoding[channel];\n\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, fieldDef => !!fieldDef.field);\n    } else {\n      return isFieldDef(channelDef) || isDatumDef(channelDef) || hasConditionalFieldOrDatumDef(channelDef);\n    }\n  }\n\n  return false;\n}\nexport function channelHasNestedOffsetScale(encoding, channel) {\n  if (isXorY(channel)) {\n    const fieldDef = encoding[channel];\n\n    if ((isFieldDef(fieldDef) || isDatumDef(fieldDef)) && isDiscrete(fieldDef.type)) {\n      const offsetChannel = getOffsetScaleChannel(channel);\n      return channelHasFieldOrDatum(encoding, offsetChannel);\n    }\n  }\n\n  return false;\n}\nexport function isAggregate(encoding) {\n  return some(CHANNELS, channel => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n\n      if (isArray(channelDef)) {\n        return some(channelDef, fieldDef => !!fieldDef.aggregate);\n      } else {\n        const fieldDef = getFieldDef(channelDef);\n        return fieldDef && !!fieldDef.aggregate;\n      }\n    }\n\n    return false;\n  });\n}\nexport function extractTransformsFromEncoding(oldEncoding, config) {\n  const groupby = [];\n  const bins = [];\n  const timeUnits = [];\n  const aggregate = [];\n  const encoding = {};\n  forEach(oldEncoding, (channelDef, channel) => {\n    // Extract potential embedded transformations along with remaining properties\n    if (isFieldDef(channelDef)) {\n      const {\n        field,\n        aggregate: aggOp,\n        bin,\n        timeUnit\n      } = channelDef,\n            remaining = __rest(channelDef, [\"field\", \"aggregate\", \"bin\", \"timeUnit\"]);\n\n      if (aggOp || timeUnit || bin) {\n        const guide = getGuide(channelDef);\n        const isTitleDefined = guide === null || guide === void 0 ? void 0 : guide.title;\n        let newField = vgField(channelDef, {\n          forAs: true\n        });\n        const newFieldDef = Object.assign(Object.assign(Object.assign({}, isTitleDefined ? [] : {\n          title: title(channelDef, config, {\n            allowDisabling: true\n          })\n        }), remaining), {\n          // Always overwrite field\n          field: newField\n        });\n\n        if (aggOp) {\n          let op;\n\n          if (isArgmaxDef(aggOp)) {\n            op = 'argmax';\n            newField = vgField({\n              op: 'argmax',\n              field: aggOp.argmax\n            }, {\n              forAs: true\n            });\n            newFieldDef.field = `${newField}.${field}`;\n          } else if (isArgminDef(aggOp)) {\n            op = 'argmin';\n            newField = vgField({\n              op: 'argmin',\n              field: aggOp.argmin\n            }, {\n              forAs: true\n            });\n            newFieldDef.field = `${newField}.${field}`;\n          } else if (aggOp !== 'boxplot' && aggOp !== 'errorbar' && aggOp !== 'errorband') {\n            op = aggOp;\n          }\n\n          if (op) {\n            const aggregateEntry = {\n              op,\n              as: newField\n            };\n\n            if (field) {\n              aggregateEntry.field = field;\n            }\n\n            aggregate.push(aggregateEntry);\n          }\n        } else {\n          groupby.push(newField);\n\n          if (isTypedFieldDef(channelDef) && isBinning(bin)) {\n            bins.push({\n              bin,\n              field,\n              as: newField\n            }); // Add additional groupbys for range and end of bins\n\n            groupby.push(vgField(channelDef, {\n              binSuffix: 'end'\n            }));\n\n            if (binRequiresRange(channelDef, channel)) {\n              groupby.push(vgField(channelDef, {\n                binSuffix: 'range'\n              }));\n            } // Create accompanying 'x2' or 'y2' field if channel is 'x' or 'y' respectively\n\n\n            if (isXorY(channel)) {\n              const secondaryChannel = {\n                field: `${newField}_end`\n              };\n              encoding[`${channel}2`] = secondaryChannel;\n            }\n\n            newFieldDef.bin = 'binned';\n\n            if (!isSecondaryRangeChannel(channel)) {\n              newFieldDef['type'] = QUANTITATIVE;\n            }\n          } else if (timeUnit) {\n            timeUnits.push({\n              timeUnit,\n              field,\n              as: newField\n            }); // define the format type for later compilation\n\n            const formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && 'time';\n\n            if (formatType) {\n              if (channel === TEXT || channel === TOOLTIP) {\n                newFieldDef['formatType'] = formatType;\n              } else if (isNonPositionScaleChannel(channel)) {\n                newFieldDef['legend'] = Object.assign({\n                  formatType\n                }, newFieldDef['legend']);\n              } else if (isXorY(channel)) {\n                newFieldDef['axis'] = Object.assign({\n                  formatType\n                }, newFieldDef['axis']);\n              }\n            }\n          }\n        } // now the field should refer to post-transformed field instead\n\n\n        encoding[channel] = newFieldDef;\n      } else {\n        groupby.push(field);\n        encoding[channel] = oldEncoding[channel];\n      }\n    } else {\n      // For value def / signal ref / datum def, just copy\n      encoding[channel] = oldEncoding[channel];\n    }\n  });\n  return {\n    bins,\n    timeUnits,\n    aggregate,\n    groupby,\n    encoding\n  };\n}\nexport function markChannelCompatible(encoding, channel, mark) {\n  const markSupported = supportMark(channel, mark);\n\n  if (!markSupported) {\n    return false;\n  } else if (markSupported === 'binned') {\n    const primaryFieldDef = encoding[channel === X2 ? X : Y]; // circle, point, square and tick only support x2/y2 when their corresponding x/y fieldDef\n    // has \"binned\" data and thus need x2/y2 to specify the bin-end field.\n\n    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function initEncoding(encoding, mark, filled, config) {\n  const normalizedEncoding = {};\n\n  for (const key of keys(encoding)) {\n    if (!isChannel(key)) {\n      // Drop invalid channel\n      log.warn(log.message.invalidEncodingChannel(key));\n    }\n  }\n\n  for (let channel of UNIT_CHANNELS) {\n    if (!encoding[channel]) {\n      continue;\n    }\n\n    const channelDef = encoding[channel];\n\n    if (isXorYOffset(channel)) {\n      const mainChannel = getMainChannelFromOffsetChannel(channel);\n      const positionDef = normalizedEncoding[mainChannel];\n\n      if (isFieldDef(positionDef)) {\n        if (isContinuous(positionDef.type)) {\n          if (isFieldDef(channelDef)) {\n            // TODO: nesting continuous field instead continuous field should\n            // behave like offsetting the data in data domain\n            log.warn(log.message.offsetNestedInsideContinuousPositionScaleDropped(mainChannel));\n            continue;\n          }\n        }\n      } else {\n        // no x/y, replace it with main channel\n        channel = mainChannel;\n        log.warn(log.message.replaceOffsetWithMainChannel(mainChannel));\n      }\n    }\n\n    if (channel === 'angle' && mark === 'arc' && !encoding.theta) {\n      log.warn(log.message.REPLACE_ANGLE_WITH_THETA);\n      channel = THETA;\n    }\n\n    if (!markChannelCompatible(encoding, channel, mark)) {\n      // Drop unsupported channel\n      log.warn(log.message.incompatibleChannel(channel, mark));\n      continue;\n    } // Drop line's size if the field is aggregated.\n\n\n    if (channel === SIZE && mark === 'line') {\n      const fieldDef = getFieldDef(encoding[channel]);\n\n      if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.aggregate) {\n        log.warn(log.message.LINE_WITH_VARYING_SIZE);\n        continue;\n      }\n    } // Drop color if either fill or stroke is specified\n\n\n    if (channel === COLOR && (filled ? 'fill' in encoding : 'stroke' in encoding)) {\n      log.warn(log.message.droppingColor('encoding', {\n        fill: 'fill' in encoding,\n        stroke: 'stroke' in encoding\n      }));\n      continue;\n    }\n\n    if (channel === DETAIL || channel === ORDER && !isArray(channelDef) && !isValueDef(channelDef) || channel === TOOLTIP && isArray(channelDef)) {\n      if (channelDef) {\n        // Array of fieldDefs for detail channel (or production rule)\n        normalizedEncoding[channel] = array(channelDef).reduce((defs, fieldDef) => {\n          if (!isFieldDef(fieldDef)) {\n            log.warn(log.message.emptyFieldDef(fieldDef, channel));\n          } else {\n            defs.push(initFieldDef(fieldDef, channel));\n          }\n\n          return defs;\n        }, []);\n      }\n    } else {\n      if (channel === TOOLTIP && channelDef === null) {\n        // Preserve null so we can use it to disable tooltip\n        normalizedEncoding[channel] = null;\n      } else if (!isFieldDef(channelDef) && !isDatumDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef) && !isSignalRef(channelDef)) {\n        log.warn(log.message.emptyFieldDef(channelDef, channel));\n        continue;\n      }\n\n      normalizedEncoding[channel] = initChannelDef(channelDef, channel, config);\n    }\n  }\n\n  return normalizedEncoding;\n}\n/**\n * For composite marks, we have to call initChannelDef during init so we can infer types earlier.\n */\n\nexport function normalizeEncoding(encoding, config) {\n  const normalizedEncoding = {};\n\n  for (const channel of keys(encoding)) {\n    const newChannelDef = initChannelDef(encoding[channel], channel, config, {\n      compositeMark: true\n    });\n    normalizedEncoding[channel] = newChannelDef;\n  }\n\n  return normalizedEncoding;\n}\nexport function fieldDefs(encoding) {\n  const arr = [];\n\n  for (const channel of keys(encoding)) {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      const channelDefArray = array(channelDef);\n\n      for (const def of channelDefArray) {\n        if (isFieldDef(def)) {\n          arr.push(def);\n        } else if (hasConditionalFieldDef(def)) {\n          arr.push(def.condition);\n        }\n      }\n    }\n  }\n\n  return arr;\n}\nexport function forEach(mapping, f, thisArg) {\n  if (!mapping) {\n    return;\n  }\n\n  for (const channel of keys(mapping)) {\n    const el = mapping[channel];\n\n    if (isArray(el)) {\n      for (const channelDef of el) {\n        f.call(thisArg, channelDef, channel);\n      }\n    } else {\n      f.call(thisArg, el, channel);\n    }\n  }\n}\nexport function reduce(mapping, f, init, thisArg) {\n  if (!mapping) {\n    return init;\n  }\n\n  return keys(mapping).reduce((r, channel) => {\n    const map = mapping[channel];\n\n    if (isArray(map)) {\n      return map.reduce((r1, channelDef) => {\n        return f.call(thisArg, r1, channelDef, channel);\n      }, r);\n    } else {\n      return f.call(thisArg, r, map, channel);\n    }\n  }, init);\n}\n/**\n * Returns list of path grouping fields for the given encoding\n */\n\nexport function pathGroupingFields(mark, encoding) {\n  return keys(encoding).reduce((details, channel) => {\n    switch (channel) {\n      // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, aria label, cursor should not cause lines to group\n      case X:\n      case Y:\n      case HREF:\n      case DESCRIPTION:\n      case URL:\n      case X2:\n      case Y2:\n      case XOFFSET:\n      case YOFFSET:\n      case THETA:\n      case THETA2:\n      case RADIUS:\n      case RADIUS2: // falls through\n\n      case LATITUDE:\n      case LONGITUDE:\n      case LATITUDE2:\n      case LONGITUDE2: // TODO: case 'cursor':\n      // text, shape, shouldn't be a part of line/trail/area [falls through]\n\n      case TEXT:\n      case SHAPE:\n      case ANGLE: // falls through\n      // tooltip fields should not be added to group by [falls through]\n\n      case TOOLTIP:\n        return details;\n\n      case ORDER:\n        // order should not group line / trail\n        if (mark === 'line' || mark === 'trail') {\n          return details;\n        }\n\n      // but order should group area for stacking (falls through)\n\n      case DETAIL:\n      case KEY:\n        {\n          const channelDef = encoding[channel];\n\n          if (isArray(channelDef) || isFieldDef(channelDef)) {\n            for (const fieldDef of array(channelDef)) {\n              if (!fieldDef.aggregate) {\n                details.push(vgField(fieldDef, {}));\n              }\n            }\n          }\n\n          return details;\n        }\n\n      case SIZE:\n        if (mark === 'trail') {\n          // For trail, size should not group trail lines.\n          return details;\n        }\n\n      // For line, size should group lines.\n      // falls through\n\n      case COLOR:\n      case FILL:\n      case STROKE:\n      case OPACITY:\n      case FILLOPACITY:\n      case STROKEOPACITY:\n      case STROKEDASH:\n      case STROKEWIDTH:\n        {\n          // TODO strokeDashOffset:\n          // falls through\n          const fieldDef = getFieldDef(encoding[channel]);\n\n          if (fieldDef && !fieldDef.aggregate) {\n            details.push(vgField(fieldDef, {}));\n          }\n\n          return details;\n        }\n    }\n  }, []);\n}","map":{"version":3,"mappings":"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","names":["array","isArray","isArgmaxDef","isArgminDef","isBinned","isBinning","ANGLE","CHANNELS","COLOR","DESCRIPTION","DETAIL","FILL","FILLOPACITY","getMainChannelFromOffsetChannel","getOffsetScaleChannel","HREF","isChannel","isNonPositionScaleChannel","isSecondaryRangeChannel","isXorY","isXorYOffset","KEY","LATITUDE","LATITUDE2","LONGITUDE","LONGITUDE2","OPACITY","ORDER","RADIUS","RADIUS2","SHAPE","SIZE","STROKE","STROKEDASH","STROKEOPACITY","STROKEWIDTH","supportMark","TEXT","THETA","THETA2","TOOLTIP","UNIT_CHANNELS","URL","X","X2","XOFFSET","Y","Y2","YOFFSET","binRequiresRange","getFieldDef","getGuide","hasConditionalFieldDef","hasConditionalFieldOrDatumDef","initChannelDef","initFieldDef","isConditionalDef","isDatumDef","isFieldDef","isTypedFieldDef","isValueDef","title","vgField","log","isContinuous","isDiscrete","QUANTITATIVE","TEMPORAL","keys","some","isSignalRef","channelHasField","encoding","channel","channelDef","fieldDef","field","channelHasFieldOrDatum","channelHasNestedOffsetScale","type","offsetChannel","isAggregate","aggregate","extractTransformsFromEncoding","oldEncoding","config","groupby","bins","timeUnits","forEach","aggOp","bin","timeUnit","remaining","guide","isTitleDefined","newField","forAs","newFieldDef","allowDisabling","op","argmax","argmin","aggregateEntry","as","push","binSuffix","secondaryChannel","formatType","Object","markChannelCompatible","mark","markSupported","primaryFieldDef","initEncoding","filled","normalizedEncoding","key","warn","message","invalidEncodingChannel","mainChannel","positionDef","offsetNestedInsideContinuousPositionScaleDropped","replaceOffsetWithMainChannel","theta","REPLACE_ANGLE_WITH_THETA","incompatibleChannel","LINE_WITH_VARYING_SIZE","droppingColor","fill","stroke","reduce","defs","emptyFieldDef","normalizeEncoding","newChannelDef","compositeMark","fieldDefs","arr","channelDefArray","def","condition","mapping","f","thisArg","el","call","init","r","map","r1","pathGroupingFields","details"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/encoding.ts"],"sourcesContent":["import {AggregateOp} from 'vega';\nimport {array, isArray} from 'vega-util';\nimport {isArgmaxDef, isArgminDef} from './aggregate';\nimport {isBinned, isBinning} from './bin';\nimport {\n  ANGLE,\n  Channel,\n  CHANNELS,\n  COLOR,\n  DESCRIPTION,\n  DETAIL,\n  FILL,\n  FILLOPACITY,\n  getMainChannelFromOffsetChannel,\n  getOffsetScaleChannel,\n  HREF,\n  isChannel,\n  isNonPositionScaleChannel,\n  isSecondaryRangeChannel,\n  isXorY,\n  isXorYOffset,\n  KEY,\n  LATITUDE,\n  LATITUDE2,\n  LONGITUDE,\n  LONGITUDE2,\n  OPACITY,\n  ORDER,\n  RADIUS,\n  RADIUS2,\n  SHAPE,\n  SIZE,\n  STROKE,\n  STROKEDASH,\n  STROKEOPACITY,\n  STROKEWIDTH,\n  supportMark,\n  TEXT,\n  THETA,\n  THETA2,\n  TOOLTIP,\n  UNIT_CHANNELS,\n  URL,\n  X,\n  X2,\n  XOFFSET,\n  Y,\n  Y2,\n  YOFFSET\n} from './channel';\nimport {\n  binRequiresRange,\n  ChannelDef,\n  ColorDef,\n  Field,\n  FieldDef,\n  FieldDefWithoutScale,\n  getFieldDef,\n  getGuide,\n  hasConditionalFieldDef,\n  hasConditionalFieldOrDatumDef,\n  initChannelDef,\n  initFieldDef,\n  isConditionalDef,\n  isDatumDef,\n  isFieldDef,\n  isTypedFieldDef,\n  isValueDef,\n  LatLongDef,\n  NumericArrayMarkPropDef,\n  NumericMarkPropDef,\n  OffsetDef,\n  OrderFieldDef,\n  OrderValueDef,\n  PolarDef,\n  Position2Def,\n  PositionDef,\n  SecondaryFieldDef,\n  ShapeDef,\n  StringFieldDef,\n  StringFieldDefWithCondition,\n  StringValueDefWithCondition,\n  TextDef,\n  title,\n  TypedFieldDef,\n  vgField\n} from './channeldef';\nimport {Config} from './config';\nimport * as log from './log';\nimport {Mark} from './mark';\nimport {EncodingFacetMapping} from './spec/facet';\nimport {AggregatedFieldDef, BinTransform, TimeUnitTransform} from './transform';\nimport {isContinuous, isDiscrete, QUANTITATIVE, TEMPORAL} from './type';\nimport {keys, some} from './util';\nimport {isSignalRef} from './vega.schema';\n\nexport interface Encoding<F extends Field> {\n  /**\n   * X coordinates of the marks, or width of horizontal `\"bar\"` and `\"area\"` without specified `x2` or `width`.\n   *\n   * The `value` of this channel can be a number or a string `\"width\"` for the width of the plot.\n   */\n  x?: PositionDef<F>;\n\n  /**\n   * Y coordinates of the marks, or height of vertical `\"bar\"` and `\"area\"` without specified `y2` or `height`.\n   *\n   * The `value` of this channel can be a number or a string `\"height\"` for the height of the plot.\n   */\n  y?: PositionDef<F>;\n\n  /**\n   * Offset of x-position of the marks\n   */\n  xOffset?: OffsetDef<F>;\n\n  /**\n   * Offset of y-position of the marks\n   */\n  yOffset?: OffsetDef<F>;\n\n  /**\n   * X2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   *\n   * The `value` of this channel can be a number or a string `\"width\"` for the width of the plot.\n   */\n  // TODO: Ham need to add default behavior\n  // `x2` cannot have type as it should have the same type as `x`\n  x2?: Position2Def<F>;\n\n  /**\n   * Y2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   *\n   * The `value` of this channel can be a number or a string `\"height\"` for the height of the plot.\n   */\n  // TODO: Ham need to add default behavior\n  // `y2` cannot have type as it should have the same type as `y`\n  y2?: Position2Def<F>;\n\n  /**\n   * Longitude position of geographically projected marks.\n   */\n  longitude?: LatLongDef<F>;\n\n  /**\n   * Latitude position of geographically projected marks.\n   */\n  latitude?: LatLongDef<F>;\n\n  /**\n   * Longitude-2 position for geographically projected ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   */\n  // `longitude2` cannot have type as it should have the same type as `longitude`\n  longitude2?: Position2Def<F>;\n\n  /**\n   * Latitude-2 position for geographically projected ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   */\n  // `latitude2` cannot have type as it should have the same type as `latitude`\n  latitude2?: Position2Def<F>;\n\n  /**\n   * - For arc marks, the arc length in radians if theta2 is not specified, otherwise the start arc angle. (A value of 0 indicates up or “north”, increasing values proceed clockwise.)\n   *\n   * - For text marks, polar coordinate angle in radians.\n   */\n  theta?: PolarDef<F>;\n\n  /**\n   * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing values proceed clockwise.\n   */\n  theta2?: Position2Def<F>;\n\n  /**\n   * The outer radius in pixels of arc marks.\n   */\n\n  radius?: PolarDef<F>;\n\n  /**\n   * The inner radius in pixels of arc marks.\n   */\n  radius2?: Position2Def<F>;\n\n  /**\n   * Color of the marks – either fill or stroke color based on  the `filled` property of mark definition.\n   * By default, `color` represents fill color for `\"area\"`, `\"bar\"`, `\"tick\"`,\n   * `\"text\"`, `\"trail\"`, `\"circle\"`, and `\"square\"` / stroke color for `\"line\"` and `\"point\"`.\n   *\n   * __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color` property.\n   *\n   * _Note:_\n   * 1) For fine-grained control over both fill and stroke colors of the marks, please use the `fill` and `stroke` channels. The `fill` or `stroke` encodings have higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified.\n   * 2) See the scale documentation for more information about customizing [color scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme).\n   */\n  color?: ColorDef<F>;\n\n  /**\n   * Fill color of the marks.\n   * __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color` property.\n   *\n   * _Note:_ The `fill` encoding has higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified.\n   */\n  fill?: ColorDef<F>;\n\n  /**\n   * Stroke color of the marks.\n   * __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color` property.\n   *\n   * _Note:_ The `stroke` encoding has higher precedence than `color`, thus may override the `color` encoding if conflicting encodings are specified.\n   */\n\n  stroke?: ColorDef<F>;\n\n  /**\n   * Opacity of the marks.\n   *\n   * __Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `opacity` property.\n   */\n  opacity?: NumericMarkPropDef<F>;\n\n  /**\n   * Fill opacity of the marks.\n   *\n   * __Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `fillOpacity` property.\n   */\n  fillOpacity?: NumericMarkPropDef<F>;\n\n  /**\n   * Stroke opacity of the marks.\n   *\n   * __Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeOpacity` property.\n   */\n  strokeOpacity?: NumericMarkPropDef<F>;\n\n  /**\n   * Stroke width of the marks.\n   *\n   * __Default value:__ If undefined, the default stroke width depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeWidth` property.\n   */\n  strokeWidth?: NumericMarkPropDef<F>;\n\n  /**\n   * Stroke dash of the marks.\n   *\n   * __Default value:__ `[1,0]` (No dash).\n   */\n  strokeDash?: NumericArrayMarkPropDef<F>;\n\n  /**\n   * Size of the mark.\n   * - For `\"point\"`, `\"square\"` and `\"circle\"`, – the symbol size, or pixel area of the mark.\n   * - For `\"bar\"` and `\"tick\"` – the bar and tick's size.\n   * - For `\"text\"` – the text's font size.\n   * - Size is unsupported for `\"line\"`, `\"area\"`, and `\"rect\"`. (Use `\"trail\"` instead of line with varying size)\n   */\n  size?: NumericMarkPropDef<F>;\n\n  /**\n   * Rotation angle of point and text marks.\n   */\n  angle?: NumericMarkPropDef<F>;\n\n  /**\n   * Shape of the mark.\n   *\n   * 1. For `point` marks the supported values include:\n   *   - plotting shapes: `\"circle\"`, `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, `\"triangle-down\"`, `\"triangle-right\"`, or `\"triangle-left\"`.\n   *   - the line symbol `\"stroke\"`\n   *   - centered directional shapes `\"arrow\"`, `\"wedge\"`, or `\"triangle\"`\n   *   - a custom [SVG path string](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths) (For correct sizing, custom shape paths should be defined within a square bounding box with coordinates ranging from -1 to 1 along both the x and y dimensions.)\n   *\n   * 2. For `geoshape` marks it should be a field definition of the geojson data\n   *\n   * __Default value:__ If undefined, the default shape depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#point-config)'s `shape` property. (`\"circle\"` if unset.)\n   */\n  shape?: ShapeDef<F>;\n  /**\n   * Additional levels of detail for grouping data in aggregate views and\n   * in line, trail, and area marks without mapping data to a specific visual channel.\n   */\n  detail?: FieldDefWithoutScale<F> | FieldDefWithoutScale<F>[];\n\n  /**\n   * A data field to use as a unique key for data binding. When a visualization’s data is updated, the key value will be used to match data elements to existing mark instances. Use a key channel to enable object constancy for transitions over dynamic data.\n   */\n  key?: FieldDefWithoutScale<F>;\n\n  /**\n   * Text of the `text` mark.\n   */\n  text?: TextDef<F>;\n\n  /**\n   * The tooltip text to show upon mouse hover. Specifying `tooltip` encoding overrides [the `tooltip` property in the mark definition](https://vega.github.io/vega-lite/docs/mark.html#mark-def).\n   *\n   * See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for a detailed discussion about tooltip in Vega-Lite.\n   */\n  tooltip?: StringFieldDefWithCondition<F> | StringValueDefWithCondition<F> | StringFieldDef<F>[] | null;\n\n  /**\n   * A URL to load upon mouse click.\n   */\n  href?: StringFieldDefWithCondition<F> | StringValueDefWithCondition<F>;\n\n  /**\n   * The URL of an image mark.\n   */\n  url?: StringFieldDefWithCondition<F> | StringValueDefWithCondition<F>;\n\n  /**\n   * A text description of this mark for ARIA accessibility (SVG output only). For SVG output the `\"aria-label\"` attribute will be set to this description.\n   */\n  description?: StringFieldDefWithCondition<F> | StringValueDefWithCondition<F>;\n\n  /**\n   * Order of the marks.\n   * - For stacked marks, this `order` channel encodes [stack order](https://vega.github.io/vega-lite/docs/stack.html#order).\n   * - For line and trail marks, this `order` channel encodes order of data points in the lines. This can be useful for creating [a connected scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html). Setting `order` to `{\"value\": null}` makes the line marks use the original order in the data sources.\n   * - Otherwise, this `order` channel encodes layer order of the marks.\n   *\n   * __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping.\n   */\n  order?: OrderFieldDef<F> | OrderFieldDef<F>[] | OrderValueDef;\n}\n\nexport interface EncodingWithFacet<F extends Field> extends Encoding<F>, EncodingFacetMapping<F> {}\n\nexport function channelHasField<F extends Field>(\n  encoding: EncodingWithFacet<F>,\n  channel: keyof EncodingWithFacet<F>\n): boolean {\n  const channelDef = encoding && encoding[channel];\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, fieldDef => !!fieldDef.field);\n    } else {\n      return isFieldDef(channelDef) || hasConditionalFieldDef<Field>(channelDef);\n    }\n  }\n  return false;\n}\n\nexport function channelHasFieldOrDatum<F extends Field>(\n  encoding: EncodingWithFacet<F>,\n  channel: keyof EncodingWithFacet<F>\n): boolean {\n  const channelDef = encoding && encoding[channel];\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, fieldDef => !!fieldDef.field);\n    } else {\n      return isFieldDef(channelDef) || isDatumDef(channelDef) || hasConditionalFieldOrDatumDef<Field>(channelDef);\n    }\n  }\n  return false;\n}\n\nexport function channelHasNestedOffsetScale<F extends Field>(\n  encoding: EncodingWithFacet<F>,\n  channel: keyof EncodingWithFacet<F>\n): boolean {\n  if (isXorY(channel)) {\n    const fieldDef = encoding[channel];\n    if ((isFieldDef(fieldDef) || isDatumDef(fieldDef)) && isDiscrete(fieldDef.type)) {\n      const offsetChannel = getOffsetScaleChannel(channel);\n      return channelHasFieldOrDatum(encoding, offsetChannel);\n    }\n  }\n  return false;\n}\n\nexport function isAggregate(encoding: EncodingWithFacet<any>) {\n  return some(CHANNELS, channel => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      if (isArray(channelDef)) {\n        return some(channelDef, fieldDef => !!fieldDef.aggregate);\n      } else {\n        const fieldDef = getFieldDef(channelDef);\n        return fieldDef && !!fieldDef.aggregate;\n      }\n    }\n    return false;\n  });\n}\n\nexport function extractTransformsFromEncoding(oldEncoding: Encoding<any>, config: Config) {\n  const groupby: string[] = [];\n  const bins: BinTransform[] = [];\n  const timeUnits: TimeUnitTransform[] = [];\n  const aggregate: AggregatedFieldDef[] = [];\n  const encoding: Encoding<string> = {};\n\n  forEach(oldEncoding, (channelDef, channel) => {\n    // Extract potential embedded transformations along with remaining properties\n    if (isFieldDef(channelDef)) {\n      const {field, aggregate: aggOp, bin, timeUnit, ...remaining} = channelDef;\n      if (aggOp || timeUnit || bin) {\n        const guide = getGuide(channelDef);\n        const isTitleDefined = guide?.title;\n        let newField = vgField(channelDef, {forAs: true});\n        const newFieldDef: FieldDef<string> = {\n          // Only add title if it doesn't exist\n          ...(isTitleDefined ? [] : {title: title(channelDef, config, {allowDisabling: true})}),\n          ...remaining,\n          // Always overwrite field\n          field: newField\n        };\n\n        if (aggOp) {\n          let op: AggregateOp;\n\n          if (isArgmaxDef(aggOp)) {\n            op = 'argmax';\n            newField = vgField({op: 'argmax', field: aggOp.argmax}, {forAs: true});\n            newFieldDef.field = `${newField}.${field}`;\n          } else if (isArgminDef(aggOp)) {\n            op = 'argmin';\n            newField = vgField({op: 'argmin', field: aggOp.argmin}, {forAs: true});\n            newFieldDef.field = `${newField}.${field}`;\n          } else if (aggOp !== 'boxplot' && aggOp !== 'errorbar' && aggOp !== 'errorband') {\n            op = aggOp;\n          }\n\n          if (op) {\n            const aggregateEntry: AggregatedFieldDef = {\n              op,\n              as: newField\n            };\n            if (field) {\n              aggregateEntry.field = field;\n            }\n            aggregate.push(aggregateEntry);\n          }\n        } else {\n          groupby.push(newField);\n          if (isTypedFieldDef(channelDef) && isBinning(bin)) {\n            bins.push({bin, field, as: newField});\n            // Add additional groupbys for range and end of bins\n            groupby.push(vgField(channelDef, {binSuffix: 'end'}));\n            if (binRequiresRange(channelDef, channel)) {\n              groupby.push(vgField(channelDef, {binSuffix: 'range'}));\n            }\n            // Create accompanying 'x2' or 'y2' field if channel is 'x' or 'y' respectively\n            if (isXorY(channel)) {\n              const secondaryChannel: SecondaryFieldDef<string> = {\n                field: `${newField}_end`\n              };\n              encoding[`${channel}2`] = secondaryChannel;\n            }\n            newFieldDef.bin = 'binned';\n            if (!isSecondaryRangeChannel(channel)) {\n              newFieldDef['type'] = QUANTITATIVE;\n            }\n          } else if (timeUnit) {\n            timeUnits.push({\n              timeUnit,\n              field,\n              as: newField\n            });\n\n            // define the format type for later compilation\n            const formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && 'time';\n            if (formatType) {\n              if (channel === TEXT || channel === TOOLTIP) {\n                newFieldDef['formatType'] = formatType;\n              } else if (isNonPositionScaleChannel(channel)) {\n                newFieldDef['legend'] = {\n                  formatType,\n                  ...newFieldDef['legend']\n                };\n              } else if (isXorY(channel)) {\n                newFieldDef['axis'] = {\n                  formatType,\n                  ...newFieldDef['axis']\n                };\n              }\n            }\n          }\n        }\n\n        // now the field should refer to post-transformed field instead\n        encoding[channel as any] = newFieldDef;\n      } else {\n        groupby.push(field);\n        encoding[channel as any] = oldEncoding[channel];\n      }\n    } else {\n      // For value def / signal ref / datum def, just copy\n      encoding[channel as any] = oldEncoding[channel];\n    }\n  });\n\n  return {\n    bins,\n    timeUnits,\n    aggregate,\n    groupby,\n    encoding\n  };\n}\n\nexport function markChannelCompatible(encoding: Encoding<string>, channel: Channel, mark: Mark) {\n  const markSupported = supportMark(channel, mark);\n  if (!markSupported) {\n    return false;\n  } else if (markSupported === 'binned') {\n    const primaryFieldDef = encoding[channel === X2 ? X : Y];\n\n    // circle, point, square and tick only support x2/y2 when their corresponding x/y fieldDef\n    // has \"binned\" data and thus need x2/y2 to specify the bin-end field.\n    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function initEncoding(\n  encoding: Encoding<string>,\n  mark: Mark,\n  filled: boolean,\n  config: Config\n): Encoding<string> {\n  const normalizedEncoding: Encoding<string> = {};\n  for (const key of keys(encoding)) {\n    if (!isChannel(key)) {\n      // Drop invalid channel\n      log.warn(log.message.invalidEncodingChannel(key));\n    }\n  }\n\n  for (let channel of UNIT_CHANNELS) {\n    if (!encoding[channel]) {\n      continue;\n    }\n\n    const channelDef = encoding[channel];\n    if (isXorYOffset(channel)) {\n      const mainChannel = getMainChannelFromOffsetChannel(channel);\n\n      const positionDef = normalizedEncoding[mainChannel];\n      if (isFieldDef(positionDef)) {\n        if (isContinuous(positionDef.type)) {\n          if (isFieldDef(channelDef)) {\n            // TODO: nesting continuous field instead continuous field should\n            // behave like offsetting the data in data domain\n            log.warn(log.message.offsetNestedInsideContinuousPositionScaleDropped(mainChannel));\n            continue;\n          }\n        }\n      } else {\n        // no x/y, replace it with main channel\n        channel = mainChannel;\n        log.warn(log.message.replaceOffsetWithMainChannel(mainChannel));\n      }\n    }\n\n    if (channel === 'angle' && mark === 'arc' && !encoding.theta) {\n      log.warn(log.message.REPLACE_ANGLE_WITH_THETA);\n      channel = THETA;\n    }\n\n    if (!markChannelCompatible(encoding, channel, mark)) {\n      // Drop unsupported channel\n      log.warn(log.message.incompatibleChannel(channel, mark));\n      continue;\n    }\n\n    // Drop line's size if the field is aggregated.\n    if (channel === SIZE && mark === 'line') {\n      const fieldDef = getFieldDef(encoding[channel]);\n      if (fieldDef?.aggregate) {\n        log.warn(log.message.LINE_WITH_VARYING_SIZE);\n        continue;\n      }\n    }\n    // Drop color if either fill or stroke is specified\n\n    if (channel === COLOR && (filled ? 'fill' in encoding : 'stroke' in encoding)) {\n      log.warn(log.message.droppingColor('encoding', {fill: 'fill' in encoding, stroke: 'stroke' in encoding}));\n      continue;\n    }\n\n    if (\n      channel === DETAIL ||\n      (channel === ORDER && !isArray(channelDef) && !isValueDef(channelDef)) ||\n      (channel === TOOLTIP && isArray(channelDef))\n    ) {\n      if (channelDef) {\n        // Array of fieldDefs for detail channel (or production rule)\n        (normalizedEncoding[channel] as any) = array(channelDef).reduce(\n          (defs: FieldDef<string>[], fieldDef: FieldDef<string>) => {\n            if (!isFieldDef(fieldDef)) {\n              log.warn(log.message.emptyFieldDef(fieldDef, channel));\n            } else {\n              defs.push(initFieldDef(fieldDef, channel));\n            }\n            return defs;\n          },\n          []\n        );\n      }\n    } else {\n      if (channel === TOOLTIP && channelDef === null) {\n        // Preserve null so we can use it to disable tooltip\n        normalizedEncoding[channel] = null;\n      } else if (\n        !isFieldDef(channelDef) &&\n        !isDatumDef(channelDef) &&\n        !isValueDef(channelDef) &&\n        !isConditionalDef(channelDef) &&\n        !isSignalRef(channelDef)\n      ) {\n        log.warn(log.message.emptyFieldDef(channelDef, channel));\n        continue;\n      }\n\n      normalizedEncoding[channel as any] = initChannelDef(channelDef as ChannelDef, channel, config);\n    }\n  }\n  return normalizedEncoding;\n}\n\n/**\n * For composite marks, we have to call initChannelDef during init so we can infer types earlier.\n */\nexport function normalizeEncoding(encoding: Encoding<string>, config: Config): Encoding<string> {\n  const normalizedEncoding: Encoding<string> = {};\n\n  for (const channel of keys(encoding)) {\n    const newChannelDef = initChannelDef(encoding[channel], channel, config, {compositeMark: true});\n    normalizedEncoding[channel as any] = newChannelDef;\n  }\n\n  return normalizedEncoding;\n}\n\nexport function fieldDefs<F extends Field>(encoding: EncodingWithFacet<F>): FieldDef<F>[] {\n  const arr: FieldDef<F>[] = [];\n  for (const channel of keys(encoding)) {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      const channelDefArray = array(channelDef);\n      for (const def of channelDefArray) {\n        if (isFieldDef(def)) {\n          arr.push(def);\n        } else if (hasConditionalFieldDef<F>(def)) {\n          arr.push(def.condition);\n        }\n      }\n    }\n  }\n  return arr;\n}\n\nexport function forEach<U extends Record<any, any>>(\n  mapping: U,\n  f: (cd: ChannelDef, c: keyof U) => void,\n  thisArg?: any\n) {\n  if (!mapping) {\n    return;\n  }\n\n  for (const channel of keys(mapping)) {\n    const el = mapping[channel];\n    if (isArray(el)) {\n      for (const channelDef of el as unknown[]) {\n        f.call(thisArg, channelDef, channel);\n      }\n    } else {\n      f.call(thisArg, el, channel);\n    }\n  }\n}\n\nexport function reduce<T, U extends Record<any, any>>(\n  mapping: U,\n  f: (acc: any, fd: TypedFieldDef<string>, c: keyof U) => U,\n  init: T,\n  thisArg?: any\n) {\n  if (!mapping) {\n    return init;\n  }\n\n  return keys(mapping).reduce((r, channel) => {\n    const map = mapping[channel];\n    if (isArray(map)) {\n      return map.reduce((r1: T, channelDef: ChannelDef) => {\n        return f.call(thisArg, r1, channelDef, channel);\n      }, r);\n    } else {\n      return f.call(thisArg, r, map, channel);\n    }\n  }, init);\n}\n\n/**\n * Returns list of path grouping fields for the given encoding\n */\nexport function pathGroupingFields(mark: Mark, encoding: Encoding<string>): string[] {\n  return keys(encoding).reduce((details, channel) => {\n    switch (channel) {\n      // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, aria label, cursor should not cause lines to group\n      case X:\n      case Y:\n      case HREF:\n      case DESCRIPTION:\n      case URL:\n      case X2:\n      case Y2:\n      case XOFFSET:\n      case YOFFSET:\n      case THETA:\n      case THETA2:\n      case RADIUS:\n      case RADIUS2:\n      // falls through\n\n      case LATITUDE:\n      case LONGITUDE:\n      case LATITUDE2:\n      case LONGITUDE2:\n      // TODO: case 'cursor':\n\n      // text, shape, shouldn't be a part of line/trail/area [falls through]\n      case TEXT:\n      case SHAPE:\n      case ANGLE:\n      // falls through\n\n      // tooltip fields should not be added to group by [falls through]\n      case TOOLTIP:\n        return details;\n\n      case ORDER:\n        // order should not group line / trail\n        if (mark === 'line' || mark === 'trail') {\n          return details;\n        }\n      // but order should group area for stacking (falls through)\n\n      case DETAIL:\n      case KEY: {\n        const channelDef = encoding[channel];\n        if (isArray(channelDef) || isFieldDef(channelDef)) {\n          for (const fieldDef of array(channelDef)) {\n            if (!fieldDef.aggregate) {\n              details.push(vgField(fieldDef, {}));\n            }\n          }\n        }\n        return details;\n      }\n\n      case SIZE:\n        if (mark === 'trail') {\n          // For trail, size should not group trail lines.\n          return details;\n        }\n      // For line, size should group lines.\n\n      // falls through\n      case COLOR:\n      case FILL:\n      case STROKE:\n      case OPACITY:\n      case FILLOPACITY:\n      case STROKEOPACITY:\n      case STROKEDASH:\n      case STROKEWIDTH: {\n        // TODO strokeDashOffset:\n        // falls through\n\n        const fieldDef = getFieldDef<string>(encoding[channel]);\n        if (fieldDef && !fieldDef.aggregate) {\n          details.push(vgField(fieldDef, {}));\n        }\n        return details;\n      }\n    }\n  }, []);\n}\n"]},"metadata":{},"sourceType":"module"}