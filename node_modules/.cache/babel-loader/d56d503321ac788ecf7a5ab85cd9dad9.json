{"ast":null,"code":"import { array } from 'vega-util';\nimport { SCALE_CHANNELS } from '../../../channel';\nimport { isPathMark } from '../../../mark';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { VG_MARK_CONFIGS } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { aria } from './aria';\nimport { color } from './color';\nimport { nonPosition } from './nonposition';\nimport { text } from './text';\nimport { tooltip } from './tooltip';\nimport { fieldInvalidPredicate } from './valueref';\nimport { zindex } from './zindex';\nexport { color } from './color';\nexport { wrapCondition } from './conditional';\nexport { nonPosition } from './nonposition';\nexport { pointPosition } from './position-point';\nexport { pointOrRangePosition, rangePosition } from './position-range';\nexport { rectPosition } from './position-rect';\nexport { text } from './text';\nexport { tooltip } from './tooltip';\nconst ALWAYS_IGNORE = new Set(['aria', 'width', 'height']);\nexport function baseEncodeEntry(model, ignore) {\n  const {\n    fill = undefined,\n    stroke = undefined\n  } = ignore.color === 'include' ? color(model) : {};\n  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, markDefProperties(model.markDef, ignore)), wrapAllFieldsInvalid(model, 'fill', fill)), wrapAllFieldsInvalid(model, 'stroke', stroke)), nonPosition('opacity', model)), nonPosition('fillOpacity', model)), nonPosition('strokeOpacity', model)), nonPosition('strokeWidth', model)), nonPosition('strokeDash', model)), zindex(model)), tooltip(model)), text(model, 'href')), aria(model));\n} // TODO: mark VgValueRef[] as readonly after https://github.com/vega/vega/pull/1987\n\nfunction wrapAllFieldsInvalid(model, channel, valueRef) {\n  const {\n    config,\n    mark,\n    markDef\n  } = model;\n  const invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid === 'hide' && valueRef && !isPathMark(mark)) {\n    // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n    // For path marks, we will use \"defined\" property and skip these values instead.\n    const test = allFieldsInvalidPredicate(model, {\n      invalid: true,\n      channels: SCALE_CHANNELS\n    });\n\n    if (test) {\n      return {\n        [channel]: [// prepend the invalid case\n        // TODO: support custom value\n        {\n          test,\n          value: null\n        }, ...array(valueRef)]\n      };\n    }\n  }\n\n  return valueRef ? {\n    [channel]: valueRef\n  } : {};\n}\n\nfunction markDefProperties(mark, ignore) {\n  return VG_MARK_CONFIGS.reduce((m, prop) => {\n    if (!ALWAYS_IGNORE.has(prop) && mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n      m[prop] = signalOrValueRef(mark[prop]);\n    }\n\n    return m;\n  }, {});\n}\n\nfunction allFieldsInvalidPredicate(model, _ref) {\n  let {\n    invalid = false,\n    channels\n  } = _ref;\n  const filterIndex = channels.reduce((aggregator, channel) => {\n    const scaleComponent = model.getScaleComponent(channel);\n\n    if (scaleComponent) {\n      const scaleType = scaleComponent.get('type');\n      const field = model.vgField(channel, {\n        expr: 'datum'\n      }); // While discrete domain scales can handle invalid values, continuous scales can't.\n\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n\n    return aggregator;\n  }, {});\n  const fields = keys(filterIndex);\n\n  if (fields.length > 0) {\n    const op = invalid ? '||' : '&&';\n    return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n  }\n\n  return undefined;\n}","map":{"version":3,"mappings":"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","names":["array","SCALE_CHANNELS","isPathMark","hasContinuousDomain","keys","VG_MARK_CONFIGS","getMarkPropOrConfig","signalOrValueRef","aria","color","nonPosition","text","tooltip","fieldInvalidPredicate","zindex","wrapCondition","pointPosition","pointOrRangePosition","rangePosition","rectPosition","ALWAYS_IGNORE","Set","baseEncodeEntry","model","ignore","fill","undefined","stroke","markDefProperties","markDef","wrapAllFieldsInvalid","channel","valueRef","config","mark","invalid","test","allFieldsInvalidPredicate","channels","value","reduce","m","prop","has","filterIndex","aggregator","scaleComponent","getScaleComponent","scaleType","get","field","vgField","expr","fields","length","op","map","join"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/mark/encode/base.ts"],"sourcesContent":["import {array} from 'vega-util';\nimport {Channel, ScaleChannel, SCALE_CHANNELS} from '../../../channel';\nimport {isPathMark, MarkDef} from '../../../mark';\nimport {hasContinuousDomain} from '../../../scale';\nimport {Dict, keys} from '../../../util';\nimport {VgEncodeEntry, VgValueRef, VG_MARK_CONFIGS} from '../../../vega.schema';\nimport {getMarkPropOrConfig, signalOrValueRef} from '../../common';\nimport {UnitModel} from '../../unit';\nimport {aria} from './aria';\nimport {color} from './color';\nimport {nonPosition} from './nonposition';\nimport {text} from './text';\nimport {tooltip} from './tooltip';\nimport {fieldInvalidPredicate} from './valueref';\nimport {zindex} from './zindex';\n\nexport {color} from './color';\nexport {wrapCondition} from './conditional';\nexport {nonPosition} from './nonposition';\nexport {pointPosition} from './position-point';\nexport {pointOrRangePosition, rangePosition} from './position-range';\nexport {rectPosition} from './position-rect';\nexport {text} from './text';\nexport {tooltip} from './tooltip';\n\nexport type Ignore = Record<'color' | 'size' | 'orient' | 'align' | 'baseline' | 'theta', 'ignore' | 'include'>;\n\nconst ALWAYS_IGNORE = new Set(['aria', 'width', 'height']);\n\nexport function baseEncodeEntry(model: UnitModel, ignore: Ignore) {\n  const {fill = undefined, stroke = undefined} = ignore.color === 'include' ? color(model) : {};\n  return {\n    ...markDefProperties(model.markDef, ignore),\n    ...wrapAllFieldsInvalid(model, 'fill', fill),\n    ...wrapAllFieldsInvalid(model, 'stroke', stroke),\n    ...nonPosition('opacity', model),\n    ...nonPosition('fillOpacity', model),\n    ...nonPosition('strokeOpacity', model),\n    ...nonPosition('strokeWidth', model),\n    ...nonPosition('strokeDash', model),\n    ...zindex(model),\n    ...tooltip(model),\n    ...text(model, 'href'),\n    ...aria(model)\n  };\n}\n\n// TODO: mark VgValueRef[] as readonly after https://github.com/vega/vega/pull/1987\nfunction wrapAllFieldsInvalid(model: UnitModel, channel: Channel, valueRef: VgValueRef | VgValueRef[]): VgEncodeEntry {\n  const {config, mark, markDef} = model;\n\n  const invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid === 'hide' && valueRef && !isPathMark(mark)) {\n    // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n    // For path marks, we will use \"defined\" property and skip these values instead.\n    const test = allFieldsInvalidPredicate(model, {invalid: true, channels: SCALE_CHANNELS});\n    if (test) {\n      return {\n        [channel]: [\n          // prepend the invalid case\n          // TODO: support custom value\n          {test, value: null},\n          ...array(valueRef)\n        ]\n      };\n    }\n  }\n  return valueRef ? {[channel]: valueRef} : {};\n}\n\nfunction markDefProperties(mark: MarkDef, ignore: Ignore) {\n  return VG_MARK_CONFIGS.reduce((m, prop) => {\n    if (!ALWAYS_IGNORE.has(prop) && mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n      m[prop] = signalOrValueRef(mark[prop]);\n    }\n    return m;\n  }, {});\n}\n\nfunction allFieldsInvalidPredicate(\n  model: UnitModel,\n  {invalid = false, channels}: {invalid?: boolean; channels: ScaleChannel[]}\n) {\n  const filterIndex = channels.reduce((aggregator: Dict<true>, channel) => {\n    const scaleComponent = model.getScaleComponent(channel);\n    if (scaleComponent) {\n      const scaleType = scaleComponent.get('type');\n      const field = model.vgField(channel, {expr: 'datum'});\n\n      // While discrete domain scales can handle invalid values, continuous scales can't.\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n    return aggregator;\n  }, {});\n\n  const fields = keys(filterIndex);\n  if (fields.length > 0) {\n    const op = invalid ? '||' : '&&';\n    return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n  }\n  return undefined;\n}\n"]},"metadata":{},"sourceType":"module"}