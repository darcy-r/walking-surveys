{"ast":null,"code":"import { contains } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { isConcatModel, isLayerModel } from '../model';\nexport function assembleProjections(model) {\n  if (isLayerModel(model) || isConcatModel(model)) {\n    return assembleProjectionsForModelAndChildren(model);\n  } else {\n    return assembleProjectionForModel(model);\n  }\n}\nexport function assembleProjectionsForModelAndChildren(model) {\n  return model.children.reduce((projections, child) => {\n    return projections.concat(child.assembleProjections());\n  }, assembleProjectionForModel(model));\n}\nexport function assembleProjectionForModel(model) {\n  const component = model.component.projection;\n\n  if (!component || component.merged) {\n    return [];\n  }\n\n  const projection = component.combine();\n  const {\n    name\n  } = projection; // we need to extract name so that it is always present in the output and pass TS type validation\n\n  if (!component.data) {\n    // generate custom projection, no automatic fitting\n    return [Object.assign(Object.assign({\n      name\n    }, {\n      translate: {\n        signal: '[width / 2, height / 2]'\n      }\n    }), projection)];\n  } else {\n    // generate projection that uses extent fitting\n    const size = {\n      signal: `[${component.size.map(ref => ref.signal).join(', ')}]`\n    };\n    const fits = component.data.reduce((sources, data) => {\n      const source = isSignalRef(data) ? data.signal : `data('${model.lookupDataSource(data)}')`;\n\n      if (!contains(sources, source)) {\n        // build a unique list of sources\n        sources.push(source);\n      }\n\n      return sources;\n    }, []);\n\n    if (fits.length <= 0) {\n      throw new Error(\"Projection's fit didn't find any data sources\");\n    }\n\n    return [Object.assign({\n      name,\n      size,\n      fit: {\n        signal: fits.length > 1 ? `[${fits.join(', ')}]` : fits[0]\n      }\n    }, projection)];\n  }\n}","map":{"version":3,"mappings":"AACA,SAAQA,QAAR,QAAuB,YAAvB;AACA,SAAQC,WAAR,QAA0B,mBAA1B;AACA,SAAQC,aAAR,EAAuBC,YAAvB,QAAiD,UAAjD;AAEA,OAAM,SAAUC,mBAAV,CAA8BC,KAA9B,EAA0C;EAC9C,IAAIF,YAAY,CAACE,KAAD,CAAZ,IAAuBH,aAAa,CAACG,KAAD,CAAxC,EAAiD;IAC/C,OAAOC,sCAAsC,CAACD,KAAD,CAA7C;EACD,CAFD,MAEO;IACL,OAAOE,0BAA0B,CAACF,KAAD,CAAjC;EACD;AACF;AAED,OAAM,SAAUC,sCAAV,CAAiDD,KAAjD,EAA6D;EACjE,OAAOA,KAAK,CAACG,QAAN,CAAeC,MAAf,CAAsB,CAACC,WAAD,EAAcC,KAAd,KAAuB;IAClD,OAAOD,WAAW,CAACE,MAAZ,CAAmBD,KAAK,CAACP,mBAAN,EAAnB,CAAP;EACD,CAFM,EAEJG,0BAA0B,CAACF,KAAD,CAFtB,CAAP;AAGD;AAED,OAAM,SAAUE,0BAAV,CAAqCF,KAArC,EAAiD;EACrD,MAAMQ,SAAS,GAAGR,KAAK,CAACQ,SAAN,CAAgBC,UAAlC;;EACA,IAAI,CAACD,SAAD,IAAcA,SAAS,CAACE,MAA5B,EAAoC;IAClC,OAAO,EAAP;EACD;;EAED,MAAMD,UAAU,GAAGD,SAAS,CAACG,OAAV,EAAnB;EACA,MAAM;IAACC;EAAD,IAASH,UAAf,CAPqD,CAO1B;;EAE3B,IAAI,CAACD,SAAS,CAACK,IAAf,EAAqB;IACnB;IACA,OAAO;MAEHD;OAEG;MAACE,SAAS,EAAE;QAACC,MAAM,EAAE;MAAT;IAAZ,IAEAN,WANA,CAAP;EASD,CAXD,MAWO;IACL;IACA,MAAMO,IAAI,GAAc;MACtBD,MAAM,EAAE,IAAIP,SAAS,CAACQ,IAAV,CAAeC,GAAf,CAAmBC,GAAG,IAAIA,GAAG,CAACH,MAA9B,EAAsCI,IAAtC,CAA2C,IAA3C,CAAgD;IADtC,CAAxB;IAIA,MAAMC,IAAI,GAAaZ,SAAS,CAACK,IAAV,CAAeT,MAAf,CAAsB,CAACiB,OAAD,EAAUR,IAAV,KAAkB;MAC7D,MAAMS,MAAM,GAAW1B,WAAW,CAACiB,IAAD,CAAX,GAAoBA,IAAI,CAACE,MAAzB,GAAkC,SAASf,KAAK,CAACuB,gBAAN,CAAuBV,IAAvB,CAA4B,IAA9F;;MACA,IAAI,CAAClB,QAAQ,CAAC0B,OAAD,EAAUC,MAAV,CAAb,EAAgC;QAC9B;QACAD,OAAO,CAACG,IAAR,CAAaF,MAAb;MACD;;MACD,OAAOD,OAAP;IACD,CAPsB,EAOpB,EAPoB,CAAvB;;IASA,IAAID,IAAI,CAACK,MAAL,IAAe,CAAnB,EAAsB;MACpB,MAAM,IAAIC,KAAJ,CAAU,+CAAV,CAAN;IACD;;IAED,OAAO;MAEHd;MACAI;MACAW,GAAG,EAAE;QACHZ,MAAM,EAAEK,IAAI,CAACK,MAAL,GAAc,CAAd,GAAkB,IAAIL,IAAI,CAACD,IAAL,CAAU,IAAV,CAAe,GAArC,GAA2CC,IAAI,CAAC,CAAD;MADpD;OAGFX,WAPA,CAAP;EAUD;AACF","names":["contains","isSignalRef","isConcatModel","isLayerModel","assembleProjections","model","assembleProjectionsForModelAndChildren","assembleProjectionForModel","children","reduce","projections","child","concat","component","projection","merged","combine","name","data","translate","signal","size","map","ref","join","fits","sources","source","lookupDataSource","push","length","Error","fit"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/projection/assemble.ts"],"sourcesContent":["import {Projection as VgProjection, SignalRef} from 'vega';\nimport {contains} from '../../util';\nimport {isSignalRef} from '../../vega.schema';\nimport {isConcatModel, isLayerModel, Model} from '../model';\n\nexport function assembleProjections(model: Model): VgProjection[] {\n  if (isLayerModel(model) || isConcatModel(model)) {\n    return assembleProjectionsForModelAndChildren(model);\n  } else {\n    return assembleProjectionForModel(model);\n  }\n}\n\nexport function assembleProjectionsForModelAndChildren(model: Model): VgProjection[] {\n  return model.children.reduce((projections, child) => {\n    return projections.concat(child.assembleProjections());\n  }, assembleProjectionForModel(model));\n}\n\nexport function assembleProjectionForModel(model: Model): VgProjection[] {\n  const component = model.component.projection;\n  if (!component || component.merged) {\n    return [];\n  }\n\n  const projection = component.combine();\n  const {name} = projection; // we need to extract name so that it is always present in the output and pass TS type validation\n\n  if (!component.data) {\n    // generate custom projection, no automatic fitting\n    return [\n      {\n        name,\n        // translate to center by default\n        ...{translate: {signal: '[width / 2, height / 2]'}},\n        // parameters, overwrite default translate if specified\n        ...projection\n      }\n    ];\n  } else {\n    // generate projection that uses extent fitting\n    const size: SignalRef = {\n      signal: `[${component.size.map(ref => ref.signal).join(', ')}]`\n    };\n\n    const fits: string[] = component.data.reduce((sources, data) => {\n      const source: string = isSignalRef(data) ? data.signal : `data('${model.lookupDataSource(data)}')`;\n      if (!contains(sources, source)) {\n        // build a unique list of sources\n        sources.push(source);\n      }\n      return sources;\n    }, []);\n\n    if (fits.length <= 0) {\n      throw new Error(\"Projection's fit didn't find any data sources\");\n    }\n\n    return [\n      {\n        name,\n        size,\n        fit: {\n          signal: fits.length > 1 ? `[${fits.join(', ')}]` : fits[0]\n        },\n        ...projection\n      }\n    ];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}