{"ast":null,"code":"import { identity, array, isFunction, constant, isArray, id, error, truthy, debounce, extend, visitArray, inherits, logger, Error, hasOwnProperty } from 'vega-util';\nimport { read, responseType, loader } from 'vega-loader';\nimport { defaultLocale } from 'vega-format';\n\nfunction UniqueList(idFunc) {\n  const $ = idFunc || identity,\n        list = [],\n        ids = {};\n\n  list.add = _ => {\n    const id = $(_);\n\n    if (!ids[id]) {\n      ids[id] = 1;\n      list.push(_);\n    }\n\n    return list;\n  };\n\n  list.remove = _ => {\n    const id = $(_);\n\n    if (ids[id]) {\n      ids[id] = 0;\n      const idx = list.indexOf(_);\n      if (idx >= 0) list.splice(idx, 1);\n    }\n\n    return list;\n  };\n\n  return list;\n}\n/**\n * Invoke and await a potentially async callback function. If\n * an error occurs, trap it and route to Dataflow.error.\n * @param {Dataflow} df - The dataflow instance\n * @param {function} callback - A callback function to invoke\n *   and then await. The dataflow will be passed as the single\n *   argument to the function.\n */\n\n\nasync function asyncCallback(df, callback) {\n  try {\n    await callback(df);\n  } catch (err) {\n    df.error(err);\n  }\n}\n\nconst TUPLE_ID_KEY = Symbol('vega_id');\nlet TUPLE_ID = 1;\n/**\n * Checks if an input value is a registered tuple.\n * @param {*} t - The value to check.\n * @return {boolean} True if the input is a tuple, false otherwise.\n */\n\nfunction isTuple(t) {\n  return !!(t && tupleid(t));\n}\n/**\n * Returns the id of a tuple.\n * @param {object} t - The input tuple.\n * @return {*} the tuple id.\n */\n\n\nfunction tupleid(t) {\n  return t[TUPLE_ID_KEY];\n}\n/**\n * Sets the id of a tuple.\n * @param {object} t - The input tuple.\n * @param {*} id - The id value to set.\n * @return {object} the input tuple.\n */\n\n\nfunction setid(t, id) {\n  t[TUPLE_ID_KEY] = id;\n  return t;\n}\n/**\n * Ingest an object or value as a data tuple.\n * If the input value is an object, an id field will be added to it. For\n * efficiency, the input object is modified directly. A copy is not made.\n * If the input value is a literal, it will be wrapped in a new object\n * instance, with the value accessible as the 'data' property.\n * @param datum - The value to ingest.\n * @return {object} The ingested data tuple.\n */\n\n\nfunction ingest$1(datum) {\n  const t = datum === Object(datum) ? datum : {\n    data: datum\n  };\n  return tupleid(t) ? t : setid(t, TUPLE_ID++);\n}\n/**\n * Given a source tuple, return a derived copy.\n * @param {object} t - The source tuple.\n * @return {object} The derived tuple.\n */\n\n\nfunction derive(t) {\n  return rederive(t, ingest$1({}));\n}\n/**\n * Rederive a derived tuple by copying values from the source tuple.\n * @param {object} t - The source tuple.\n * @param {object} d - The derived tuple.\n * @return {object} The derived tuple.\n */\n\n\nfunction rederive(t, d) {\n  for (const k in t) d[k] = t[k];\n\n  return d;\n}\n/**\n * Replace an existing tuple with a new tuple.\n * @param {object} t - The existing data tuple.\n * @param {object} d - The new tuple that replaces the old.\n * @return {object} The new tuple.\n */\n\n\nfunction replace(t, d) {\n  return setid(d, tupleid(t));\n}\n/**\n * Generate an augmented comparator function that provides stable\n * sorting by tuple id when the given comparator produces ties.\n * @param {function} cmp - The comparator to augment.\n * @param {function} [f] - Optional tuple accessor function.\n * @return {function} An augmented comparator function.\n */\n\n\nfunction stableCompare(cmp, f) {\n  return !cmp ? null : f ? (a, b) => cmp(a, b) || tupleid(f(a)) - tupleid(f(b)) : (a, b) => cmp(a, b) || tupleid(a) - tupleid(b);\n}\n\nfunction isChangeSet(v) {\n  return v && v.constructor === changeset;\n}\n\nfunction changeset() {\n  const add = [],\n        // insert tuples\n  rem = [],\n        // remove tuples\n  mod = [],\n        // modify tuples\n  remp = [],\n        // remove by predicate\n  modp = []; // modify by predicate\n\n  let clean = null,\n      reflow = false;\n  return {\n    constructor: changeset,\n\n    insert(t) {\n      const d = array(t),\n            n = d.length;\n\n      for (let i = 0; i < n; ++i) add.push(d[i]);\n\n      return this;\n    },\n\n    remove(t) {\n      const a = isFunction(t) ? remp : rem,\n            d = array(t),\n            n = d.length;\n\n      for (let i = 0; i < n; ++i) a.push(d[i]);\n\n      return this;\n    },\n\n    modify(t, field, value) {\n      const m = {\n        field: field,\n        value: constant(value)\n      };\n\n      if (isFunction(t)) {\n        m.filter = t;\n        modp.push(m);\n      } else {\n        m.tuple = t;\n        mod.push(m);\n      }\n\n      return this;\n    },\n\n    encode(t, set) {\n      if (isFunction(t)) modp.push({\n        filter: t,\n        field: set\n      });else mod.push({\n        tuple: t,\n        field: set\n      });\n      return this;\n    },\n\n    clean(value) {\n      clean = value;\n      return this;\n    },\n\n    reflow() {\n      reflow = true;\n      return this;\n    },\n\n    pulse(pulse, tuples) {\n      const cur = {},\n            out = {};\n      let i, n, m, f, t, id; // build lookup table of current tuples\n\n      for (i = 0, n = tuples.length; i < n; ++i) {\n        cur[tupleid(tuples[i])] = 1;\n      } // process individual tuples to remove\n\n\n      for (i = 0, n = rem.length; i < n; ++i) {\n        t = rem[i];\n        cur[tupleid(t)] = -1;\n      } // process predicate-based removals\n\n\n      for (i = 0, n = remp.length; i < n; ++i) {\n        f = remp[i];\n        tuples.forEach(t => {\n          if (f(t)) cur[tupleid(t)] = -1;\n        });\n      } // process all add tuples\n\n\n      for (i = 0, n = add.length; i < n; ++i) {\n        t = add[i];\n        id = tupleid(t);\n\n        if (cur[id]) {\n          // tuple already resides in dataset\n          // if flagged for both add and remove, cancel\n          cur[id] = 1;\n        } else {\n          // tuple does not reside in dataset, add\n          pulse.add.push(ingest$1(add[i]));\n        }\n      } // populate pulse rem list\n\n\n      for (i = 0, n = tuples.length; i < n; ++i) {\n        t = tuples[i];\n        if (cur[tupleid(t)] < 0) pulse.rem.push(t);\n      } // modify helper method\n\n\n      function modify(t, f, v) {\n        if (v) {\n          t[f] = v(t);\n        } else {\n          pulse.encode = f;\n        }\n\n        if (!reflow) out[tupleid(t)] = t;\n      } // process individual tuples to modify\n\n\n      for (i = 0, n = mod.length; i < n; ++i) {\n        m = mod[i];\n        t = m.tuple;\n        f = m.field;\n        id = cur[tupleid(t)];\n\n        if (id > 0) {\n          modify(t, f, m.value);\n          pulse.modifies(f);\n        }\n      } // process predicate-based modifications\n\n\n      for (i = 0, n = modp.length; i < n; ++i) {\n        m = modp[i];\n        f = m.filter;\n        tuples.forEach(t => {\n          if (f(t) && cur[tupleid(t)] > 0) {\n            modify(t, m.field, m.value);\n          }\n        });\n        pulse.modifies(m.field);\n      } // upon reflow request, populate mod with all non-removed tuples\n      // otherwise, populate mod with modified tuples only\n\n\n      if (reflow) {\n        pulse.mod = rem.length || remp.length ? tuples.filter(t => cur[tupleid(t)] > 0) : tuples.slice();\n      } else {\n        for (id in out) pulse.mod.push(out[id]);\n      } // set pulse garbage collection request\n\n\n      if (clean || clean == null && (rem.length || remp.length)) {\n        pulse.clean(true);\n      }\n\n      return pulse;\n    }\n\n  };\n}\n\nconst CACHE = '_:mod:_';\n/**\n * Hash that tracks modifications to assigned values.\n * Callers *must* use the set method to update values.\n */\n\nfunction Parameters() {\n  Object.defineProperty(this, CACHE, {\n    writable: true,\n    value: {}\n  });\n}\n\nParameters.prototype = {\n  /**\n   * Set a parameter value. If the parameter value changes, the parameter\n   * will be recorded as modified.\n   * @param {string} name - The parameter name.\n   * @param {number} index - The index into an array-value parameter. Ignored if\n   *   the argument is undefined, null or less than zero.\n   * @param {*} value - The parameter value to set.\n   * @param {boolean} [force=false] - If true, records the parameter as modified\n   *   even if the value is unchanged.\n   * @return {Parameters} - This parameter object.\n   */\n  set(name, index, value, force) {\n    const o = this,\n          v = o[name],\n          mod = o[CACHE];\n\n    if (index != null && index >= 0) {\n      if (v[index] !== value || force) {\n        v[index] = value;\n        mod[index + ':' + name] = -1;\n        mod[name] = -1;\n      }\n    } else if (v !== value || force) {\n      o[name] = value;\n      mod[name] = isArray(value) ? 1 + value.length : -1;\n    }\n\n    return o;\n  },\n\n  /**\n   * Tests if one or more parameters has been modified. If invoked with no\n   * arguments, returns true if any parameter value has changed. If the first\n   * argument is array, returns trues if any parameter name in the array has\n   * changed. Otherwise, tests if the given name and optional array index has\n   * changed.\n   * @param {string} name - The parameter name to test.\n   * @param {number} [index=undefined] - The parameter array index to test.\n   * @return {boolean} - Returns true if a queried parameter was modified.\n   */\n  modified(name, index) {\n    const mod = this[CACHE];\n\n    if (!arguments.length) {\n      for (const k in mod) {\n        if (mod[k]) return true;\n      }\n\n      return false;\n    } else if (isArray(name)) {\n      for (let k = 0; k < name.length; ++k) {\n        if (mod[name[k]]) return true;\n      }\n\n      return false;\n    }\n\n    return index != null && index >= 0 ? index + 1 < mod[name] || !!mod[index + ':' + name] : !!mod[name];\n  },\n\n  /**\n   * Clears the modification records. After calling this method,\n   * all parameters are considered unmodified.\n   */\n  clear() {\n    this[CACHE] = {};\n    return this;\n  }\n\n};\nlet OP_ID = 0;\nconst PULSE = 'pulse',\n      NO_PARAMS = new Parameters(); // Boolean Flags\n\nconst SKIP$1 = 1,\n      MODIFIED = 2;\n/**\n * An Operator is a processing node in a dataflow graph.\n * Each operator stores a value and an optional value update function.\n * Operators can accept a hash of named parameters. Parameter values can\n * either be direct (JavaScript literals, arrays, objects) or indirect\n * (other operators whose values will be pulled dynamically). Operators\n * included as parameters will have this operator added as a dependency.\n * @constructor\n * @param {*} [init] - The initial value for this operator.\n * @param {function(object, Pulse)} [update] - An update function. Upon\n *   evaluation of this operator, the update function will be invoked and the\n *   return value will be used as the new value of this operator.\n * @param {object} [params] - The parameters for this operator.\n * @param {boolean} [react=true] - Flag indicating if this operator should\n *   listen for changes to upstream operators included as parameters.\n * @see parameters\n */\n\nfunction Operator(init, update, params, react) {\n  this.id = ++OP_ID;\n  this.value = init;\n  this.stamp = -1;\n  this.rank = -1;\n  this.qrank = -1;\n  this.flags = 0;\n\n  if (update) {\n    this._update = update;\n  }\n\n  if (params) this.parameters(params, react);\n}\n\nfunction flag(bit) {\n  return function (state) {\n    const f = this.flags;\n    if (arguments.length === 0) return !!(f & bit);\n    this.flags = state ? f | bit : f & ~bit;\n    return this;\n  };\n}\n\nOperator.prototype = {\n  /**\n   * Returns a list of target operators dependent on this operator.\n   * If this list does not exist, it is created and then returned.\n   * @return {UniqueList}\n   */\n  targets() {\n    return this._targets || (this._targets = UniqueList(id));\n  },\n\n  /**\n   * Sets the value of this operator.\n   * @param {*} value - the value to set.\n   * @return {Number} Returns 1 if the operator value has changed\n   *   according to strict equality, returns 0 otherwise.\n   */\n  set(value) {\n    if (this.value !== value) {\n      this.value = value;\n      return 1;\n    } else {\n      return 0;\n    }\n  },\n\n  /**\n   * Indicates that operator evaluation should be skipped on the next pulse.\n   * This operator will still propagate incoming pulses, but its update function\n   * will not be invoked. The skip flag is reset after every pulse, so calling\n   * this method will affect processing of the next pulse only.\n   */\n  skip: flag(SKIP$1),\n\n  /**\n   * Indicates that this operator's value has been modified on its most recent\n   * pulse. Normally modification is checked via strict equality; however, in\n   * some cases it is more efficient to update the internal state of an object.\n   * In those cases, the modified flag can be used to trigger propagation. Once\n   * set, the modification flag persists across pulses until unset. The flag can\n   * be used with the last timestamp to test if a modification is recent.\n   */\n  modified: flag(MODIFIED),\n\n  /**\n   * Sets the parameters for this operator. The parameter values are analyzed for\n   * operator instances. If found, this operator will be added as a dependency\n   * of the parameterizing operator. Operator values are dynamically marshalled\n   * from each operator parameter prior to evaluation. If a parameter value is\n   * an array, the array will also be searched for Operator instances. However,\n   * the search does not recurse into sub-arrays or object properties.\n   * @param {object} params - A hash of operator parameters.\n   * @param {boolean} [react=true] - A flag indicating if this operator should\n   *   automatically update (react) when parameter values change. In other words,\n   *   this flag determines if the operator registers itself as a listener on\n   *   any upstream operators included in the parameters.\n   * @param {boolean} [initonly=false] - A flag indicating if this operator\n   *   should calculate an update only upon its initiatal evaluation, then\n   *   deregister dependencies and suppress all future update invocations.\n   * @return {Operator[]} - An array of upstream dependencies.\n   */\n  parameters(params, react, initonly) {\n    react = react !== false;\n    const argval = this._argval = this._argval || new Parameters(),\n          argops = this._argops = this._argops || [],\n          deps = [];\n    let name, value, n, i;\n\n    const add = (name, index, value) => {\n      if (value instanceof Operator) {\n        if (value !== this) {\n          if (react) value.targets().add(this);\n          deps.push(value);\n        }\n\n        argops.push({\n          op: value,\n          name: name,\n          index: index\n        });\n      } else {\n        argval.set(name, index, value);\n      }\n    };\n\n    for (name in params) {\n      value = params[name];\n\n      if (name === PULSE) {\n        array(value).forEach(op => {\n          if (!(op instanceof Operator)) {\n            error('Pulse parameters must be operator instances.');\n          } else if (op !== this) {\n            op.targets().add(this);\n            deps.push(op);\n          }\n        });\n        this.source = value;\n      } else if (isArray(value)) {\n        argval.set(name, -1, Array(n = value.length));\n\n        for (i = 0; i < n; ++i) add(name, i, value[i]);\n      } else {\n        add(name, -1, value);\n      }\n    }\n\n    this.marshall().clear(); // initialize values\n\n    if (initonly) argops.initonly = true;\n    return deps;\n  },\n\n  /**\n   * Internal method for marshalling parameter values.\n   * Visits each operator dependency to pull the latest value.\n   * @return {Parameters} A Parameters object to pass to the update function.\n   */\n  marshall(stamp) {\n    const argval = this._argval || NO_PARAMS,\n          argops = this._argops;\n    let item, i, op, mod;\n\n    if (argops) {\n      const n = argops.length;\n\n      for (i = 0; i < n; ++i) {\n        item = argops[i];\n        op = item.op;\n        mod = op.modified() && op.stamp === stamp;\n        argval.set(item.name, item.index, op.value, mod);\n      }\n\n      if (argops.initonly) {\n        for (i = 0; i < n; ++i) {\n          item = argops[i];\n          item.op.targets().remove(this);\n        }\n\n        this._argops = null;\n        this._update = null;\n      }\n    }\n\n    return argval;\n  },\n\n  /**\n   * Detach this operator from the dataflow.\n   * Unregisters listeners on upstream dependencies.\n   */\n  detach() {\n    const argops = this._argops;\n    let i, n, item, op;\n\n    if (argops) {\n      for (i = 0, n = argops.length; i < n; ++i) {\n        item = argops[i];\n        op = item.op;\n\n        if (op._targets) {\n          op._targets.remove(this);\n        }\n      }\n    } // remove references to the source and pulse object,\n    // if present, to prevent memory leaks of old data.\n\n\n    this.pulse = null;\n    this.source = null;\n  },\n\n  /**\n   * Delegate method to perform operator processing.\n   * Subclasses can override this method to perform custom processing.\n   * By default, it marshalls parameters and calls the update function\n   * if that function is defined. If the update function does not\n   * change the operator value then StopPropagation is returned.\n   * If no update function is defined, this method does nothing.\n   * @param {Pulse} pulse - the current dataflow pulse.\n   * @return The output pulse or StopPropagation. A falsy return value\n   *   (including undefined) will let the input pulse pass through.\n   */\n  evaluate(pulse) {\n    const update = this._update;\n\n    if (update) {\n      const params = this.marshall(pulse.stamp),\n            v = update.call(this, params, pulse);\n      params.clear();\n\n      if (v !== this.value) {\n        this.value = v;\n      } else if (!this.modified()) {\n        return pulse.StopPropagation;\n      }\n    }\n  },\n\n  /**\n   * Run this operator for the current pulse. If this operator has already\n   * been run at (or after) the pulse timestamp, returns StopPropagation.\n   * Internally, this method calls {@link evaluate} to perform processing.\n   * If {@link evaluate} returns a falsy value, the input pulse is returned.\n   * This method should NOT be overridden, instead overrride {@link evaluate}.\n   * @param {Pulse} pulse - the current dataflow pulse.\n   * @return the output pulse for this operator (or StopPropagation)\n   */\n  run(pulse) {\n    if (pulse.stamp < this.stamp) return pulse.StopPropagation;\n    let rv;\n\n    if (this.skip()) {\n      this.skip(false);\n      rv = 0;\n    } else {\n      rv = this.evaluate(pulse);\n    }\n\n    return this.pulse = rv || pulse;\n  }\n\n};\n/**\n * Add an operator to the dataflow graph. This function accepts a\n * variety of input argument types. The basic signature supports an\n * initial value, update function and parameters. If the first parameter\n * is an Operator instance, it will be added directly. If it is a\n * constructor for an Operator subclass, a new instance will be instantiated.\n * Otherwise, if the first parameter is a function instance, it will be used\n * as the update function and a null initial value is assumed.\n * @param {*} init - One of: the operator to add, the initial value of\n *   the operator, an operator class to instantiate, or an update function.\n * @param {function} [update] - The operator update function.\n * @param {object} [params] - The operator parameters.\n * @param {boolean} [react=true] - Flag indicating if this operator should\n *   listen for changes to upstream operators included as parameters.\n * @return {Operator} - The added operator.\n */\n\nfunction add(init, update, params, react) {\n  let shift = 1,\n      op;\n\n  if (init instanceof Operator) {\n    op = init;\n  } else if (init && init.prototype instanceof Operator) {\n    op = new init();\n  } else if (isFunction(init)) {\n    op = new Operator(null, init);\n  } else {\n    shift = 0;\n    op = new Operator(init, update);\n  }\n\n  this.rank(op);\n\n  if (shift) {\n    react = params;\n    params = update;\n  }\n\n  if (params) this.connect(op, op.parameters(params, react));\n  this.touch(op);\n  return op;\n}\n/**\n * Connect a target operator as a dependent of source operators.\n * If necessary, this method will rerank the target operator and its\n * dependents to ensure propagation proceeds in a topologically sorted order.\n * @param {Operator} target - The target operator.\n * @param {Array<Operator>} - The source operators that should propagate\n *   to the target operator.\n */\n\n\nfunction connect(target, sources) {\n  const targetRank = target.rank,\n        n = sources.length;\n\n  for (let i = 0; i < n; ++i) {\n    if (targetRank < sources[i].rank) {\n      this.rerank(target);\n      return;\n    }\n  }\n}\n\nlet STREAM_ID = 0;\n/**\n * Models an event stream.\n * @constructor\n * @param {function(Object, number): boolean} [filter] - Filter predicate.\n *   Events pass through when truthy, events are suppressed when falsy.\n * @param {function(Object): *} [apply] - Applied to input events to produce\n *   new event values.\n * @param {function(Object)} [receive] - Event callback function to invoke\n *   upon receipt of a new event. Use to override standard event processing.\n */\n\nfunction EventStream(filter, apply, receive) {\n  this.id = ++STREAM_ID;\n  this.value = null;\n  if (receive) this.receive = receive;\n  if (filter) this._filter = filter;\n  if (apply) this._apply = apply;\n}\n/**\n * Creates a new event stream instance with the provided\n * (optional) filter, apply and receive functions.\n * @param {function(Object, number): boolean} [filter] - Filter predicate.\n *   Events pass through when truthy, events are suppressed when falsy.\n * @param {function(Object): *} [apply] - Applied to input events to produce\n *   new event values.\n * @see EventStream\n */\n\n\nfunction stream(filter, apply, receive) {\n  return new EventStream(filter, apply, receive);\n}\n\nEventStream.prototype = {\n  _filter: truthy,\n  _apply: identity,\n\n  targets() {\n    return this._targets || (this._targets = UniqueList(id));\n  },\n\n  consume(_) {\n    if (!arguments.length) return !!this._consume;\n    this._consume = !!_;\n    return this;\n  },\n\n  receive(evt) {\n    if (this._filter(evt)) {\n      const val = this.value = this._apply(evt),\n            trg = this._targets,\n            n = trg ? trg.length : 0;\n\n      for (let i = 0; i < n; ++i) trg[i].receive(val);\n\n      if (this._consume) {\n        evt.preventDefault();\n        evt.stopPropagation();\n      }\n    }\n  },\n\n  filter(filter) {\n    const s = stream(filter);\n    this.targets().add(s);\n    return s;\n  },\n\n  apply(apply) {\n    const s = stream(null, apply);\n    this.targets().add(s);\n    return s;\n  },\n\n  merge() {\n    const s = stream();\n    this.targets().add(s);\n\n    for (let i = 0, n = arguments.length; i < n; ++i) {\n      arguments[i].targets().add(s);\n    }\n\n    return s;\n  },\n\n  throttle(pause) {\n    let t = -1;\n    return this.filter(() => {\n      const now = Date.now();\n\n      if (now - t > pause) {\n        t = now;\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n  },\n\n  debounce(delay) {\n    const s = stream();\n    this.targets().add(stream(null, null, debounce(delay, e => {\n      const df = e.dataflow;\n      s.receive(e);\n      if (df && df.run) df.run();\n    })));\n    return s;\n  },\n\n  between(a, b) {\n    let active = false;\n    a.targets().add(stream(null, null, () => active = true));\n    b.targets().add(stream(null, null, () => active = false));\n    return this.filter(() => active);\n  },\n\n  detach() {\n    // ensures compatibility with operators (#2753)\n    // remove references to other streams and filter functions that may\n    // be bound to subcontexts that need to be garbage collected.\n    this._filter = truthy;\n    this._targets = null;\n  }\n\n};\n/**\n * Create a new event stream from an event source.\n * @param {object} source - The event source to monitor. The input must\n *  support the addEventListener method.\n * @param {string} type - The event type.\n * @param {function(object): boolean} [filter] - Event filter function.\n * @param {function(object): *} [apply] - Event application function.\n *   If provided, this function will be invoked and the result will be\n *   used as the downstream event value.\n * @return {EventStream}\n */\n\nfunction events(source, type, filter, apply) {\n  const df = this,\n        s = stream(filter, apply),\n        send = function (e) {\n    e.dataflow = df;\n\n    try {\n      s.receive(e);\n    } catch (error) {\n      df.error(error);\n    } finally {\n      df.run();\n    }\n  };\n\n  let sources;\n\n  if (typeof source === 'string' && typeof document !== 'undefined') {\n    sources = document.querySelectorAll(source);\n  } else {\n    sources = array(source);\n  }\n\n  const n = sources.length;\n\n  for (let i = 0; i < n; ++i) {\n    sources[i].addEventListener(type, send);\n  }\n\n  return s;\n}\n\nfunction parse(data, format) {\n  const locale = this.locale();\n  return read(data, format, locale.timeParse, locale.utcParse);\n}\n/**\n * Ingests new data into the dataflow. First parses the data using the\n * vega-loader read method, then pulses a changeset to the target operator.\n * @param {Operator} target - The Operator to target with ingested data,\n *   typically a Collect transform instance.\n * @param {*} data - The input data, prior to parsing. For JSON this may\n *   be a string or an object. For CSV, TSV, etc should be a string.\n * @param {object} format - The data format description for parsing\n *   loaded data. This object is passed to the vega-loader read method.\n * @returns {Dataflow}\n */\n\n\nfunction ingest(target, data, format) {\n  data = this.parse(data, format);\n  return this.pulse(target, this.changeset().insert(data));\n}\n/**\n * Request data from an external source, parse it, and return a Promise.\n * @param {string} url - The URL from which to load the data. This string\n *   is passed to the vega-loader load method.\n * @param {object} [format] - The data format description for parsing\n *   loaded data. This object is passed to the vega-loader read method.\n * @return {Promise} A Promise that resolves upon completion of the request.\n *   The resolved object contains the following properties:\n *   - data: an array of parsed data (or null upon error)\n *   - status: a code for success (0), load fail (-1), or parse fail (-2)\n */\n\n\nasync function request(url, format) {\n  const df = this;\n  let status = 0,\n      data;\n\n  try {\n    data = await df.loader().load(url, {\n      context: 'dataflow',\n      response: responseType(format && format.type)\n    });\n\n    try {\n      data = df.parse(data, format);\n    } catch (err) {\n      status = -2;\n      df.warn('Data ingestion failed', url, err);\n    }\n  } catch (err) {\n    status = -1;\n    df.warn('Loading failed', url, err);\n  }\n\n  return {\n    data,\n    status\n  };\n}\n\nasync function preload(target, url, format) {\n  const df = this,\n        pending = df._pending || loadPending(df);\n  pending.requests += 1;\n  const res = await df.request(url, format);\n  df.pulse(target, df.changeset().remove(truthy).insert(res.data || []));\n  pending.done();\n  return res;\n}\n\nfunction loadPending(df) {\n  let accept;\n  const pending = new Promise(a => accept = a);\n  pending.requests = 0;\n\n  pending.done = () => {\n    if (--pending.requests === 0) {\n      df._pending = null;\n      accept(df);\n    }\n  };\n\n  return df._pending = pending;\n}\n\nconst SKIP = {\n  skip: true\n};\n/**\n * Perform operator updates in response to events. Applies an\n * update function to compute a new operator value. If the update function\n * returns a {@link ChangeSet}, the operator will be pulsed with those tuple\n * changes. Otherwise, the operator value will be updated to the return value.\n * @param {EventStream|Operator} source - The event source to react to.\n *   This argument can be either an EventStream or an Operator.\n * @param {Operator|function(object):Operator} target - The operator to update.\n *   This argument can either be an Operator instance or (if the source\n *   argument is an EventStream), a function that accepts an event object as\n *   input and returns an Operator to target.\n * @param {function(Parameters,Event): *} [update] - Optional update function\n *   to compute the new operator value, or a literal value to set. Update\n *   functions expect to receive a parameter object and event as arguments.\n *   This function can either return a new operator value or (if the source\n *   argument is an EventStream) a {@link ChangeSet} instance to pulse\n *   the target operator with tuple changes.\n * @param {object} [params] - The update function parameters.\n * @param {object} [options] - Additional options hash. If not overridden,\n *   updated operators will be skipped by default.\n * @param {boolean} [options.skip] - If true, the operator will\n *  be skipped: it will not be evaluated, but its dependents will be.\n * @param {boolean} [options.force] - If true, the operator will\n *   be re-evaluated even if its value has not changed.\n * @return {Dataflow}\n */\n\nfunction on(source, target, update, params, options) {\n  const fn = source instanceof Operator ? onOperator : onStream;\n  fn(this, source, target, update, params, options);\n  return this;\n}\n\nfunction onStream(df, stream, target, update, params, options) {\n  const opt = extend({}, options, SKIP);\n  let func, op;\n  if (!isFunction(target)) target = constant(target);\n\n  if (update === undefined) {\n    func = e => df.touch(target(e));\n  } else if (isFunction(update)) {\n    op = new Operator(null, update, params, false);\n\n    func = e => {\n      op.evaluate(e);\n      const t = target(e),\n            v = op.value;\n      isChangeSet(v) ? df.pulse(t, v, options) : df.update(t, v, opt);\n    };\n  } else {\n    func = e => df.update(target(e), update, opt);\n  }\n\n  stream.apply(func);\n}\n\nfunction onOperator(df, source, target, update, params, options) {\n  if (update === undefined) {\n    source.targets().add(target);\n  } else {\n    const opt = options || {},\n          op = new Operator(null, updater(target, update), params, false);\n    op.modified(opt.force);\n    op.rank = source.rank; // immediately follow source\n\n    source.targets().add(op); // add dependency\n\n    if (target) {\n      op.skip(true); // skip first invocation\n\n      op.value = target.value; // initialize value\n\n      op.targets().add(target); // chain dependencies\n\n      df.connect(target, [op]); // rerank as needed, #1672\n    }\n  }\n}\n\nfunction updater(target, update) {\n  update = isFunction(update) ? update : constant(update);\n  return target ? function (_, pulse) {\n    const value = update(_, pulse);\n\n    if (!target.skip()) {\n      target.skip(value !== this.value).value = value;\n    }\n\n    return value;\n  } : update;\n}\n/**\n * Assigns a rank to an operator. Ranks are assigned in increasing order\n * by incrementing an internal rank counter.\n * @param {Operator} op - The operator to assign a rank.\n */\n\n\nfunction rank(op) {\n  op.rank = ++this._rank;\n}\n/**\n * Re-ranks an operator and all downstream target dependencies. This\n * is necessary when upstream dependencies of higher rank are added to\n * a target operator.\n * @param {Operator} op - The operator to re-rank.\n */\n\n\nfunction rerank(op) {\n  const queue = [op];\n  let cur, list, i;\n\n  while (queue.length) {\n    this.rank(cur = queue.pop());\n\n    if (list = cur._targets) {\n      for (i = list.length; --i >= 0;) {\n        queue.push(cur = list[i]);\n        if (cur === op) error('Cycle detected in dataflow graph.');\n      }\n    }\n  }\n}\n/**\n * Sentinel value indicating pulse propagation should stop.\n */\n\n\nconst StopPropagation = {}; // Pulse visit type flags\n\nconst ADD = 1 << 0,\n      REM = 1 << 1,\n      MOD = 1 << 2,\n      ADD_REM = ADD | REM,\n      ADD_MOD = ADD | MOD,\n      ALL = ADD | REM | MOD,\n      REFLOW = 1 << 3,\n      SOURCE = 1 << 4,\n      NO_SOURCE = 1 << 5,\n      NO_FIELDS = 1 << 6;\n/**\n * A Pulse enables inter-operator communication during a run of the\n * dataflow graph. In addition to the current timestamp, a pulse may also\n * contain a change-set of added, removed or modified data tuples, as well as\n * a pointer to a full backing data source. Tuple change sets may not\n * be fully materialized; for example, to prevent needless array creation\n * a change set may include larger arrays and corresponding filter functions.\n * The pulse provides a {@link visit} method to enable proper and efficient\n * iteration over requested data tuples.\n *\n * In addition, each pulse can track modification flags for data tuple fields.\n * Responsible transform operators should call the {@link modifies} method to\n * indicate changes to data fields. The {@link modified} method enables\n * querying of this modification state.\n *\n * @constructor\n * @param {Dataflow} dataflow - The backing dataflow instance.\n * @param {number} stamp - The current propagation timestamp.\n * @param {string} [encode] - An optional encoding set name, which is then\n *   accessible as Pulse.encode. Operators can respond to (or ignore) this\n *   setting as appropriate. This parameter can be used in conjunction with\n *   the Encode transform in the vega-encode module.\n */\n\nfunction Pulse(dataflow, stamp, encode) {\n  this.dataflow = dataflow;\n  this.stamp = stamp == null ? -1 : stamp;\n  this.add = [];\n  this.rem = [];\n  this.mod = [];\n  this.fields = null;\n  this.encode = encode || null;\n}\n\nfunction materialize(data, filter) {\n  const out = [];\n  visitArray(data, filter, _ => out.push(_));\n  return out;\n}\n\nfunction filter(pulse, flags) {\n  const map = {};\n  pulse.visit(flags, t => {\n    map[tupleid(t)] = 1;\n  });\n  return t => map[tupleid(t)] ? null : t;\n}\n\nfunction addFilter(a, b) {\n  return a ? (t, i) => a(t, i) && b(t, i) : b;\n}\n\nPulse.prototype = {\n  /**\n   * Sentinel value indicating pulse propagation should stop.\n   */\n  StopPropagation,\n\n  /**\n   * Boolean flag indicating ADD (added) tuples.\n   */\n  ADD,\n\n  /**\n   * Boolean flag indicating REM (removed) tuples.\n   */\n  REM,\n\n  /**\n   * Boolean flag indicating MOD (modified) tuples.\n   */\n  MOD,\n\n  /**\n   * Boolean flag indicating ADD (added) and REM (removed) tuples.\n   */\n  ADD_REM,\n\n  /**\n   * Boolean flag indicating ADD (added) and MOD (modified) tuples.\n   */\n  ADD_MOD,\n\n  /**\n   * Boolean flag indicating ADD, REM and MOD tuples.\n   */\n  ALL,\n\n  /**\n   * Boolean flag indicating all tuples in a data source\n   * except for the ADD, REM and MOD tuples.\n   */\n  REFLOW,\n\n  /**\n   * Boolean flag indicating a 'pass-through' to a\n   * backing data source, ignoring ADD, REM and MOD tuples.\n   */\n  SOURCE,\n\n  /**\n   * Boolean flag indicating that source data should be\n   * suppressed when creating a forked pulse.\n   */\n  NO_SOURCE,\n\n  /**\n   * Boolean flag indicating that field modifications should be\n   * suppressed when creating a forked pulse.\n   */\n  NO_FIELDS,\n\n  /**\n   * Creates a new pulse based on the values of this pulse.\n   * The dataflow, time stamp and field modification values are copied over.\n   * By default, new empty ADD, REM and MOD arrays are created.\n   * @param {number} flags - Integer of boolean flags indicating which (if any)\n   *   tuple arrays should be copied to the new pulse. The supported flag values\n   *   are ADD, REM and MOD. Array references are copied directly: new array\n   *   instances are not created.\n   * @return {Pulse} - The forked pulse instance.\n   * @see init\n   */\n  fork(flags) {\n    return new Pulse(this.dataflow).init(this, flags);\n  },\n\n  /**\n   * Creates a copy of this pulse with new materialized array\n   * instances for the ADD, REM, MOD, and SOURCE arrays.\n   * The dataflow, time stamp and field modification values are copied over.\n   * @return {Pulse} - The cloned pulse instance.\n   * @see init\n   */\n  clone() {\n    const p = this.fork(ALL);\n    p.add = p.add.slice();\n    p.rem = p.rem.slice();\n    p.mod = p.mod.slice();\n    if (p.source) p.source = p.source.slice();\n    return p.materialize(ALL | SOURCE);\n  },\n\n  /**\n   * Returns a pulse that adds all tuples from a backing source. This is\n   * useful for cases where operators are added to a dataflow after an\n   * upstream data pipeline has already been processed, ensuring that\n   * new operators can observe all tuples within a stream.\n   * @return {Pulse} - A pulse instance with all source tuples included\n   *   in the add array. If the current pulse already has all source\n   *   tuples in its add array, it is returned directly. If the current\n   *   pulse does not have a backing source, it is returned directly.\n   */\n  addAll() {\n    let p = this;\n    const reuse = !p.source || p.add === p.rem // special case for indexed set (e.g., crossfilter)\n    || !p.rem.length && p.source.length === p.add.length;\n\n    if (reuse) {\n      return p;\n    } else {\n      p = new Pulse(this.dataflow).init(this);\n      p.add = p.source;\n      p.rem = []; // new operators can ignore rem #2769\n\n      return p;\n    }\n  },\n\n  /**\n   * Initialize this pulse based on the values of another pulse. This method\n   * is used internally by {@link fork} to initialize a new forked tuple.\n   * The dataflow, time stamp and field modification values are copied over.\n   * By default, new empty ADD, REM and MOD arrays are created.\n   * @param {Pulse} src - The source pulse to copy from.\n   * @param {number} flags - Integer of boolean flags indicating which (if any)\n   *   tuple arrays should be copied to the new pulse. The supported flag values\n   *   are ADD, REM and MOD. Array references are copied directly: new array\n   *   instances are not created. By default, source data arrays are copied\n   *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.\n   * @return {Pulse} - Returns this Pulse instance.\n   */\n  init(src, flags) {\n    const p = this;\n    p.stamp = src.stamp;\n    p.encode = src.encode;\n\n    if (src.fields && !(flags & NO_FIELDS)) {\n      p.fields = src.fields;\n    }\n\n    if (flags & ADD) {\n      p.addF = src.addF;\n      p.add = src.add;\n    } else {\n      p.addF = null;\n      p.add = [];\n    }\n\n    if (flags & REM) {\n      p.remF = src.remF;\n      p.rem = src.rem;\n    } else {\n      p.remF = null;\n      p.rem = [];\n    }\n\n    if (flags & MOD) {\n      p.modF = src.modF;\n      p.mod = src.mod;\n    } else {\n      p.modF = null;\n      p.mod = [];\n    }\n\n    if (flags & NO_SOURCE) {\n      p.srcF = null;\n      p.source = null;\n    } else {\n      p.srcF = src.srcF;\n      p.source = src.source;\n      if (src.cleans) p.cleans = src.cleans;\n    }\n\n    return p;\n  },\n\n  /**\n   * Schedules a function to run after pulse propagation completes.\n   * @param {function} func - The function to run.\n   */\n  runAfter(func) {\n    this.dataflow.runAfter(func);\n  },\n\n  /**\n   * Indicates if tuples have been added, removed or modified.\n   * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.\n   *   Defaults to ALL, returning true if any tuple type has changed.\n   * @return {boolean} - Returns true if one or more queried tuple types have\n   *   changed, false otherwise.\n   */\n  changed(flags) {\n    const f = flags || ALL;\n    return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD && this.mod.length;\n  },\n\n  /**\n   * Forces a \"reflow\" of tuple values, such that all tuples in the backing\n   * source are added to the MOD set, unless already present in the ADD set.\n   * @param {boolean} [fork=false] - If true, returns a forked copy of this\n   *   pulse, and invokes reflow on that derived pulse.\n   * @return {Pulse} - The reflowed pulse instance.\n   */\n  reflow(fork) {\n    if (fork) return this.fork(ALL).reflow();\n    const len = this.add.length,\n          src = this.source && this.source.length;\n\n    if (src && src !== len) {\n      this.mod = this.source;\n      if (len) this.filter(MOD, filter(this, ADD));\n    }\n\n    return this;\n  },\n\n  /**\n   * Get/set metadata to pulse requesting garbage collection\n   * to reclaim currently unused resources.\n   */\n  clean(value) {\n    if (arguments.length) {\n      this.cleans = !!value;\n      return this;\n    } else {\n      return this.cleans;\n    }\n  },\n\n  /**\n   * Marks one or more data field names as modified to assist dependency\n   * tracking and incremental processing by transform operators.\n   * @param {string|Array<string>} _ - The field(s) to mark as modified.\n   * @return {Pulse} - This pulse instance.\n   */\n  modifies(_) {\n    const hash = this.fields || (this.fields = {});\n\n    if (isArray(_)) {\n      _.forEach(f => hash[f] = true);\n    } else {\n      hash[_] = true;\n    }\n\n    return this;\n  },\n\n  /**\n   * Checks if one or more data fields have been modified during this pulse\n   * propagation timestamp.\n   * @param {string|Array<string>} _ - The field(s) to check for modified.\n   * @param {boolean} nomod - If true, will check the modified flag even if\n   *   no mod tuples exist. If false (default), mod tuples must be present.\n   * @return {boolean} - Returns true if any of the provided fields has been\n   *   marked as modified, false otherwise.\n   */\n  modified(_, nomod) {\n    const fields = this.fields;\n    return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : isArray(_) ? _.some(f => fields[f]) : fields[_];\n  },\n\n  /**\n   * Adds a filter function to one more tuple sets. Filters are applied to\n   * backing tuple arrays, to determine the actual set of tuples considered\n   * added, removed or modified. They can be used to delay materialization of\n   * a tuple set in order to avoid expensive array copies. In addition, the\n   * filter functions can serve as value transformers: unlike standard predicate\n   * function (which return boolean values), Pulse filters should return the\n   * actual tuple value to process. If a tuple set is already filtered, the\n   * new filter function will be appended into a conjuntive ('and') query.\n   * @param {number} flags - Flags indicating the tuple set(s) to filter.\n   * @param {function(*):object} filter - Filter function that will be applied\n   *   to the tuple set array, and should return a data tuple if the value\n   *   should be included in the tuple set, and falsy (or null) otherwise.\n   * @return {Pulse} - Returns this pulse instance.\n   */\n  filter(flags, filter) {\n    const p = this;\n    if (flags & ADD) p.addF = addFilter(p.addF, filter);\n    if (flags & REM) p.remF = addFilter(p.remF, filter);\n    if (flags & MOD) p.modF = addFilter(p.modF, filter);\n    if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter);\n    return p;\n  },\n\n  /**\n   * Materialize one or more tuple sets in this pulse. If the tuple set(s) have\n   * a registered filter function, it will be applied and the tuple set(s) will\n   * be replaced with materialized tuple arrays.\n   * @param {number} flags - Flags indicating the tuple set(s) to materialize.\n   * @return {Pulse} - Returns this pulse instance.\n   */\n  materialize(flags) {\n    flags = flags || ALL;\n    const p = this;\n\n    if (flags & ADD && p.addF) {\n      p.add = materialize(p.add, p.addF);\n      p.addF = null;\n    }\n\n    if (flags & REM && p.remF) {\n      p.rem = materialize(p.rem, p.remF);\n      p.remF = null;\n    }\n\n    if (flags & MOD && p.modF) {\n      p.mod = materialize(p.mod, p.modF);\n      p.modF = null;\n    }\n\n    if (flags & SOURCE && p.srcF) {\n      p.source = p.source.filter(p.srcF);\n      p.srcF = null;\n    }\n\n    return p;\n  },\n\n  /**\n   * Visit one or more tuple sets in this pulse.\n   * @param {number} flags - Flags indicating the tuple set(s) to visit.\n   *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source\n   *   has been set).\n   * @param {function(object):*} - Visitor function invoked per-tuple.\n   * @return {Pulse} - Returns this pulse instance.\n   */\n  visit(flags, visitor) {\n    const p = this,\n          v = visitor;\n\n    if (flags & SOURCE) {\n      visitArray(p.source, p.srcF, v);\n      return p;\n    }\n\n    if (flags & ADD) visitArray(p.add, p.addF, v);\n    if (flags & REM) visitArray(p.rem, p.remF, v);\n    if (flags & MOD) visitArray(p.mod, p.modF, v);\n    const src = p.source;\n\n    if (flags & REFLOW && src) {\n      const sum = p.add.length + p.mod.length;\n      if (sum === src.length) ;else if (sum) {\n        visitArray(src, filter(p, ADD_MOD), v);\n      } else {\n        // if no add/rem/mod tuples, visit source\n        visitArray(src, p.srcF, v);\n      }\n    }\n\n    return p;\n  }\n\n};\n/**\n * Represents a set of multiple pulses. Used as input for operators\n * that accept multiple pulses at a time. Contained pulses are\n * accessible via the public \"pulses\" array property. This pulse doe\n * not carry added, removed or modified tuples directly. However,\n * the visit method can be used to traverse all such tuples contained\n * in sub-pulses with a timestamp matching this parent multi-pulse.\n * @constructor\n * @param {Dataflow} dataflow - The backing dataflow instance.\n * @param {number} stamp - The timestamp.\n * @param {Array<Pulse>} pulses - The sub-pulses for this multi-pulse.\n */\n\nfunction MultiPulse(dataflow, stamp, pulses, encode) {\n  const p = this,\n        n = pulses.length;\n  let c = 0;\n  this.dataflow = dataflow;\n  this.stamp = stamp;\n  this.fields = null;\n  this.encode = encode || null;\n  this.pulses = pulses;\n\n  for (let i = 0; i < n; ++i) {\n    const pulse = pulses[i];\n    if (pulse.stamp !== stamp) continue;\n\n    if (pulse.fields) {\n      const hash = p.fields || (p.fields = {});\n\n      for (const f in pulse.fields) {\n        hash[f] = 1;\n      }\n    }\n\n    if (pulse.changed(p.ADD)) c |= p.ADD;\n    if (pulse.changed(p.REM)) c |= p.REM;\n    if (pulse.changed(p.MOD)) c |= p.MOD;\n  }\n\n  this.changes = c;\n}\n\ninherits(MultiPulse, Pulse, {\n  /**\n   * Creates a new pulse based on the values of this pulse.\n   * The dataflow, time stamp and field modification values are copied over.\n   * @return {Pulse}\n   */\n  fork(flags) {\n    const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);\n\n    if (flags !== undefined) {\n      if (flags & p.ADD) this.visit(p.ADD, t => p.add.push(t));\n      if (flags & p.REM) this.visit(p.REM, t => p.rem.push(t));\n      if (flags & p.MOD) this.visit(p.MOD, t => p.mod.push(t));\n    }\n\n    return p;\n  },\n\n  changed(flags) {\n    return this.changes & flags;\n  },\n\n  modified(_) {\n    const p = this,\n          fields = p.fields;\n    return !(fields && p.changes & p.MOD) ? 0 : isArray(_) ? _.some(f => fields[f]) : fields[_];\n  },\n\n  filter() {\n    error('MultiPulse does not support filtering.');\n  },\n\n  materialize() {\n    error('MultiPulse does not support materialization.');\n  },\n\n  visit(flags, visitor) {\n    const p = this,\n          pulses = p.pulses,\n          n = pulses.length;\n    let i = 0;\n\n    if (flags & p.SOURCE) {\n      for (; i < n; ++i) {\n        pulses[i].visit(flags, visitor);\n      }\n    } else {\n      for (; i < n; ++i) {\n        if (pulses[i].stamp === p.stamp) {\n          pulses[i].visit(flags, visitor);\n        }\n      }\n    }\n\n    return p;\n  }\n\n});\n/* eslint-disable require-atomic-updates */\n\n/**\n * Evaluates the dataflow and returns a Promise that resolves when pulse\n * propagation completes. This method will increment the current timestamp\n * and process all updated, pulsed and touched operators. When invoked for\n * the first time, all registered operators will be processed. This method\n * should not be invoked by third-party clients, use {@link runAsync} or\n * {@link run} instead.\n * @param {string} [encode] - The name of an encoding set to invoke during\n *   propagation. This value is added to generated Pulse instances;\n *   operators can then respond to (or ignore) this setting as appropriate.\n *   This parameter can be used in conjunction with the Encode transform in\n *   the vega-encode package.\n * @param {function} [prerun] - An optional callback function to invoke\n *   immediately before dataflow evaluation commences.\n * @param {function} [postrun] - An optional callback function to invoke\n *   after dataflow evaluation completes. The callback will be invoked\n *   after those registered via {@link runAfter}.\n * @return {Promise} - A promise that resolves to this dataflow after\n *   evaluation completes.\n */\n\nasync function evaluate(encode, prerun, postrun) {\n  const df = this,\n        async = []; // if the pulse value is set, this is a re-entrant call\n\n  if (df._pulse) return reentrant(df); // wait for pending datasets to load\n\n  if (df._pending) await df._pending; // invoke prerun function, if provided\n\n  if (prerun) await asyncCallback(df, prerun); // exit early if there are no updates\n\n  if (!df._touched.length) {\n    df.debug('Dataflow invoked, but nothing to do.');\n    return df;\n  } // increment timestamp clock\n\n\n  const stamp = ++df._clock; // set the current pulse\n\n  df._pulse = new Pulse(df, stamp, encode); // initialize priority queue, reset touched operators\n\n  df._touched.forEach(op => df._enqueue(op, true));\n\n  df._touched = UniqueList(id);\n  let count = 0,\n      op,\n      next,\n      error;\n\n  try {\n    while (df._heap.size() > 0) {\n      // dequeue operator with highest priority\n      op = df._heap.pop(); // re-queue if rank changed\n\n      if (op.rank !== op.qrank) {\n        df._enqueue(op, true);\n\n        continue;\n      } // otherwise, evaluate the operator\n\n\n      next = op.run(df._getPulse(op, encode));\n\n      if (next.then) {\n        // await if operator returns a promise directly\n        next = await next;\n      } else if (next.async) {\n        // queue parallel asynchronous execution\n        async.push(next.async);\n        next = StopPropagation;\n      } // propagate evaluation, enqueue dependent operators\n\n\n      if (next !== StopPropagation) {\n        if (op._targets) op._targets.forEach(op => df._enqueue(op));\n      } // increment visit counter\n\n\n      ++count;\n    }\n  } catch (err) {\n    df._heap.clear();\n\n    error = err;\n  } // reset pulse map\n\n\n  df._input = {};\n  df._pulse = null;\n  df.debug(`Pulse ${stamp}: ${count} operators`);\n\n  if (error) {\n    df._postrun = [];\n    df.error(error);\n  } // invoke callbacks queued via runAfter\n\n\n  if (df._postrun.length) {\n    const pr = df._postrun.sort((a, b) => b.priority - a.priority);\n\n    df._postrun = [];\n\n    for (let i = 0; i < pr.length; ++i) {\n      await asyncCallback(df, pr[i].callback);\n    }\n  } // invoke postrun function, if provided\n\n\n  if (postrun) await asyncCallback(df, postrun); // handle non-blocking asynchronous callbacks\n\n  if (async.length) {\n    Promise.all(async).then(cb => df.runAsync(null, () => {\n      cb.forEach(f => {\n        try {\n          f(df);\n        } catch (err) {\n          df.error(err);\n        }\n      });\n    }));\n  }\n\n  return df;\n}\n/**\n * Queues dataflow evaluation to run once any other queued evaluations have\n * completed and returns a Promise that resolves when the queued pulse\n * propagation completes. If provided, a callback function will be invoked\n * immediately before evaluation commences. This method will ensure a\n * separate evaluation is invoked for each time it is called.\n * @param {string} [encode] - The name of an encoding set to invoke during\n *   propagation. This value is added to generated Pulse instances;\n *   operators can then respond to (or ignore) this setting as appropriate.\n *   This parameter can be used in conjunction with the Encode transform in\n *   the vega-encode package.\n * @param {function} [prerun] - An optional callback function to invoke\n *   immediately before dataflow evaluation commences.\n * @param {function} [postrun] - An optional callback function to invoke\n *   after dataflow evaluation completes. The callback will be invoked\n *   after those registered via {@link runAfter}.\n * @return {Promise} - A promise that resolves to this dataflow after\n *   evaluation completes.\n */\n\n\nasync function runAsync(encode, prerun, postrun) {\n  // await previously queued functions\n  while (this._running) await this._running; // run dataflow, manage running promise\n\n\n  const clear = () => this._running = null;\n\n  (this._running = this.evaluate(encode, prerun, postrun)).then(clear, clear);\n  return this._running;\n}\n/**\n * Requests dataflow evaluation and the immediately returns this dataflow\n * instance. If there are pending data loading or other asynchronous\n * operations, the dataflow will evaluate asynchronously after this method\n * has been invoked. To track when dataflow evaluation completes, use the\n * {@link runAsync} method instead. This method will raise an error if\n * invoked while the dataflow is already in the midst of evaluation.\n * @param {string} [encode] - The name of an encoding set to invoke during\n *   propagation. This value is added to generated Pulse instances;\n *   operators can then respond to (or ignore) this setting as appropriate.\n *   This parameter can be used in conjunction with the Encode transform in\n *   the vega-encode module.\n * @param {function} [prerun] - An optional callback function to invoke\n *   immediately before dataflow evaluation commences.\n * @param {function} [postrun] - An optional callback function to invoke\n *   after dataflow evaluation completes. The callback will be invoked\n *   after those registered via {@link runAfter}.\n * @return {Dataflow} - This dataflow instance.\n */\n\n\nfunction run(encode, prerun, postrun) {\n  return this._pulse ? reentrant(this) : (this.evaluate(encode, prerun, postrun), this);\n}\n/**\n * Schedules a callback function to be invoked after the current pulse\n * propagation completes. If no propagation is currently occurring,\n * the function is invoked immediately. Callbacks scheduled via runAfter\n * are invoked immediately upon completion of the current cycle, before\n * any request queued via runAsync. This method is primarily intended for\n * internal use. Third-party callers using runAfter to schedule a callback\n * that invokes {@link run} or {@link runAsync} should not use this method,\n * but instead use {@link runAsync} with prerun or postrun arguments.\n * @param {function(Dataflow)} callback - The callback function to run.\n *   The callback will be invoked with this Dataflow instance as its\n *   sole argument.\n * @param {boolean} enqueue - A boolean flag indicating that the\n *   callback should be queued up to run after the next propagation\n *   cycle, suppressing immediate invocation when propagation is not\n *   currently occurring.\n * @param {number} [priority] - A priority value used to sort registered\n *   callbacks to determine execution order. This argument is intended\n *   for internal Vega use only.\n */\n\n\nfunction runAfter(callback, enqueue, priority) {\n  if (this._pulse || enqueue) {\n    // pulse propagation is currently running, queue to run after\n    this._postrun.push({\n      priority: priority || 0,\n      callback: callback\n    });\n  } else {\n    // pulse propagation already complete, invoke immediately\n    try {\n      callback(this);\n    } catch (err) {\n      this.error(err);\n    }\n  }\n}\n/**\n * Raise an error for re-entrant dataflow evaluation.\n */\n\n\nfunction reentrant(df) {\n  df.error('Dataflow already running. Use runAsync() to chain invocations.');\n  return df;\n}\n/**\n * Enqueue an operator into the priority queue for evaluation. The operator\n * will be enqueued if it has no registered pulse for the current cycle, or if\n * the force argument is true. Upon enqueue, this method also sets the\n * operator's qrank to the current rank value.\n * @param {Operator} op - The operator to enqueue.\n * @param {boolean} [force] - A flag indicating if the operator should be\n *   forceably added to the queue, even if it has already been previously\n *   enqueued during the current pulse propagation. This is useful when the\n *   dataflow graph is dynamically modified and the operator rank changes.\n */\n\n\nfunction enqueue(op, force) {\n  const q = op.stamp < this._clock;\n  if (q) op.stamp = this._clock;\n\n  if (q || force) {\n    op.qrank = op.rank;\n\n    this._heap.push(op);\n  }\n}\n/**\n * Provide a correct pulse for evaluating an operator. If the operator has an\n * explicit source operator, we will try to pull the pulse(s) from it.\n * If there is an array of source operators, we build a multi-pulse.\n * Otherwise, we return a current pulse with correct source data.\n * If the pulse is the pulse map has an explicit target set, we use that.\n * Else if the pulse on the upstream source operator is current, we use that.\n * Else we use the pulse from the pulse map, but copy the source tuple array.\n * @param {Operator} op - The operator for which to get an input pulse.\n * @param {string} [encode] - An (optional) encoding set name with which to\n *   annotate the returned pulse. See {@link run} for more information.\n */\n\n\nfunction getPulse(op, encode) {\n  const s = op.source,\n        stamp = this._clock;\n  return s && isArray(s) ? new MultiPulse(this, stamp, s.map(_ => _.pulse), encode) : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);\n}\n\nfunction singlePulse(p, s) {\n  if (s && s.stamp === p.stamp) {\n    return s;\n  }\n\n  p = p.fork();\n\n  if (s && s !== StopPropagation) {\n    p.source = s.source;\n  }\n\n  return p;\n}\n\nconst NO_OPT = {\n  skip: false,\n  force: false\n};\n/**\n * Touches an operator, scheduling it to be evaluated. If invoked outside of\n * a pulse propagation, the operator will be evaluated the next time this\n * dataflow is run. If invoked in the midst of pulse propagation, the operator\n * will be queued for evaluation if and only if the operator has not yet been\n * evaluated on the current propagation timestamp.\n * @param {Operator} op - The operator to touch.\n * @param {object} [options] - Additional options hash.\n * @param {boolean} [options.skip] - If true, the operator will\n *   be skipped: it will not be evaluated, but its dependents will be.\n * @return {Dataflow}\n */\n\nfunction touch(op, options) {\n  const opt = options || NO_OPT;\n\n  if (this._pulse) {\n    // if in midst of propagation, add to priority queue\n    this._enqueue(op);\n  } else {\n    // otherwise, queue for next propagation\n    this._touched.add(op);\n  }\n\n  if (opt.skip) op.skip(true);\n  return this;\n}\n/**\n * Updates the value of the given operator.\n * @param {Operator} op - The operator to update.\n * @param {*} value - The value to set.\n * @param {object} [options] - Additional options hash.\n * @param {boolean} [options.force] - If true, the operator will\n *   be re-evaluated even if its value has not changed.\n * @param {boolean} [options.skip] - If true, the operator will\n *   be skipped: it will not be evaluated, but its dependents will be.\n * @return {Dataflow}\n */\n\n\nfunction update(op, value, options) {\n  const opt = options || NO_OPT;\n\n  if (op.set(value) || opt.force) {\n    this.touch(op, opt);\n  }\n\n  return this;\n}\n/**\n * Pulses an operator with a changeset of tuples. If invoked outside of\n * a pulse propagation, the pulse will be applied the next time this\n * dataflow is run. If invoked in the midst of pulse propagation, the pulse\n * will be added to the set of active pulses and will be applied if and\n * only if the target operator has not yet been evaluated on the current\n * propagation timestamp.\n * @param {Operator} op - The operator to pulse.\n * @param {ChangeSet} value - The tuple changeset to apply.\n * @param {object} [options] - Additional options hash.\n * @param {boolean} [options.skip] - If true, the operator will\n *   be skipped: it will not be evaluated, but its dependents will be.\n * @return {Dataflow}\n */\n\n\nfunction pulse(op, changeset, options) {\n  this.touch(op, options || NO_OPT);\n  const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)),\n        t = op.pulse && op.pulse.source || [];\n  p.target = op;\n  this._input[op.id] = changeset.pulse(p, t);\n  return this;\n}\n\nfunction Heap(cmp) {\n  let nodes = [];\n  return {\n    clear: () => nodes = [],\n    size: () => nodes.length,\n    peek: () => nodes[0],\n    push: x => {\n      nodes.push(x);\n      return siftdown(nodes, 0, nodes.length - 1, cmp);\n    },\n    pop: () => {\n      const last = nodes.pop();\n      let item;\n\n      if (nodes.length) {\n        item = nodes[0];\n        nodes[0] = last;\n        siftup(nodes, 0, cmp);\n      } else {\n        item = last;\n      }\n\n      return item;\n    }\n  };\n}\n\nfunction siftdown(array, start, idx, cmp) {\n  let parent, pidx;\n  const item = array[idx];\n\n  while (idx > start) {\n    pidx = idx - 1 >> 1;\n    parent = array[pidx];\n\n    if (cmp(item, parent) < 0) {\n      array[idx] = parent;\n      idx = pidx;\n      continue;\n    }\n\n    break;\n  }\n\n  return array[idx] = item;\n}\n\nfunction siftup(array, idx, cmp) {\n  const start = idx,\n        end = array.length,\n        item = array[idx];\n  let cidx = (idx << 1) + 1,\n      ridx;\n\n  while (cidx < end) {\n    ridx = cidx + 1;\n\n    if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {\n      cidx = ridx;\n    }\n\n    array[idx] = array[cidx];\n    idx = cidx;\n    cidx = (idx << 1) + 1;\n  }\n\n  array[idx] = item;\n  return siftdown(array, start, idx, cmp);\n}\n/**\n * A dataflow graph for reactive processing of data streams.\n * @constructor\n */\n\n\nfunction Dataflow() {\n  this.logger(logger());\n  this.logLevel(Error);\n  this._clock = 0;\n  this._rank = 0;\n  this._locale = defaultLocale();\n\n  try {\n    this._loader = loader();\n  } catch (e) {// do nothing if loader module is unavailable\n  }\n\n  this._touched = UniqueList(id);\n  this._input = {};\n  this._pulse = null;\n  this._heap = Heap((a, b) => a.qrank - b.qrank);\n  this._postrun = [];\n}\n\nfunction logMethod(method) {\n  return function () {\n    return this._log[method].apply(this, arguments);\n  };\n}\n\nDataflow.prototype = {\n  /**\n   * The current timestamp of this dataflow. This value reflects the\n   * timestamp of the previous dataflow run. The dataflow is initialized\n   * with a stamp value of 0. The initial run of the dataflow will have\n   * a timestap of 1, and so on. This value will match the\n   * {@link Pulse.stamp} property.\n   * @return {number} - The current timestamp value.\n   */\n  stamp() {\n    return this._clock;\n  },\n\n  /**\n   * Gets or sets the loader instance to use for data file loading. A\n   * loader object must provide a \"load\" method for loading files and a\n   * \"sanitize\" method for checking URL/filename validity. Both methods\n   * should accept a URI and options hash as arguments, and return a Promise\n   * that resolves to the loaded file contents (load) or a hash containing\n   * sanitized URI data with the sanitized url assigned to the \"href\" property\n   * (sanitize).\n   * @param {object} _ - The loader instance to use.\n   * @return {object|Dataflow} - If no arguments are provided, returns\n   *   the current loader instance. Otherwise returns this Dataflow instance.\n   */\n  loader(_) {\n    if (arguments.length) {\n      this._loader = _;\n      return this;\n    } else {\n      return this._loader;\n    }\n  },\n\n  /**\n   * Gets or sets the locale instance to use for formatting and parsing\n   * string values. The locale object should be provided by the\n   * vega-format library, and include methods such as format, timeFormat,\n   * utcFormat, timeParse, and utcParse.\n   * @param {object} _ - The locale instance to use.\n   * @return {object|Dataflow} - If no arguments are provided, returns\n   *   the current locale instance. Otherwise returns this Dataflow instance.\n   */\n  locale(_) {\n    if (arguments.length) {\n      this._locale = _;\n      return this;\n    } else {\n      return this._locale;\n    }\n  },\n\n  /**\n   * Get or set the logger instance used to log messages. If no arguments are\n   * provided, returns the current logger instance. Otherwise, sets the logger\n   * and return this Dataflow instance. Provided loggers must support the full\n   * API of logger objects generated by the vega-util logger method. Note that\n   * by default the log level of the new logger will be used; use the logLevel\n   * method to adjust the log level as needed.\n   */\n  logger(logger) {\n    if (arguments.length) {\n      this._log = logger;\n      return this;\n    } else {\n      return this._log;\n    }\n  },\n\n  /**\n   * Logs an error message. By default, logged messages are written to console\n   * output. The message will only be logged if the current log level is high\n   * enough to permit error messages.\n   */\n  error: logMethod('error'),\n\n  /**\n   * Logs a warning message. By default, logged messages are written to console\n   * output. The message will only be logged if the current log level is high\n   * enough to permit warning messages.\n   */\n  warn: logMethod('warn'),\n\n  /**\n   * Logs a information message. By default, logged messages are written to\n   * console output. The message will only be logged if the current log level is\n   * high enough to permit information messages.\n   */\n  info: logMethod('info'),\n\n  /**\n   * Logs a debug message. By default, logged messages are written to console\n   * output. The message will only be logged if the current log level is high\n   * enough to permit debug messages.\n   */\n  debug: logMethod('debug'),\n\n  /**\n   * Get or set the current log level. If an argument is provided, it\n   * will be used as the new log level.\n   * @param {number} [level] - Should be one of None, Warn, Info\n   * @return {number} - The current log level.\n   */\n  logLevel: logMethod('level'),\n\n  /**\n   * Empty entry threshold for garbage cleaning. Map data structures will\n   * perform cleaning once the number of empty entries exceeds this value.\n   */\n  cleanThreshold: 1e4,\n  // OPERATOR REGISTRATION\n  add,\n  connect,\n  rank,\n  rerank,\n  // OPERATOR UPDATES\n  pulse,\n  touch,\n  update,\n  changeset,\n  // DATA LOADING\n  ingest,\n  parse,\n  preload,\n  request,\n  // EVENT HANDLING\n  events,\n  on,\n  // PULSE PROPAGATION\n  evaluate,\n  run,\n  runAsync,\n  runAfter,\n  _enqueue: enqueue,\n  _getPulse: getPulse\n};\n/**\n * Abstract class for operators that process data tuples.\n * Subclasses must provide a {@link transform} method for operator processing.\n * @constructor\n * @param {*} [init] - The initial value for this operator.\n * @param {object} [params] - The parameters for this operator.\n * @param {Operator} [source] - The operator from which to receive pulses.\n */\n\nfunction Transform(init, params) {\n  Operator.call(this, init, null, params);\n}\n\ninherits(Transform, Operator, {\n  /**\n   * Overrides {@link Operator.evaluate} for transform operators.\n   * Internally, this method calls {@link evaluate} to perform processing.\n   * If {@link evaluate} returns a falsy value, the input pulse is returned.\n   * This method should NOT be overridden, instead overrride {@link evaluate}.\n   * @param {Pulse} pulse - the current dataflow pulse.\n   * @return the output pulse for this operator (or StopPropagation)\n   */\n  run(pulse) {\n    if (pulse.stamp < this.stamp) return pulse.StopPropagation;\n    let rv;\n\n    if (this.skip()) {\n      this.skip(false);\n    } else {\n      rv = this.evaluate(pulse);\n    }\n\n    rv = rv || pulse;\n\n    if (rv.then) {\n      rv = rv.then(_ => this.pulse = _);\n    } else if (rv !== pulse.StopPropagation) {\n      this.pulse = rv;\n    }\n\n    return rv;\n  },\n\n  /**\n   * Overrides {@link Operator.evaluate} for transform operators.\n   * Marshalls parameter values and then invokes {@link transform}.\n   * @param {Pulse} pulse - the current dataflow pulse.\n   * @return {Pulse} The output pulse (or StopPropagation). A falsy return\n       value (including undefined) will let the input pulse pass through.\n  */\n  evaluate(pulse) {\n    const params = this.marshall(pulse.stamp),\n          out = this.transform(params, pulse);\n    params.clear();\n    return out;\n  },\n\n  /**\n   * Process incoming pulses.\n   * Subclasses should override this method to implement transforms.\n   * @param {Parameters} _ - The operator parameter values.\n   * @param {Pulse} pulse - The current dataflow pulse.\n   * @return {Pulse} The output pulse (or StopPropagation). A falsy return\n   *   value (including undefined) will let the input pulse pass through.\n   */\n  transform() {}\n\n});\nconst transforms = {};\n\nfunction definition(type) {\n  const t = transform(type);\n  return t && t.Definition || null;\n}\n\nfunction transform(type) {\n  type = type && type.toLowerCase();\n  return hasOwnProperty(transforms, type) ? transforms[type] : null;\n}\n\nexport { Dataflow, EventStream, MultiPulse, Operator, Parameters, Pulse, Transform, UniqueList, asyncCallback, changeset, definition, derive, ingest$1 as ingest, isChangeSet, isTuple, rederive, replace, stableCompare, transform, transforms, tupleid };","map":{"version":3,"names":["identity","array","isFunction","constant","isArray","id","error","truthy","debounce","extend","visitArray","inherits","logger","Error","hasOwnProperty","read","responseType","loader","defaultLocale","UniqueList","idFunc","$","list","ids","add","_","push","remove","idx","indexOf","splice","asyncCallback","df","callback","err","TUPLE_ID_KEY","Symbol","TUPLE_ID","isTuple","t","tupleid","setid","ingest$1","datum","Object","data","derive","rederive","d","k","replace","stableCompare","cmp","f","a","b","isChangeSet","v","constructor","changeset","rem","mod","remp","modp","clean","reflow","insert","n","length","i","modify","field","value","m","filter","tuple","encode","set","pulse","tuples","cur","out","forEach","modifies","slice","CACHE","Parameters","defineProperty","writable","prototype","name","index","force","o","modified","arguments","clear","OP_ID","PULSE","NO_PARAMS","SKIP$1","MODIFIED","Operator","init","update","params","react","stamp","rank","qrank","flags","_update","parameters","flag","bit","state","targets","_targets","skip","initonly","argval","_argval","argops","_argops","deps","op","source","Array","marshall","item","detach","evaluate","call","StopPropagation","run","rv","shift","connect","touch","target","sources","targetRank","rerank","STREAM_ID","EventStream","apply","receive","_filter","_apply","stream","consume","_consume","evt","val","trg","preventDefault","stopPropagation","s","merge","throttle","pause","now","Date","delay","e","dataflow","between","active","events","type","send","document","querySelectorAll","addEventListener","parse","format","locale","timeParse","utcParse","ingest","request","url","status","load","context","response","warn","preload","pending","_pending","loadPending","requests","res","done","accept","Promise","SKIP","on","options","fn","onOperator","onStream","opt","func","undefined","updater","_rank","queue","pop","ADD","REM","MOD","ADD_REM","ADD_MOD","ALL","REFLOW","SOURCE","NO_SOURCE","NO_FIELDS","Pulse","fields","materialize","map","visit","addFilter","fork","clone","p","addAll","reuse","src","addF","remF","modF","srcF","cleans","runAfter","changed","len","hash","nomod","some","visitor","sum","MultiPulse","pulses","c","changes","prerun","postrun","async","_pulse","reentrant","_touched","debug","_clock","_enqueue","count","next","_heap","size","_getPulse","then","_input","_postrun","pr","sort","priority","all","cb","runAsync","_running","enqueue","q","getPulse","singlePulse","NO_OPT","Heap","nodes","peek","x","siftdown","last","siftup","start","parent","pidx","end","cidx","ridx","Dataflow","logLevel","_locale","_loader","logMethod","method","_log","info","cleanThreshold","Transform","transform","transforms","definition","Definition","toLowerCase"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-dataflow/build/vega-dataflow.module.js"],"sourcesContent":["import { identity, array, isFunction, constant, isArray, id, error, truthy, debounce, extend, visitArray, inherits, logger, Error, hasOwnProperty } from 'vega-util';\nimport { read, responseType, loader } from 'vega-loader';\nimport { defaultLocale } from 'vega-format';\n\nfunction UniqueList(idFunc) {\n  const $ = idFunc || identity,\n        list = [],\n        ids = {};\n\n  list.add = _ => {\n    const id = $(_);\n\n    if (!ids[id]) {\n      ids[id] = 1;\n      list.push(_);\n    }\n\n    return list;\n  };\n\n  list.remove = _ => {\n    const id = $(_);\n\n    if (ids[id]) {\n      ids[id] = 0;\n      const idx = list.indexOf(_);\n      if (idx >= 0) list.splice(idx, 1);\n    }\n\n    return list;\n  };\n\n  return list;\n}\n\n/**\n * Invoke and await a potentially async callback function. If\n * an error occurs, trap it and route to Dataflow.error.\n * @param {Dataflow} df - The dataflow instance\n * @param {function} callback - A callback function to invoke\n *   and then await. The dataflow will be passed as the single\n *   argument to the function.\n */\nasync function asyncCallback (df, callback) {\n  try {\n    await callback(df);\n  } catch (err) {\n    df.error(err);\n  }\n}\n\nconst TUPLE_ID_KEY = Symbol('vega_id');\nlet TUPLE_ID = 1;\n/**\n * Checks if an input value is a registered tuple.\n * @param {*} t - The value to check.\n * @return {boolean} True if the input is a tuple, false otherwise.\n */\n\nfunction isTuple(t) {\n  return !!(t && tupleid(t));\n}\n/**\n * Returns the id of a tuple.\n * @param {object} t - The input tuple.\n * @return {*} the tuple id.\n */\n\nfunction tupleid(t) {\n  return t[TUPLE_ID_KEY];\n}\n/**\n * Sets the id of a tuple.\n * @param {object} t - The input tuple.\n * @param {*} id - The id value to set.\n * @return {object} the input tuple.\n */\n\nfunction setid(t, id) {\n  t[TUPLE_ID_KEY] = id;\n  return t;\n}\n/**\n * Ingest an object or value as a data tuple.\n * If the input value is an object, an id field will be added to it. For\n * efficiency, the input object is modified directly. A copy is not made.\n * If the input value is a literal, it will be wrapped in a new object\n * instance, with the value accessible as the 'data' property.\n * @param datum - The value to ingest.\n * @return {object} The ingested data tuple.\n */\n\n\nfunction ingest$1(datum) {\n  const t = datum === Object(datum) ? datum : {\n    data: datum\n  };\n  return tupleid(t) ? t : setid(t, TUPLE_ID++);\n}\n/**\n * Given a source tuple, return a derived copy.\n * @param {object} t - The source tuple.\n * @return {object} The derived tuple.\n */\n\nfunction derive(t) {\n  return rederive(t, ingest$1({}));\n}\n/**\n * Rederive a derived tuple by copying values from the source tuple.\n * @param {object} t - The source tuple.\n * @param {object} d - The derived tuple.\n * @return {object} The derived tuple.\n */\n\nfunction rederive(t, d) {\n  for (const k in t) d[k] = t[k];\n\n  return d;\n}\n/**\n * Replace an existing tuple with a new tuple.\n * @param {object} t - The existing data tuple.\n * @param {object} d - The new tuple that replaces the old.\n * @return {object} The new tuple.\n */\n\nfunction replace(t, d) {\n  return setid(d, tupleid(t));\n}\n/**\n * Generate an augmented comparator function that provides stable\n * sorting by tuple id when the given comparator produces ties.\n * @param {function} cmp - The comparator to augment.\n * @param {function} [f] - Optional tuple accessor function.\n * @return {function} An augmented comparator function.\n */\n\nfunction stableCompare(cmp, f) {\n  return !cmp ? null : f ? (a, b) => cmp(a, b) || tupleid(f(a)) - tupleid(f(b)) : (a, b) => cmp(a, b) || tupleid(a) - tupleid(b);\n}\n\nfunction isChangeSet(v) {\n  return v && v.constructor === changeset;\n}\nfunction changeset() {\n  const add = [],\n        // insert tuples\n  rem = [],\n        // remove tuples\n  mod = [],\n        // modify tuples\n  remp = [],\n        // remove by predicate\n  modp = []; // modify by predicate\n\n  let clean = null,\n      reflow = false;\n  return {\n    constructor: changeset,\n\n    insert(t) {\n      const d = array(t),\n            n = d.length;\n\n      for (let i = 0; i < n; ++i) add.push(d[i]);\n\n      return this;\n    },\n\n    remove(t) {\n      const a = isFunction(t) ? remp : rem,\n            d = array(t),\n            n = d.length;\n\n      for (let i = 0; i < n; ++i) a.push(d[i]);\n\n      return this;\n    },\n\n    modify(t, field, value) {\n      const m = {\n        field: field,\n        value: constant(value)\n      };\n\n      if (isFunction(t)) {\n        m.filter = t;\n        modp.push(m);\n      } else {\n        m.tuple = t;\n        mod.push(m);\n      }\n\n      return this;\n    },\n\n    encode(t, set) {\n      if (isFunction(t)) modp.push({\n        filter: t,\n        field: set\n      });else mod.push({\n        tuple: t,\n        field: set\n      });\n      return this;\n    },\n\n    clean(value) {\n      clean = value;\n      return this;\n    },\n\n    reflow() {\n      reflow = true;\n      return this;\n    },\n\n    pulse(pulse, tuples) {\n      const cur = {},\n            out = {};\n      let i, n, m, f, t, id; // build lookup table of current tuples\n\n      for (i = 0, n = tuples.length; i < n; ++i) {\n        cur[tupleid(tuples[i])] = 1;\n      } // process individual tuples to remove\n\n\n      for (i = 0, n = rem.length; i < n; ++i) {\n        t = rem[i];\n        cur[tupleid(t)] = -1;\n      } // process predicate-based removals\n\n\n      for (i = 0, n = remp.length; i < n; ++i) {\n        f = remp[i];\n        tuples.forEach(t => {\n          if (f(t)) cur[tupleid(t)] = -1;\n        });\n      } // process all add tuples\n\n\n      for (i = 0, n = add.length; i < n; ++i) {\n        t = add[i];\n        id = tupleid(t);\n\n        if (cur[id]) {\n          // tuple already resides in dataset\n          // if flagged for both add and remove, cancel\n          cur[id] = 1;\n        } else {\n          // tuple does not reside in dataset, add\n          pulse.add.push(ingest$1(add[i]));\n        }\n      } // populate pulse rem list\n\n\n      for (i = 0, n = tuples.length; i < n; ++i) {\n        t = tuples[i];\n        if (cur[tupleid(t)] < 0) pulse.rem.push(t);\n      } // modify helper method\n\n\n      function modify(t, f, v) {\n        if (v) {\n          t[f] = v(t);\n        } else {\n          pulse.encode = f;\n        }\n\n        if (!reflow) out[tupleid(t)] = t;\n      } // process individual tuples to modify\n\n\n      for (i = 0, n = mod.length; i < n; ++i) {\n        m = mod[i];\n        t = m.tuple;\n        f = m.field;\n        id = cur[tupleid(t)];\n\n        if (id > 0) {\n          modify(t, f, m.value);\n          pulse.modifies(f);\n        }\n      } // process predicate-based modifications\n\n\n      for (i = 0, n = modp.length; i < n; ++i) {\n        m = modp[i];\n        f = m.filter;\n        tuples.forEach(t => {\n          if (f(t) && cur[tupleid(t)] > 0) {\n            modify(t, m.field, m.value);\n          }\n        });\n        pulse.modifies(m.field);\n      } // upon reflow request, populate mod with all non-removed tuples\n      // otherwise, populate mod with modified tuples only\n\n\n      if (reflow) {\n        pulse.mod = rem.length || remp.length ? tuples.filter(t => cur[tupleid(t)] > 0) : tuples.slice();\n      } else {\n        for (id in out) pulse.mod.push(out[id]);\n      } // set pulse garbage collection request\n\n\n      if (clean || clean == null && (rem.length || remp.length)) {\n        pulse.clean(true);\n      }\n\n      return pulse;\n    }\n\n  };\n}\n\nconst CACHE = '_:mod:_';\n/**\n * Hash that tracks modifications to assigned values.\n * Callers *must* use the set method to update values.\n */\n\nfunction Parameters() {\n  Object.defineProperty(this, CACHE, {\n    writable: true,\n    value: {}\n  });\n}\nParameters.prototype = {\n  /**\n   * Set a parameter value. If the parameter value changes, the parameter\n   * will be recorded as modified.\n   * @param {string} name - The parameter name.\n   * @param {number} index - The index into an array-value parameter. Ignored if\n   *   the argument is undefined, null or less than zero.\n   * @param {*} value - The parameter value to set.\n   * @param {boolean} [force=false] - If true, records the parameter as modified\n   *   even if the value is unchanged.\n   * @return {Parameters} - This parameter object.\n   */\n  set(name, index, value, force) {\n    const o = this,\n          v = o[name],\n          mod = o[CACHE];\n\n    if (index != null && index >= 0) {\n      if (v[index] !== value || force) {\n        v[index] = value;\n        mod[index + ':' + name] = -1;\n        mod[name] = -1;\n      }\n    } else if (v !== value || force) {\n      o[name] = value;\n      mod[name] = isArray(value) ? 1 + value.length : -1;\n    }\n\n    return o;\n  },\n\n  /**\n   * Tests if one or more parameters has been modified. If invoked with no\n   * arguments, returns true if any parameter value has changed. If the first\n   * argument is array, returns trues if any parameter name in the array has\n   * changed. Otherwise, tests if the given name and optional array index has\n   * changed.\n   * @param {string} name - The parameter name to test.\n   * @param {number} [index=undefined] - The parameter array index to test.\n   * @return {boolean} - Returns true if a queried parameter was modified.\n   */\n  modified(name, index) {\n    const mod = this[CACHE];\n\n    if (!arguments.length) {\n      for (const k in mod) {\n        if (mod[k]) return true;\n      }\n\n      return false;\n    } else if (isArray(name)) {\n      for (let k = 0; k < name.length; ++k) {\n        if (mod[name[k]]) return true;\n      }\n\n      return false;\n    }\n\n    return index != null && index >= 0 ? index + 1 < mod[name] || !!mod[index + ':' + name] : !!mod[name];\n  },\n\n  /**\n   * Clears the modification records. After calling this method,\n   * all parameters are considered unmodified.\n   */\n  clear() {\n    this[CACHE] = {};\n    return this;\n  }\n\n};\n\nlet OP_ID = 0;\nconst PULSE = 'pulse',\n      NO_PARAMS = new Parameters(); // Boolean Flags\n\nconst SKIP$1 = 1,\n      MODIFIED = 2;\n/**\n * An Operator is a processing node in a dataflow graph.\n * Each operator stores a value and an optional value update function.\n * Operators can accept a hash of named parameters. Parameter values can\n * either be direct (JavaScript literals, arrays, objects) or indirect\n * (other operators whose values will be pulled dynamically). Operators\n * included as parameters will have this operator added as a dependency.\n * @constructor\n * @param {*} [init] - The initial value for this operator.\n * @param {function(object, Pulse)} [update] - An update function. Upon\n *   evaluation of this operator, the update function will be invoked and the\n *   return value will be used as the new value of this operator.\n * @param {object} [params] - The parameters for this operator.\n * @param {boolean} [react=true] - Flag indicating if this operator should\n *   listen for changes to upstream operators included as parameters.\n * @see parameters\n */\n\nfunction Operator(init, update, params, react) {\n  this.id = ++OP_ID;\n  this.value = init;\n  this.stamp = -1;\n  this.rank = -1;\n  this.qrank = -1;\n  this.flags = 0;\n\n  if (update) {\n    this._update = update;\n  }\n\n  if (params) this.parameters(params, react);\n}\n\nfunction flag(bit) {\n  return function (state) {\n    const f = this.flags;\n    if (arguments.length === 0) return !!(f & bit);\n    this.flags = state ? f | bit : f & ~bit;\n    return this;\n  };\n}\n\nOperator.prototype = {\n  /**\n   * Returns a list of target operators dependent on this operator.\n   * If this list does not exist, it is created and then returned.\n   * @return {UniqueList}\n   */\n  targets() {\n    return this._targets || (this._targets = UniqueList(id));\n  },\n\n  /**\n   * Sets the value of this operator.\n   * @param {*} value - the value to set.\n   * @return {Number} Returns 1 if the operator value has changed\n   *   according to strict equality, returns 0 otherwise.\n   */\n  set(value) {\n    if (this.value !== value) {\n      this.value = value;\n      return 1;\n    } else {\n      return 0;\n    }\n  },\n\n  /**\n   * Indicates that operator evaluation should be skipped on the next pulse.\n   * This operator will still propagate incoming pulses, but its update function\n   * will not be invoked. The skip flag is reset after every pulse, so calling\n   * this method will affect processing of the next pulse only.\n   */\n  skip: flag(SKIP$1),\n\n  /**\n   * Indicates that this operator's value has been modified on its most recent\n   * pulse. Normally modification is checked via strict equality; however, in\n   * some cases it is more efficient to update the internal state of an object.\n   * In those cases, the modified flag can be used to trigger propagation. Once\n   * set, the modification flag persists across pulses until unset. The flag can\n   * be used with the last timestamp to test if a modification is recent.\n   */\n  modified: flag(MODIFIED),\n\n  /**\n   * Sets the parameters for this operator. The parameter values are analyzed for\n   * operator instances. If found, this operator will be added as a dependency\n   * of the parameterizing operator. Operator values are dynamically marshalled\n   * from each operator parameter prior to evaluation. If a parameter value is\n   * an array, the array will also be searched for Operator instances. However,\n   * the search does not recurse into sub-arrays or object properties.\n   * @param {object} params - A hash of operator parameters.\n   * @param {boolean} [react=true] - A flag indicating if this operator should\n   *   automatically update (react) when parameter values change. In other words,\n   *   this flag determines if the operator registers itself as a listener on\n   *   any upstream operators included in the parameters.\n   * @param {boolean} [initonly=false] - A flag indicating if this operator\n   *   should calculate an update only upon its initiatal evaluation, then\n   *   deregister dependencies and suppress all future update invocations.\n   * @return {Operator[]} - An array of upstream dependencies.\n   */\n  parameters(params, react, initonly) {\n    react = react !== false;\n    const argval = this._argval = this._argval || new Parameters(),\n          argops = this._argops = this._argops || [],\n          deps = [];\n    let name, value, n, i;\n\n    const add = (name, index, value) => {\n      if (value instanceof Operator) {\n        if (value !== this) {\n          if (react) value.targets().add(this);\n          deps.push(value);\n        }\n\n        argops.push({\n          op: value,\n          name: name,\n          index: index\n        });\n      } else {\n        argval.set(name, index, value);\n      }\n    };\n\n    for (name in params) {\n      value = params[name];\n\n      if (name === PULSE) {\n        array(value).forEach(op => {\n          if (!(op instanceof Operator)) {\n            error('Pulse parameters must be operator instances.');\n          } else if (op !== this) {\n            op.targets().add(this);\n            deps.push(op);\n          }\n        });\n        this.source = value;\n      } else if (isArray(value)) {\n        argval.set(name, -1, Array(n = value.length));\n\n        for (i = 0; i < n; ++i) add(name, i, value[i]);\n      } else {\n        add(name, -1, value);\n      }\n    }\n\n    this.marshall().clear(); // initialize values\n\n    if (initonly) argops.initonly = true;\n    return deps;\n  },\n\n  /**\n   * Internal method for marshalling parameter values.\n   * Visits each operator dependency to pull the latest value.\n   * @return {Parameters} A Parameters object to pass to the update function.\n   */\n  marshall(stamp) {\n    const argval = this._argval || NO_PARAMS,\n          argops = this._argops;\n    let item, i, op, mod;\n\n    if (argops) {\n      const n = argops.length;\n\n      for (i = 0; i < n; ++i) {\n        item = argops[i];\n        op = item.op;\n        mod = op.modified() && op.stamp === stamp;\n        argval.set(item.name, item.index, op.value, mod);\n      }\n\n      if (argops.initonly) {\n        for (i = 0; i < n; ++i) {\n          item = argops[i];\n          item.op.targets().remove(this);\n        }\n\n        this._argops = null;\n        this._update = null;\n      }\n    }\n\n    return argval;\n  },\n\n  /**\n   * Detach this operator from the dataflow.\n   * Unregisters listeners on upstream dependencies.\n   */\n  detach() {\n    const argops = this._argops;\n    let i, n, item, op;\n\n    if (argops) {\n      for (i = 0, n = argops.length; i < n; ++i) {\n        item = argops[i];\n        op = item.op;\n\n        if (op._targets) {\n          op._targets.remove(this);\n        }\n      }\n    } // remove references to the source and pulse object,\n    // if present, to prevent memory leaks of old data.\n\n\n    this.pulse = null;\n    this.source = null;\n  },\n\n  /**\n   * Delegate method to perform operator processing.\n   * Subclasses can override this method to perform custom processing.\n   * By default, it marshalls parameters and calls the update function\n   * if that function is defined. If the update function does not\n   * change the operator value then StopPropagation is returned.\n   * If no update function is defined, this method does nothing.\n   * @param {Pulse} pulse - the current dataflow pulse.\n   * @return The output pulse or StopPropagation. A falsy return value\n   *   (including undefined) will let the input pulse pass through.\n   */\n  evaluate(pulse) {\n    const update = this._update;\n\n    if (update) {\n      const params = this.marshall(pulse.stamp),\n            v = update.call(this, params, pulse);\n      params.clear();\n\n      if (v !== this.value) {\n        this.value = v;\n      } else if (!this.modified()) {\n        return pulse.StopPropagation;\n      }\n    }\n  },\n\n  /**\n   * Run this operator for the current pulse. If this operator has already\n   * been run at (or after) the pulse timestamp, returns StopPropagation.\n   * Internally, this method calls {@link evaluate} to perform processing.\n   * If {@link evaluate} returns a falsy value, the input pulse is returned.\n   * This method should NOT be overridden, instead overrride {@link evaluate}.\n   * @param {Pulse} pulse - the current dataflow pulse.\n   * @return the output pulse for this operator (or StopPropagation)\n   */\n  run(pulse) {\n    if (pulse.stamp < this.stamp) return pulse.StopPropagation;\n    let rv;\n\n    if (this.skip()) {\n      this.skip(false);\n      rv = 0;\n    } else {\n      rv = this.evaluate(pulse);\n    }\n\n    return this.pulse = rv || pulse;\n  }\n\n};\n\n/**\n * Add an operator to the dataflow graph. This function accepts a\n * variety of input argument types. The basic signature supports an\n * initial value, update function and parameters. If the first parameter\n * is an Operator instance, it will be added directly. If it is a\n * constructor for an Operator subclass, a new instance will be instantiated.\n * Otherwise, if the first parameter is a function instance, it will be used\n * as the update function and a null initial value is assumed.\n * @param {*} init - One of: the operator to add, the initial value of\n *   the operator, an operator class to instantiate, or an update function.\n * @param {function} [update] - The operator update function.\n * @param {object} [params] - The operator parameters.\n * @param {boolean} [react=true] - Flag indicating if this operator should\n *   listen for changes to upstream operators included as parameters.\n * @return {Operator} - The added operator.\n */\n\nfunction add (init, update, params, react) {\n  let shift = 1,\n      op;\n\n  if (init instanceof Operator) {\n    op = init;\n  } else if (init && init.prototype instanceof Operator) {\n    op = new init();\n  } else if (isFunction(init)) {\n    op = new Operator(null, init);\n  } else {\n    shift = 0;\n    op = new Operator(init, update);\n  }\n\n  this.rank(op);\n\n  if (shift) {\n    react = params;\n    params = update;\n  }\n\n  if (params) this.connect(op, op.parameters(params, react));\n  this.touch(op);\n  return op;\n}\n\n/**\n * Connect a target operator as a dependent of source operators.\n * If necessary, this method will rerank the target operator and its\n * dependents to ensure propagation proceeds in a topologically sorted order.\n * @param {Operator} target - The target operator.\n * @param {Array<Operator>} - The source operators that should propagate\n *   to the target operator.\n */\nfunction connect (target, sources) {\n  const targetRank = target.rank,\n        n = sources.length;\n\n  for (let i = 0; i < n; ++i) {\n    if (targetRank < sources[i].rank) {\n      this.rerank(target);\n      return;\n    }\n  }\n}\n\nlet STREAM_ID = 0;\n/**\n * Models an event stream.\n * @constructor\n * @param {function(Object, number): boolean} [filter] - Filter predicate.\n *   Events pass through when truthy, events are suppressed when falsy.\n * @param {function(Object): *} [apply] - Applied to input events to produce\n *   new event values.\n * @param {function(Object)} [receive] - Event callback function to invoke\n *   upon receipt of a new event. Use to override standard event processing.\n */\n\nfunction EventStream(filter, apply, receive) {\n  this.id = ++STREAM_ID;\n  this.value = null;\n  if (receive) this.receive = receive;\n  if (filter) this._filter = filter;\n  if (apply) this._apply = apply;\n}\n/**\n * Creates a new event stream instance with the provided\n * (optional) filter, apply and receive functions.\n * @param {function(Object, number): boolean} [filter] - Filter predicate.\n *   Events pass through when truthy, events are suppressed when falsy.\n * @param {function(Object): *} [apply] - Applied to input events to produce\n *   new event values.\n * @see EventStream\n */\n\nfunction stream(filter, apply, receive) {\n  return new EventStream(filter, apply, receive);\n}\nEventStream.prototype = {\n  _filter: truthy,\n  _apply: identity,\n\n  targets() {\n    return this._targets || (this._targets = UniqueList(id));\n  },\n\n  consume(_) {\n    if (!arguments.length) return !!this._consume;\n    this._consume = !!_;\n    return this;\n  },\n\n  receive(evt) {\n    if (this._filter(evt)) {\n      const val = this.value = this._apply(evt),\n            trg = this._targets,\n            n = trg ? trg.length : 0;\n\n      for (let i = 0; i < n; ++i) trg[i].receive(val);\n\n      if (this._consume) {\n        evt.preventDefault();\n        evt.stopPropagation();\n      }\n    }\n  },\n\n  filter(filter) {\n    const s = stream(filter);\n    this.targets().add(s);\n    return s;\n  },\n\n  apply(apply) {\n    const s = stream(null, apply);\n    this.targets().add(s);\n    return s;\n  },\n\n  merge() {\n    const s = stream();\n    this.targets().add(s);\n\n    for (let i = 0, n = arguments.length; i < n; ++i) {\n      arguments[i].targets().add(s);\n    }\n\n    return s;\n  },\n\n  throttle(pause) {\n    let t = -1;\n    return this.filter(() => {\n      const now = Date.now();\n\n      if (now - t > pause) {\n        t = now;\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n  },\n\n  debounce(delay) {\n    const s = stream();\n    this.targets().add(stream(null, null, debounce(delay, e => {\n      const df = e.dataflow;\n      s.receive(e);\n      if (df && df.run) df.run();\n    })));\n    return s;\n  },\n\n  between(a, b) {\n    let active = false;\n    a.targets().add(stream(null, null, () => active = true));\n    b.targets().add(stream(null, null, () => active = false));\n    return this.filter(() => active);\n  },\n\n  detach() {\n    // ensures compatibility with operators (#2753)\n    // remove references to other streams and filter functions that may\n    // be bound to subcontexts that need to be garbage collected.\n    this._filter = truthy;\n    this._targets = null;\n  }\n\n};\n\n/**\n * Create a new event stream from an event source.\n * @param {object} source - The event source to monitor. The input must\n *  support the addEventListener method.\n * @param {string} type - The event type.\n * @param {function(object): boolean} [filter] - Event filter function.\n * @param {function(object): *} [apply] - Event application function.\n *   If provided, this function will be invoked and the result will be\n *   used as the downstream event value.\n * @return {EventStream}\n */\n\nfunction events (source, type, filter, apply) {\n  const df = this,\n        s = stream(filter, apply),\n        send = function (e) {\n    e.dataflow = df;\n\n    try {\n      s.receive(e);\n    } catch (error) {\n      df.error(error);\n    } finally {\n      df.run();\n    }\n  };\n\n  let sources;\n\n  if (typeof source === 'string' && typeof document !== 'undefined') {\n    sources = document.querySelectorAll(source);\n  } else {\n    sources = array(source);\n  }\n\n  const n = sources.length;\n\n  for (let i = 0; i < n; ++i) {\n    sources[i].addEventListener(type, send);\n  }\n\n  return s;\n}\n\nfunction parse(data, format) {\n  const locale = this.locale();\n  return read(data, format, locale.timeParse, locale.utcParse);\n}\n/**\n * Ingests new data into the dataflow. First parses the data using the\n * vega-loader read method, then pulses a changeset to the target operator.\n * @param {Operator} target - The Operator to target with ingested data,\n *   typically a Collect transform instance.\n * @param {*} data - The input data, prior to parsing. For JSON this may\n *   be a string or an object. For CSV, TSV, etc should be a string.\n * @param {object} format - The data format description for parsing\n *   loaded data. This object is passed to the vega-loader read method.\n * @returns {Dataflow}\n */\n\nfunction ingest(target, data, format) {\n  data = this.parse(data, format);\n  return this.pulse(target, this.changeset().insert(data));\n}\n/**\n * Request data from an external source, parse it, and return a Promise.\n * @param {string} url - The URL from which to load the data. This string\n *   is passed to the vega-loader load method.\n * @param {object} [format] - The data format description for parsing\n *   loaded data. This object is passed to the vega-loader read method.\n * @return {Promise} A Promise that resolves upon completion of the request.\n *   The resolved object contains the following properties:\n *   - data: an array of parsed data (or null upon error)\n *   - status: a code for success (0), load fail (-1), or parse fail (-2)\n */\n\nasync function request(url, format) {\n  const df = this;\n  let status = 0,\n      data;\n\n  try {\n    data = await df.loader().load(url, {\n      context: 'dataflow',\n      response: responseType(format && format.type)\n    });\n\n    try {\n      data = df.parse(data, format);\n    } catch (err) {\n      status = -2;\n      df.warn('Data ingestion failed', url, err);\n    }\n  } catch (err) {\n    status = -1;\n    df.warn('Loading failed', url, err);\n  }\n\n  return {\n    data,\n    status\n  };\n}\nasync function preload(target, url, format) {\n  const df = this,\n        pending = df._pending || loadPending(df);\n  pending.requests += 1;\n  const res = await df.request(url, format);\n  df.pulse(target, df.changeset().remove(truthy).insert(res.data || []));\n  pending.done();\n  return res;\n}\n\nfunction loadPending(df) {\n  let accept;\n  const pending = new Promise(a => accept = a);\n  pending.requests = 0;\n\n  pending.done = () => {\n    if (--pending.requests === 0) {\n      df._pending = null;\n      accept(df);\n    }\n  };\n\n  return df._pending = pending;\n}\n\nconst SKIP = {\n  skip: true\n};\n/**\n * Perform operator updates in response to events. Applies an\n * update function to compute a new operator value. If the update function\n * returns a {@link ChangeSet}, the operator will be pulsed with those tuple\n * changes. Otherwise, the operator value will be updated to the return value.\n * @param {EventStream|Operator} source - The event source to react to.\n *   This argument can be either an EventStream or an Operator.\n * @param {Operator|function(object):Operator} target - The operator to update.\n *   This argument can either be an Operator instance or (if the source\n *   argument is an EventStream), a function that accepts an event object as\n *   input and returns an Operator to target.\n * @param {function(Parameters,Event): *} [update] - Optional update function\n *   to compute the new operator value, or a literal value to set. Update\n *   functions expect to receive a parameter object and event as arguments.\n *   This function can either return a new operator value or (if the source\n *   argument is an EventStream) a {@link ChangeSet} instance to pulse\n *   the target operator with tuple changes.\n * @param {object} [params] - The update function parameters.\n * @param {object} [options] - Additional options hash. If not overridden,\n *   updated operators will be skipped by default.\n * @param {boolean} [options.skip] - If true, the operator will\n *  be skipped: it will not be evaluated, but its dependents will be.\n * @param {boolean} [options.force] - If true, the operator will\n *   be re-evaluated even if its value has not changed.\n * @return {Dataflow}\n */\n\nfunction on (source, target, update, params, options) {\n  const fn = source instanceof Operator ? onOperator : onStream;\n  fn(this, source, target, update, params, options);\n  return this;\n}\n\nfunction onStream(df, stream, target, update, params, options) {\n  const opt = extend({}, options, SKIP);\n  let func, op;\n  if (!isFunction(target)) target = constant(target);\n\n  if (update === undefined) {\n    func = e => df.touch(target(e));\n  } else if (isFunction(update)) {\n    op = new Operator(null, update, params, false);\n\n    func = e => {\n      op.evaluate(e);\n      const t = target(e),\n            v = op.value;\n      isChangeSet(v) ? df.pulse(t, v, options) : df.update(t, v, opt);\n    };\n  } else {\n    func = e => df.update(target(e), update, opt);\n  }\n\n  stream.apply(func);\n}\n\nfunction onOperator(df, source, target, update, params, options) {\n  if (update === undefined) {\n    source.targets().add(target);\n  } else {\n    const opt = options || {},\n          op = new Operator(null, updater(target, update), params, false);\n    op.modified(opt.force);\n    op.rank = source.rank; // immediately follow source\n\n    source.targets().add(op); // add dependency\n\n    if (target) {\n      op.skip(true); // skip first invocation\n\n      op.value = target.value; // initialize value\n\n      op.targets().add(target); // chain dependencies\n\n      df.connect(target, [op]); // rerank as needed, #1672\n    }\n  }\n}\n\nfunction updater(target, update) {\n  update = isFunction(update) ? update : constant(update);\n  return target ? function (_, pulse) {\n    const value = update(_, pulse);\n\n    if (!target.skip()) {\n      target.skip(value !== this.value).value = value;\n    }\n\n    return value;\n  } : update;\n}\n\n/**\n * Assigns a rank to an operator. Ranks are assigned in increasing order\n * by incrementing an internal rank counter.\n * @param {Operator} op - The operator to assign a rank.\n */\n\nfunction rank(op) {\n  op.rank = ++this._rank;\n}\n/**\n * Re-ranks an operator and all downstream target dependencies. This\n * is necessary when upstream dependencies of higher rank are added to\n * a target operator.\n * @param {Operator} op - The operator to re-rank.\n */\n\nfunction rerank(op) {\n  const queue = [op];\n  let cur, list, i;\n\n  while (queue.length) {\n    this.rank(cur = queue.pop());\n\n    if (list = cur._targets) {\n      for (i = list.length; --i >= 0;) {\n        queue.push(cur = list[i]);\n        if (cur === op) error('Cycle detected in dataflow graph.');\n      }\n    }\n  }\n}\n\n/**\n * Sentinel value indicating pulse propagation should stop.\n */\n\nconst StopPropagation = {}; // Pulse visit type flags\n\nconst ADD = 1 << 0,\n      REM = 1 << 1,\n      MOD = 1 << 2,\n      ADD_REM = ADD | REM,\n      ADD_MOD = ADD | MOD,\n      ALL = ADD | REM | MOD,\n      REFLOW = 1 << 3,\n      SOURCE = 1 << 4,\n      NO_SOURCE = 1 << 5,\n      NO_FIELDS = 1 << 6;\n/**\n * A Pulse enables inter-operator communication during a run of the\n * dataflow graph. In addition to the current timestamp, a pulse may also\n * contain a change-set of added, removed or modified data tuples, as well as\n * a pointer to a full backing data source. Tuple change sets may not\n * be fully materialized; for example, to prevent needless array creation\n * a change set may include larger arrays and corresponding filter functions.\n * The pulse provides a {@link visit} method to enable proper and efficient\n * iteration over requested data tuples.\n *\n * In addition, each pulse can track modification flags for data tuple fields.\n * Responsible transform operators should call the {@link modifies} method to\n * indicate changes to data fields. The {@link modified} method enables\n * querying of this modification state.\n *\n * @constructor\n * @param {Dataflow} dataflow - The backing dataflow instance.\n * @param {number} stamp - The current propagation timestamp.\n * @param {string} [encode] - An optional encoding set name, which is then\n *   accessible as Pulse.encode. Operators can respond to (or ignore) this\n *   setting as appropriate. This parameter can be used in conjunction with\n *   the Encode transform in the vega-encode module.\n */\n\nfunction Pulse(dataflow, stamp, encode) {\n  this.dataflow = dataflow;\n  this.stamp = stamp == null ? -1 : stamp;\n  this.add = [];\n  this.rem = [];\n  this.mod = [];\n  this.fields = null;\n  this.encode = encode || null;\n}\n\nfunction materialize(data, filter) {\n  const out = [];\n  visitArray(data, filter, _ => out.push(_));\n  return out;\n}\n\nfunction filter(pulse, flags) {\n  const map = {};\n  pulse.visit(flags, t => {\n    map[tupleid(t)] = 1;\n  });\n  return t => map[tupleid(t)] ? null : t;\n}\n\nfunction addFilter(a, b) {\n  return a ? (t, i) => a(t, i) && b(t, i) : b;\n}\n\nPulse.prototype = {\n  /**\n   * Sentinel value indicating pulse propagation should stop.\n   */\n  StopPropagation,\n\n  /**\n   * Boolean flag indicating ADD (added) tuples.\n   */\n  ADD,\n\n  /**\n   * Boolean flag indicating REM (removed) tuples.\n   */\n  REM,\n\n  /**\n   * Boolean flag indicating MOD (modified) tuples.\n   */\n  MOD,\n\n  /**\n   * Boolean flag indicating ADD (added) and REM (removed) tuples.\n   */\n  ADD_REM,\n\n  /**\n   * Boolean flag indicating ADD (added) and MOD (modified) tuples.\n   */\n  ADD_MOD,\n\n  /**\n   * Boolean flag indicating ADD, REM and MOD tuples.\n   */\n  ALL,\n\n  /**\n   * Boolean flag indicating all tuples in a data source\n   * except for the ADD, REM and MOD tuples.\n   */\n  REFLOW,\n\n  /**\n   * Boolean flag indicating a 'pass-through' to a\n   * backing data source, ignoring ADD, REM and MOD tuples.\n   */\n  SOURCE,\n\n  /**\n   * Boolean flag indicating that source data should be\n   * suppressed when creating a forked pulse.\n   */\n  NO_SOURCE,\n\n  /**\n   * Boolean flag indicating that field modifications should be\n   * suppressed when creating a forked pulse.\n   */\n  NO_FIELDS,\n\n  /**\n   * Creates a new pulse based on the values of this pulse.\n   * The dataflow, time stamp and field modification values are copied over.\n   * By default, new empty ADD, REM and MOD arrays are created.\n   * @param {number} flags - Integer of boolean flags indicating which (if any)\n   *   tuple arrays should be copied to the new pulse. The supported flag values\n   *   are ADD, REM and MOD. Array references are copied directly: new array\n   *   instances are not created.\n   * @return {Pulse} - The forked pulse instance.\n   * @see init\n   */\n  fork(flags) {\n    return new Pulse(this.dataflow).init(this, flags);\n  },\n\n  /**\n   * Creates a copy of this pulse with new materialized array\n   * instances for the ADD, REM, MOD, and SOURCE arrays.\n   * The dataflow, time stamp and field modification values are copied over.\n   * @return {Pulse} - The cloned pulse instance.\n   * @see init\n   */\n  clone() {\n    const p = this.fork(ALL);\n    p.add = p.add.slice();\n    p.rem = p.rem.slice();\n    p.mod = p.mod.slice();\n    if (p.source) p.source = p.source.slice();\n    return p.materialize(ALL | SOURCE);\n  },\n\n  /**\n   * Returns a pulse that adds all tuples from a backing source. This is\n   * useful for cases where operators are added to a dataflow after an\n   * upstream data pipeline has already been processed, ensuring that\n   * new operators can observe all tuples within a stream.\n   * @return {Pulse} - A pulse instance with all source tuples included\n   *   in the add array. If the current pulse already has all source\n   *   tuples in its add array, it is returned directly. If the current\n   *   pulse does not have a backing source, it is returned directly.\n   */\n  addAll() {\n    let p = this;\n    const reuse = !p.source || p.add === p.rem // special case for indexed set (e.g., crossfilter)\n    || !p.rem.length && p.source.length === p.add.length;\n\n    if (reuse) {\n      return p;\n    } else {\n      p = new Pulse(this.dataflow).init(this);\n      p.add = p.source;\n      p.rem = []; // new operators can ignore rem #2769\n\n      return p;\n    }\n  },\n\n  /**\n   * Initialize this pulse based on the values of another pulse. This method\n   * is used internally by {@link fork} to initialize a new forked tuple.\n   * The dataflow, time stamp and field modification values are copied over.\n   * By default, new empty ADD, REM and MOD arrays are created.\n   * @param {Pulse} src - The source pulse to copy from.\n   * @param {number} flags - Integer of boolean flags indicating which (if any)\n   *   tuple arrays should be copied to the new pulse. The supported flag values\n   *   are ADD, REM and MOD. Array references are copied directly: new array\n   *   instances are not created. By default, source data arrays are copied\n   *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.\n   * @return {Pulse} - Returns this Pulse instance.\n   */\n  init(src, flags) {\n    const p = this;\n    p.stamp = src.stamp;\n    p.encode = src.encode;\n\n    if (src.fields && !(flags & NO_FIELDS)) {\n      p.fields = src.fields;\n    }\n\n    if (flags & ADD) {\n      p.addF = src.addF;\n      p.add = src.add;\n    } else {\n      p.addF = null;\n      p.add = [];\n    }\n\n    if (flags & REM) {\n      p.remF = src.remF;\n      p.rem = src.rem;\n    } else {\n      p.remF = null;\n      p.rem = [];\n    }\n\n    if (flags & MOD) {\n      p.modF = src.modF;\n      p.mod = src.mod;\n    } else {\n      p.modF = null;\n      p.mod = [];\n    }\n\n    if (flags & NO_SOURCE) {\n      p.srcF = null;\n      p.source = null;\n    } else {\n      p.srcF = src.srcF;\n      p.source = src.source;\n      if (src.cleans) p.cleans = src.cleans;\n    }\n\n    return p;\n  },\n\n  /**\n   * Schedules a function to run after pulse propagation completes.\n   * @param {function} func - The function to run.\n   */\n  runAfter(func) {\n    this.dataflow.runAfter(func);\n  },\n\n  /**\n   * Indicates if tuples have been added, removed or modified.\n   * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.\n   *   Defaults to ALL, returning true if any tuple type has changed.\n   * @return {boolean} - Returns true if one or more queried tuple types have\n   *   changed, false otherwise.\n   */\n  changed(flags) {\n    const f = flags || ALL;\n    return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD && this.mod.length;\n  },\n\n  /**\n   * Forces a \"reflow\" of tuple values, such that all tuples in the backing\n   * source are added to the MOD set, unless already present in the ADD set.\n   * @param {boolean} [fork=false] - If true, returns a forked copy of this\n   *   pulse, and invokes reflow on that derived pulse.\n   * @return {Pulse} - The reflowed pulse instance.\n   */\n  reflow(fork) {\n    if (fork) return this.fork(ALL).reflow();\n    const len = this.add.length,\n          src = this.source && this.source.length;\n\n    if (src && src !== len) {\n      this.mod = this.source;\n      if (len) this.filter(MOD, filter(this, ADD));\n    }\n\n    return this;\n  },\n\n  /**\n   * Get/set metadata to pulse requesting garbage collection\n   * to reclaim currently unused resources.\n   */\n  clean(value) {\n    if (arguments.length) {\n      this.cleans = !!value;\n      return this;\n    } else {\n      return this.cleans;\n    }\n  },\n\n  /**\n   * Marks one or more data field names as modified to assist dependency\n   * tracking and incremental processing by transform operators.\n   * @param {string|Array<string>} _ - The field(s) to mark as modified.\n   * @return {Pulse} - This pulse instance.\n   */\n  modifies(_) {\n    const hash = this.fields || (this.fields = {});\n\n    if (isArray(_)) {\n      _.forEach(f => hash[f] = true);\n    } else {\n      hash[_] = true;\n    }\n\n    return this;\n  },\n\n  /**\n   * Checks if one or more data fields have been modified during this pulse\n   * propagation timestamp.\n   * @param {string|Array<string>} _ - The field(s) to check for modified.\n   * @param {boolean} nomod - If true, will check the modified flag even if\n   *   no mod tuples exist. If false (default), mod tuples must be present.\n   * @return {boolean} - Returns true if any of the provided fields has been\n   *   marked as modified, false otherwise.\n   */\n  modified(_, nomod) {\n    const fields = this.fields;\n    return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : isArray(_) ? _.some(f => fields[f]) : fields[_];\n  },\n\n  /**\n   * Adds a filter function to one more tuple sets. Filters are applied to\n   * backing tuple arrays, to determine the actual set of tuples considered\n   * added, removed or modified. They can be used to delay materialization of\n   * a tuple set in order to avoid expensive array copies. In addition, the\n   * filter functions can serve as value transformers: unlike standard predicate\n   * function (which return boolean values), Pulse filters should return the\n   * actual tuple value to process. If a tuple set is already filtered, the\n   * new filter function will be appended into a conjuntive ('and') query.\n   * @param {number} flags - Flags indicating the tuple set(s) to filter.\n   * @param {function(*):object} filter - Filter function that will be applied\n   *   to the tuple set array, and should return a data tuple if the value\n   *   should be included in the tuple set, and falsy (or null) otherwise.\n   * @return {Pulse} - Returns this pulse instance.\n   */\n  filter(flags, filter) {\n    const p = this;\n    if (flags & ADD) p.addF = addFilter(p.addF, filter);\n    if (flags & REM) p.remF = addFilter(p.remF, filter);\n    if (flags & MOD) p.modF = addFilter(p.modF, filter);\n    if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter);\n    return p;\n  },\n\n  /**\n   * Materialize one or more tuple sets in this pulse. If the tuple set(s) have\n   * a registered filter function, it will be applied and the tuple set(s) will\n   * be replaced with materialized tuple arrays.\n   * @param {number} flags - Flags indicating the tuple set(s) to materialize.\n   * @return {Pulse} - Returns this pulse instance.\n   */\n  materialize(flags) {\n    flags = flags || ALL;\n    const p = this;\n\n    if (flags & ADD && p.addF) {\n      p.add = materialize(p.add, p.addF);\n      p.addF = null;\n    }\n\n    if (flags & REM && p.remF) {\n      p.rem = materialize(p.rem, p.remF);\n      p.remF = null;\n    }\n\n    if (flags & MOD && p.modF) {\n      p.mod = materialize(p.mod, p.modF);\n      p.modF = null;\n    }\n\n    if (flags & SOURCE && p.srcF) {\n      p.source = p.source.filter(p.srcF);\n      p.srcF = null;\n    }\n\n    return p;\n  },\n\n  /**\n   * Visit one or more tuple sets in this pulse.\n   * @param {number} flags - Flags indicating the tuple set(s) to visit.\n   *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source\n   *   has been set).\n   * @param {function(object):*} - Visitor function invoked per-tuple.\n   * @return {Pulse} - Returns this pulse instance.\n   */\n  visit(flags, visitor) {\n    const p = this,\n          v = visitor;\n\n    if (flags & SOURCE) {\n      visitArray(p.source, p.srcF, v);\n      return p;\n    }\n\n    if (flags & ADD) visitArray(p.add, p.addF, v);\n    if (flags & REM) visitArray(p.rem, p.remF, v);\n    if (flags & MOD) visitArray(p.mod, p.modF, v);\n    const src = p.source;\n\n    if (flags & REFLOW && src) {\n      const sum = p.add.length + p.mod.length;\n\n      if (sum === src.length) ; else if (sum) {\n        visitArray(src, filter(p, ADD_MOD), v);\n      } else {\n        // if no add/rem/mod tuples, visit source\n        visitArray(src, p.srcF, v);\n      }\n    }\n\n    return p;\n  }\n\n};\n\n/**\n * Represents a set of multiple pulses. Used as input for operators\n * that accept multiple pulses at a time. Contained pulses are\n * accessible via the public \"pulses\" array property. This pulse doe\n * not carry added, removed or modified tuples directly. However,\n * the visit method can be used to traverse all such tuples contained\n * in sub-pulses with a timestamp matching this parent multi-pulse.\n * @constructor\n * @param {Dataflow} dataflow - The backing dataflow instance.\n * @param {number} stamp - The timestamp.\n * @param {Array<Pulse>} pulses - The sub-pulses for this multi-pulse.\n */\n\nfunction MultiPulse(dataflow, stamp, pulses, encode) {\n  const p = this,\n        n = pulses.length;\n  let c = 0;\n  this.dataflow = dataflow;\n  this.stamp = stamp;\n  this.fields = null;\n  this.encode = encode || null;\n  this.pulses = pulses;\n\n  for (let i = 0; i < n; ++i) {\n    const pulse = pulses[i];\n    if (pulse.stamp !== stamp) continue;\n\n    if (pulse.fields) {\n      const hash = p.fields || (p.fields = {});\n\n      for (const f in pulse.fields) {\n        hash[f] = 1;\n      }\n    }\n\n    if (pulse.changed(p.ADD)) c |= p.ADD;\n    if (pulse.changed(p.REM)) c |= p.REM;\n    if (pulse.changed(p.MOD)) c |= p.MOD;\n  }\n\n  this.changes = c;\n}\ninherits(MultiPulse, Pulse, {\n  /**\n   * Creates a new pulse based on the values of this pulse.\n   * The dataflow, time stamp and field modification values are copied over.\n   * @return {Pulse}\n   */\n  fork(flags) {\n    const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);\n\n    if (flags !== undefined) {\n      if (flags & p.ADD) this.visit(p.ADD, t => p.add.push(t));\n      if (flags & p.REM) this.visit(p.REM, t => p.rem.push(t));\n      if (flags & p.MOD) this.visit(p.MOD, t => p.mod.push(t));\n    }\n\n    return p;\n  },\n\n  changed(flags) {\n    return this.changes & flags;\n  },\n\n  modified(_) {\n    const p = this,\n          fields = p.fields;\n    return !(fields && p.changes & p.MOD) ? 0 : isArray(_) ? _.some(f => fields[f]) : fields[_];\n  },\n\n  filter() {\n    error('MultiPulse does not support filtering.');\n  },\n\n  materialize() {\n    error('MultiPulse does not support materialization.');\n  },\n\n  visit(flags, visitor) {\n    const p = this,\n          pulses = p.pulses,\n          n = pulses.length;\n    let i = 0;\n\n    if (flags & p.SOURCE) {\n      for (; i < n; ++i) {\n        pulses[i].visit(flags, visitor);\n      }\n    } else {\n      for (; i < n; ++i) {\n        if (pulses[i].stamp === p.stamp) {\n          pulses[i].visit(flags, visitor);\n        }\n      }\n    }\n\n    return p;\n  }\n\n});\n\n/* eslint-disable require-atomic-updates */\n/**\n * Evaluates the dataflow and returns a Promise that resolves when pulse\n * propagation completes. This method will increment the current timestamp\n * and process all updated, pulsed and touched operators. When invoked for\n * the first time, all registered operators will be processed. This method\n * should not be invoked by third-party clients, use {@link runAsync} or\n * {@link run} instead.\n * @param {string} [encode] - The name of an encoding set to invoke during\n *   propagation. This value is added to generated Pulse instances;\n *   operators can then respond to (or ignore) this setting as appropriate.\n *   This parameter can be used in conjunction with the Encode transform in\n *   the vega-encode package.\n * @param {function} [prerun] - An optional callback function to invoke\n *   immediately before dataflow evaluation commences.\n * @param {function} [postrun] - An optional callback function to invoke\n *   after dataflow evaluation completes. The callback will be invoked\n *   after those registered via {@link runAfter}.\n * @return {Promise} - A promise that resolves to this dataflow after\n *   evaluation completes.\n */\n\nasync function evaluate(encode, prerun, postrun) {\n  const df = this,\n        async = []; // if the pulse value is set, this is a re-entrant call\n\n  if (df._pulse) return reentrant(df); // wait for pending datasets to load\n\n  if (df._pending) await df._pending; // invoke prerun function, if provided\n\n  if (prerun) await asyncCallback(df, prerun); // exit early if there are no updates\n\n  if (!df._touched.length) {\n    df.debug('Dataflow invoked, but nothing to do.');\n    return df;\n  } // increment timestamp clock\n\n\n  const stamp = ++df._clock; // set the current pulse\n\n  df._pulse = new Pulse(df, stamp, encode); // initialize priority queue, reset touched operators\n\n  df._touched.forEach(op => df._enqueue(op, true));\n\n  df._touched = UniqueList(id);\n  let count = 0,\n      op,\n      next,\n      error;\n\n  try {\n    while (df._heap.size() > 0) {\n      // dequeue operator with highest priority\n      op = df._heap.pop(); // re-queue if rank changed\n\n      if (op.rank !== op.qrank) {\n        df._enqueue(op, true);\n\n        continue;\n      } // otherwise, evaluate the operator\n\n\n      next = op.run(df._getPulse(op, encode));\n\n      if (next.then) {\n        // await if operator returns a promise directly\n        next = await next;\n      } else if (next.async) {\n        // queue parallel asynchronous execution\n        async.push(next.async);\n        next = StopPropagation;\n      } // propagate evaluation, enqueue dependent operators\n\n\n      if (next !== StopPropagation) {\n        if (op._targets) op._targets.forEach(op => df._enqueue(op));\n      } // increment visit counter\n\n\n      ++count;\n    }\n  } catch (err) {\n    df._heap.clear();\n\n    error = err;\n  } // reset pulse map\n\n\n  df._input = {};\n  df._pulse = null;\n  df.debug(`Pulse ${stamp}: ${count} operators`);\n\n  if (error) {\n    df._postrun = [];\n    df.error(error);\n  } // invoke callbacks queued via runAfter\n\n\n  if (df._postrun.length) {\n    const pr = df._postrun.sort((a, b) => b.priority - a.priority);\n\n    df._postrun = [];\n\n    for (let i = 0; i < pr.length; ++i) {\n      await asyncCallback(df, pr[i].callback);\n    }\n  } // invoke postrun function, if provided\n\n\n  if (postrun) await asyncCallback(df, postrun); // handle non-blocking asynchronous callbacks\n\n  if (async.length) {\n    Promise.all(async).then(cb => df.runAsync(null, () => {\n      cb.forEach(f => {\n        try {\n          f(df);\n        } catch (err) {\n          df.error(err);\n        }\n      });\n    }));\n  }\n\n  return df;\n}\n/**\n * Queues dataflow evaluation to run once any other queued evaluations have\n * completed and returns a Promise that resolves when the queued pulse\n * propagation completes. If provided, a callback function will be invoked\n * immediately before evaluation commences. This method will ensure a\n * separate evaluation is invoked for each time it is called.\n * @param {string} [encode] - The name of an encoding set to invoke during\n *   propagation. This value is added to generated Pulse instances;\n *   operators can then respond to (or ignore) this setting as appropriate.\n *   This parameter can be used in conjunction with the Encode transform in\n *   the vega-encode package.\n * @param {function} [prerun] - An optional callback function to invoke\n *   immediately before dataflow evaluation commences.\n * @param {function} [postrun] - An optional callback function to invoke\n *   after dataflow evaluation completes. The callback will be invoked\n *   after those registered via {@link runAfter}.\n * @return {Promise} - A promise that resolves to this dataflow after\n *   evaluation completes.\n */\n\nasync function runAsync(encode, prerun, postrun) {\n  // await previously queued functions\n  while (this._running) await this._running; // run dataflow, manage running promise\n\n\n  const clear = () => this._running = null;\n\n  (this._running = this.evaluate(encode, prerun, postrun)).then(clear, clear);\n  return this._running;\n}\n/**\n * Requests dataflow evaluation and the immediately returns this dataflow\n * instance. If there are pending data loading or other asynchronous\n * operations, the dataflow will evaluate asynchronously after this method\n * has been invoked. To track when dataflow evaluation completes, use the\n * {@link runAsync} method instead. This method will raise an error if\n * invoked while the dataflow is already in the midst of evaluation.\n * @param {string} [encode] - The name of an encoding set to invoke during\n *   propagation. This value is added to generated Pulse instances;\n *   operators can then respond to (or ignore) this setting as appropriate.\n *   This parameter can be used in conjunction with the Encode transform in\n *   the vega-encode module.\n * @param {function} [prerun] - An optional callback function to invoke\n *   immediately before dataflow evaluation commences.\n * @param {function} [postrun] - An optional callback function to invoke\n *   after dataflow evaluation completes. The callback will be invoked\n *   after those registered via {@link runAfter}.\n * @return {Dataflow} - This dataflow instance.\n */\n\nfunction run(encode, prerun, postrun) {\n  return this._pulse ? reentrant(this) : (this.evaluate(encode, prerun, postrun), this);\n}\n/**\n * Schedules a callback function to be invoked after the current pulse\n * propagation completes. If no propagation is currently occurring,\n * the function is invoked immediately. Callbacks scheduled via runAfter\n * are invoked immediately upon completion of the current cycle, before\n * any request queued via runAsync. This method is primarily intended for\n * internal use. Third-party callers using runAfter to schedule a callback\n * that invokes {@link run} or {@link runAsync} should not use this method,\n * but instead use {@link runAsync} with prerun or postrun arguments.\n * @param {function(Dataflow)} callback - The callback function to run.\n *   The callback will be invoked with this Dataflow instance as its\n *   sole argument.\n * @param {boolean} enqueue - A boolean flag indicating that the\n *   callback should be queued up to run after the next propagation\n *   cycle, suppressing immediate invocation when propagation is not\n *   currently occurring.\n * @param {number} [priority] - A priority value used to sort registered\n *   callbacks to determine execution order. This argument is intended\n *   for internal Vega use only.\n */\n\nfunction runAfter(callback, enqueue, priority) {\n  if (this._pulse || enqueue) {\n    // pulse propagation is currently running, queue to run after\n    this._postrun.push({\n      priority: priority || 0,\n      callback: callback\n    });\n  } else {\n    // pulse propagation already complete, invoke immediately\n    try {\n      callback(this);\n    } catch (err) {\n      this.error(err);\n    }\n  }\n}\n/**\n * Raise an error for re-entrant dataflow evaluation.\n */\n\nfunction reentrant(df) {\n  df.error('Dataflow already running. Use runAsync() to chain invocations.');\n  return df;\n}\n/**\n * Enqueue an operator into the priority queue for evaluation. The operator\n * will be enqueued if it has no registered pulse for the current cycle, or if\n * the force argument is true. Upon enqueue, this method also sets the\n * operator's qrank to the current rank value.\n * @param {Operator} op - The operator to enqueue.\n * @param {boolean} [force] - A flag indicating if the operator should be\n *   forceably added to the queue, even if it has already been previously\n *   enqueued during the current pulse propagation. This is useful when the\n *   dataflow graph is dynamically modified and the operator rank changes.\n */\n\n\nfunction enqueue(op, force) {\n  const q = op.stamp < this._clock;\n  if (q) op.stamp = this._clock;\n\n  if (q || force) {\n    op.qrank = op.rank;\n\n    this._heap.push(op);\n  }\n}\n/**\n * Provide a correct pulse for evaluating an operator. If the operator has an\n * explicit source operator, we will try to pull the pulse(s) from it.\n * If there is an array of source operators, we build a multi-pulse.\n * Otherwise, we return a current pulse with correct source data.\n * If the pulse is the pulse map has an explicit target set, we use that.\n * Else if the pulse on the upstream source operator is current, we use that.\n * Else we use the pulse from the pulse map, but copy the source tuple array.\n * @param {Operator} op - The operator for which to get an input pulse.\n * @param {string} [encode] - An (optional) encoding set name with which to\n *   annotate the returned pulse. See {@link run} for more information.\n */\n\nfunction getPulse(op, encode) {\n  const s = op.source,\n        stamp = this._clock;\n  return s && isArray(s) ? new MultiPulse(this, stamp, s.map(_ => _.pulse), encode) : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);\n}\n\nfunction singlePulse(p, s) {\n  if (s && s.stamp === p.stamp) {\n    return s;\n  }\n\n  p = p.fork();\n\n  if (s && s !== StopPropagation) {\n    p.source = s.source;\n  }\n\n  return p;\n}\n\nconst NO_OPT = {\n  skip: false,\n  force: false\n};\n/**\n * Touches an operator, scheduling it to be evaluated. If invoked outside of\n * a pulse propagation, the operator will be evaluated the next time this\n * dataflow is run. If invoked in the midst of pulse propagation, the operator\n * will be queued for evaluation if and only if the operator has not yet been\n * evaluated on the current propagation timestamp.\n * @param {Operator} op - The operator to touch.\n * @param {object} [options] - Additional options hash.\n * @param {boolean} [options.skip] - If true, the operator will\n *   be skipped: it will not be evaluated, but its dependents will be.\n * @return {Dataflow}\n */\n\nfunction touch(op, options) {\n  const opt = options || NO_OPT;\n\n  if (this._pulse) {\n    // if in midst of propagation, add to priority queue\n    this._enqueue(op);\n  } else {\n    // otherwise, queue for next propagation\n    this._touched.add(op);\n  }\n\n  if (opt.skip) op.skip(true);\n  return this;\n}\n/**\n * Updates the value of the given operator.\n * @param {Operator} op - The operator to update.\n * @param {*} value - The value to set.\n * @param {object} [options] - Additional options hash.\n * @param {boolean} [options.force] - If true, the operator will\n *   be re-evaluated even if its value has not changed.\n * @param {boolean} [options.skip] - If true, the operator will\n *   be skipped: it will not be evaluated, but its dependents will be.\n * @return {Dataflow}\n */\n\nfunction update(op, value, options) {\n  const opt = options || NO_OPT;\n\n  if (op.set(value) || opt.force) {\n    this.touch(op, opt);\n  }\n\n  return this;\n}\n/**\n * Pulses an operator with a changeset of tuples. If invoked outside of\n * a pulse propagation, the pulse will be applied the next time this\n * dataflow is run. If invoked in the midst of pulse propagation, the pulse\n * will be added to the set of active pulses and will be applied if and\n * only if the target operator has not yet been evaluated on the current\n * propagation timestamp.\n * @param {Operator} op - The operator to pulse.\n * @param {ChangeSet} value - The tuple changeset to apply.\n * @param {object} [options] - Additional options hash.\n * @param {boolean} [options.skip] - If true, the operator will\n *   be skipped: it will not be evaluated, but its dependents will be.\n * @return {Dataflow}\n */\n\nfunction pulse(op, changeset, options) {\n  this.touch(op, options || NO_OPT);\n  const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)),\n        t = op.pulse && op.pulse.source || [];\n  p.target = op;\n  this._input[op.id] = changeset.pulse(p, t);\n  return this;\n}\n\nfunction Heap(cmp) {\n  let nodes = [];\n  return {\n    clear: () => nodes = [],\n    size: () => nodes.length,\n    peek: () => nodes[0],\n    push: x => {\n      nodes.push(x);\n      return siftdown(nodes, 0, nodes.length - 1, cmp);\n    },\n    pop: () => {\n      const last = nodes.pop();\n      let item;\n\n      if (nodes.length) {\n        item = nodes[0];\n        nodes[0] = last;\n        siftup(nodes, 0, cmp);\n      } else {\n        item = last;\n      }\n\n      return item;\n    }\n  };\n}\n\nfunction siftdown(array, start, idx, cmp) {\n  let parent, pidx;\n  const item = array[idx];\n\n  while (idx > start) {\n    pidx = idx - 1 >> 1;\n    parent = array[pidx];\n\n    if (cmp(item, parent) < 0) {\n      array[idx] = parent;\n      idx = pidx;\n      continue;\n    }\n\n    break;\n  }\n\n  return array[idx] = item;\n}\n\nfunction siftup(array, idx, cmp) {\n  const start = idx,\n        end = array.length,\n        item = array[idx];\n  let cidx = (idx << 1) + 1,\n      ridx;\n\n  while (cidx < end) {\n    ridx = cidx + 1;\n\n    if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {\n      cidx = ridx;\n    }\n\n    array[idx] = array[cidx];\n    idx = cidx;\n    cidx = (idx << 1) + 1;\n  }\n\n  array[idx] = item;\n  return siftdown(array, start, idx, cmp);\n}\n\n/**\n * A dataflow graph for reactive processing of data streams.\n * @constructor\n */\n\nfunction Dataflow() {\n  this.logger(logger());\n  this.logLevel(Error);\n  this._clock = 0;\n  this._rank = 0;\n  this._locale = defaultLocale();\n\n  try {\n    this._loader = loader();\n  } catch (e) {// do nothing if loader module is unavailable\n  }\n\n  this._touched = UniqueList(id);\n  this._input = {};\n  this._pulse = null;\n  this._heap = Heap((a, b) => a.qrank - b.qrank);\n  this._postrun = [];\n}\n\nfunction logMethod(method) {\n  return function () {\n    return this._log[method].apply(this, arguments);\n  };\n}\n\nDataflow.prototype = {\n  /**\n   * The current timestamp of this dataflow. This value reflects the\n   * timestamp of the previous dataflow run. The dataflow is initialized\n   * with a stamp value of 0. The initial run of the dataflow will have\n   * a timestap of 1, and so on. This value will match the\n   * {@link Pulse.stamp} property.\n   * @return {number} - The current timestamp value.\n   */\n  stamp() {\n    return this._clock;\n  },\n\n  /**\n   * Gets or sets the loader instance to use for data file loading. A\n   * loader object must provide a \"load\" method for loading files and a\n   * \"sanitize\" method for checking URL/filename validity. Both methods\n   * should accept a URI and options hash as arguments, and return a Promise\n   * that resolves to the loaded file contents (load) or a hash containing\n   * sanitized URI data with the sanitized url assigned to the \"href\" property\n   * (sanitize).\n   * @param {object} _ - The loader instance to use.\n   * @return {object|Dataflow} - If no arguments are provided, returns\n   *   the current loader instance. Otherwise returns this Dataflow instance.\n   */\n  loader(_) {\n    if (arguments.length) {\n      this._loader = _;\n      return this;\n    } else {\n      return this._loader;\n    }\n  },\n\n  /**\n   * Gets or sets the locale instance to use for formatting and parsing\n   * string values. The locale object should be provided by the\n   * vega-format library, and include methods such as format, timeFormat,\n   * utcFormat, timeParse, and utcParse.\n   * @param {object} _ - The locale instance to use.\n   * @return {object|Dataflow} - If no arguments are provided, returns\n   *   the current locale instance. Otherwise returns this Dataflow instance.\n   */\n  locale(_) {\n    if (arguments.length) {\n      this._locale = _;\n      return this;\n    } else {\n      return this._locale;\n    }\n  },\n\n  /**\n   * Get or set the logger instance used to log messages. If no arguments are\n   * provided, returns the current logger instance. Otherwise, sets the logger\n   * and return this Dataflow instance. Provided loggers must support the full\n   * API of logger objects generated by the vega-util logger method. Note that\n   * by default the log level of the new logger will be used; use the logLevel\n   * method to adjust the log level as needed.\n   */\n  logger(logger) {\n    if (arguments.length) {\n      this._log = logger;\n      return this;\n    } else {\n      return this._log;\n    }\n  },\n\n  /**\n   * Logs an error message. By default, logged messages are written to console\n   * output. The message will only be logged if the current log level is high\n   * enough to permit error messages.\n   */\n  error: logMethod('error'),\n\n  /**\n   * Logs a warning message. By default, logged messages are written to console\n   * output. The message will only be logged if the current log level is high\n   * enough to permit warning messages.\n   */\n  warn: logMethod('warn'),\n\n  /**\n   * Logs a information message. By default, logged messages are written to\n   * console output. The message will only be logged if the current log level is\n   * high enough to permit information messages.\n   */\n  info: logMethod('info'),\n\n  /**\n   * Logs a debug message. By default, logged messages are written to console\n   * output. The message will only be logged if the current log level is high\n   * enough to permit debug messages.\n   */\n  debug: logMethod('debug'),\n\n  /**\n   * Get or set the current log level. If an argument is provided, it\n   * will be used as the new log level.\n   * @param {number} [level] - Should be one of None, Warn, Info\n   * @return {number} - The current log level.\n   */\n  logLevel: logMethod('level'),\n\n  /**\n   * Empty entry threshold for garbage cleaning. Map data structures will\n   * perform cleaning once the number of empty entries exceeds this value.\n   */\n  cleanThreshold: 1e4,\n  // OPERATOR REGISTRATION\n  add,\n  connect,\n  rank,\n  rerank,\n  // OPERATOR UPDATES\n  pulse,\n  touch,\n  update,\n  changeset,\n  // DATA LOADING\n  ingest,\n  parse,\n  preload,\n  request,\n  // EVENT HANDLING\n  events,\n  on,\n  // PULSE PROPAGATION\n  evaluate,\n  run,\n  runAsync,\n  runAfter,\n  _enqueue: enqueue,\n  _getPulse: getPulse\n};\n\n/**\n * Abstract class for operators that process data tuples.\n * Subclasses must provide a {@link transform} method for operator processing.\n * @constructor\n * @param {*} [init] - The initial value for this operator.\n * @param {object} [params] - The parameters for this operator.\n * @param {Operator} [source] - The operator from which to receive pulses.\n */\n\nfunction Transform(init, params) {\n  Operator.call(this, init, null, params);\n}\ninherits(Transform, Operator, {\n  /**\n   * Overrides {@link Operator.evaluate} for transform operators.\n   * Internally, this method calls {@link evaluate} to perform processing.\n   * If {@link evaluate} returns a falsy value, the input pulse is returned.\n   * This method should NOT be overridden, instead overrride {@link evaluate}.\n   * @param {Pulse} pulse - the current dataflow pulse.\n   * @return the output pulse for this operator (or StopPropagation)\n   */\n  run(pulse) {\n    if (pulse.stamp < this.stamp) return pulse.StopPropagation;\n    let rv;\n\n    if (this.skip()) {\n      this.skip(false);\n    } else {\n      rv = this.evaluate(pulse);\n    }\n\n    rv = rv || pulse;\n\n    if (rv.then) {\n      rv = rv.then(_ => this.pulse = _);\n    } else if (rv !== pulse.StopPropagation) {\n      this.pulse = rv;\n    }\n\n    return rv;\n  },\n\n  /**\n   * Overrides {@link Operator.evaluate} for transform operators.\n   * Marshalls parameter values and then invokes {@link transform}.\n   * @param {Pulse} pulse - the current dataflow pulse.\n   * @return {Pulse} The output pulse (or StopPropagation). A falsy return\n       value (including undefined) will let the input pulse pass through.\n  */\n  evaluate(pulse) {\n    const params = this.marshall(pulse.stamp),\n          out = this.transform(params, pulse);\n    params.clear();\n    return out;\n  },\n\n  /**\n   * Process incoming pulses.\n   * Subclasses should override this method to implement transforms.\n   * @param {Parameters} _ - The operator parameter values.\n   * @param {Pulse} pulse - The current dataflow pulse.\n   * @return {Pulse} The output pulse (or StopPropagation). A falsy return\n   *   value (including undefined) will let the input pulse pass through.\n   */\n  transform() {}\n\n});\n\nconst transforms = {};\nfunction definition(type) {\n  const t = transform(type);\n  return t && t.Definition || null;\n}\nfunction transform(type) {\n  type = type && type.toLowerCase();\n  return hasOwnProperty(transforms, type) ? transforms[type] : null;\n}\n\nexport { Dataflow, EventStream, MultiPulse, Operator, Parameters, Pulse, Transform, UniqueList, asyncCallback, changeset, definition, derive, ingest$1 as ingest, isChangeSet, isTuple, rederive, replace, stableCompare, transform, transforms, tupleid };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}