{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../bin';\nimport { COLOR, FILL, isXorY, isXorYOffset, POLAR_POSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, STROKE } from '../../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldDef, valueExpr } from '../../channeldef';\nimport { isDateTime } from '../../datetime';\nimport { channelHasNestedOffsetScale } from '../../encoding';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, isContinuousToContinuous, isContinuousToDiscrete, ScaleType, scaleTypeSupportProperty } from '../../scale';\nimport * as util from '../../util';\nimport { contains, getFirstDefined, keys } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { parseUnitScaleRange } from './range';\nexport function parseScaleProperty(model, property) {\n  if (isUnitModel(model)) {\n    parseUnitScaleProperty(model, property);\n  } else {\n    parseNonUnitScaleProperty(model, property);\n  }\n}\n\nfunction parseUnitScaleProperty(model, property) {\n  const localScaleComponents = model.component.scales;\n  const {\n    config,\n    encoding,\n    markDef,\n    specifiedScales\n  } = model;\n\n  for (const channel of keys(localScaleComponents)) {\n    const specifiedScale = specifiedScales[channel];\n    const localScaleCmpt = localScaleComponents[channel];\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n    const specifiedValue = specifiedScale[property];\n    const scaleType = mergedScaleCmpt.get('type');\n    const scalePadding = mergedScaleCmpt.get('padding');\n    const scalePaddingInner = mergedScaleCmpt.get('paddingInner');\n    const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n    const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n    if (specifiedValue !== undefined) {\n      // If there is a specified value, check if it is compatible with scale type and channel\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      }\n    }\n\n    if (supportedByScaleType && channelIncompatability === undefined) {\n      if (specifiedValue !== undefined) {\n        const timeUnit = fieldOrDatumDef['timeUnit'];\n        const type = fieldOrDatumDef.type;\n\n        switch (property) {\n          // domainMax/Min to signal if the value is a datetime object\n          case 'domainMax':\n          case 'domainMin':\n            if (isDateTime(specifiedScale[property]) || type === 'temporal' || timeUnit) {\n              localScaleCmpt.set(property, {\n                signal: valueExpr(specifiedScale[property], {\n                  type,\n                  timeUnit\n                })\n              }, true);\n            } else {\n              localScaleCmpt.set(property, specifiedScale[property], true);\n            }\n\n            break;\n\n          default:\n            localScaleCmpt.copyKeyFromObject(property, specifiedScale);\n        }\n      } else {\n        const value = property in scaleRules ? scaleRules[property]({\n          model,\n          channel,\n          fieldOrDatumDef,\n          scaleType,\n          scalePadding,\n          scalePaddingInner,\n          domain: specifiedScale.domain,\n          domainMin: specifiedScale.domainMin,\n          domainMax: specifiedScale.domainMax,\n          markDef,\n          config,\n          hasNestedOffsetScale: channelHasNestedOffsetScale(encoding, channel)\n        }) : config.scale[property];\n\n        if (value !== undefined) {\n          localScaleCmpt.set(property, value, false);\n        }\n      }\n    }\n  }\n}\n\nexport const scaleRules = {\n  bins: _ref => {\n    let {\n      model,\n      fieldOrDatumDef\n    } = _ref;\n    return isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : undefined;\n  },\n  interpolate: _ref2 => {\n    let {\n      channel,\n      fieldOrDatumDef\n    } = _ref2;\n    return interpolate(channel, fieldOrDatumDef.type);\n  },\n  nice: _ref3 => {\n    let {\n      scaleType,\n      channel,\n      domain,\n      domainMin,\n      domainMax,\n      fieldOrDatumDef\n    } = _ref3;\n    return nice(scaleType, channel, domain, domainMin, domainMax, fieldOrDatumDef);\n  },\n  padding: _ref4 => {\n    let {\n      channel,\n      scaleType,\n      fieldOrDatumDef,\n      markDef,\n      config\n    } = _ref4;\n    return padding(channel, scaleType, config.scale, fieldOrDatumDef, markDef, config.bar);\n  },\n  paddingInner: _ref5 => {\n    let {\n      scalePadding,\n      channel,\n      markDef,\n      scaleType,\n      config,\n      hasNestedOffsetScale\n    } = _ref5;\n    return paddingInner(scalePadding, channel, markDef.type, scaleType, config.scale, hasNestedOffsetScale);\n  },\n  paddingOuter: _ref6 => {\n    let {\n      scalePadding,\n      channel,\n      scaleType,\n      scalePaddingInner,\n      config,\n      hasNestedOffsetScale\n    } = _ref6;\n    return paddingOuter(scalePadding, channel, scaleType, scalePaddingInner, config.scale, hasNestedOffsetScale);\n  },\n  reverse: _ref7 => {\n    let {\n      fieldOrDatumDef,\n      scaleType,\n      channel,\n      config\n    } = _ref7;\n    const sort = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined;\n    return reverse(scaleType, sort, channel, config.scale);\n  },\n  zero: _ref8 => {\n    let {\n      channel,\n      fieldOrDatumDef,\n      domain,\n      markDef,\n      scaleType\n    } = _ref8;\n    return zero(channel, fieldOrDatumDef, domain, markDef, scaleType);\n  }\n}; // This method is here rather than in range.ts to avoid circular dependency.\n\nexport function parseScaleRange(model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleRange(model);\n  } else {\n    parseNonUnitScaleProperty(model, 'range');\n  }\n}\nexport function parseNonUnitScaleProperty(model, property) {\n  const localScaleComponents = model.component.scales;\n\n  for (const child of model.children) {\n    if (property === 'range') {\n      parseScaleRange(child);\n    } else {\n      parseScaleProperty(child, property);\n    }\n  }\n\n  for (const channel of keys(localScaleComponents)) {\n    let valueWithExplicit;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n\n      if (childComponent) {\n        const childValueWithExplicit = childComponent.getWithExplicit(property);\n        valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property, 'scale', tieBreakByComparing((v1, v2) => {\n          switch (property) {\n            case 'range':\n              // For step, prefer larger step\n              if (v1.step && v2.step) {\n                return v1.step - v2.step;\n              }\n\n              return 0;\n            // TODO: precedence rule for other properties\n          }\n\n          return 0;\n        }));\n      }\n    }\n\n    localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n  }\n}\nexport function bins(model, fieldDef) {\n  const bin = fieldDef.bin;\n\n  if (isBinning(bin)) {\n    const binSignal = getBinSignalName(model, fieldDef.field, bin);\n    return new SignalRefWrapper(() => {\n      return model.getSignalName(binSignal);\n    });\n  } else if (isBinned(bin) && isBinParams(bin) && bin.step !== undefined) {\n    // start and stop will be determined from the scale domain\n    return {\n      step: bin.step\n    };\n  }\n\n  return undefined;\n}\nexport function interpolate(channel, type) {\n  if (contains([COLOR, FILL, STROKE], channel) && type !== 'nominal') {\n    return 'hcl';\n  }\n\n  return undefined;\n}\nexport function nice(scaleType, channel, specifiedDomain, domainMin, domainMax, fieldOrDatumDef) {\n  var _a;\n\n  if (((_a = getFieldDef(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.bin) || isArray(specifiedDomain) || domainMax != null || domainMin != null || util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n    return undefined;\n  }\n\n  return isXorY(channel) ? true : undefined;\n}\nexport function padding(channel, scaleType, scaleConfig, fieldOrDatumDef, markDef, barConfig) {\n  if (isXorY(channel)) {\n    if (isContinuousToContinuous(scaleType)) {\n      if (scaleConfig.continuousPadding !== undefined) {\n        return scaleConfig.continuousPadding;\n      }\n\n      const {\n        type,\n        orient\n      } = markDef;\n\n      if (type === 'bar' && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {\n        if (orient === 'vertical' && channel === 'x' || orient === 'horizontal' && channel === 'y') {\n          return barConfig.continuousBandSize;\n        }\n      }\n    }\n\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n\n  return undefined;\n}\nexport function paddingInner(paddingValue, channel, mark, scaleType, scaleConfig) {\n  let hasNestedOffsetScale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n\n  if (isXorY(channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n    const {\n      bandPaddingInner,\n      barBandPaddingInner,\n      rectBandPaddingInner,\n      bandWithNestedOffsetPaddingInner\n    } = scaleConfig;\n\n    if (hasNestedOffsetScale) {\n      return bandWithNestedOffsetPaddingInner;\n    }\n\n    return getFirstDefined(bandPaddingInner, mark === 'bar' ? barBandPaddingInner : rectBandPaddingInner);\n  } else if (isXorYOffset(channel)) {\n    if (scaleType === ScaleType.BAND) {\n      return scaleConfig.offsetBandPaddingInner;\n    }\n  }\n\n  return undefined;\n}\nexport function paddingOuter(paddingValue, channel, scaleType, paddingInnerValue, scaleConfig) {\n  let hasNestedOffsetScale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n\n  if (isXorY(channel)) {\n    const {\n      bandPaddingOuter,\n      bandWithNestedOffsetPaddingOuter\n    } = scaleConfig;\n\n    if (hasNestedOffsetScale) {\n      return bandWithNestedOffsetPaddingOuter;\n    } // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n\n\n    if (scaleType === ScaleType.BAND) {\n      return getFirstDefined(bandPaddingOuter,\n      /* By default, paddingOuter is paddingInner / 2. The reason is that\n        size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n        and we want the width/height to be integer by default.\n        Note that step (by default) and cardinality are integers.) */\n      isSignalRef(paddingInnerValue) ? {\n        signal: `${paddingInnerValue.signal}/2`\n      } : paddingInnerValue / 2);\n    }\n  } else if (isXorYOffset(channel)) {\n    if (scaleType === ScaleType.POINT) {\n      return 0.5; // so the point positions align with centers of band scales.\n    } else if (scaleType === ScaleType.BAND) {\n      return scaleConfig.offsetBandPaddingOuter;\n    }\n  }\n\n  return undefined;\n}\nexport function reverse(scaleType, sort, channel, scaleConfig) {\n  if (channel === 'x' && scaleConfig.xReverse !== undefined) {\n    if (hasContinuousDomain(scaleType) && sort === 'descending') {\n      if (isSignalRef(scaleConfig.xReverse)) {\n        return {\n          signal: `!${scaleConfig.xReverse.signal}`\n        };\n      } else {\n        return !scaleConfig.xReverse;\n      }\n    }\n\n    return scaleConfig.xReverse;\n  }\n\n  if (hasContinuousDomain(scaleType) && sort === 'descending') {\n    // For continuous domain scales, Vega does not support domain sort.\n    // Thus, we reverse range instead if sort is descending\n    return true;\n  }\n\n  return undefined;\n}\nexport function zero(channel, fieldDef, specifiedDomain, markDef, scaleType) {\n  // If users explicitly provide a domain, we should not augment zero as that will be unexpected.\n  const hasCustomDomain = !!specifiedDomain && specifiedDomain !== 'unaggregated';\n\n  if (hasCustomDomain) {\n    if (hasContinuousDomain(scaleType)) {\n      if (isArray(specifiedDomain)) {\n        const first = specifiedDomain[0];\n        const last = specifiedDomain[specifiedDomain.length - 1];\n\n        if (first <= 0 && last >= 0) {\n          // if the domain includes zero, make zero remains true\n          return true;\n        }\n      }\n\n      return false;\n    }\n  } // If there is no custom domain, return true only for the following cases:\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common. However, if the scaleType is discretizing scale, we want to return\n  // false so that range doesn't start at zero\n\n\n  if (channel === 'size' && fieldDef.type === 'quantitative' && !isContinuousToDiscrete(scaleType)) {\n    return true;\n  } // 2) non-binned, quantitative x-scale or y-scale\n  // (For binning, we should not include zero by default because binning are calculated without zero.)\n\n\n  if (!(isFieldDef(fieldDef) && fieldDef.bin) && util.contains([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)) {\n    const {\n      orient,\n      type\n    } = markDef;\n\n    if (contains(['bar', 'area', 'line', 'trail'], type)) {\n      if (orient === 'horizontal' && channel === 'y' || orient === 'vertical' && channel === 'x') {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"mappings":"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","names":["isArray","isBinned","isBinning","isBinParams","COLOR","FILL","isXorY","isXorYOffset","POLAR_POSITION_SCALE_CHANNELS","POSITION_SCALE_CHANNELS","STROKE","getFieldDef","getFieldOrDatumDef","isFieldDef","valueExpr","isDateTime","channelHasNestedOffsetScale","log","channelScalePropertyIncompatability","hasContinuousDomain","isContinuousToContinuous","isContinuousToDiscrete","ScaleType","scaleTypeSupportProperty","util","contains","getFirstDefined","keys","isSignalRef","getBinSignalName","isUnitModel","SignalRefWrapper","mergeValuesWithExplicit","tieBreakByComparing","parseUnitScaleRange","parseScaleProperty","model","property","parseUnitScaleProperty","parseNonUnitScaleProperty","localScaleComponents","component","scales","config","encoding","markDef","specifiedScales","channel","specifiedScale","localScaleCmpt","mergedScaleCmpt","getScaleComponent","fieldOrDatumDef","specifiedValue","scaleType","get","scalePadding","scalePaddingInner","supportedByScaleType","channelIncompatability","undefined","warn","message","scalePropertyNotWorkWithScaleType","timeUnit","type","set","signal","copyKeyFromObject","value","scaleRules","domain","domainMin","domainMax","hasNestedOffsetScale","scale","bins","interpolate","nice","padding","bar","paddingInner","paddingOuter","reverse","sort","zero","parseScaleRange","child","children","valueWithExplicit","childComponent","childValueWithExplicit","getWithExplicit","v1","v2","step","setWithExplicit","fieldDef","bin","binSignal","field","getSignalName","specifiedDomain","_a","TIME","UTC","scaleConfig","barConfig","continuousPadding","orient","continuousBandSize","POINT","pointPadding","paddingValue","mark","bandPaddingInner","barBandPaddingInner","rectBandPaddingInner","bandWithNestedOffsetPaddingInner","BAND","offsetBandPaddingInner","paddingInnerValue","bandPaddingOuter","bandWithNestedOffsetPaddingOuter","offsetBandPaddingOuter","xReverse","hasCustomDomain","first","last","length"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/scale/properties.ts"],"sourcesContent":["import {SignalRef, TimeInterval} from 'vega';\nimport {isArray} from 'vega-util';\nimport {isBinned, isBinning, isBinParams} from '../../bin';\nimport {\n  COLOR,\n  FILL,\n  isXorY,\n  isXorYOffset,\n  POLAR_POSITION_SCALE_CHANNELS,\n  POSITION_SCALE_CHANNELS,\n  ScaleChannel,\n  STROKE\n} from '../../channel';\nimport {\n  getFieldDef,\n  getFieldOrDatumDef,\n  isFieldDef,\n  ScaleDatumDef,\n  ScaleFieldDef,\n  TypedFieldDef,\n  valueExpr\n} from '../../channeldef';\nimport {Config} from '../../config';\nimport {isDateTime} from '../../datetime';\nimport {channelHasNestedOffsetScale} from '../../encoding';\nimport * as log from '../../log';\nimport {Mark, MarkDef, RectConfig} from '../../mark';\nimport {\n  channelScalePropertyIncompatability,\n  Domain,\n  hasContinuousDomain,\n  isContinuousToContinuous,\n  isContinuousToDiscrete,\n  Scale,\n  ScaleConfig,\n  ScaleType,\n  scaleTypeSupportProperty\n} from '../../scale';\nimport {Sort} from '../../sort';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {contains, getFirstDefined, keys} from '../../util';\nimport {isSignalRef, VgScale} from '../../vega.schema';\nimport {getBinSignalName} from '../data/bin';\nimport {isUnitModel, Model} from '../model';\nimport {SignalRefWrapper} from '../signal';\nimport {Explicit, mergeValuesWithExplicit, tieBreakByComparing} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex, ScaleComponentProps} from './component';\nimport {parseUnitScaleRange} from './range';\n\nexport function parseScaleProperty(model: Model, property: Exclude<keyof (Scale | ScaleComponentProps), 'range'>) {\n  if (isUnitModel(model)) {\n    parseUnitScaleProperty(model, property);\n  } else {\n    parseNonUnitScaleProperty(model, property);\n  }\n}\n\nfunction parseUnitScaleProperty(model: UnitModel, property: Exclude<keyof (Scale | ScaleComponentProps), 'range'>) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n  const {config, encoding, markDef, specifiedScales} = model;\n\n  for (const channel of keys(localScaleComponents)) {\n    const specifiedScale = specifiedScales[channel];\n    const localScaleCmpt = localScaleComponents[channel];\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) as ScaleFieldDef<string, Type> | ScaleDatumDef;\n\n    const specifiedValue = specifiedScale[property];\n    const scaleType = mergedScaleCmpt.get('type');\n    const scalePadding = mergedScaleCmpt.get('padding');\n    const scalePaddingInner = mergedScaleCmpt.get('paddingInner');\n\n    const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n    const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n    if (specifiedValue !== undefined) {\n      // If there is a specified value, check if it is compatible with scale type and channel\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      }\n    }\n    if (supportedByScaleType && channelIncompatability === undefined) {\n      if (specifiedValue !== undefined) {\n        const timeUnit = fieldOrDatumDef['timeUnit'];\n        const type = fieldOrDatumDef.type;\n\n        switch (property) {\n          // domainMax/Min to signal if the value is a datetime object\n          case 'domainMax':\n          case 'domainMin':\n            if (isDateTime(specifiedScale[property]) || type === 'temporal' || timeUnit) {\n              localScaleCmpt.set(property, {signal: valueExpr(specifiedScale[property], {type, timeUnit})}, true);\n            } else {\n              localScaleCmpt.set(property, specifiedScale[property] as any, true);\n            }\n            break;\n          default:\n            localScaleCmpt.copyKeyFromObject<Omit<ScaleComponentProps, 'range' | 'domainMin' | 'domainMax'>>(\n              property,\n              specifiedScale\n            );\n        }\n      } else {\n        const value =\n          property in scaleRules\n            ? scaleRules[property]({\n                model,\n                channel,\n                fieldOrDatumDef,\n                scaleType,\n                scalePadding,\n                scalePaddingInner,\n                domain: specifiedScale.domain,\n                domainMin: specifiedScale.domainMin,\n                domainMax: specifiedScale.domainMax,\n                markDef,\n                config,\n                hasNestedOffsetScale: channelHasNestedOffsetScale(encoding, channel)\n              })\n            : config.scale[property];\n        if (value !== undefined) {\n          localScaleCmpt.set(property, value, false);\n        }\n      }\n    }\n  }\n}\n\nexport interface ScaleRuleParams {\n  model: Model;\n  channel: ScaleChannel;\n  fieldOrDatumDef: ScaleFieldDef<string, Type> | ScaleDatumDef;\n  hasNestedOffsetScale: boolean;\n  scaleType: ScaleType;\n  scalePadding: number | SignalRef;\n  scalePaddingInner: number | SignalRef;\n  domain: Domain;\n  domainMin: Scale['domainMin'];\n  domainMax: Scale['domainMax'];\n  markDef: MarkDef<Mark, SignalRef>;\n  config: Config<SignalRef>;\n}\n\nexport const scaleRules: {\n  [k in keyof Scale]?: (params: ScaleRuleParams) => Scale[k];\n} = {\n  bins: ({model, fieldOrDatumDef}) => (isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : undefined),\n\n  interpolate: ({channel, fieldOrDatumDef}) => interpolate(channel, fieldOrDatumDef.type),\n\n  nice: ({scaleType, channel, domain, domainMin, domainMax, fieldOrDatumDef}) =>\n    nice(scaleType, channel, domain, domainMin, domainMax, fieldOrDatumDef),\n\n  padding: ({channel, scaleType, fieldOrDatumDef, markDef, config}) =>\n    padding(channel, scaleType, config.scale, fieldOrDatumDef, markDef, config.bar),\n\n  paddingInner: ({scalePadding, channel, markDef, scaleType, config, hasNestedOffsetScale}) =>\n    paddingInner(scalePadding, channel, markDef.type, scaleType, config.scale, hasNestedOffsetScale),\n\n  paddingOuter: ({scalePadding, channel, scaleType, scalePaddingInner, config, hasNestedOffsetScale}) =>\n    paddingOuter(scalePadding, channel, scaleType, scalePaddingInner, config.scale, hasNestedOffsetScale),\n\n  reverse: ({fieldOrDatumDef, scaleType, channel, config}) => {\n    const sort = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined;\n    return reverse(scaleType, sort, channel, config.scale);\n  },\n  zero: ({channel, fieldOrDatumDef, domain, markDef, scaleType}) =>\n    zero(channel, fieldOrDatumDef, domain, markDef, scaleType)\n};\n\n// This method is here rather than in range.ts to avoid circular dependency.\nexport function parseScaleRange(model: Model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleRange(model);\n  } else {\n    parseNonUnitScaleProperty(model, 'range');\n  }\n}\n\nexport function parseNonUnitScaleProperty(model: Model, property: keyof (Scale | ScaleComponentProps)) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  for (const child of model.children) {\n    if (property === 'range') {\n      parseScaleRange(child);\n    } else {\n      parseScaleProperty(child, property);\n    }\n  }\n\n  for (const channel of keys(localScaleComponents)) {\n    let valueWithExplicit: Explicit<any>;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        const childValueWithExplicit = childComponent.getWithExplicit(property);\n        valueWithExplicit = mergeValuesWithExplicit<VgScale, any>(\n          valueWithExplicit,\n          childValueWithExplicit,\n          property,\n          'scale',\n          tieBreakByComparing<VgScale, any>((v1, v2) => {\n            switch (property) {\n              case 'range':\n                // For step, prefer larger step\n                if (v1.step && v2.step) {\n                  return v1.step - v2.step;\n                }\n                return 0;\n              // TODO: precedence rule for other properties\n            }\n            return 0;\n          })\n        );\n      }\n    }\n    localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n  }\n}\n\nexport function bins(model: Model, fieldDef: TypedFieldDef<string>) {\n  const bin = fieldDef.bin;\n  if (isBinning(bin)) {\n    const binSignal = getBinSignalName(model, fieldDef.field, bin);\n    return new SignalRefWrapper(() => {\n      return model.getSignalName(binSignal);\n    });\n  } else if (isBinned(bin) && isBinParams(bin) && bin.step !== undefined) {\n    // start and stop will be determined from the scale domain\n    return {\n      step: bin.step\n    };\n  }\n  return undefined;\n}\n\nexport function interpolate(channel: ScaleChannel, type: Type): Scale['interpolate'] {\n  if (contains([COLOR, FILL, STROKE], channel) && type !== 'nominal') {\n    return 'hcl';\n  }\n  return undefined;\n}\n\nexport function nice(\n  scaleType: ScaleType,\n  channel: ScaleChannel,\n  specifiedDomain: Domain,\n  domainMin: Scale['domainMin'],\n  domainMax: Scale['domainMax'],\n  fieldOrDatumDef: TypedFieldDef<string> | ScaleDatumDef\n): boolean | TimeInterval {\n  if (\n    getFieldDef(fieldOrDatumDef)?.bin ||\n    isArray(specifiedDomain) ||\n    domainMax != null ||\n    domainMin != null ||\n    util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)\n  ) {\n    return undefined;\n  }\n  return isXorY(channel) ? true : undefined;\n}\n\nexport function padding(\n  channel: ScaleChannel,\n  scaleType: ScaleType,\n  scaleConfig: ScaleConfig<SignalRef>,\n  fieldOrDatumDef: TypedFieldDef<string> | ScaleDatumDef,\n  markDef: MarkDef<Mark, SignalRef>,\n  barConfig: RectConfig<SignalRef>\n) {\n  if (isXorY(channel)) {\n    if (isContinuousToContinuous(scaleType)) {\n      if (scaleConfig.continuousPadding !== undefined) {\n        return scaleConfig.continuousPadding;\n      }\n\n      const {type, orient} = markDef;\n      if (type === 'bar' && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {\n        if ((orient === 'vertical' && channel === 'x') || (orient === 'horizontal' && channel === 'y')) {\n          return barConfig.continuousBandSize;\n        }\n      }\n    }\n\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n  return undefined;\n}\n\nexport function paddingInner(\n  paddingValue: number | SignalRef,\n  channel: ScaleChannel,\n  mark: Mark,\n  scaleType: ScaleType,\n  scaleConfig: ScaleConfig<SignalRef>,\n  hasNestedOffsetScale = false\n) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n\n  if (isXorY(channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n    const {bandPaddingInner, barBandPaddingInner, rectBandPaddingInner, bandWithNestedOffsetPaddingInner} = scaleConfig;\n\n    if (hasNestedOffsetScale) {\n      return bandWithNestedOffsetPaddingInner;\n    }\n\n    return getFirstDefined(bandPaddingInner, mark === 'bar' ? barBandPaddingInner : rectBandPaddingInner);\n  } else if (isXorYOffset(channel)) {\n    if (scaleType === ScaleType.BAND) {\n      return scaleConfig.offsetBandPaddingInner;\n    }\n  }\n  return undefined;\n}\n\nexport function paddingOuter(\n  paddingValue: number | SignalRef,\n  channel: ScaleChannel,\n  scaleType: ScaleType,\n  paddingInnerValue: number | SignalRef,\n  scaleConfig: ScaleConfig<SignalRef>,\n  hasNestedOffsetScale = false\n) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n\n  if (isXorY(channel)) {\n    const {bandPaddingOuter, bandWithNestedOffsetPaddingOuter} = scaleConfig;\n    if (hasNestedOffsetScale) {\n      return bandWithNestedOffsetPaddingOuter;\n    }\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    if (scaleType === ScaleType.BAND) {\n      return getFirstDefined(\n        bandPaddingOuter,\n        /* By default, paddingOuter is paddingInner / 2. The reason is that\n          size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n          and we want the width/height to be integer by default.\n          Note that step (by default) and cardinality are integers.) */\n        isSignalRef(paddingInnerValue) ? {signal: `${paddingInnerValue.signal}/2`} : paddingInnerValue / 2\n      );\n    }\n  } else if (isXorYOffset(channel)) {\n    if (scaleType === ScaleType.POINT) {\n      return 0.5; // so the point positions align with centers of band scales.\n    } else if (scaleType === ScaleType.BAND) {\n      return scaleConfig.offsetBandPaddingOuter;\n    }\n  }\n  return undefined;\n}\n\nexport function reverse(\n  scaleType: ScaleType,\n  sort: Sort<string>,\n  channel: ScaleChannel,\n  scaleConfig: ScaleConfig<SignalRef>\n) {\n  if (channel === 'x' && scaleConfig.xReverse !== undefined) {\n    if (hasContinuousDomain(scaleType) && sort === 'descending') {\n      if (isSignalRef(scaleConfig.xReverse)) {\n        return {signal: `!${scaleConfig.xReverse.signal}`};\n      } else {\n        return !scaleConfig.xReverse;\n      }\n    }\n    return scaleConfig.xReverse;\n  }\n\n  if (hasContinuousDomain(scaleType) && sort === 'descending') {\n    // For continuous domain scales, Vega does not support domain sort.\n    // Thus, we reverse range instead if sort is descending\n    return true;\n  }\n  return undefined;\n}\n\nexport function zero(\n  channel: ScaleChannel,\n  fieldDef: TypedFieldDef<string> | ScaleDatumDef,\n  specifiedDomain: Domain,\n  markDef: MarkDef,\n  scaleType: ScaleType\n) {\n  // If users explicitly provide a domain, we should not augment zero as that will be unexpected.\n  const hasCustomDomain = !!specifiedDomain && specifiedDomain !== 'unaggregated';\n  if (hasCustomDomain) {\n    if (hasContinuousDomain(scaleType)) {\n      if (isArray(specifiedDomain)) {\n        const first = specifiedDomain[0];\n        const last = specifiedDomain[specifiedDomain.length - 1];\n\n        if (first <= 0 && last >= 0) {\n          // if the domain includes zero, make zero remains true\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  // If there is no custom domain, return true only for the following cases:\n\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common. However, if the scaleType is discretizing scale, we want to return\n  // false so that range doesn't start at zero\n  if (channel === 'size' && fieldDef.type === 'quantitative' && !isContinuousToDiscrete(scaleType)) {\n    return true;\n  }\n\n  // 2) non-binned, quantitative x-scale or y-scale\n  // (For binning, we should not include zero by default because binning are calculated without zero.)\n  if (\n    !(isFieldDef(fieldDef) && fieldDef.bin) &&\n    util.contains([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)\n  ) {\n    const {orient, type} = markDef;\n    if (contains(['bar', 'area', 'line', 'trail'], type)) {\n      if ((orient === 'horizontal' && channel === 'y') || (orient === 'vertical' && channel === 'x')) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}