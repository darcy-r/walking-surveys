{"ast":null,"code":"import { entries, isEmpty } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { VG_MARK_INDEX } from './../../../vega.schema';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nimport { tooltipData } from './tooltip';\nexport function aria(model) {\n  const {\n    markDef,\n    config\n  } = model;\n  const enableAria = getMarkPropOrConfig('aria', markDef, config); // We can ignore other aria properties if ariaHidden is true.\n\n  if (enableAria === false) {\n    // getMarkGroups sets aria to false already so we don't have to set it in the encode block\n    return {};\n  }\n\n  return Object.assign(Object.assign(Object.assign({}, enableAria ? {\n    aria: enableAria\n  } : {}), ariaRoleDescription(model)), description(model));\n}\n\nfunction ariaRoleDescription(model) {\n  const {\n    mark,\n    markDef,\n    config\n  } = model;\n\n  if (config.aria === false) {\n    return {};\n  }\n\n  const ariaRoleDesc = getMarkPropOrConfig('ariaRoleDescription', markDef, config);\n\n  if (ariaRoleDesc != null) {\n    return {\n      ariaRoleDescription: {\n        value: ariaRoleDesc\n      }\n    };\n  }\n\n  return mark in VG_MARK_INDEX ? {} : {\n    ariaRoleDescription: {\n      value: mark\n    }\n  };\n}\n\nexport function description(model) {\n  const {\n    encoding,\n    markDef,\n    config,\n    stack\n  } = model;\n  const channelDef = encoding.description;\n\n  if (channelDef) {\n    return wrapCondition(model, channelDef, 'description', cDef => textRef(cDef, model.config));\n  } // Use default from mark def or config if defined.\n  // Functions in encode usually just return undefined but since we are defining a default below, we need to check the default here.\n\n\n  const descriptionValue = getMarkPropOrConfig('description', markDef, config);\n\n  if (descriptionValue != null) {\n    return {\n      description: signalOrValueRef(descriptionValue)\n    };\n  }\n\n  if (config.aria === false) {\n    return {};\n  }\n\n  const data = tooltipData(encoding, stack, config);\n\n  if (isEmpty(data)) {\n    return undefined;\n  }\n\n  return {\n    description: {\n      signal: entries(data).map((_ref, index) => {\n        let [key, value] = _ref;\n        return `\"${index > 0 ? '; ' : ''}${key}: \" + (${value})`;\n      }).join(' + ')\n    }\n  };\n}","map":{"version":3,"mappings":"AAAA,SAAQA,OAAR,EAAiBC,OAAjB,QAA+B,eAA/B;AACA,SAAQC,mBAAR,EAA6BC,gBAA7B,QAAoD,cAApD;AACA,SAAQC,aAAR,QAA4B,wBAA5B;AAEA,SAAQC,aAAR,QAA4B,eAA5B;AACA,SAAQC,OAAR,QAAsB,QAAtB;AACA,SAAQC,WAAR,QAA0B,WAA1B;AAEA,OAAM,SAAUC,IAAV,CAAeC,KAAf,EAA+B;EACnC,MAAM;IAACC,OAAD;IAAUC;EAAV,IAAoBF,KAA1B;EAEA,MAAMG,UAAU,GAAGV,mBAAmB,CAAC,MAAD,EAASQ,OAAT,EAAkBC,MAAlB,CAAtC,CAHmC,CAKnC;;EACA,IAAIC,UAAU,KAAK,KAAnB,EAA0B;IACxB;IACA,OAAO,EAAP;EACD;;EAED,qDACMA,UAAU,GAAG;IAACJ,IAAI,EAAEI;EAAP,CAAH,GAAwB,EADxC,GAEKC,mBAAmB,CAACJ,KAAD,CAFxB,GAGKK,WAAW,CAACL,KAAD,CAHhB;AAKD;;AAED,SAASI,mBAAT,CAA6BJ,KAA7B,EAA6C;EAC3C,MAAM;IAACM,IAAD;IAAOL,OAAP;IAAgBC;EAAhB,IAA0BF,KAAhC;;EAEA,IAAIE,MAAM,CAACH,IAAP,KAAgB,KAApB,EAA2B;IACzB,OAAO,EAAP;EACD;;EAED,MAAMQ,YAAY,GAAGd,mBAAmB,CAAC,qBAAD,EAAwBQ,OAAxB,EAAiCC,MAAjC,CAAxC;;EAEA,IAAIK,YAAY,IAAI,IAApB,EAA0B;IACxB,OAAO;MAACH,mBAAmB,EAAE;QAACI,KAAK,EAAED;MAAR;IAAtB,CAAP;EACD;;EAED,OAAOD,IAAI,IAAIX,aAAR,GAAwB,EAAxB,GAA6B;IAACS,mBAAmB,EAAE;MAACI,KAAK,EAAEF;IAAR;EAAtB,CAApC;AACD;;AAED,OAAM,SAAUD,WAAV,CAAsBL,KAAtB,EAAsC;EAC1C,MAAM;IAACS,QAAD;IAAWR,OAAX;IAAoBC,MAApB;IAA4BQ;EAA5B,IAAqCV,KAA3C;EACA,MAAMW,UAAU,GAAGF,QAAQ,CAACJ,WAA5B;;EAEA,IAAIM,UAAJ,EAAgB;IACd,OAAOf,aAAa,CAACI,KAAD,EAAQW,UAAR,EAAoB,aAApB,EAAmCC,IAAI,IAAIf,OAAO,CAACe,IAAD,EAAOZ,KAAK,CAACE,MAAb,CAAlD,CAApB;EACD,CANyC,CAQ1C;EACA;;;EACA,MAAMW,gBAAgB,GAAGpB,mBAAmB,CAAC,aAAD,EAAgBQ,OAAhB,EAAyBC,MAAzB,CAA5C;;EACA,IAAIW,gBAAgB,IAAI,IAAxB,EAA8B;IAC5B,OAAO;MACLR,WAAW,EAAEX,gBAAgB,CAACmB,gBAAD;IADxB,CAAP;EAGD;;EAED,IAAIX,MAAM,CAACH,IAAP,KAAgB,KAApB,EAA2B;IACzB,OAAO,EAAP;EACD;;EAED,MAAMe,IAAI,GAAGhB,WAAW,CAACW,QAAD,EAAWC,KAAX,EAAkBR,MAAlB,CAAxB;;EAEA,IAAIV,OAAO,CAACsB,IAAD,CAAX,EAAmB;IACjB,OAAOC,SAAP;EACD;;EAED,OAAO;IACLV,WAAW,EAAE;MACXW,MAAM,EAAEzB,OAAO,CAACuB,IAAD,CAAP,CACLG,GADK,CACD,OAAeC,KAAf;QAAA,IAAC,CAACC,GAAD,EAAMX,KAAN,CAAD;QAAA,OAAyB,IAAIU,KAAK,GAAG,CAAR,GAAY,IAAZ,GAAmB,EAAE,GAAGC,GAAG,UAAUX,KAAK,GAAvE;MAAA,CADC,EAELY,IAFK,CAEA,KAFA;IADG;EADR,CAAP;AAOD","names":["entries","isEmpty","getMarkPropOrConfig","signalOrValueRef","VG_MARK_INDEX","wrapCondition","textRef","tooltipData","aria","model","markDef","config","enableAria","ariaRoleDescription","description","mark","ariaRoleDesc","value","encoding","stack","channelDef","cDef","descriptionValue","data","undefined","signal","map","index","key","join"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/mark/encode/aria.ts"],"sourcesContent":["import {entries, isEmpty} from '../../../util';\nimport {getMarkPropOrConfig, signalOrValueRef} from '../../common';\nimport {VG_MARK_INDEX} from './../../../vega.schema';\nimport {UnitModel} from './../../unit';\nimport {wrapCondition} from './conditional';\nimport {textRef} from './text';\nimport {tooltipData} from './tooltip';\n\nexport function aria(model: UnitModel) {\n  const {markDef, config} = model;\n\n  const enableAria = getMarkPropOrConfig('aria', markDef, config);\n\n  // We can ignore other aria properties if ariaHidden is true.\n  if (enableAria === false) {\n    // getMarkGroups sets aria to false already so we don't have to set it in the encode block\n    return {};\n  }\n\n  return {\n    ...(enableAria ? {aria: enableAria} : {}),\n    ...ariaRoleDescription(model),\n    ...description(model)\n  };\n}\n\nfunction ariaRoleDescription(model: UnitModel) {\n  const {mark, markDef, config} = model;\n\n  if (config.aria === false) {\n    return {};\n  }\n\n  const ariaRoleDesc = getMarkPropOrConfig('ariaRoleDescription', markDef, config);\n\n  if (ariaRoleDesc != null) {\n    return {ariaRoleDescription: {value: ariaRoleDesc}};\n  }\n\n  return mark in VG_MARK_INDEX ? {} : {ariaRoleDescription: {value: mark}};\n}\n\nexport function description(model: UnitModel) {\n  const {encoding, markDef, config, stack} = model;\n  const channelDef = encoding.description;\n\n  if (channelDef) {\n    return wrapCondition(model, channelDef, 'description', cDef => textRef(cDef, model.config));\n  }\n\n  // Use default from mark def or config if defined.\n  // Functions in encode usually just return undefined but since we are defining a default below, we need to check the default here.\n  const descriptionValue = getMarkPropOrConfig('description', markDef, config);\n  if (descriptionValue != null) {\n    return {\n      description: signalOrValueRef(descriptionValue)\n    };\n  }\n\n  if (config.aria === false) {\n    return {};\n  }\n\n  const data = tooltipData(encoding, stack, config);\n\n  if (isEmpty(data)) {\n    return undefined;\n  }\n\n  return {\n    description: {\n      signal: entries(data)\n        .map(([key, value], index) => `\"${index > 0 ? '; ' : ''}${key}: \" + (${value})`)\n        .join(' + ')\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}