{"ast":null,"code":"import getOrCreateMeasurementElement from './getOrCreateMeasurementElement';\nvar MEASUREMENT_ELEMENT_ID = '__visx_splitpath_svg_path_measurement_id';\n\nvar TRUE = function TRUE() {\n  return true;\n};\n\nexport default function getSplitLineSegments(_ref) {\n  var path = _ref.path,\n      pointsInSegments = _ref.pointsInSegments,\n      _ref$segmentation = _ref.segmentation,\n      segmentation = _ref$segmentation === void 0 ? 'x' : _ref$segmentation,\n      _ref$sampleRate = _ref.sampleRate,\n      sampleRate = _ref$sampleRate === void 0 ? 1 : _ref$sampleRate;\n\n  try {\n    var pathElement = getOrCreateMeasurementElement(MEASUREMENT_ELEMENT_ID);\n    pathElement.setAttribute('d', path);\n    var totalLength = pathElement.getTotalLength();\n    var numSegments = pointsInSegments.length;\n    var lineSegments = pointsInSegments.map(function () {\n      return [];\n    });\n\n    if (segmentation === 'x' || segmentation === 'y') {\n      var segmentStarts = pointsInSegments.map(function (points) {\n        var _points$find;\n\n        return (_points$find = points.find(function (p) {\n          return typeof p[segmentation] === 'number';\n        })) == null ? void 0 : _points$find[segmentation];\n      });\n      var first = pathElement.getPointAtLength(0);\n      var last = pathElement.getPointAtLength(totalLength);\n      var isIncreasing = last[segmentation] > first[segmentation];\n      var isBeyondSegmentStart = isIncreasing ? segmentStarts.map(function (start) {\n        return typeof start === 'undefined' ? TRUE : function (xOrY) {\n          return xOrY >= start;\n        };\n      }) : segmentStarts.map(function (start) {\n        return typeof start === 'undefined' ? TRUE : function (xOrY) {\n          return xOrY <= start;\n        };\n      });\n      var currentSegment = 0;\n\n      for (var distance = 0; distance <= totalLength; distance += sampleRate) {\n        var sample = pathElement.getPointAtLength(distance);\n        var position = sample[segmentation]; // find the current segment to which this sample belongs\n\n        while (currentSegment < numSegments - 1 && isBeyondSegmentStart[currentSegment + 1](position)) {\n          currentSegment += 1;\n        } // add sample to segment\n\n\n        lineSegments[currentSegment].push(sample);\n      }\n    } else {\n      // segmentation === \"length\"\n      var numPointsInSegment = pointsInSegments.map(function (points) {\n        return points.length;\n      });\n      var numPoints = numPointsInSegment.reduce(function (sum, curr) {\n        return sum + curr;\n      }, 0);\n      var lengthBetweenPoints = totalLength / Math.max(1, numPoints - 1);\n\n      var _segmentStarts = numPointsInSegment.slice(0, numSegments - 1);\n\n      _segmentStarts.unshift(0);\n\n      for (var i = 2; i < numSegments; i += 1) {\n        _segmentStarts[i] += _segmentStarts[i - 1];\n      }\n\n      for (var _i = 0; _i < numSegments; _i += 1) {\n        _segmentStarts[_i] *= lengthBetweenPoints;\n      }\n\n      var _currentSegment = 0;\n\n      for (var _distance = 0; _distance <= totalLength; _distance += sampleRate) {\n        var _sample = pathElement.getPointAtLength(_distance); // find the current segment to which this sample belongs\n\n\n        while (_currentSegment < numSegments - 1 && _distance >= _segmentStarts[_currentSegment + 1]) {\n          _currentSegment += 1;\n        } // add sample to segment\n\n\n        lineSegments[_currentSegment].push(_sample);\n      }\n    }\n\n    return lineSegments;\n  } catch (e) {\n    return [];\n  }\n}","map":{"version":3,"names":["getOrCreateMeasurementElement","MEASUREMENT_ELEMENT_ID","TRUE","getSplitLineSegments","_ref","path","pointsInSegments","_ref$segmentation","segmentation","_ref$sampleRate","sampleRate","pathElement","setAttribute","totalLength","getTotalLength","numSegments","length","lineSegments","map","segmentStarts","points","_points$find","find","p","first","getPointAtLength","last","isIncreasing","isBeyondSegmentStart","start","xOrY","currentSegment","distance","sample","position","push","numPointsInSegment","numPoints","reduce","sum","curr","lengthBetweenPoints","Math","max","_segmentStarts","slice","unshift","i","_i","_currentSegment","_distance","_sample","e"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/@visx/shape/esm/util/getSplitLineSegments.js"],"sourcesContent":["import getOrCreateMeasurementElement from './getOrCreateMeasurementElement';\nvar MEASUREMENT_ELEMENT_ID = '__visx_splitpath_svg_path_measurement_id';\n\nvar TRUE = function TRUE() {\n  return true;\n};\n\nexport default function getSplitLineSegments(_ref) {\n  var path = _ref.path,\n      pointsInSegments = _ref.pointsInSegments,\n      _ref$segmentation = _ref.segmentation,\n      segmentation = _ref$segmentation === void 0 ? 'x' : _ref$segmentation,\n      _ref$sampleRate = _ref.sampleRate,\n      sampleRate = _ref$sampleRate === void 0 ? 1 : _ref$sampleRate;\n\n  try {\n    var pathElement = getOrCreateMeasurementElement(MEASUREMENT_ELEMENT_ID);\n    pathElement.setAttribute('d', path);\n    var totalLength = pathElement.getTotalLength();\n    var numSegments = pointsInSegments.length;\n    var lineSegments = pointsInSegments.map(function () {\n      return [];\n    });\n\n    if (segmentation === 'x' || segmentation === 'y') {\n      var segmentStarts = pointsInSegments.map(function (points) {\n        var _points$find;\n\n        return (_points$find = points.find(function (p) {\n          return typeof p[segmentation] === 'number';\n        })) == null ? void 0 : _points$find[segmentation];\n      });\n      var first = pathElement.getPointAtLength(0);\n      var last = pathElement.getPointAtLength(totalLength);\n      var isIncreasing = last[segmentation] > first[segmentation];\n      var isBeyondSegmentStart = isIncreasing ? segmentStarts.map(function (start) {\n        return typeof start === 'undefined' ? TRUE : function (xOrY) {\n          return xOrY >= start;\n        };\n      }) : segmentStarts.map(function (start) {\n        return typeof start === 'undefined' ? TRUE : function (xOrY) {\n          return xOrY <= start;\n        };\n      });\n      var currentSegment = 0;\n\n      for (var distance = 0; distance <= totalLength; distance += sampleRate) {\n        var sample = pathElement.getPointAtLength(distance);\n        var position = sample[segmentation]; // find the current segment to which this sample belongs\n\n        while (currentSegment < numSegments - 1 && isBeyondSegmentStart[currentSegment + 1](position)) {\n          currentSegment += 1;\n        } // add sample to segment\n\n\n        lineSegments[currentSegment].push(sample);\n      }\n    } else {\n      // segmentation === \"length\"\n      var numPointsInSegment = pointsInSegments.map(function (points) {\n        return points.length;\n      });\n      var numPoints = numPointsInSegment.reduce(function (sum, curr) {\n        return sum + curr;\n      }, 0);\n      var lengthBetweenPoints = totalLength / Math.max(1, numPoints - 1);\n\n      var _segmentStarts = numPointsInSegment.slice(0, numSegments - 1);\n\n      _segmentStarts.unshift(0);\n\n      for (var i = 2; i < numSegments; i += 1) {\n        _segmentStarts[i] += _segmentStarts[i - 1];\n      }\n\n      for (var _i = 0; _i < numSegments; _i += 1) {\n        _segmentStarts[_i] *= lengthBetweenPoints;\n      }\n\n      var _currentSegment = 0;\n\n      for (var _distance = 0; _distance <= totalLength; _distance += sampleRate) {\n        var _sample = pathElement.getPointAtLength(_distance); // find the current segment to which this sample belongs\n\n\n        while (_currentSegment < numSegments - 1 && _distance >= _segmentStarts[_currentSegment + 1]) {\n          _currentSegment += 1;\n        } // add sample to segment\n\n\n        lineSegments[_currentSegment].push(_sample);\n      }\n    }\n\n    return lineSegments;\n  } catch (e) {\n    return [];\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}