{"ast":null,"code":"import { isObject, isArray, extend, hasOwnProperty, array, stringValue, peek, isString, error, splitAccessPath, mergeConfig } from 'vega-util';\nimport { parseExpression } from 'vega-functions';\nimport { parseSelector } from 'vega-event-selector';\nimport { isValidScaleType, isDiscrete, isQuantile, isDiscretizing, isContinuous } from 'vega-scale';\nimport { definition as definition$1 } from 'vega-dataflow';\n\nfunction parseAutosize(spec) {\n  return isObject(spec) ? spec : {\n    type: spec || 'pad'\n  };\n}\n\nconst number = _ => +_ || 0;\n\nconst paddingObject = _ => ({\n  top: _,\n  bottom: _,\n  left: _,\n  right: _\n});\n\nfunction parsePadding(spec) {\n  return !isObject(spec) ? paddingObject(number(spec)) : spec.signal ? spec : {\n    top: number(spec.top),\n    bottom: number(spec.bottom),\n    left: number(spec.left),\n    right: number(spec.right)\n  };\n}\n\nconst encoder = _ => isObject(_) && !isArray(_) ? extend({}, _) : {\n  value: _\n};\n\nfunction addEncode(object, name, value, set) {\n  if (value != null) {\n    const isEncoder = isObject(value) && !isArray(value) || isArray(value) && value.length && isObject(value[0]); // Always assign signal to update, even if the signal is from the enter block\n\n    if (isEncoder) {\n      object.update[name] = value;\n    } else {\n      object[set || 'enter'][name] = {\n        value: value\n      };\n    }\n\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nfunction addEncoders(object, enter, update) {\n  for (const name in enter) {\n    addEncode(object, name, enter[name]);\n  }\n\n  for (const name in update) {\n    addEncode(object, name, update[name], 'update');\n  }\n}\n\nfunction extendEncode(encode, extra, skip) {\n  for (const name in extra) {\n    if (skip && hasOwnProperty(skip, name)) continue;\n    encode[name] = extend(encode[name] || {}, extra[name]);\n  }\n\n  return encode;\n}\n\nfunction has(key, encode) {\n  return encode && (encode.enter && encode.enter[key] || encode.update && encode.update[key]);\n}\n\nconst MarkRole = 'mark';\nconst FrameRole = 'frame';\nconst ScopeRole = 'scope';\nconst AxisRole = 'axis';\nconst AxisDomainRole = 'axis-domain';\nconst AxisGridRole = 'axis-grid';\nconst AxisLabelRole = 'axis-label';\nconst AxisTickRole = 'axis-tick';\nconst AxisTitleRole = 'axis-title';\nconst LegendRole = 'legend';\nconst LegendBandRole = 'legend-band';\nconst LegendEntryRole = 'legend-entry';\nconst LegendGradientRole = 'legend-gradient';\nconst LegendLabelRole = 'legend-label';\nconst LegendSymbolRole = 'legend-symbol';\nconst LegendTitleRole = 'legend-title';\nconst TitleRole = 'title';\nconst TitleTextRole = 'title-text';\nconst TitleSubtitleRole = 'title-subtitle';\n\nfunction applyDefaults(encode, type, role, style, config) {\n  const defaults = {},\n        enter = {};\n  let update, key, skip, props; // if text mark, apply global lineBreak settings (#2370)\n\n  key = 'lineBreak';\n\n  if (type === 'text' && config[key] != null && !has(key, encode)) {\n    applyDefault(defaults, key, config[key]);\n  } // ignore legend and axis roles\n\n\n  if (role == 'legend' || String(role).startsWith('axis')) {\n    role = null;\n  } // resolve mark config\n\n\n  props = role === FrameRole ? config.group : role === MarkRole ? extend({}, config.mark, config[type]) : null;\n\n  for (key in props) {\n    // do not apply defaults if relevant fields are defined\n    skip = has(key, encode) || (key === 'fill' || key === 'stroke') && (has('fill', encode) || has('stroke', encode));\n    if (!skip) applyDefault(defaults, key, props[key]);\n  } // resolve styles, apply with increasing precedence\n\n\n  array(style).forEach(name => {\n    const props = config.style && config.style[name];\n\n    for (const key in props) {\n      if (!has(key, encode)) {\n        applyDefault(defaults, key, props[key]);\n      }\n    }\n  });\n  encode = extend({}, encode); // defensive copy\n\n  for (key in defaults) {\n    props = defaults[key];\n\n    if (props.signal) {\n      (update = update || {})[key] = props;\n    } else {\n      enter[key] = props;\n    }\n  }\n\n  encode.enter = extend(enter, encode.enter);\n  if (update) encode.update = extend(update, encode.update);\n  return encode;\n}\n\nfunction applyDefault(defaults, key, value) {\n  defaults[key] = value && value.signal ? {\n    signal: value.signal\n  } : {\n    value: value\n  };\n}\n\nconst scaleRef = scale => isString(scale) ? stringValue(scale) : scale.signal ? `(${scale.signal})` : field(scale);\n\nfunction entry$1(enc) {\n  if (enc.gradient != null) {\n    return gradient(enc);\n  }\n\n  let value = enc.signal ? `(${enc.signal})` : enc.color ? color(enc.color) : enc.field != null ? field(enc.field) : enc.value !== undefined ? stringValue(enc.value) : undefined;\n\n  if (enc.scale != null) {\n    value = scale(enc, value);\n  }\n\n  if (value === undefined) {\n    value = null;\n  }\n\n  if (enc.exponent != null) {\n    value = `pow(${value},${property(enc.exponent)})`;\n  }\n\n  if (enc.mult != null) {\n    value += `*${property(enc.mult)}`;\n  }\n\n  if (enc.offset != null) {\n    value += `+${property(enc.offset)}`;\n  }\n\n  if (enc.round) {\n    value = `round(${value})`;\n  }\n\n  return value;\n}\n\nconst _color = (type, x, y, z) => `(${type}(${[x, y, z].map(entry$1).join(',')})+'')`;\n\nfunction color(enc) {\n  return enc.c ? _color('hcl', enc.h, enc.c, enc.l) : enc.h || enc.s ? _color('hsl', enc.h, enc.s, enc.l) : enc.l || enc.a ? _color('lab', enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color('rgb', enc.r, enc.g, enc.b) : null;\n}\n\nfunction gradient(enc) {\n  // map undefined to null; expression lang does not allow undefined\n  const args = [enc.start, enc.stop, enc.count].map(_ => _ == null ? null : stringValue(_)); // trim null inputs from the end\n\n  while (args.length && peek(args) == null) args.pop();\n\n  args.unshift(scaleRef(enc.gradient));\n  return `gradient(${args.join(',')})`;\n}\n\nfunction property(property) {\n  return isObject(property) ? '(' + entry$1(property) + ')' : property;\n}\n\nfunction field(ref) {\n  return resolveField(isObject(ref) ? ref : {\n    datum: ref\n  });\n}\n\nfunction resolveField(ref) {\n  let object, level, field;\n\n  if (ref.signal) {\n    object = 'datum';\n    field = ref.signal;\n  } else if (ref.group || ref.parent) {\n    level = Math.max(1, ref.level || 1);\n    object = 'item';\n\n    while (level-- > 0) {\n      object += '.mark.group';\n    }\n\n    if (ref.parent) {\n      field = ref.parent;\n      object += '.datum';\n    } else {\n      field = ref.group;\n    }\n  } else if (ref.datum) {\n    object = 'datum';\n    field = ref.datum;\n  } else {\n    error('Invalid field reference: ' + stringValue(ref));\n  }\n\n  if (!ref.signal) {\n    field = isString(field) ? splitAccessPath(field).map(stringValue).join('][') : resolveField(field);\n  }\n\n  return object + '[' + field + ']';\n}\n\nfunction scale(enc, value) {\n  const scale = scaleRef(enc.scale);\n\n  if (enc.range != null) {\n    // pull value from scale range\n    value = `lerp(_range(${scale}), ${+enc.range})`;\n  } else {\n    // run value through scale and/or pull scale bandwidth\n    if (value !== undefined) value = `_scale(${scale}, ${value})`;\n\n    if (enc.band) {\n      value = (value ? value + '+' : '') + `_bandwidth(${scale})` + (+enc.band === 1 ? '' : '*' + property(enc.band));\n\n      if (enc.extra) {\n        // include logic to handle extraneous elements\n        value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;\n      }\n    }\n\n    if (value == null) value = '0';\n  }\n\n  return value;\n}\n\nfunction rule(enc) {\n  let code = '';\n  enc.forEach(rule => {\n    const value = entry$1(rule);\n    code += rule.test ? `(${rule.test})?${value}:` : value;\n  }); // if no else clause, terminate with null (#1366)\n\n  if (peek(code) === ':') {\n    code += 'null';\n  }\n\n  return code;\n}\n\nfunction parseEncode(encode, type, role, style, scope, params) {\n  const enc = {};\n  params = params || {};\n  params.encoders = {\n    $encode: enc\n  };\n  encode = applyDefaults(encode, type, role, style, scope.config);\n\n  for (const key in encode) {\n    enc[key] = parseBlock(encode[key], type, params, scope);\n  }\n\n  return params;\n}\n\nfunction parseBlock(block, marktype, params, scope) {\n  const channels = {},\n        fields = {};\n\n  for (const name in block) {\n    if (block[name] != null) {\n      // skip any null entries\n      channels[name] = parse$1(expr(block[name]), scope, params, fields);\n    }\n  }\n\n  return {\n    $expr: {\n      marktype,\n      channels\n    },\n    $fields: Object.keys(fields),\n    $output: Object.keys(block)\n  };\n}\n\nfunction expr(enc) {\n  return isArray(enc) ? rule(enc) : entry$1(enc);\n}\n\nfunction parse$1(code, scope, params, fields) {\n  const expr = parseExpression(code, scope);\n  expr.$fields.forEach(name => fields[name] = 1);\n  extend(params, expr.$params);\n  return expr.$expr;\n}\n\nconst OUTER = 'outer',\n      OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\n\nfunction outerError(prefix, name) {\n  error(prefix + ' for \"outer\" push: ' + stringValue(name));\n}\n\nfunction parseSignal(signal, scope) {\n  const name = signal.name;\n\n  if (signal.push === OUTER) {\n    // signal must already be defined, raise error if not\n    if (!scope.signals[name]) outerError('No prior signal definition', name); // signal push must not use properties reserved for standard definition\n\n    OUTER_INVALID.forEach(prop => {\n      if (signal[prop] !== undefined) outerError('Invalid property ', prop);\n    });\n  } else {\n    // define a new signal in the current scope\n    const op = scope.addSignal(name, signal.value);\n    if (signal.react === false) op.react = false;\n    if (signal.bind) scope.addBinding(name, signal.bind);\n  }\n}\n\nfunction Entry(type, value, params, parent) {\n  this.id = -1;\n  this.type = type;\n  this.value = value;\n  this.params = params;\n  if (parent) this.parent = parent;\n}\n\nfunction entry(type, value, params, parent) {\n  return new Entry(type, value, params, parent);\n}\n\nfunction operator(value, params) {\n  return entry('operator', value, params);\n} // -----\n\n\nfunction ref(op) {\n  const ref = {\n    $ref: op.id\n  }; // if operator not yet registered, cache ref to resolve later\n\n  if (op.id < 0) (op.refs = op.refs || []).push(ref);\n  return ref;\n}\n\nfunction fieldRef$1(field, name) {\n  return name ? {\n    $field: field,\n    $name: name\n  } : {\n    $field: field\n  };\n}\n\nconst keyFieldRef = fieldRef$1('key');\n\nfunction compareRef(fields, orders) {\n  return {\n    $compare: fields,\n    $order: orders\n  };\n}\n\nfunction keyRef(fields, flat) {\n  const ref = {\n    $key: fields\n  };\n  if (flat) ref.$flat = true;\n  return ref;\n} // -----\n\n\nconst Ascending = 'ascending';\nconst Descending = 'descending';\n\nfunction sortKey(sort) {\n  return !isObject(sort) ? '' : (sort.order === Descending ? '-' : '+') + aggrField(sort.op, sort.field);\n}\n\nfunction aggrField(op, field) {\n  return (op && op.signal ? '$' + op.signal : op || '') + (op && field ? '_' : '') + (field && field.signal ? '$' + field.signal : field || '');\n} // -----\n\n\nconst Scope$1 = 'scope';\nconst View = 'view';\n\nfunction isSignal(_) {\n  return _ && _.signal;\n}\n\nfunction isExpr$1(_) {\n  return _ && _.expr;\n}\n\nfunction hasSignal(_) {\n  if (isSignal(_)) return true;\n  if (isObject(_)) for (const key in _) {\n    if (hasSignal(_[key])) return true;\n  }\n  return false;\n}\n\nfunction value(specValue, defaultValue) {\n  return specValue != null ? specValue : defaultValue;\n}\n\nfunction deref(v) {\n  return v && v.signal || v;\n}\n\nconst Timer = 'timer';\n\nfunction parseStream(stream, scope) {\n  const method = stream.merge ? mergeStream : stream.stream ? nestedStream : stream.type ? eventStream : error('Invalid stream specification: ' + stringValue(stream));\n  return method(stream, scope);\n}\n\nfunction eventSource(source) {\n  return source === Scope$1 ? View : source || View;\n}\n\nfunction mergeStream(stream, scope) {\n  const list = stream.merge.map(s => parseStream(s, scope)),\n        entry = streamParameters({\n    merge: list\n  }, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction nestedStream(stream, scope) {\n  const id = parseStream(stream.stream, scope),\n        entry = streamParameters({\n    stream: id\n  }, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction eventStream(stream, scope) {\n  let id;\n\n  if (stream.type === Timer) {\n    id = scope.event(Timer, stream.throttle);\n    stream = {\n      between: stream.between,\n      filter: stream.filter\n    };\n  } else {\n    id = scope.event(eventSource(stream.source), stream.type);\n  }\n\n  const entry = streamParameters({\n    stream: id\n  }, stream, scope);\n  return Object.keys(entry).length === 1 ? id : scope.addStream(entry).id;\n}\n\nfunction streamParameters(entry, stream, scope) {\n  let param = stream.between;\n\n  if (param) {\n    if (param.length !== 2) {\n      error('Stream \"between\" parameter must have 2 entries: ' + stringValue(stream));\n    }\n\n    entry.between = [parseStream(param[0], scope), parseStream(param[1], scope)];\n  }\n\n  param = stream.filter ? [].concat(stream.filter) : [];\n\n  if (stream.marktype || stream.markname || stream.markrole) {\n    // add filter for mark type, name and/or role\n    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\n  }\n\n  if (stream.source === Scope$1) {\n    // add filter to limit events from sub-scope only\n    param.push('inScope(event.item)');\n  }\n\n  if (param.length) {\n    entry.filter = parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\n  }\n\n  if ((param = stream.throttle) != null) {\n    entry.throttle = +param;\n  }\n\n  if ((param = stream.debounce) != null) {\n    entry.debounce = +param;\n  }\n\n  if (stream.consume) {\n    entry.consume = true;\n  }\n\n  return entry;\n}\n\nfunction filterMark(type, name, role) {\n  const item = 'event.item';\n  return item + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\'' + type + '\\'' : '') + (role ? '&&' + item + '.mark.role===\\'' + role + '\\'' : '') + (name ? '&&' + item + '.mark.name===\\'' + name + '\\'' : '');\n}\n\nconst OP_VALUE_EXPR = {\n  code: '_.$value',\n  ast: {\n    type: 'Identifier',\n    value: 'value'\n  }\n};\n\nfunction parseUpdate(spec, scope, target) {\n  const encode = spec.encode,\n        entry = {\n    target: target\n  };\n  let events = spec.events,\n      update = spec.update,\n      sources = [];\n\n  if (!events) {\n    error('Signal update missing events specification.');\n  } // interpret as an event selector string\n\n\n  if (isString(events)) {\n    events = parseSelector(events, scope.isSubscope() ? Scope$1 : View);\n  } // separate event streams from signal updates\n\n\n  events = array(events).filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1); // merge internal operator listeners\n\n  if (sources.length > 1) {\n    sources = [mergeSources(sources)];\n  } // merge event streams, include as source\n\n\n  if (events.length) {\n    sources.push(events.length > 1 ? {\n      merge: events\n    } : events[0]);\n  }\n\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  } // resolve update value\n\n\n  entry.update = isString(update) ? parseExpression(update, scope) : update.expr != null ? parseExpression(update.expr, scope) : update.value != null ? update.value : update.signal != null ? {\n    $expr: OP_VALUE_EXPR,\n    $params: {\n      $value: scope.signalRef(update.signal)\n    }\n  } : error('Invalid signal update specification.');\n\n  if (spec.force) {\n    entry.options = {\n      force: true\n    };\n  }\n\n  sources.forEach(source => scope.addUpdate(extend(streamSource(source, scope), entry)));\n}\n\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)\n  };\n}\n\nfunction mergeSources(sources) {\n  return {\n    signal: '[' + sources.map(s => s.scale ? 'scale(\"' + s.scale + '\")' : s.signal) + ']'\n  };\n}\n\nfunction parseSignalUpdates(signal, scope) {\n  const op = scope.getSignal(signal.name);\n  let expr = signal.update;\n\n  if (signal.init) {\n    if (expr) {\n      error('Signals can not include both init and update expressions.');\n    } else {\n      expr = signal.init;\n      op.initonly = true;\n    }\n  }\n\n  if (expr) {\n    expr = parseExpression(expr, scope);\n    op.update = expr.$expr;\n    op.params = expr.$params;\n  }\n\n  if (signal.on) {\n    signal.on.forEach(_ => parseUpdate(_, scope, op.id));\n  }\n}\n\nconst transform = name => (params, value, parent) => entry(name, value, params || undefined, parent);\n\nconst Aggregate = transform('aggregate');\nconst AxisTicks = transform('axisticks');\nconst Bound = transform('bound');\nconst Collect = transform('collect');\nconst Compare = transform('compare');\nconst DataJoin = transform('datajoin');\nconst Encode = transform('encode');\nconst Expression = transform('expression');\nconst Facet = transform('facet');\nconst Field = transform('field');\nconst Key = transform('key');\nconst LegendEntries = transform('legendentries');\nconst Load = transform('load');\nconst Mark = transform('mark');\nconst MultiExtent = transform('multiextent');\nconst MultiValues = transform('multivalues');\nconst Overlap = transform('overlap');\nconst Params = transform('params');\nconst PreFacet = transform('prefacet');\nconst Projection = transform('projection');\nconst Proxy = transform('proxy');\nconst Relay = transform('relay');\nconst Render = transform('render');\nconst Scale = transform('scale');\nconst Sieve = transform('sieve');\nconst SortItems = transform('sortitems');\nconst ViewLayout = transform('viewlayout');\nconst Values = transform('values');\nlet FIELD_REF_ID = 0;\nconst MULTIDOMAIN_SORT_OPS = {\n  min: 'min',\n  max: 'max',\n  count: 'sum'\n};\n\nfunction initScale(spec, scope) {\n  const type = spec.type || 'linear';\n\n  if (!isValidScaleType(type)) {\n    error('Unrecognized scale type: ' + stringValue(type));\n  }\n\n  scope.addScale(spec.name, {\n    type,\n    domain: undefined\n  });\n}\n\nfunction parseScale(spec, scope) {\n  const params = scope.getScale(spec.name).params;\n  let key;\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n\n  if (spec.nice != null) {\n    params.nice = parseScaleNice(spec.nice);\n  }\n\n  if (spec.bins != null) {\n    params.bins = parseScaleBins(spec.bins, scope);\n  }\n\n  for (key in spec) {\n    if (hasOwnProperty(params, key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\n\nfunction parseLiteral(v, scope) {\n  return !isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : error('Unsupported object: ' + stringValue(v));\n}\n\nfunction parseArray(v, scope) {\n  return v.signal ? scope.signalRef(v.signal) : v.map(v => parseLiteral(v, scope));\n}\n\nfunction dataLookupError(name) {\n  error('Can not find data set: ' + stringValue(name));\n} // -- SCALE DOMAIN ----\n\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      error('No scale domain defined for domainMin/domainMax to override.');\n    }\n\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal) : (isArray(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);\n}\n\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(v => parseLiteral(v, scope));\n}\n\nfunction singularDomain(domain, spec, scope) {\n  const data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n  return isDiscrete(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : isQuantile(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);\n}\n\nfunction multipleDomain(domain, spec, scope) {\n  const data = domain.data,\n        fields = domain.fields.reduce((dom, d) => {\n    d = isString(d) ? {\n      data: data,\n      field: d\n    } : isArray(d) || d.signal ? fieldRef(d, scope) : d;\n    dom.push(d);\n    return dom;\n  }, []);\n  return (isDiscrete(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);\n}\n\nfunction fieldRef(data, scope) {\n  const name = '_:vega:_' + FIELD_REF_ID++,\n        coll = Collect({});\n\n  if (isArray(data)) {\n    coll.value = {\n      $ingest: data\n    };\n  } else if (data.signal) {\n    const code = 'setdata(' + stringValue(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n\n  scope.addDataPipeline(name, [coll, Sieve({})]);\n  return {\n    data: name,\n    field: 'data'\n  };\n}\n\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  const sort = parseSort(domain.sort, true);\n  let a, v; // get value counts for each domain field\n\n  const counts = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field, sort);\n  }); // aggregate the results from each domain field\n\n  const p = {\n    groupby: keyFieldRef,\n    pulse: counts\n  };\n\n  if (sort) {\n    a = sort.op || 'count';\n    v = sort.field ? aggrField(a, sort.field) : 'count';\n    p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n    p.fields = [scope.fieldRef(v)];\n    p.as = [v];\n  }\n\n  a = scope.add(Aggregate(p)); // collect aggregate output\n\n  const c = scope.add(Collect({\n    pulse: ref(a)\n  })); // extract values for combined domain\n\n  v = scope.add(Values({\n    field: keyFieldRef,\n    sort: scope.sortRef(sort),\n    pulse: ref(c)\n  }));\n  return ref(v);\n}\n\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if (isObject(sort)) sort.field = 'key';else sort = {\n        field: 'key'\n      };\n    } else if (!sort.field && sort.op !== 'count') {\n      error('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n        error('Multiple domain scales can not be sorted using ' + sort.op);\n      }\n    }\n  }\n\n  return sort;\n}\n\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  const values = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  }); // combine value arrays\n\n  return ref(scope.add(MultiValues({\n    values: values\n  })));\n}\n\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  const extents = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  }); // combine extents\n\n  return ref(scope.add(MultiExtent({\n    extents: extents\n  })));\n} // -- SCALE BINS -----\n\n\nfunction parseScaleBins(v, scope) {\n  return v.signal || isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);\n} // -- SCALE NICE -----\n\n\nfunction parseScaleNice(nice) {\n  return isObject(nice) ? {\n    interval: parseLiteral(nice.interval),\n    step: parseLiteral(nice.step)\n  } : parseLiteral(nice);\n} // -- SCALE INTERPOLATION -----\n\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n} // -- SCALE RANGE -----\n\n\nfunction parseScaleRange(spec, scope, params) {\n  const config = scope.config.range;\n  let range = spec.range;\n\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if (isString(range)) {\n    if (config && hasOwnProperty(config, range)) {\n      spec = extend({}, spec, {\n        range: config[range]\n      });\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, {\n        signal: 'width'\n      }];\n    } else if (range === 'height') {\n      range = isDiscrete(spec.type) ? [0, {\n        signal: 'height'\n      }] : [{\n        signal: 'height'\n      }, 0];\n    } else {\n      error('Unrecognized scale range value: ' + stringValue(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = isArray(range.scheme) ? parseArray(range.scheme, scope) : parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isDiscrete(spec.type) && !isArray(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!isArray(range)) {\n    error('Unsupported range type: ' + stringValue(range));\n  }\n\n  return range.map(v => (isArray(v) ? parseArray : parseLiteral)(v, scope));\n}\n\nfunction parseProjection(proj, scope) {\n  const config = scope.config.projection || {},\n        params = {};\n\n  for (const name in proj) {\n    if (name === 'name') continue;\n    params[name] = parseParameter$1(proj[name], name, scope);\n  } // apply projection defaults from config\n\n\n  for (const name in config) {\n    if (params[name] == null) {\n      params[name] = parseParameter$1(config[name], name, scope);\n    }\n  }\n\n  scope.addProjection(proj.name, params);\n}\n\nfunction parseParameter$1(_, name, scope) {\n  return isArray(_) ? _.map(_ => parseParameter$1(_, name, scope)) : !isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === 'fit' ? _ : error('Unsupported parameter object: ' + stringValue(_));\n}\n\nconst Top = 'top';\nconst Left = 'left';\nconst Right = 'right';\nconst Bottom = 'bottom';\nconst Center = 'center';\nconst Vertical = 'vertical';\nconst Start = 'start';\nconst Middle = 'middle';\nconst End = 'end';\nconst Index = 'index';\nconst Label = 'label';\nconst Offset = 'offset';\nconst Perc = 'perc';\nconst Perc2 = 'perc2';\nconst Value = 'value';\nconst GuideLabelStyle = 'guide-label';\nconst GuideTitleStyle = 'guide-title';\nconst GroupTitleStyle = 'group-title';\nconst GroupSubtitleStyle = 'group-subtitle';\nconst Symbols = 'symbol';\nconst Gradient = 'gradient';\nconst Discrete = 'discrete';\nconst Size = 'size';\nconst Shape = 'shape';\nconst Fill = 'fill';\nconst Stroke = 'stroke';\nconst StrokeWidth = 'strokeWidth';\nconst StrokeDash = 'strokeDash';\nconst Opacity = 'opacity'; // Encoding channels supported by legends\n// In priority order of 'canonical' scale\n\nconst LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];\nconst Skip = {\n  name: 1,\n  style: 1,\n  interactive: 1\n};\nconst zero = {\n  value: 0\n};\nconst one = {\n  value: 1\n};\nconst GroupMark = 'group';\nconst RectMark = 'rect';\nconst RuleMark = 'rule';\nconst SymbolMark = 'symbol';\nconst TextMark = 'text';\n\nfunction guideGroup(mark) {\n  mark.type = GroupMark;\n  mark.interactive = mark.interactive || false;\n  return mark;\n}\n\nfunction lookup(spec, config) {\n  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));\n\n  _.isVertical = s => Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));\n\n  _.gradientLength = () => value(spec.gradientLength, config.gradientLength || config.gradientWidth);\n\n  _.gradientThickness = () => value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);\n\n  _.entryColumns = () => value(spec.columns, value(config.columns, +_.isVertical(true)));\n\n  return _;\n}\n\nfunction getEncoding(name, encode) {\n  const v = encode && (encode.update && encode.update[name] || encode.enter && encode.enter[name]);\n  return v && v.signal ? v : v ? v.value : null;\n}\n\nfunction getStyle(name, scope, style) {\n  const s = scope.config.style[style];\n  return s && s[name];\n}\n\nfunction anchorExpr(s, e, m) {\n  return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;\n}\n\nconst alignExpr$1 = anchorExpr(stringValue(Left), stringValue(Right), stringValue(Center));\n\nfunction tickBand(_) {\n  const v = _('tickBand');\n\n  let offset = _('tickOffset'),\n      band,\n      extra;\n\n  if (!v) {\n    // if no tick band entry, fall back on other properties\n    band = _('bandPosition');\n    extra = _('tickExtra');\n  } else if (v.signal) {\n    // if signal, augment code to interpret values\n    band = {\n      signal: `(${v.signal}) === 'extent' ? 1 : 0.5`\n    };\n    extra = {\n      signal: `(${v.signal}) === 'extent'`\n    };\n\n    if (!isObject(offset)) {\n      offset = {\n        signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`\n      };\n    }\n  } else if (v === 'extent') {\n    // if constant, simply set values\n    band = 1;\n    extra = true;\n    offset = 0;\n  } else {\n    band = 0.5;\n    extra = false;\n  }\n\n  return {\n    extra,\n    band,\n    offset\n  };\n}\n\nfunction extendOffset(value, offset) {\n  return !offset ? value : !value ? offset : !isObject(value) ? {\n    value,\n    offset\n  } : Object.assign({}, value, {\n    offset: extendOffset(value.offset, offset)\n  });\n}\n\nfunction guideMark(mark, extras) {\n  if (extras) {\n    mark.name = extras.name;\n    mark.style = extras.style || mark.style;\n    mark.interactive = !!extras.interactive;\n    mark.encode = extendEncode(mark.encode, extras, Skip);\n  } else {\n    mark.interactive = false;\n  }\n\n  return mark;\n}\n\nfunction legendGradient(spec, scale, config, userEncode) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let enter, start, stop, width, height;\n\n  if (vertical) {\n    start = [0, 1];\n    stop = [0, 0];\n    width = thickness;\n    height = length;\n  } else {\n    start = [0, 0];\n    stop = [1, 0];\n    width = length;\n    height = thickness;\n  }\n\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      x: zero,\n      y: zero,\n      width: encoder(width),\n      height: encoder(height)\n    },\n    update: extend({}, enter, {\n      opacity: one,\n      fill: {\n        gradient: scale,\n        start: start,\n        stop: stop\n      }\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendGradientRole,\n    encode\n  }, userEncode);\n}\n\nfunction legendGradientDiscrete(spec, scale, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let u,\n      v,\n      uu,\n      vv,\n      adjust = '';\n  vertical ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-') : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\n  const enter = {\n    opacity: zero,\n    fill: {\n      scale: scale,\n      field: Value\n    }\n  };\n  enter[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = zero;\n  enter[uu] = {\n    signal: adjust + 'datum.' + Perc2,\n    mult: length\n  };\n  enter[vv] = encoder(thickness);\n  const encode = {\n    enter: enter,\n    update: extend({}, enter, {\n      opacity: one\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendBandRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nconst alignExpr = `datum.${Perc}<=0?\"${Left}\":datum.${Perc}>=1?\"${Right}\":\"${Center}\"`,\n      baselineExpr = `datum.${Perc}<=0?\"${Bottom}\":datum.${Perc}>=1?\"${Top}\":\"${Middle}\"`;\n\nfunction legendGradientLabels(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = encoder(_.gradientThickness()),\n        length = _.gradientLength();\n\n  let overlap = _('labelOverlap'),\n      enter,\n      update,\n      u,\n      v,\n      adjust = '';\n\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: value(spec.labelLimit, config.gradientLabelLimit)\n  });\n\n  if (vertical) {\n    enter.align = {\n      value: 'left'\n    };\n    enter.baseline = update.baseline = {\n      signal: baselineExpr\n    };\n    u = 'y';\n    v = 'x';\n    adjust = '1-';\n  } else {\n    enter.align = update.align = {\n      signal: alignExpr\n    };\n    enter.baseline = {\n      value: 'top'\n    };\n    u = 'x';\n    v = 'y';\n  }\n\n  enter[u] = update[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = update[v] = thickness;\n  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\n  overlap = overlap ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.' + Index\n  } : undefined; // type, role, style, key, dataRef, encode, extras\n\n  return guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n\nfunction legendSymbolGroups(spec, config, userEncode, dataRef, columns) {\n  const _ = lookup(spec, config),\n        entries = userEncode.entries,\n        interactive = !!(entries && entries.interactive),\n        name = entries ? entries.name : undefined,\n        height = _('clipHeight'),\n        symbolOffset = _('symbolOffset'),\n        valueRef = {\n    data: 'value'\n  },\n        xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,\n        yEncode = height ? encoder(height) : {\n    field: Size\n  },\n        index = `datum.${Index}`,\n        ncols = `max(1, ${columns})`;\n\n  let encode, enter, update, nrows, sort;\n  yEncode.mult = 0.5; // -- LEGEND SYMBOLS --\n\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        mult: 0.5,\n        offset: symbolOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  let baseFill = null,\n      baseStroke = null;\n\n  if (!spec.fill) {\n    baseFill = config.symbolBaseFillColor;\n    baseStroke = config.symbolBaseStrokeColor;\n  }\n\n  addEncoders(encode, {\n    fill: _('symbolFillColor', baseFill),\n    shape: _('symbolType'),\n    size: _('symbolSize'),\n    stroke: _('symbolStrokeColor', baseStroke),\n    strokeDash: _('symbolDash'),\n    strokeDashOffset: _('symbolDashOffset'),\n    strokeWidth: _('symbolStrokeWidth')\n  }, {\n    // update\n    opacity: _('symbolOpacity')\n  });\n  LegendScales.forEach(scale => {\n    if (spec[scale]) {\n      update[scale] = enter[scale] = {\n        scale: spec[scale],\n        field: Value\n      };\n    }\n  });\n  const symbols = guideMark({\n    type: SymbolMark,\n    role: LegendSymbolRole,\n    key: Value,\n    from: valueRef,\n    clip: height ? true : undefined,\n    encode\n  }, userEncode.symbols); // -- LEGEND LABELS --\n\n  const labelOffset = encoder(symbolOffset);\n  labelOffset.offset = _('labelOffset');\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        offset: labelOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    align: _('labelAlign'),\n    baseline: _('labelBaseline'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: _('labelLimit')\n  });\n  const labels = guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: valueRef,\n    encode\n  }, userEncode.labels); // -- LEGEND ENTRY GROUPS --\n\n  encode = {\n    enter: {\n      noBound: {\n        value: !height\n      },\n      // ignore width/height in bounds calc\n      width: zero,\n      height: height ? encoder(height) : zero,\n      opacity: zero\n    },\n    exit: {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      row: {\n        signal: null\n      },\n      column: {\n        signal: null\n      }\n    }\n  }; // annotate and sort groups to ensure correct ordering\n\n  if (_.isVertical(true)) {\n    nrows = `ceil(item.mark.items.length / ${ncols})`;\n    update.row.signal = `${index}%${nrows}`;\n    update.column.signal = `floor(${index} / ${nrows})`;\n    sort = {\n      field: ['row', index]\n    };\n  } else {\n    update.row.signal = `floor(${index} / ${ncols})`;\n    update.column.signal = `${index} % ${ncols}`;\n    sort = {\n      field: index\n    };\n  } // handle zero column case (implies infinite columns)\n\n\n  update.column.signal = `(${columns})?${update.column.signal}:${index}`; // facet legend entries into sub-groups\n\n  dataRef = {\n    facet: {\n      data: dataRef,\n      name: 'value',\n      groupby: Index\n    }\n  };\n  return guideGroup({\n    role: ScopeRole,\n    from: dataRef,\n    encode: extendEncode(encode, entries, Skip),\n    marks: [symbols, labels],\n    name,\n    interactive,\n    sort\n  });\n}\n\nfunction legendSymbolLayout(spec, config) {\n  const _ = lookup(spec, config); // layout parameters for legend entries\n\n\n  return {\n    align: _('gridAlign'),\n    columns: _.entryColumns(),\n    center: {\n      row: true,\n      column: false\n    },\n    padding: {\n      row: _('rowPadding'),\n      column: _('columnPadding')\n    }\n  };\n}\n\nconst isL = 'item.orient === \"left\"',\n      isR = 'item.orient === \"right\"',\n      isLR = `(${isL} || ${isR})`,\n      isVG = `datum.vgrad && ${isLR}`,\n      baseline = anchorExpr('\"top\"', '\"bottom\"', '\"middle\"'),\n      alignFlip = anchorExpr('\"right\"', '\"left\"', '\"center\"'),\n      exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? \"left\" : ${alignExpr$1}`,\n      exprAnchor = `item._anchor || (${isLR} ? \"middle\" : \"start\")`,\n      exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,\n      exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? \"bottom\" : \"top\") : ${baseline}) : \"top\"`;\n\nfunction legendTitle(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config);\n\n  const encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: one,\n      x: {\n        field: {\n          group: 'padding'\n        }\n      },\n      y: {\n        field: {\n          group: 'padding'\n        }\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    orient: _('titleOrient'),\n    _anchor: _('titleAnchor'),\n    anchor: {\n      signal: exprAnchor\n    },\n    angle: {\n      signal: exprAngle\n    },\n    align: {\n      signal: exprAlign\n    },\n    baseline: {\n      signal: exprBaseline\n    },\n    text: spec.title,\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    baseline: _('titleBaseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: LegendTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction clip(clip, scope) {\n  let expr;\n\n  if (isObject(clip)) {\n    if (clip.signal) {\n      expr = clip.signal;\n    } else if (clip.path) {\n      expr = 'pathShape(' + param(clip.path) + ')';\n    } else if (clip.sphere) {\n      expr = 'geoShape(' + param(clip.sphere) + ', {type: \"Sphere\"})';\n    }\n  }\n\n  return expr ? scope.signalRef(expr) : !!clip;\n}\n\nfunction param(value) {\n  return isObject(value) && value.signal ? value.signal : stringValue(value);\n}\n\nfunction getRole(spec) {\n  const role = spec.role || '';\n  return !role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title') ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;\n}\n\nfunction definition(spec) {\n  return {\n    marktype: spec.type,\n    name: spec.name || undefined,\n    role: spec.role || getRole(spec),\n    zindex: +spec.zindex || undefined,\n    aria: spec.aria,\n    description: spec.description\n  };\n}\n\nfunction interactive(spec, scope) {\n  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;\n}\n/**\n * Parse a data transform specification.\n */\n\n\nfunction parseTransform(spec, scope) {\n  const def = definition$1(spec.type);\n  if (!def) error('Unrecognized transform type: ' + stringValue(spec.type));\n  const t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n  return t;\n}\n/**\n * Parse all parameters of a data transform.\n */\n\n\nfunction parseParameters(def, spec, scope) {\n  const params = {},\n        n = def.params.length;\n\n  for (let i = 0; i < n; ++i) {\n    const pdef = def.params[i];\n    params[pdef.name] = parseParameter(pdef, spec, scope);\n  }\n\n  return params;\n}\n/**\n * Parse a data transform parameter.\n */\n\n\nfunction parseParameter(def, spec, scope) {\n  const type = def.type,\n        value = spec[def.name];\n\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      error('Missing required ' + stringValue(spec.type) + ' parameter: ' + stringValue(def.name));\n    }\n\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n\n  return def.array && !isSignal(value) ? value.map(v => parameterValue(def, v, scope)) : parameterValue(def, value, scope);\n}\n/**\n * Parse a single parameter value.\n */\n\n\nfunction parameterValue(def, value, scope) {\n  const type = def.type;\n\n  if (isSignal(value)) {\n    return isExpr(type) ? error('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);\n  } else {\n    const expr = def.expr || isField(type);\n    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as) : expr && outerField(value) ? fieldRef$1(value.field, value.as) : isExpr(type) ? parseExpression(value, scope) : isData(type) ? ref(scope.getData(value).values) : isField(type) ? fieldRef$1(value) : isCompare(type) ? scope.compareRef(value) : value;\n  }\n}\n/**\n * Parse parameter for accessing an index of another data set.\n */\n\n\nfunction parseIndexParameter(def, spec, scope) {\n  if (!isString(spec.from)) {\n    error('Lookup \"from\" parameter must be a string literal.');\n  }\n\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\n\n\nfunction parseSubParameters(def, spec, scope) {\n  const value = spec[def.name];\n\n  if (def.array) {\n    if (!isArray(value)) {\n      // signals not allowed!\n      error('Expected an array of sub-parameters. Instead: ' + stringValue(value));\n    }\n\n    return value.map(v => parseSubParameter(def, v, scope));\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n/**\n * Parse a sub-parameter object.\n */\n\n\nfunction parseSubParameter(def, value, scope) {\n  const n = def.params.length;\n  let pdef; // loop over defs to find matching key\n\n  for (let i = 0; i < n; ++i) {\n    pdef = def.params[i];\n\n    for (const k in pdef.key) {\n      if (pdef.key[k] !== value[k]) {\n        pdef = null;\n        break;\n      }\n    }\n\n    if (pdef) break;\n  } // raise error if matching key not found\n\n\n  if (!pdef) error('Unsupported parameter: ' + stringValue(value)); // parse params, create Params transform, return ref\n\n  const params = extend(parseParameters(pdef, value, scope), pdef.key);\n  return ref(scope.add(Params(params)));\n} // -- Utilities -----\n\n\nconst outerExpr = _ => _ && _.expr;\n\nconst outerField = _ => _ && _.field;\n\nconst isData = _ => _ === 'data';\n\nconst isExpr = _ => _ === 'expr';\n\nconst isField = _ => _ === 'field';\n\nconst isCompare = _ => _ === 'compare';\n\nfunction parseData$1(from, group, scope) {\n  let facet, key, op, dataRef, parent; // if no source data, generate singleton datum\n\n  if (!from) {\n    dataRef = ref(scope.add(Collect(null, [{}])));\n  } // if faceted, process facet specification\n  else if (facet = from.facet) {\n    if (!group) error('Only group marks can be faceted.'); // use pre-faceted source data, if available\n\n    if (facet.field != null) {\n      dataRef = parent = getDataRef(facet, scope);\n    } else {\n      // generate facet aggregates if no direct data specification\n      if (!from.data) {\n        op = parseTransform(extend({\n          type: 'aggregate',\n          groupby: array(facet.groupby)\n        }, facet.aggregate), scope);\n        op.params.key = scope.keyRef(facet.groupby);\n        op.params.pulse = getDataRef(facet, scope);\n        dataRef = parent = ref(scope.add(op));\n      } else {\n        parent = ref(scope.getData(from.data).aggregate);\n      }\n\n      key = scope.keyRef(facet.groupby, true);\n    }\n  } // if not yet defined, get source data reference\n\n\n  if (!dataRef) {\n    dataRef = getDataRef(from, scope);\n  }\n\n  return {\n    key: key,\n    pulse: dataRef,\n    parent: parent\n  };\n}\n\nfunction getDataRef(from, scope) {\n  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);\n}\n\nfunction DataScope(scope, input, output, values, aggr) {\n  this.scope = scope; // parent scope object\n\n  this.input = input; // first operator in pipeline (tuple input)\n\n  this.output = output; // last operator in pipeline (tuple output)\n\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n  // last aggregate in transform pipeline\n\n  this.aggregate = aggr; // lookup table of field indices\n\n  this.index = {};\n}\n\nDataScope.fromEntries = function (scope, entries) {\n  const n = entries.length,\n        values = entries[n - 1],\n        output = entries[n - 2];\n  let input = entries[0],\n      aggr = null,\n      i = 1;\n\n  if (input && input.type === 'load') {\n    input = entries[1];\n  } // add operator entries to this scope, wire up pulse chain\n\n\n  scope.add(entries[0]);\n\n  for (; i < n; ++i) {\n    entries[i].params.pulse = ref(entries[i - 1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n\n  return new DataScope(scope, input, output, values, aggr);\n};\n\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\n\nfunction addSortField(scope, p, sort) {\n  const as = aggrField(sort.op, sort.field);\n  let s;\n\n  if (p.ops) {\n    for (let i = 0, n = p.as.length; i < n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n\n  if (sort.op) {\n    p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\n\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  const cache = ds[name] || (ds[name] = {}),\n        sort = sortKey(counts);\n  let k = fieldKey(field),\n      v,\n      op;\n\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n\n  if (!v) {\n    const params = counts ? {\n      field: keyFieldRef,\n      pulse: ds.countsRef(scope, field, counts)\n    } : {\n      field: scope.fieldRef(field),\n      pulse: ref(ds.output)\n    };\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n\n  return v;\n}\n\nDataScope.prototype = {\n  countsRef(scope, field, sort) {\n    const ds = this,\n          cache = ds.counts || (ds.counts = {}),\n          k = fieldKey(field);\n    let v, a, p;\n\n    if (k != null) {\n      scope = ds.scope;\n      v = cache[k];\n    }\n\n    if (!v) {\n      p = {\n        groupby: scope.fieldRef(field, 'key'),\n        pulse: ref(ds.output)\n      };\n      if (sort && sort.field) addSortField(scope, p, sort);\n      a = scope.add(Aggregate(p));\n      v = scope.add(Collect({\n        pulse: ref(a)\n      }));\n      v = {\n        agg: a,\n        ref: ref(v)\n      };\n      if (k != null) cache[k] = v;\n    } else if (sort && sort.field) {\n      addSortField(scope, v.agg.params, sort);\n    }\n\n    return v.ref;\n  },\n\n  tuplesRef() {\n    return ref(this.values);\n  },\n\n  extentRef(scope, field) {\n    return cache(scope, this, 'extent', 'extent', field, false);\n  },\n\n  domainRef(scope, field) {\n    return cache(scope, this, 'domain', 'values', field, false);\n  },\n\n  valuesRef(scope, field, sort) {\n    return cache(scope, this, 'vals', 'values', field, sort || true);\n  },\n\n  lookupRef(scope, field) {\n    return cache(scope, this, 'lookup', 'tupleindex', field, false);\n  },\n\n  indataRef(scope, field) {\n    return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n  }\n\n};\n\nfunction parseFacet(spec, scope, group) {\n  const facet = spec.from.facet,\n        name = facet.name,\n        data = getDataRef(facet, scope);\n  let op;\n\n  if (!facet.name) {\n    error('Facet must have a name: ' + stringValue(facet));\n  }\n\n  if (!facet.data) {\n    error('Facet must reference a data set: ' + stringValue(facet));\n  }\n\n  if (facet.field) {\n    op = scope.add(PreFacet({\n      field: scope.fieldRef(facet.field),\n      pulse: data\n    }));\n  } else if (facet.groupby) {\n    op = scope.add(Facet({\n      key: scope.keyRef(facet.groupby),\n      group: ref(scope.proxy(group.parent)),\n      pulse: data\n    }));\n  } else {\n    error('Facet must specify groupby or field: ' + stringValue(facet));\n  } // initialize facet subscope\n\n\n  const subscope = scope.fork(),\n        source = subscope.add(Collect()),\n        values = subscope.add(Sieve({\n    pulse: ref(source)\n  }));\n  subscope.addData(name, new DataScope(subscope, source, source, values));\n  subscope.addSignal('parent', null); // parse faceted subflow\n\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n\nfunction parseSubflow(spec, scope, input) {\n  const op = scope.add(PreFacet({\n    pulse: input.pulse\n  })),\n        subscope = scope.fork();\n  subscope.add(Sieve());\n  subscope.addSignal('parent', null); // parse group mark subflow\n\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n\nfunction parseTrigger(spec, scope, name) {\n  const remove = spec.remove,\n        insert = spec.insert,\n        toggle = spec.toggle,\n        modify = spec.modify,\n        values = spec.values,\n        op = scope.add(operator());\n  const update = 'if(' + spec.trigger + ',modify(\"' + name + '\",' + [insert, remove, toggle, modify, values].map(_ => _ == null ? 'null' : _).join(',') + '),0)';\n  const expr = parseExpression(update, scope);\n  op.update = expr.$expr;\n  op.params = expr.$params;\n}\n\nfunction parseMark(spec, scope) {\n  const role = getRole(spec),\n        group = spec.type === GroupMark,\n        facet = spec.from && spec.from.facet,\n        overlap = spec.overlap;\n  let layout = spec.layout || role === ScopeRole || role === FrameRole,\n      ops,\n      op,\n      store,\n      enc,\n      name,\n      layoutRef,\n      boundRef;\n  const nested = role === MarkRole || layout || facet; // resolve input data\n\n  const input = parseData$1(spec.from, group, scope); // data join to map tuples to visual items\n\n  op = scope.add(DataJoin({\n    key: input.key || (spec.key ? fieldRef$1(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  const joinRef = ref(op); // collect visual items\n\n  op = store = scope.add(Collect({\n    pulse: joinRef\n  })); // connect visual items to scenegraph\n\n  op = scope.add(Mark({\n    markdef: definition(spec),\n    interactive: interactive(spec.interactive, scope),\n    clip: clip(spec.clip, scope),\n    context: {\n      $context: true\n    },\n    groups: scope.lookup(),\n    parent: scope.signals.parent ? scope.signalRef('parent') : null,\n    index: scope.markpath(),\n    pulse: ref(op)\n  }));\n  const markRef = ref(op); // add visual encoders\n\n  op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {\n    mod: false,\n    pulse: markRef\n  }))); // monitor parent marks to propagate changes\n\n  op.params.parent = scope.encode(); // add post-encoding transforms, if defined\n\n  if (spec.transform) {\n    spec.transform.forEach(_ => {\n      const tx = parseTransform(_, scope),\n            md = tx.metadata;\n\n      if (md.generates || md.changes) {\n        error('Mark transforms should not generate new data.');\n      }\n\n      if (!md.nomod) enc.params.mod = true; // update encode mod handling\n\n      tx.params.pulse = ref(op);\n      scope.add(op = tx);\n    });\n  } // if item sort specified, perform post-encoding\n\n\n  if (spec.sort) {\n    op = scope.add(SortItems({\n      sort: scope.compareRef(spec.sort),\n      pulse: ref(op)\n    }));\n  }\n\n  const encodeRef = ref(op); // add view layout operator if needed\n\n  if (facet || layout) {\n    layout = scope.add(ViewLayout({\n      layout: scope.objectProperty(spec.layout),\n      legends: scope.legends,\n      mark: markRef,\n      pulse: encodeRef\n    }));\n    layoutRef = ref(layout);\n  } // compute bounding boxes\n\n\n  const bound = scope.add(Bound({\n    mark: markRef,\n    pulse: layoutRef || encodeRef\n  }));\n  boundRef = ref(bound); // if group mark, recurse to parse nested content\n\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) {\n      ops = scope.operators;\n      ops.pop();\n      if (layout) ops.pop();\n    }\n\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? parseFacet(spec, scope, input) // explicit facet\n    : nested ? parseSubflow(spec, scope, input) // standard mark group\n    : scope.parse(spec); // guide group, we can avoid nested scopes\n\n    scope.popState();\n\n    if (nested) {\n      if (layout) ops.push(layout);\n      ops.push(bound);\n    }\n  } // if requested, add overlap removal transform\n\n\n  if (overlap) {\n    boundRef = parseOverlap(overlap, boundRef, scope);\n  } // render / sieve items\n\n\n  const render = scope.add(Render({\n    pulse: boundRef\n  })),\n        sieve = scope.add(Sieve({\n    pulse: ref(render)\n  }, undefined, scope.parent())); // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new DataScope(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(on => {\n      if (on.insert || on.remove || on.toggle) {\n        error('Marks only support modify triggers.');\n      }\n\n      parseTrigger(on, scope, name);\n    });\n  }\n}\n\nfunction parseOverlap(overlap, source, scope) {\n  const method = overlap.method,\n        bound = overlap.bound,\n        sep = overlap.separation;\n  const params = {\n    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n    method: isSignal(method) ? scope.signalRef(method.signal) : method,\n    pulse: source\n  };\n\n  if (overlap.order) {\n    params.sort = scope.compareRef({\n      field: overlap.order\n    });\n  }\n\n  if (bound) {\n    const tol = bound.tolerance;\n    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n    params.boundScale = scope.scaleRef(bound.scale);\n    params.boundOrient = bound.orient;\n  }\n\n  return ref(scope.add(Overlap(params)));\n}\n\nfunction parseLegend(spec, scope) {\n  const config = scope.config.legend,\n        encode = spec.encode || {},\n        _ = lookup(spec, config),\n        legendEncode = encode.legend || {},\n        name = legendEncode.name || undefined,\n        interactive = legendEncode.interactive,\n        style = legendEncode.style,\n        scales = {};\n\n  let scale = 0,\n      entryLayout,\n      params,\n      children; // resolve scales and 'canonical' scale name\n\n  LegendScales.forEach(s => spec[s] ? (scales[s] = spec[s], scale = scale || spec[s]) : 0);\n  if (!scale) error('Missing valid scale for legend.'); // resolve legend type (symbol, gradient, or discrete gradient)\n\n  const type = legendType(spec, scope.scaleType(scale)); // single-element data source for legend group\n\n  const datum = {\n    title: spec.title != null,\n    scales: scales,\n    type: type,\n    vgrad: type !== 'symbol' && _.isVertical()\n  };\n  const dataRef = ref(scope.add(Collect(null, [datum]))); // encoding properties for legend entry sub-group\n\n  const entryEncode = {\n    enter: {\n      x: {\n        value: 0\n      },\n      y: {\n        value: 0\n      }\n    }\n  }; // data source for legend values\n\n  const entryRef = ref(scope.add(LegendEntries(params = {\n    type: type,\n    scale: scope.scaleRef(scale),\n    count: scope.objectProperty(_('tickCount')),\n    limit: scope.property(_('symbolLimit')),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // continuous gradient legend\n\n  if (type === Gradient) {\n    children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)]; // adjust default tick count based on the gradient length\n\n    params.count = params.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);\n  } // discrete gradient legend\n  else if (type === Discrete) {\n    children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];\n  } // symbol legend\n  else {\n    // determine legend symbol group layout\n    entryLayout = legendSymbolLayout(spec, config);\n    children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))]; // pass symbol size information to legend entry generator\n\n    params.size = sizeExpression(spec, scope, children[0].marks);\n  } // generate legend marks\n\n\n  children = [guideGroup({\n    role: LegendEntryRole,\n    from: dataRef,\n    encode: entryEncode,\n    marks: children,\n    layout: entryLayout,\n    interactive\n  })]; // include legend title if defined\n\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  } // parse legend specification\n\n\n  return parseMark(guideGroup({\n    role: LegendRole,\n    from: dataRef,\n    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\n\nfunction legendType(spec, scaleType) {\n  let type = spec.type || Symbols;\n\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient : isDiscretizing(scaleType) ? Discrete : Symbols;\n  }\n\n  return type !== Gradient ? type : isDiscretizing(scaleType) ? Discrete : Gradient;\n}\n\nfunction scaleCount(spec) {\n  return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);\n}\n\nfunction buildLegendEncode(_, spec, config) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset'),\n    padding: _('padding'),\n    titlePadding: _('titlePadding'),\n    cornerRadius: _('cornerRadius'),\n    fill: _('fillColor'),\n    stroke: _('strokeColor'),\n    strokeWidth: config.strokeWidth,\n    strokeDash: config.strokeDash,\n    x: _('legendX'),\n    y: _('legendY'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\n\nfunction sizeExpression(spec, scope, marks) {\n  const size = deref(getChannel('size', spec, marks)),\n        strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n        fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n  return parseExpression(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`, scope);\n}\n\nfunction getChannel(name, spec, marks) {\n  return spec[name] ? `scale(\"${spec[name]}\",datum)` : getEncoding(name, marks[0].encode);\n}\n\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}\n\nconst angleExpr = `item.orient===\"${Left}\"?-90:item.orient===\"${Right}\"?90:0`;\n\nfunction parseTitle(spec, scope) {\n  spec = isString(spec) ? {\n    text: spec\n  } : spec;\n\n  const _ = lookup(spec, scope.config.title),\n        encode = spec.encode || {},\n        userEncode = encode.group || {},\n        name = userEncode.name || undefined,\n        interactive = userEncode.interactive,\n        style = userEncode.style,\n        children = []; // single-element data source for group title\n\n\n  const datum = {},\n        dataRef = ref(scope.add(Collect(null, [datum]))); // include title text\n\n  children.push(buildTitle(spec, _, titleEncode(spec), dataRef)); // include subtitle text\n\n  if (spec.subtitle) {\n    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\n  } // parse title specification\n\n\n  return parseMark(guideGroup({\n    role: TitleRole,\n    from: dataRef,\n    encode: groupEncode(_, userEncode),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n} // provide backwards-compatibility for title custom encode;\n// the top-level encode block has been *deprecated*.\n\n\nfunction titleEncode(spec) {\n  const encode = spec.encode;\n  return encode && encode.title || extend({\n    name: spec.name,\n    interactive: spec.interactive,\n    style: spec.style\n  }, encode);\n}\n\nfunction groupEncode(_, userEncode) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    anchor: _('anchor'),\n    align: {\n      signal: alignExpr$1\n    },\n    angle: {\n      signal: angleExpr\n    },\n    limit: _('limit'),\n    frame: _('frame'),\n    offset: _('offset') || 0,\n    padding: _('subtitlePadding')\n  });\n  return extendEncode(encode, userEncode, Skip);\n}\n\nfunction buildTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n    value: 0\n  },\n        text = spec.text,\n        encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: {\n        value: 1\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('color'),\n    font: _('font'),\n    fontSize: _('fontSize'),\n    fontStyle: _('fontStyle'),\n    fontWeight: _('fontWeight'),\n    lineHeight: _('lineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleTextRole,\n    style: GroupTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction buildSubTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n    value: 0\n  },\n        text = spec.subtitle,\n        encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: {\n        value: 1\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('subtitleColor'),\n    font: _('subtitleFont'),\n    fontSize: _('subtitleFontSize'),\n    fontStyle: _('subtitleFontStyle'),\n    fontWeight: _('subtitleFontWeight'),\n    lineHeight: _('subtitleLineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleSubtitleRole,\n    style: GroupSubtitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction parseData(data, scope) {\n  const transforms = [];\n\n  if (data.transform) {\n    data.transform.forEach(tx => {\n      transforms.push(parseTransform(tx, scope));\n    });\n  }\n\n  if (data.on) {\n    data.on.forEach(on => {\n      parseTrigger(on, scope, data.name);\n    });\n  }\n\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n/**\n * Analyze a data pipeline, add needed operators.\n */\n\n\nfunction analyze(data, scope, ops) {\n  const output = [];\n  let source = null,\n      modify = false,\n      generate = false,\n      upstream,\n      i,\n      n,\n      t,\n      m;\n\n  if (data.values) {\n    // hard-wired input data set\n    if (isSignal(data.values) || hasSignal(data.format)) {\n      // if either values is signal or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, ingest upon dataflow init\n      output.push(source = collect({\n        $ingest: data.values,\n        $format: data.format\n      }));\n    }\n  } else if (data.url) {\n    // load data from external source\n    if (hasSignal(data.url) || hasSignal(data.format)) {\n      // if either url or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, request load upon dataflow init\n      output.push(source = collect({\n        $request: data.url,\n        $format: data.format\n      }));\n    }\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = array(data.source).map(d => ref(scope.getData(d).output));\n    output.push(null); // populate later\n  } // scan data transforms, add collectors as needed\n\n\n  for (i = 0, n = ops.length; i < n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n\n    output.push(t);\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n    if (m.source) source = t;else if (m.changes) source = null;\n  }\n\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = Relay({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n\n  if (!source) output.push(collect());\n  output.push(Sieve({}));\n  return output;\n}\n\nfunction collect(values) {\n  const s = Collect({}, values);\n  s.metadata = {\n    source: true\n  };\n  return s;\n}\n\nfunction load(scope, data) {\n  return Load({\n    url: data.url ? scope.property(data.url) : undefined,\n    async: data.async ? scope.property(data.async) : undefined,\n    values: data.values ? scope.property(data.values) : undefined,\n    format: scope.objectProperty(data.format)\n  });\n}\n\nconst isX = orient => orient === Bottom || orient === Top; // get sign coefficient based on axis orient\n\n\nconst getSign = (orient, a, b) => isSignal(orient) ? ifLeftTopExpr(orient.signal, a, b) : orient === Left || orient === Top ? a : b; // condition on axis x-direction\n\n\nconst ifX = (orient, a, b) => isSignal(orient) ? ifXEnc(orient.signal, a, b) : isX(orient) ? a : b; // condition on axis y-direction\n\n\nconst ifY = (orient, a, b) => isSignal(orient) ? ifYEnc(orient.signal, a, b) : isX(orient) ? b : a;\n\nconst ifTop = (orient, a, b) => isSignal(orient) ? ifTopExpr(orient.signal, a, b) : orient === Top ? {\n  value: a\n} : {\n  value: b\n};\n\nconst ifRight = (orient, a, b) => isSignal(orient) ? ifRightExpr(orient.signal, a, b) : orient === Right ? {\n  value: a\n} : {\n  value: b\n};\n\nconst ifXEnc = ($orient, a, b) => ifEnc(`${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b);\n\nconst ifYEnc = ($orient, a, b) => ifEnc(`${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b);\n\nconst ifLeftTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b);\n\nconst ifTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Top}'`, a, b);\n\nconst ifRightExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Right}'`, a, b);\n\nconst ifEnc = (test, a, b) => {\n  // ensure inputs are encoder objects (or null)\n  a = a != null ? encoder(a) : a;\n  b = b != null ? encoder(b) : b;\n\n  if (isSimple(a) && isSimple(b)) {\n    // if possible generate simple signal expression\n    a = a ? a.signal || stringValue(a.value) : null;\n    b = b ? b.signal || stringValue(b.value) : null;\n    return {\n      signal: `${test} ? (${a}) : (${b})`\n    };\n  } else {\n    // otherwise generate rule set\n    return [extend({\n      test\n    }, a)].concat(b || []);\n  }\n};\n\nconst isSimple = enc => enc == null || Object.keys(enc).length === 1;\n\nconst ifExpr = (test, a, b) => ({\n  signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`\n});\n\nconst ifOrient = ($orient, t, b, l, r) => ({\n  signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '') + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '') + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '') + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '') + '(null)'\n});\n\nconst toExpr = v => isSignal(v) ? v.signal : v == null ? null : stringValue(v);\n\nconst mult = (sign, value) => value === 0 ? 0 : isSignal(sign) ? {\n  signal: `(${sign.signal}) * ${value}`\n} : {\n  value: sign * value\n};\n\nconst patch = (value, base) => {\n  const s = value.signal;\n  return s && s.endsWith('(null)') ? {\n    signal: s.slice(0, -6) + base.signal\n  } : value;\n};\n\nfunction fallback(prop, config, axisConfig, style) {\n  let styleProp;\n\n  if (config && hasOwnProperty(config, prop)) {\n    return config[prop];\n  } else if (hasOwnProperty(axisConfig, prop)) {\n    return axisConfig[prop];\n  } else if (prop.startsWith('title')) {\n    switch (prop) {\n      case 'titleColor':\n        styleProp = 'fill';\n        break;\n\n      case 'titleFont':\n      case 'titleFontSize':\n      case 'titleFontWeight':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n\n    return style[GuideTitleStyle][styleProp];\n  } else if (prop.startsWith('label')) {\n    switch (prop) {\n      case 'labelColor':\n        styleProp = 'fill';\n        break;\n\n      case 'labelFont':\n      case 'labelFontSize':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n\n    return style[GuideLabelStyle][styleProp];\n  }\n\n  return null;\n}\n\nfunction keys(objects) {\n  const map = {};\n\n  for (const obj of objects) {\n    if (!obj) continue;\n\n    for (const key in obj) map[key] = 1;\n  }\n\n  return Object.keys(map);\n}\n\nfunction axisConfig(spec, scope) {\n  var config = scope.config,\n      style = config.style,\n      axis = config.axis,\n      band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\n      orient = spec.orient,\n      xy,\n      or,\n      key;\n\n  if (isSignal(orient)) {\n    const xyKeys = keys([config.axisX, config.axisY]),\n          orientKeys = keys([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);\n    xy = {};\n\n    for (key of xyKeys) {\n      xy[key] = ifX(orient, fallback(key, config.axisX, axis, style), fallback(key, config.axisY, axis, style));\n    }\n\n    or = {};\n\n    for (key of orientKeys) {\n      or[key] = ifOrient(orient.signal, fallback(key, config.axisTop, axis, style), fallback(key, config.axisBottom, axis, style), fallback(key, config.axisLeft, axis, style), fallback(key, config.axisRight, axis, style));\n    }\n  } else {\n    xy = orient === Top || orient === Bottom ? config.axisX : config.axisY;\n    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\n  }\n\n  const result = xy || or || band ? extend({}, axis, xy, or, band) : axis;\n  return result;\n}\n\nfunction axisDomain(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient;\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('domainColor'),\n    strokeCap: _('domainCap'),\n    strokeDash: _('domainDash'),\n    strokeDashOffset: _('domainDashOffset'),\n    strokeWidth: _('domainWidth'),\n    strokeOpacity: _('domainOpacity')\n  });\n  const pos0 = position(spec, 0);\n  const pos1 = position(spec, 1);\n  enter.x = update.x = ifX(orient, pos0, zero);\n  enter.x2 = update.x2 = ifX(orient, pos1);\n  enter.y = update.y = ifY(orient, pos0, zero);\n  enter.y2 = update.y2 = ifY(orient, pos1);\n  return guideMark({\n    type: RuleMark,\n    role: AxisDomainRole,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction position(spec, pos) {\n  return {\n    scale: spec.scale,\n    range: pos\n  };\n}\n\nfunction axisGrid(spec, config, userEncode, dataRef, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        vscale = spec.gridScale,\n        sign = getSign(orient, 1, -1),\n        offset = offsetValue(spec.offset, sign);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gridColor'),\n    strokeCap: _('gridCap'),\n    strokeDash: _('gridDash'),\n    strokeDashOffset: _('gridDashOffset'),\n    strokeOpacity: _('gridOpacity'),\n    strokeWidth: _('gridWidth')\n  });\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  const sz = ifX(orient, {\n    signal: 'height'\n  }, {\n    signal: 'width'\n  });\n  const gridStart = vscale ? {\n    scale: vscale,\n    range: 0,\n    mult: sign,\n    offset: offset\n  } : {\n    value: 0,\n    offset: offset\n  };\n  const gridEnd = vscale ? {\n    scale: vscale,\n    range: 1,\n    mult: sign,\n    offset: offset\n  } : extend(sz, {\n    mult: sign,\n    offset: offset\n  });\n  enter.x = update.x = ifX(orient, tickPos, gridStart);\n  enter.y = update.y = ifY(orient, tickPos, gridStart);\n  enter.x2 = update.x2 = ifY(orient, gridEnd);\n  enter.y2 = update.y2 = ifX(orient, gridEnd);\n  exit.x = ifX(orient, tickPos);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisGridRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction offsetValue(offset, sign) {\n  if (sign === 1) ;else if (!isObject(offset)) {\n    offset = isSignal(sign) ? {\n      signal: `(${sign.signal}) * (${offset || 0})`\n    } : sign * (offset || 0);\n  } else {\n    let entry = offset = extend({}, offset);\n\n    while (entry.mult != null) {\n      if (!isObject(entry.mult)) {\n        entry.mult = isSignal(sign) // no offset if sign === 1\n        ? {\n          signal: `(${entry.mult}) * (${sign.signal})`\n        } : entry.mult * sign;\n        return offset;\n      } else {\n        entry = entry.mult = extend({}, entry.mult);\n      }\n    }\n\n    entry.mult = sign;\n  }\n  return offset;\n}\n\nfunction axisTicks(spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('tickColor'),\n    strokeCap: _('tickCap'),\n    strokeDash: _('tickDash'),\n    strokeDashOffset: _('tickDashOffset'),\n    strokeOpacity: _('tickOpacity'),\n    strokeWidth: _('tickWidth')\n  });\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  update.y = enter.y = ifX(orient, zero, tickPos);\n  update.y2 = enter.y2 = ifX(orient, tickSize);\n  exit.x = ifX(orient, tickPos);\n  update.x = enter.x = ifY(orient, zero, tickPos);\n  update.x2 = enter.x2 = ifY(orient, tickSize);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisTickRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction flushExpr(scale, threshold, a, b, c) {\n  return {\n    signal: 'flush(range(\"' + scale + '\"), ' + 'scale(\"' + scale + '\", datum.value), ' + threshold + ',' + a + ',' + b + ',' + c + ')'\n  };\n}\n\nfunction axisLabels(spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        scale = spec.scale,\n        sign = getSign(orient, -1, 1),\n        flush = deref(_('labelFlush')),\n        flushOffset = deref(_('labelFlushOffset')),\n        labelAlign = _('labelAlign'),\n        labelBaseline = _('labelBaseline');\n\n  let flushOn = flush === 0 || !!flush,\n      update;\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  tickSize.offset = encoder(_('labelPadding') || 0);\n  tickSize.offset.mult = sign;\n  const tickPos = {\n    scale: scale,\n    field: Value,\n    band: 0.5,\n    offset: extendOffset(band.offset, _('labelOffset'))\n  };\n  const align = ifX(orient, flushOn ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"') : {\n    value: 'center'\n  }, ifRight(orient, 'left', 'right'));\n  const baseline = ifX(orient, ifTop(orient, 'bottom', 'top'), flushOn ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"') : {\n    value: 'middle'\n  });\n  const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);\n  flushOn = flushOn && flushOffset;\n  const enter = {\n    opacity: zero,\n    x: ifX(orient, tickPos, tickSize),\n    y: ifY(orient, tickPos, tickSize)\n  };\n  const encode = {\n    enter: enter,\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y,\n      align,\n      baseline\n    },\n    exit: {\n      opacity: zero,\n      x: enter.x,\n      y: enter.y\n    }\n  };\n  addEncoders(encode, {\n    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\n    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\n  });\n  addEncoders(encode, {\n    angle: _('labelAngle'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontWeight: _('labelFontWeight'),\n    fontStyle: _('labelFontStyle'),\n    limit: _('labelLimit'),\n    lineHeight: _('labelLineHeight')\n  }, {\n    align: labelAlign,\n    baseline: labelBaseline\n  });\n\n  const bound = _('labelBound');\n\n  let overlap = _('labelOverlap'); // if overlap method or bound defined, request label overlap removal\n\n\n  overlap = overlap || bound ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.index',\n    bound: bound ? {\n      scale,\n      orient,\n      tolerance: bound\n    } : null\n  } : undefined;\n\n  if (update.align !== align) {\n    update.align = patch(update.align, align);\n  }\n\n  if (update.baseline !== baseline) {\n    update.baseline = patch(update.baseline, baseline);\n  }\n\n  return guideMark({\n    type: TextMark,\n    role: AxisLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n\nfunction axisTitle(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      anchor: encoder(_('titleAnchor', null)),\n      align: {\n        signal: alignExpr$1\n      }\n    },\n    update: update = extend({}, enter, {\n      opacity: one,\n      text: encoder(spec.title)\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  const titlePos = {\n    signal: `lerp(range(\"${spec.scale}\"), ${anchorExpr(0, 1, 0.5)})`\n  };\n  update.x = ifX(orient, titlePos);\n  update.y = ifY(orient, titlePos);\n  enter.angle = ifX(orient, zero, mult(sign, 90));\n  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {\n    value: Bottom\n  });\n  update.angle = enter.angle;\n  update.baseline = enter.baseline;\n  addEncoders(encode, {\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    angle: _('titleAngle'),\n    baseline: _('titleBaseline')\n  });\n  autoLayout(_, orient, encode, userEncode);\n  encode.update.align = patch(encode.update.align, enter.align);\n  encode.update.angle = patch(encode.update.angle, enter.angle);\n  encode.update.baseline = patch(encode.update.baseline, enter.baseline);\n  return guideMark({\n    type: TextMark,\n    role: AxisTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction autoLayout(_, orient, encode, userEncode) {\n  const auto = (value, dim) => value != null ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false) : !has(dim, userEncode) ? true : false;\n\n  const autoY = auto(_('titleX'), 'x'),\n        autoX = auto(_('titleY'), 'y');\n  encode.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient, encoder(autoX), encoder(autoY));\n}\n\nfunction parseAxis(spec, scope) {\n  const config = axisConfig(spec, scope),\n        encode = spec.encode || {},\n        axisEncode = encode.axis || {},\n        name = axisEncode.name || undefined,\n        interactive = axisEncode.interactive,\n        style = axisEncode.style,\n        _ = lookup(spec, config),\n        band = tickBand(_); // single-element data source for axis group\n\n\n  const datum = {\n    scale: spec.scale,\n    ticks: !!_('ticks'),\n    labels: !!_('labels'),\n    grid: !!_('grid'),\n    domain: !!_('domain'),\n    title: spec.title != null\n  };\n  const dataRef = ref(scope.add(Collect({}, [datum]))); // data source for axis ticks\n\n  const ticksRef = ref(scope.add(AxisTicks({\n    scale: scope.scaleRef(spec.scale),\n    extra: scope.property(band.extra),\n    count: scope.objectProperty(spec.tickCount),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // generate axis marks\n\n  const children = [];\n  let size; // include axis gridlines if requested\n\n  if (datum.grid) {\n    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\n  } // include axis ticks if requested\n\n\n  if (datum.ticks) {\n    size = _('tickSize');\n    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\n  } // include axis labels if requested\n\n\n  if (datum.labels) {\n    size = datum.ticks ? size : 0;\n    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\n  } // include axis domain path if requested\n\n\n  if (datum.domain) {\n    children.push(axisDomain(spec, config, encode.domain, dataRef));\n  } // include axis title if defined\n\n\n  if (datum.title) {\n    children.push(axisTitle(spec, config, encode.title, dataRef));\n  } // parse axis specification\n\n\n  return parseMark(guideGroup({\n    role: AxisRole,\n    from: dataRef,\n    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\n\nfunction buildAxisEncode(_, spec) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset') || 0,\n    position: value(spec.position, 0),\n    titlePadding: _('titlePadding'),\n    minExtent: _('minExtent'),\n    maxExtent: _('maxExtent'),\n    range: {\n      signal: `abs(span(range(\"${spec.scale}\")))`\n    },\n    translate: _('translate'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\n\nfunction parseScope(spec, scope, preprocessed) {\n  const signals = array(spec.signals),\n        scales = array(spec.scales); // parse signal definitions, if not already preprocessed\n\n  if (!preprocessed) signals.forEach(_ => parseSignal(_, scope)); // parse cartographic projection definitions\n\n  array(spec.projections).forEach(_ => parseProjection(_, scope)); // initialize scale references\n\n  scales.forEach(_ => initScale(_, scope)); // parse data sources\n\n  array(spec.data).forEach(_ => parseData(_, scope)); // parse scale definitions\n\n  scales.forEach(_ => parseScale(_, scope)); // parse signal updates\n\n  (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope)); // parse axis definitions\n\n  array(spec.axes).forEach(_ => parseAxis(_, scope)); // parse mark definitions\n\n  array(spec.marks).forEach(_ => parseMark(_, scope)); // parse legend definitions\n\n  array(spec.legends).forEach(_ => parseLegend(_, scope)); // parse title, if defined\n\n  if (spec.title) parseTitle(spec.title, scope); // parse collected lambda (anonymous) expressions\n\n  scope.parseLambdas();\n  return scope;\n}\n\nconst rootEncode = spec => extendEncode({\n  enter: {\n    x: {\n      value: 0\n    },\n    y: {\n      value: 0\n    }\n  },\n  update: {\n    width: {\n      signal: 'width'\n    },\n    height: {\n      signal: 'height'\n    }\n  }\n}, spec);\n\nfunction parseView(spec, scope) {\n  const config = scope.config; // add scenegraph root\n\n  const root = ref(scope.root = scope.add(operator())); // parse top-level signal definitions\n\n  const signals = collectSignals(spec, config);\n  signals.forEach(_ => parseSignal(_, scope)); // assign description, event, legend, and locale configuration\n\n  scope.description = spec.description || config.description;\n  scope.eventConfig = config.events;\n  scope.legends = scope.objectProperty(config.legend && config.legend.layout);\n  scope.locale = config.locale; // store root group item\n\n  const input = scope.add(Collect()); // encode root group item\n\n  const encode = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {\n    pulse: ref(input)\n  }))); // perform view layout\n\n  const parent = scope.add(ViewLayout({\n    layout: scope.objectProperty(spec.layout),\n    legends: scope.legends,\n    autosize: scope.signalRef('autosize'),\n    mark: root,\n    pulse: ref(encode)\n  }));\n  scope.operators.pop(); // parse remainder of specification\n\n  scope.pushState(ref(encode), ref(parent), null);\n  parseScope(spec, scope, signals);\n  scope.operators.push(parent); // bound / render / sieve root item\n\n  let op = scope.add(Bound({\n    mark: root,\n    pulse: ref(parent)\n  }));\n  op = scope.add(Render({\n    pulse: ref(op)\n  }));\n  op = scope.add(Sieve({\n    pulse: ref(op)\n  })); // track metadata for root item\n\n  scope.addData('root', new DataScope(scope, input, input, op));\n  return scope;\n}\n\nfunction signalObject(name, value) {\n  return value && value.signal ? {\n    name,\n    update: value.signal\n  } : {\n    name,\n    value\n  };\n}\n/**\n * Collect top-level signals, merging values as needed. Signals\n * defined in the config signals arrays are added only if that\n * signal is not explicitly defined in the specification.\n * Built-in signals (autosize, background, padding, width, height)\n * receive special treatment. They are initialized using the\n * top-level spec property, or, if undefined in the spec, using\n * the corresponding top-level config property. If this property\n * is a signal reference object, the signal expression maps to the\n * signal 'update' property. If the spec's top-level signal array\n * contains an entry that matches a built-in signal, that entry\n * will be merged with the built-in specification, potentially\n * overwriting existing 'value' or 'update' properties.\n */\n\n\nfunction collectSignals(spec, config) {\n  const _ = name => value(spec[name], config[name]),\n        signals = [signalObject('background', _('background')), signalObject('autosize', parseAutosize(_('autosize'))), signalObject('padding', parsePadding(_('padding'))), signalObject('width', _('width') || 0), signalObject('height', _('height') || 0)],\n        pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),\n        map = {}; // add spec signal array\n\n\n  array(spec.signals).forEach(s => {\n    if (hasOwnProperty(pre, s.name)) {\n      // merge if built-in signal\n      s = extend(pre[s.name], s);\n    } else {\n      // otherwise add to signal list\n      signals.push(s);\n    }\n\n    map[s.name] = s;\n  }); // add config signal array\n\n  array(config.signals).forEach(s => {\n    if (!hasOwnProperty(map, s.name) && !hasOwnProperty(pre, s.name)) {\n      // add to signal list if not already defined\n      signals.push(s);\n    }\n  });\n  return signals;\n}\n\nfunction Scope(config, options) {\n  this.config = config || {};\n  this.options = options || {};\n  this.bindings = [];\n  this.field = {};\n  this.signals = {};\n  this.lambdas = {};\n  this.scales = {};\n  this.events = {};\n  this.data = {};\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this.eventConfig = null;\n  this.locale = null;\n  this._id = 0;\n  this._subid = 0;\n  this._nextsub = [0];\n  this._parent = [];\n  this._encode = [];\n  this._lookup = [];\n  this._markpath = [];\n}\n\nfunction Subscope(scope) {\n  this.config = scope.config;\n  this.options = scope.options;\n  this.legends = scope.legends;\n  this.field = Object.create(scope.field);\n  this.signals = Object.create(scope.signals);\n  this.lambdas = Object.create(scope.lambdas);\n  this.scales = Object.create(scope.scales);\n  this.events = Object.create(scope.events);\n  this.data = Object.create(scope.data);\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this._id = 0;\n  this._subid = ++scope._nextsub[0];\n  this._nextsub = scope._nextsub;\n  this._parent = scope._parent.slice();\n  this._encode = scope._encode.slice();\n  this._lookup = scope._lookup.slice();\n  this._markpath = scope._markpath;\n}\n\nScope.prototype = Subscope.prototype = {\n  parse(spec) {\n    return parseScope(spec, this);\n  },\n\n  fork() {\n    return new Subscope(this);\n  },\n\n  isSubscope() {\n    return this._subid > 0;\n  },\n\n  toRuntime() {\n    this.finish();\n    return {\n      description: this.description,\n      operators: this.operators,\n      streams: this.streams,\n      updates: this.updates,\n      bindings: this.bindings,\n      eventConfig: this.eventConfig,\n      locale: this.locale\n    };\n  },\n\n  id() {\n    return (this._subid ? this._subid + ':' : 0) + this._id++;\n  },\n\n  add(op) {\n    this.operators.push(op);\n    op.id = this.id(); // if pre-registration references exist, resolve them now\n\n    if (op.refs) {\n      op.refs.forEach(ref => {\n        ref.$ref = op.id;\n      });\n      op.refs = null;\n    }\n\n    return op;\n  },\n\n  proxy(op) {\n    const vref = op instanceof Entry ? ref(op) : op;\n    return this.add(Proxy({\n      value: vref\n    }));\n  },\n\n  addStream(stream) {\n    this.streams.push(stream);\n    stream.id = this.id();\n    return stream;\n  },\n\n  addUpdate(update) {\n    this.updates.push(update);\n    return update;\n  },\n\n  // Apply metadata\n  finish() {\n    let name, ds; // annotate root\n\n    if (this.root) this.root.root = true; // annotate signals\n\n    for (name in this.signals) {\n      this.signals[name].signal = name;\n    } // annotate scales\n\n\n    for (name in this.scales) {\n      this.scales[name].scale = name;\n    } // annotate data sets\n\n\n    function annotate(op, name, type) {\n      let data, list;\n\n      if (op) {\n        data = op.data || (op.data = {});\n        list = data[name] || (data[name] = []);\n        list.push(type);\n      }\n    }\n\n    for (name in this.data) {\n      ds = this.data[name];\n      annotate(ds.input, name, 'input');\n      annotate(ds.output, name, 'output');\n      annotate(ds.values, name, 'values');\n\n      for (const field in ds.index) {\n        annotate(ds.index[field], name, 'index:' + field);\n      }\n    }\n\n    return this;\n  },\n\n  // ----\n  pushState(encode, parent, lookup) {\n    this._encode.push(ref(this.add(Sieve({\n      pulse: encode\n    }))));\n\n    this._parent.push(parent);\n\n    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n\n    this._markpath.push(-1);\n  },\n\n  popState() {\n    this._encode.pop();\n\n    this._parent.pop();\n\n    this._lookup.pop();\n\n    this._markpath.pop();\n  },\n\n  parent() {\n    return peek(this._parent);\n  },\n\n  encode() {\n    return peek(this._encode);\n  },\n\n  lookup() {\n    return peek(this._lookup);\n  },\n\n  markpath() {\n    const p = this._markpath;\n    return ++p[p.length - 1];\n  },\n\n  // ----\n  fieldRef(field, name) {\n    if (isString(field)) return fieldRef$1(field, name);\n\n    if (!field.signal) {\n      error('Unsupported field reference: ' + stringValue(field));\n    }\n\n    const s = field.signal;\n    let f = this.field[s];\n\n    if (!f) {\n      const params = {\n        name: this.signalRef(s)\n      };\n      if (name) params.as = name;\n      this.field[s] = f = ref(this.add(Field(params)));\n    }\n\n    return f;\n  },\n\n  compareRef(cmp) {\n    let signal = false;\n\n    const check = _ => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, this.exprRef(_.expr)) : _;\n\n    const fields = array(cmp.field).map(check),\n          orders = array(cmp.order).map(check);\n    return signal ? ref(this.add(Compare({\n      fields: fields,\n      orders: orders\n    }))) : compareRef(fields, orders);\n  },\n\n  keyRef(fields, flat) {\n    let signal = false;\n\n    const check = _ => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;\n\n    const sig = this.signals;\n    fields = array(fields).map(check);\n    return signal ? ref(this.add(Key({\n      fields: fields,\n      flat: flat\n    }))) : keyRef(fields, flat);\n  },\n\n  sortRef(sort) {\n    if (!sort) return sort; // including id ensures stable sorting\n\n    const a = aggrField(sort.op, sort.field),\n          o = sort.order || Ascending;\n    return o.signal ? ref(this.add(Compare({\n      fields: a,\n      orders: this.signalRef(o.signal)\n    }))) : compareRef(a, o);\n  },\n\n  // ----\n  event(source, type) {\n    const key = source + ':' + type;\n\n    if (!this.events[key]) {\n      const id = this.id();\n      this.streams.push({\n        id: id,\n        source: source,\n        type: type\n      });\n      this.events[key] = id;\n    }\n\n    return this.events[key];\n  },\n\n  // ----\n  hasOwnSignal(name) {\n    return hasOwnProperty(this.signals, name);\n  },\n\n  addSignal(name, value) {\n    if (this.hasOwnSignal(name)) {\n      error('Duplicate signal name: ' + stringValue(name));\n    }\n\n    const op = value instanceof Entry ? value : this.add(operator(value));\n    return this.signals[name] = op;\n  },\n\n  getSignal(name) {\n    if (!this.signals[name]) {\n      error('Unrecognized signal name: ' + stringValue(name));\n    }\n\n    return this.signals[name];\n  },\n\n  signalRef(s) {\n    if (this.signals[s]) {\n      return ref(this.signals[s]);\n    } else if (!hasOwnProperty(this.lambdas, s)) {\n      this.lambdas[s] = this.add(operator(null));\n    }\n\n    return ref(this.lambdas[s]);\n  },\n\n  parseLambdas() {\n    const code = Object.keys(this.lambdas);\n\n    for (let i = 0, n = code.length; i < n; ++i) {\n      const s = code[i],\n            e = parseExpression(s, this),\n            op = this.lambdas[s];\n      op.params = e.$params;\n      op.update = e.$expr;\n    }\n  },\n\n  property(spec) {\n    return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n  },\n\n  objectProperty(spec) {\n    return !spec || !isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));\n  },\n\n  exprRef(code, name) {\n    const params = {\n      expr: parseExpression(code, this)\n    };\n    if (name) params.expr.$name = name;\n    return ref(this.add(Expression(params)));\n  },\n\n  addBinding(name, bind) {\n    if (!this.bindings) {\n      error('Nested signals do not support binding: ' + stringValue(name));\n    }\n\n    this.bindings.push(extend({\n      signal: name\n    }, bind));\n  },\n\n  // ----\n  addScaleProj(name, transform) {\n    if (hasOwnProperty(this.scales, name)) {\n      error('Duplicate scale or projection name: ' + stringValue(name));\n    }\n\n    this.scales[name] = this.add(transform);\n  },\n\n  addScale(name, params) {\n    this.addScaleProj(name, Scale(params));\n  },\n\n  addProjection(name, params) {\n    this.addScaleProj(name, Projection(params));\n  },\n\n  getScale(name) {\n    if (!this.scales[name]) {\n      error('Unrecognized scale name: ' + stringValue(name));\n    }\n\n    return this.scales[name];\n  },\n\n  scaleRef(name) {\n    return ref(this.getScale(name));\n  },\n\n  scaleType(name) {\n    return this.getScale(name).params.type;\n  },\n\n  projectionRef(name) {\n    return this.scaleRef(name);\n  },\n\n  projectionType(name) {\n    return this.scaleType(name);\n  },\n\n  // ----\n  addData(name, dataScope) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n\n    return this.data[name] = dataScope;\n  },\n\n  getData(name) {\n    if (!this.data[name]) {\n      error('Undefined data set name: ' + stringValue(name));\n    }\n\n    return this.data[name];\n  },\n\n  addDataPipeline(name, entries) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n\n    return this.addData(name, DataScope.fromEntries(this, entries));\n  }\n\n};\n\nfunction propertyLambda(spec) {\n  return (isArray(spec) ? arrayLambda : objectLambda)(spec);\n}\n\nfunction arrayLambda(array) {\n  const n = array.length;\n  let code = '[';\n\n  for (let i = 0; i < n; ++i) {\n    const value = array[i];\n    code += (i > 0 ? ',' : '') + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n\n  return code + ']';\n}\n\nfunction objectLambda(obj) {\n  let code = '{',\n      i = 0,\n      key,\n      value;\n\n  for (key in obj) {\n    value = obj[key];\n    code += (++i > 1 ? ',' : '') + stringValue(key) + ':' + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n\n  return code + '}';\n}\n/**\n * Standard configuration defaults for Vega specification parsing.\n * Users can provide their own (sub-)set of these default values\n * by passing in a config object to the top-level parse method.\n */\n\n\nfunction defaults() {\n  const defaultFont = 'sans-serif',\n        defaultSymbolSize = 30,\n        defaultStrokeWidth = 2,\n        defaultColor = '#4c78a8',\n        black = '#000',\n        gray = '#888',\n        lightGray = '#ddd';\n  return {\n    // default visualization description\n    description: 'Vega visualization',\n    // default padding around visualization\n    padding: 0,\n    // default for automatic sizing; options: 'none', 'pad', 'fit'\n    // or provide an object (e.g., {'type': 'pad', 'resize': true})\n    autosize: 'pad',\n    // default view background color\n    // covers the entire view component\n    background: null,\n    // default event handling configuration\n    // preventDefault for view-sourced event types except 'wheel'\n    events: {\n      defaults: {\n        allow: ['wheel']\n      }\n    },\n    // defaults for top-level group marks\n    // accepts mark properties (fill, stroke, etc)\n    // covers the data rectangle within group width/height\n    group: null,\n    // defaults for basic mark types\n    // each subset accepts mark properties (fill, stroke, etc)\n    mark: null,\n    arc: {\n      fill: defaultColor\n    },\n    area: {\n      fill: defaultColor\n    },\n    image: null,\n    line: {\n      stroke: defaultColor,\n      strokeWidth: defaultStrokeWidth\n    },\n    path: {\n      stroke: defaultColor\n    },\n    rect: {\n      fill: defaultColor\n    },\n    rule: {\n      stroke: black\n    },\n    shape: {\n      stroke: defaultColor\n    },\n    symbol: {\n      fill: defaultColor,\n      size: 64\n    },\n    text: {\n      fill: black,\n      font: defaultFont,\n      fontSize: 11\n    },\n    trail: {\n      fill: defaultColor,\n      size: defaultStrokeWidth\n    },\n    // style definitions\n    style: {\n      // axis & legend labels\n      'guide-label': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 10\n      },\n      // axis & legend titles\n      'guide-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 11,\n        fontWeight: 'bold'\n      },\n      // headers, including chart title\n      'group-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 13,\n        fontWeight: 'bold'\n      },\n      // chart subtitle\n      'group-subtitle': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 12\n      },\n      // defaults for styled point marks in Vega-Lite\n      point: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'circle'\n      },\n      circle: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth\n      },\n      square: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'square'\n      },\n      // defaults for styled group marks in Vega-Lite\n      cell: {\n        fill: 'transparent',\n        stroke: lightGray\n      }\n    },\n    // defaults for title\n    title: {\n      orient: 'top',\n      anchor: 'middle',\n      offset: 4,\n      subtitlePadding: 3\n    },\n    // defaults for axes\n    axis: {\n      minExtent: 0,\n      maxExtent: 200,\n      bandPosition: 0.5,\n      domain: true,\n      domainWidth: 1,\n      domainColor: gray,\n      grid: false,\n      gridWidth: 1,\n      gridColor: lightGray,\n      labels: true,\n      labelAngle: 0,\n      labelLimit: 180,\n      labelOffset: 0,\n      labelPadding: 2,\n      ticks: true,\n      tickColor: gray,\n      tickOffset: 0,\n      tickRound: true,\n      tickSize: 5,\n      tickWidth: 1,\n      titlePadding: 4\n    },\n    // correction for centering bias\n    axisBand: {\n      tickOffset: -0.5\n    },\n    // defaults for cartographic projection\n    projection: {\n      type: 'mercator'\n    },\n    // defaults for legends\n    legend: {\n      orient: 'right',\n      padding: 0,\n      gridAlign: 'each',\n      columnPadding: 10,\n      rowPadding: 2,\n      symbolDirection: 'vertical',\n      gradientDirection: 'vertical',\n      gradientLength: 200,\n      gradientThickness: 16,\n      gradientStrokeColor: lightGray,\n      gradientStrokeWidth: 0,\n      gradientLabelOffset: 2,\n      labelAlign: 'left',\n      labelBaseline: 'middle',\n      labelLimit: 160,\n      labelOffset: 4,\n      labelOverlap: true,\n      symbolLimit: 30,\n      symbolType: 'circle',\n      symbolSize: 100,\n      symbolOffset: 0,\n      symbolStrokeWidth: 1.5,\n      symbolBaseFillColor: 'transparent',\n      symbolBaseStrokeColor: gray,\n      titleLimit: 180,\n      titleOrient: 'top',\n      titlePadding: 5,\n      layout: {\n        offset: 18,\n        direction: 'horizontal',\n        left: {\n          direction: 'vertical'\n        },\n        right: {\n          direction: 'vertical'\n        }\n      }\n    },\n    // defaults for scale ranges\n    range: {\n      category: {\n        scheme: 'tableau10'\n      },\n      ordinal: {\n        scheme: 'blues'\n      },\n      heatmap: {\n        scheme: 'yellowgreenblue'\n      },\n      ramp: {\n        scheme: 'blues'\n      },\n      diverging: {\n        scheme: 'blueorange',\n        extent: [1, 0]\n      },\n      symbol: ['circle', 'square', 'triangle-up', 'cross', 'diamond', 'triangle-right', 'triangle-down', 'triangle-left']\n    }\n  };\n}\n\nfunction parse(spec, config, options) {\n  if (!isObject(spec)) {\n    error('Input Vega specification must be an object.');\n  }\n\n  config = mergeConfig(defaults(), config, spec.config);\n  return parseView(spec, new Scope(config, options)).toRuntime();\n}\n\nexport { AxisDomainRole, AxisGridRole, AxisLabelRole, AxisRole, AxisTickRole, AxisTitleRole, DataScope, FrameRole, LegendEntryRole, LegendLabelRole, LegendRole, LegendSymbolRole, LegendTitleRole, MarkRole, Scope, ScopeRole, defaults as config, parse, parseSignal as signal, parseSignalUpdates as signalUpdates, parseStream as stream };","map":{"version":3,"names":["isObject","isArray","extend","hasOwnProperty","array","stringValue","peek","isString","error","splitAccessPath","mergeConfig","parseExpression","parseSelector","isValidScaleType","isDiscrete","isQuantile","isDiscretizing","isContinuous","definition","definition$1","parseAutosize","spec","type","number","_","paddingObject","top","bottom","left","right","parsePadding","signal","encoder","value","addEncode","object","name","set","isEncoder","length","update","addEncoders","enter","extendEncode","encode","extra","skip","has","key","MarkRole","FrameRole","ScopeRole","AxisRole","AxisDomainRole","AxisGridRole","AxisLabelRole","AxisTickRole","AxisTitleRole","LegendRole","LegendBandRole","LegendEntryRole","LegendGradientRole","LegendLabelRole","LegendSymbolRole","LegendTitleRole","TitleRole","TitleTextRole","TitleSubtitleRole","applyDefaults","role","style","config","defaults","props","applyDefault","String","startsWith","group","mark","forEach","scaleRef","scale","field","entry$1","enc","gradient","color","undefined","exponent","property","mult","offset","round","_color","x","y","z","map","join","c","h","l","s","a","b","r","g","args","start","stop","count","pop","unshift","ref","resolveField","datum","level","parent","Math","max","range","band","rule","code","test","parseEncode","scope","params","encoders","$encode","parseBlock","block","marktype","channels","fields","parse$1","expr","$expr","$fields","Object","keys","$output","$params","OUTER","OUTER_INVALID","outerError","prefix","parseSignal","push","signals","prop","op","addSignal","react","bind","addBinding","Entry","id","entry","operator","$ref","refs","fieldRef$1","$field","$name","keyFieldRef","compareRef","orders","$compare","$order","keyRef","flat","$key","$flat","Ascending","Descending","sortKey","sort","order","aggrField","Scope$1","View","isSignal","isExpr$1","hasSignal","specValue","defaultValue","deref","v","Timer","parseStream","stream","method","merge","mergeStream","nestedStream","eventStream","eventSource","source","list","streamParameters","addStream","event","throttle","between","filter","param","concat","markname","markrole","filterMark","debounce","consume","item","OP_VALUE_EXPR","ast","parseUpdate","target","events","sources","isSubscope","mergeSources","$value","signalRef","force","options","addUpdate","streamSource","parseSignalUpdates","getSignal","init","initonly","on","transform","Aggregate","AxisTicks","Bound","Collect","Compare","DataJoin","Encode","Expression","Facet","Field","Key","LegendEntries","Load","Mark","MultiExtent","MultiValues","Overlap","Params","PreFacet","Projection","Proxy","Relay","Render","Scale","Sieve","SortItems","ViewLayout","Values","FIELD_REF_ID","MULTIDOMAIN_SORT_OPS","min","initScale","addScale","domain","parseScale","getScale","parseScaleDomain","parseScaleRange","interpolate","parseScaleInterpolate","nice","parseScaleNice","bins","parseScaleBins","parseLiteral","parseArray","dataLookupError","domainMin","domainMax","explicitDomain","multipleDomain","singularDomain","data","getData","valuesRef","parseSort","domainRef","extentRef","reduce","dom","d","fieldRef","ordinalMultipleDomain","quantileMultipleDomain","numericMultipleDomain","coll","$ingest","input","addDataPipeline","counts","f","countsRef","p","groupby","pulse","ops","as","add","sortRef","multidomain","values","extents","objectProperty","interval","step","gamma","interpolateGamma","scheme","extent","schemeExtent","schemeCount","rangeStep","parseProjection","proj","projection","parseParameter$1","addProjection","Top","Left","Right","Bottom","Center","Vertical","Start","Middle","End","Index","Label","Offset","Perc","Perc2","Value","GuideLabelStyle","GuideTitleStyle","GroupTitleStyle","GroupSubtitleStyle","Symbols","Gradient","Discrete","Size","Shape","Fill","Stroke","StrokeWidth","StrokeDash","Opacity","LegendScales","Skip","interactive","zero","one","GroupMark","RectMark","RuleMark","SymbolMark","TextMark","guideGroup","lookup","dflt","isVertical","direction","symbolDirection","gradientDirection","gradientLength","gradientWidth","gradientThickness","gradientHeight","entryColumns","columns","getEncoding","getStyle","anchorExpr","e","m","alignExpr$1","tickBand","extendOffset","assign","guideMark","extras","legendGradient","userEncode","vertical","thickness","width","height","opacity","fill","exit","stroke","strokeWidth","legendGradientDiscrete","dataRef","u","uu","vv","adjust","from","alignExpr","baselineExpr","legendGradientLabels","overlap","text","fillOpacity","font","fontSize","fontStyle","fontWeight","limit","labelLimit","gradientLabelLimit","align","baseline","labelOffset","gradientLabelOffset","separation","legendSymbolGroups","entries","symbolOffset","valueRef","xSignal","yEncode","index","ncols","nrows","baseFill","baseStroke","symbolBaseFillColor","symbolBaseStrokeColor","shape","size","strokeDash","strokeDashOffset","symbols","clip","labels","noBound","row","column","facet","marks","legendSymbolLayout","center","padding","isL","isR","isLR","isVG","alignFlip","exprAlign","exprAnchor","exprAngle","exprBaseline","legendTitle","orient","_anchor","anchor","angle","title","lineHeight","path","sphere","getRole","indexOf","zindex","aria","description","parseTransform","def","t","toLowerCase","parseParameters","proxy","metadata","n","i","pdef","parseParameter","parseIndexParameter","required","parseSubParameters","projectionRef","parameterValue","isExpr","isField","isCompare","outerExpr","exprRef","outerField","isData","lookupRef","parseSubParameter","k","parseData$1","getDataRef","aggregate","output","DataScope","aggr","fromEntries","fieldKey","addSortField","cache","ds","optype","prototype","agg","tuplesRef","indataRef","parseFacet","subscope","fork","addData","subflow","$subflow","parse","toRuntime","parseSubflow","parseTrigger","remove","insert","toggle","modify","trigger","parseMark","layout","store","layoutRef","boundRef","nested","clean","joinRef","markdef","context","$context","groups","markpath","markRef","mod","tx","md","generates","changes","nomod","encodeRef","legends","bound","operators","pushState","popState","parseOverlap","render","sieve","sep","tol","tolerance","boundTolerance","boundScale","boundOrient","parseLegend","legend","legendEncode","scales","entryLayout","children","legendType","scaleType","vgrad","entryEncode","entryRef","minstep","tickMinStep","formatType","formatSpecifier","format","sizeExpression","buildLegendEncode","scaleCount","titlePadding","cornerRadius","getChannel","getFontSize","angleExpr","parseTitle","buildTitle","titleEncode","subtitle","buildSubTitle","groupEncode","frame","dx","dy","parseData","transforms","analyze","generate","upstream","load","collect","$format","url","$request","modifies","derive","splice","async","isX","getSign","ifLeftTopExpr","ifX","ifXEnc","ifY","ifYEnc","ifTop","ifTopExpr","ifRight","ifRightExpr","$orient","ifEnc","ifExpr","isSimple","toExpr","ifOrient","sign","patch","base","endsWith","slice","fallback","axisConfig","styleProp","objects","obj","axis","axisBand","xy","or","xyKeys","axisX","axisY","orientKeys","axisTop","axisBottom","axisLeft","axisRight","toUpperCase","result","axisDomain","strokeCap","strokeOpacity","pos0","position","pos1","x2","y2","pos","axisGrid","vscale","gridScale","offsetValue","tickPos","sz","gridStart","gridEnd","axisTicks","tickSize","flushExpr","threshold","axisLabels","flush","flushOffset","labelAlign","labelBaseline","flushOn","offsetExpr","axisTitle","titlePos","autoLayout","auto","dim","autoY","autoX","parseAxis","axisEncode","ticks","grid","ticksRef","tickCount","buildAxisEncode","minExtent","maxExtent","translate","parseScope","preprocessed","projections","axes","parseLambdas","rootEncode","parseView","root","collectSignals","eventConfig","locale","autosize","signalObject","pre","Scope","bindings","lambdas","streams","updates","_id","_subid","_nextsub","_parent","_encode","_lookup","_markpath","Subscope","create","finish","vref","annotate","cmp","check","sig","o","hasOwnSignal","propertyLambda","addScaleProj","projectionType","dataScope","arrayLambda","objectLambda","defaultFont","defaultSymbolSize","defaultStrokeWidth","defaultColor","black","gray","lightGray","background","allow","arc","area","image","line","rect","symbol","trail","point","circle","square","cell","subtitlePadding","bandPosition","domainWidth","domainColor","gridWidth","gridColor","labelAngle","labelPadding","tickColor","tickOffset","tickRound","tickWidth","gridAlign","columnPadding","rowPadding","gradientStrokeColor","gradientStrokeWidth","labelOverlap","symbolLimit","symbolType","symbolSize","symbolStrokeWidth","titleLimit","titleOrient","category","ordinal","heatmap","ramp","diverging","signalUpdates"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-parser/build/vega-parser.module.js"],"sourcesContent":["import { isObject, isArray, extend, hasOwnProperty, array, stringValue, peek, isString, error, splitAccessPath, mergeConfig } from 'vega-util';\nimport { parseExpression } from 'vega-functions';\nimport { parseSelector } from 'vega-event-selector';\nimport { isValidScaleType, isDiscrete, isQuantile, isDiscretizing, isContinuous } from 'vega-scale';\nimport { definition as definition$1 } from 'vega-dataflow';\n\nfunction parseAutosize (spec) {\n  return isObject(spec) ? spec : {\n    type: spec || 'pad'\n  };\n}\n\nconst number = _ => +_ || 0;\n\nconst paddingObject = _ => ({\n  top: _,\n  bottom: _,\n  left: _,\n  right: _\n});\n\nfunction parsePadding (spec) {\n  return !isObject(spec) ? paddingObject(number(spec)) : spec.signal ? spec : {\n    top: number(spec.top),\n    bottom: number(spec.bottom),\n    left: number(spec.left),\n    right: number(spec.right)\n  };\n}\n\nconst encoder = _ => isObject(_) && !isArray(_) ? extend({}, _) : {\n  value: _\n};\nfunction addEncode(object, name, value, set) {\n  if (value != null) {\n    const isEncoder = isObject(value) && !isArray(value) || isArray(value) && value.length && isObject(value[0]); // Always assign signal to update, even if the signal is from the enter block\n\n    if (isEncoder) {\n      object.update[name] = value;\n    } else {\n      object[set || 'enter'][name] = {\n        value: value\n      };\n    }\n\n    return 1;\n  } else {\n    return 0;\n  }\n}\nfunction addEncoders(object, enter, update) {\n  for (const name in enter) {\n    addEncode(object, name, enter[name]);\n  }\n\n  for (const name in update) {\n    addEncode(object, name, update[name], 'update');\n  }\n}\nfunction extendEncode(encode, extra, skip) {\n  for (const name in extra) {\n    if (skip && hasOwnProperty(skip, name)) continue;\n    encode[name] = extend(encode[name] || {}, extra[name]);\n  }\n\n  return encode;\n}\nfunction has(key, encode) {\n  return encode && (encode.enter && encode.enter[key] || encode.update && encode.update[key]);\n}\n\nconst MarkRole = 'mark';\nconst FrameRole = 'frame';\nconst ScopeRole = 'scope';\nconst AxisRole = 'axis';\nconst AxisDomainRole = 'axis-domain';\nconst AxisGridRole = 'axis-grid';\nconst AxisLabelRole = 'axis-label';\nconst AxisTickRole = 'axis-tick';\nconst AxisTitleRole = 'axis-title';\nconst LegendRole = 'legend';\nconst LegendBandRole = 'legend-band';\nconst LegendEntryRole = 'legend-entry';\nconst LegendGradientRole = 'legend-gradient';\nconst LegendLabelRole = 'legend-label';\nconst LegendSymbolRole = 'legend-symbol';\nconst LegendTitleRole = 'legend-title';\nconst TitleRole = 'title';\nconst TitleTextRole = 'title-text';\nconst TitleSubtitleRole = 'title-subtitle';\n\nfunction applyDefaults (encode, type, role, style, config) {\n  const defaults = {},\n        enter = {};\n  let update, key, skip, props; // if text mark, apply global lineBreak settings (#2370)\n\n  key = 'lineBreak';\n\n  if (type === 'text' && config[key] != null && !has(key, encode)) {\n    applyDefault(defaults, key, config[key]);\n  } // ignore legend and axis roles\n\n\n  if (role == 'legend' || String(role).startsWith('axis')) {\n    role = null;\n  } // resolve mark config\n\n\n  props = role === FrameRole ? config.group : role === MarkRole ? extend({}, config.mark, config[type]) : null;\n\n  for (key in props) {\n    // do not apply defaults if relevant fields are defined\n    skip = has(key, encode) || (key === 'fill' || key === 'stroke') && (has('fill', encode) || has('stroke', encode));\n    if (!skip) applyDefault(defaults, key, props[key]);\n  } // resolve styles, apply with increasing precedence\n\n\n  array(style).forEach(name => {\n    const props = config.style && config.style[name];\n\n    for (const key in props) {\n      if (!has(key, encode)) {\n        applyDefault(defaults, key, props[key]);\n      }\n    }\n  });\n  encode = extend({}, encode); // defensive copy\n\n  for (key in defaults) {\n    props = defaults[key];\n\n    if (props.signal) {\n      (update = update || {})[key] = props;\n    } else {\n      enter[key] = props;\n    }\n  }\n\n  encode.enter = extend(enter, encode.enter);\n  if (update) encode.update = extend(update, encode.update);\n  return encode;\n}\n\nfunction applyDefault(defaults, key, value) {\n  defaults[key] = value && value.signal ? {\n    signal: value.signal\n  } : {\n    value: value\n  };\n}\n\nconst scaleRef = scale => isString(scale) ? stringValue(scale) : scale.signal ? `(${scale.signal})` : field(scale);\n\nfunction entry$1(enc) {\n  if (enc.gradient != null) {\n    return gradient(enc);\n  }\n\n  let value = enc.signal ? `(${enc.signal})` : enc.color ? color(enc.color) : enc.field != null ? field(enc.field) : enc.value !== undefined ? stringValue(enc.value) : undefined;\n\n  if (enc.scale != null) {\n    value = scale(enc, value);\n  }\n\n  if (value === undefined) {\n    value = null;\n  }\n\n  if (enc.exponent != null) {\n    value = `pow(${value},${property(enc.exponent)})`;\n  }\n\n  if (enc.mult != null) {\n    value += `*${property(enc.mult)}`;\n  }\n\n  if (enc.offset != null) {\n    value += `+${property(enc.offset)}`;\n  }\n\n  if (enc.round) {\n    value = `round(${value})`;\n  }\n\n  return value;\n}\n\nconst _color = (type, x, y, z) => `(${type}(${[x, y, z].map(entry$1).join(',')})+'')`;\n\nfunction color(enc) {\n  return enc.c ? _color('hcl', enc.h, enc.c, enc.l) : enc.h || enc.s ? _color('hsl', enc.h, enc.s, enc.l) : enc.l || enc.a ? _color('lab', enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color('rgb', enc.r, enc.g, enc.b) : null;\n}\n\nfunction gradient(enc) {\n  // map undefined to null; expression lang does not allow undefined\n  const args = [enc.start, enc.stop, enc.count].map(_ => _ == null ? null : stringValue(_)); // trim null inputs from the end\n\n  while (args.length && peek(args) == null) args.pop();\n\n  args.unshift(scaleRef(enc.gradient));\n  return `gradient(${args.join(',')})`;\n}\n\nfunction property(property) {\n  return isObject(property) ? '(' + entry$1(property) + ')' : property;\n}\n\nfunction field(ref) {\n  return resolveField(isObject(ref) ? ref : {\n    datum: ref\n  });\n}\n\nfunction resolveField(ref) {\n  let object, level, field;\n\n  if (ref.signal) {\n    object = 'datum';\n    field = ref.signal;\n  } else if (ref.group || ref.parent) {\n    level = Math.max(1, ref.level || 1);\n    object = 'item';\n\n    while (level-- > 0) {\n      object += '.mark.group';\n    }\n\n    if (ref.parent) {\n      field = ref.parent;\n      object += '.datum';\n    } else {\n      field = ref.group;\n    }\n  } else if (ref.datum) {\n    object = 'datum';\n    field = ref.datum;\n  } else {\n    error('Invalid field reference: ' + stringValue(ref));\n  }\n\n  if (!ref.signal) {\n    field = isString(field) ? splitAccessPath(field).map(stringValue).join('][') : resolveField(field);\n  }\n\n  return object + '[' + field + ']';\n}\n\nfunction scale(enc, value) {\n  const scale = scaleRef(enc.scale);\n\n  if (enc.range != null) {\n    // pull value from scale range\n    value = `lerp(_range(${scale}), ${+enc.range})`;\n  } else {\n    // run value through scale and/or pull scale bandwidth\n    if (value !== undefined) value = `_scale(${scale}, ${value})`;\n\n    if (enc.band) {\n      value = (value ? value + '+' : '') + `_bandwidth(${scale})` + (+enc.band === 1 ? '' : '*' + property(enc.band));\n\n      if (enc.extra) {\n        // include logic to handle extraneous elements\n        value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;\n      }\n    }\n\n    if (value == null) value = '0';\n  }\n\n  return value;\n}\n\nfunction rule (enc) {\n  let code = '';\n  enc.forEach(rule => {\n    const value = entry$1(rule);\n    code += rule.test ? `(${rule.test})?${value}:` : value;\n  }); // if no else clause, terminate with null (#1366)\n\n  if (peek(code) === ':') {\n    code += 'null';\n  }\n\n  return code;\n}\n\nfunction parseEncode (encode, type, role, style, scope, params) {\n  const enc = {};\n  params = params || {};\n  params.encoders = {\n    $encode: enc\n  };\n  encode = applyDefaults(encode, type, role, style, scope.config);\n\n  for (const key in encode) {\n    enc[key] = parseBlock(encode[key], type, params, scope);\n  }\n\n  return params;\n}\n\nfunction parseBlock(block, marktype, params, scope) {\n  const channels = {},\n        fields = {};\n\n  for (const name in block) {\n    if (block[name] != null) {\n      // skip any null entries\n      channels[name] = parse$1(expr(block[name]), scope, params, fields);\n    }\n  }\n\n  return {\n    $expr: {\n      marktype,\n      channels\n    },\n    $fields: Object.keys(fields),\n    $output: Object.keys(block)\n  };\n}\n\nfunction expr(enc) {\n  return isArray(enc) ? rule(enc) : entry$1(enc);\n}\n\nfunction parse$1(code, scope, params, fields) {\n  const expr = parseExpression(code, scope);\n  expr.$fields.forEach(name => fields[name] = 1);\n  extend(params, expr.$params);\n  return expr.$expr;\n}\n\nconst OUTER = 'outer',\n      OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\n\nfunction outerError(prefix, name) {\n  error(prefix + ' for \"outer\" push: ' + stringValue(name));\n}\n\nfunction parseSignal (signal, scope) {\n  const name = signal.name;\n\n  if (signal.push === OUTER) {\n    // signal must already be defined, raise error if not\n    if (!scope.signals[name]) outerError('No prior signal definition', name); // signal push must not use properties reserved for standard definition\n\n    OUTER_INVALID.forEach(prop => {\n      if (signal[prop] !== undefined) outerError('Invalid property ', prop);\n    });\n  } else {\n    // define a new signal in the current scope\n    const op = scope.addSignal(name, signal.value);\n    if (signal.react === false) op.react = false;\n    if (signal.bind) scope.addBinding(name, signal.bind);\n  }\n}\n\nfunction Entry(type, value, params, parent) {\n  this.id = -1;\n  this.type = type;\n  this.value = value;\n  this.params = params;\n  if (parent) this.parent = parent;\n}\nfunction entry(type, value, params, parent) {\n  return new Entry(type, value, params, parent);\n}\nfunction operator(value, params) {\n  return entry('operator', value, params);\n} // -----\n\nfunction ref(op) {\n  const ref = {\n    $ref: op.id\n  }; // if operator not yet registered, cache ref to resolve later\n\n  if (op.id < 0) (op.refs = op.refs || []).push(ref);\n  return ref;\n}\nfunction fieldRef$1(field, name) {\n  return name ? {\n    $field: field,\n    $name: name\n  } : {\n    $field: field\n  };\n}\nconst keyFieldRef = fieldRef$1('key');\nfunction compareRef(fields, orders) {\n  return {\n    $compare: fields,\n    $order: orders\n  };\n}\nfunction keyRef(fields, flat) {\n  const ref = {\n    $key: fields\n  };\n  if (flat) ref.$flat = true;\n  return ref;\n} // -----\n\nconst Ascending = 'ascending';\nconst Descending = 'descending';\nfunction sortKey(sort) {\n  return !isObject(sort) ? '' : (sort.order === Descending ? '-' : '+') + aggrField(sort.op, sort.field);\n}\nfunction aggrField(op, field) {\n  return (op && op.signal ? '$' + op.signal : op || '') + (op && field ? '_' : '') + (field && field.signal ? '$' + field.signal : field || '');\n} // -----\n\nconst Scope$1 = 'scope';\nconst View = 'view';\nfunction isSignal(_) {\n  return _ && _.signal;\n}\nfunction isExpr$1(_) {\n  return _ && _.expr;\n}\nfunction hasSignal(_) {\n  if (isSignal(_)) return true;\n  if (isObject(_)) for (const key in _) {\n    if (hasSignal(_[key])) return true;\n  }\n  return false;\n}\nfunction value(specValue, defaultValue) {\n  return specValue != null ? specValue : defaultValue;\n}\nfunction deref(v) {\n  return v && v.signal || v;\n}\n\nconst Timer = 'timer';\nfunction parseStream(stream, scope) {\n  const method = stream.merge ? mergeStream : stream.stream ? nestedStream : stream.type ? eventStream : error('Invalid stream specification: ' + stringValue(stream));\n  return method(stream, scope);\n}\n\nfunction eventSource(source) {\n  return source === Scope$1 ? View : source || View;\n}\n\nfunction mergeStream(stream, scope) {\n  const list = stream.merge.map(s => parseStream(s, scope)),\n        entry = streamParameters({\n    merge: list\n  }, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction nestedStream(stream, scope) {\n  const id = parseStream(stream.stream, scope),\n        entry = streamParameters({\n    stream: id\n  }, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction eventStream(stream, scope) {\n  let id;\n\n  if (stream.type === Timer) {\n    id = scope.event(Timer, stream.throttle);\n    stream = {\n      between: stream.between,\n      filter: stream.filter\n    };\n  } else {\n    id = scope.event(eventSource(stream.source), stream.type);\n  }\n\n  const entry = streamParameters({\n    stream: id\n  }, stream, scope);\n  return Object.keys(entry).length === 1 ? id : scope.addStream(entry).id;\n}\n\nfunction streamParameters(entry, stream, scope) {\n  let param = stream.between;\n\n  if (param) {\n    if (param.length !== 2) {\n      error('Stream \"between\" parameter must have 2 entries: ' + stringValue(stream));\n    }\n\n    entry.between = [parseStream(param[0], scope), parseStream(param[1], scope)];\n  }\n\n  param = stream.filter ? [].concat(stream.filter) : [];\n\n  if (stream.marktype || stream.markname || stream.markrole) {\n    // add filter for mark type, name and/or role\n    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\n  }\n\n  if (stream.source === Scope$1) {\n    // add filter to limit events from sub-scope only\n    param.push('inScope(event.item)');\n  }\n\n  if (param.length) {\n    entry.filter = parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\n  }\n\n  if ((param = stream.throttle) != null) {\n    entry.throttle = +param;\n  }\n\n  if ((param = stream.debounce) != null) {\n    entry.debounce = +param;\n  }\n\n  if (stream.consume) {\n    entry.consume = true;\n  }\n\n  return entry;\n}\n\nfunction filterMark(type, name, role) {\n  const item = 'event.item';\n  return item + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\'' + type + '\\'' : '') + (role ? '&&' + item + '.mark.role===\\'' + role + '\\'' : '') + (name ? '&&' + item + '.mark.name===\\'' + name + '\\'' : '');\n}\n\nconst OP_VALUE_EXPR = {\n  code: '_.$value',\n  ast: {\n    type: 'Identifier',\n    value: 'value'\n  }\n};\nfunction parseUpdate (spec, scope, target) {\n  const encode = spec.encode,\n        entry = {\n    target: target\n  };\n  let events = spec.events,\n      update = spec.update,\n      sources = [];\n\n  if (!events) {\n    error('Signal update missing events specification.');\n  } // interpret as an event selector string\n\n\n  if (isString(events)) {\n    events = parseSelector(events, scope.isSubscope() ? Scope$1 : View);\n  } // separate event streams from signal updates\n\n\n  events = array(events).filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1); // merge internal operator listeners\n\n  if (sources.length > 1) {\n    sources = [mergeSources(sources)];\n  } // merge event streams, include as source\n\n\n  if (events.length) {\n    sources.push(events.length > 1 ? {\n      merge: events\n    } : events[0]);\n  }\n\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  } // resolve update value\n\n\n  entry.update = isString(update) ? parseExpression(update, scope) : update.expr != null ? parseExpression(update.expr, scope) : update.value != null ? update.value : update.signal != null ? {\n    $expr: OP_VALUE_EXPR,\n    $params: {\n      $value: scope.signalRef(update.signal)\n    }\n  } : error('Invalid signal update specification.');\n\n  if (spec.force) {\n    entry.options = {\n      force: true\n    };\n  }\n\n  sources.forEach(source => scope.addUpdate(extend(streamSource(source, scope), entry)));\n}\n\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)\n  };\n}\n\nfunction mergeSources(sources) {\n  return {\n    signal: '[' + sources.map(s => s.scale ? 'scale(\"' + s.scale + '\")' : s.signal) + ']'\n  };\n}\n\nfunction parseSignalUpdates (signal, scope) {\n  const op = scope.getSignal(signal.name);\n  let expr = signal.update;\n\n  if (signal.init) {\n    if (expr) {\n      error('Signals can not include both init and update expressions.');\n    } else {\n      expr = signal.init;\n      op.initonly = true;\n    }\n  }\n\n  if (expr) {\n    expr = parseExpression(expr, scope);\n    op.update = expr.$expr;\n    op.params = expr.$params;\n  }\n\n  if (signal.on) {\n    signal.on.forEach(_ => parseUpdate(_, scope, op.id));\n  }\n}\n\nconst transform = name => (params, value, parent) => entry(name, value, params || undefined, parent);\n\nconst Aggregate = transform('aggregate');\nconst AxisTicks = transform('axisticks');\nconst Bound = transform('bound');\nconst Collect = transform('collect');\nconst Compare = transform('compare');\nconst DataJoin = transform('datajoin');\nconst Encode = transform('encode');\nconst Expression = transform('expression');\nconst Facet = transform('facet');\nconst Field = transform('field');\nconst Key = transform('key');\nconst LegendEntries = transform('legendentries');\nconst Load = transform('load');\nconst Mark = transform('mark');\nconst MultiExtent = transform('multiextent');\nconst MultiValues = transform('multivalues');\nconst Overlap = transform('overlap');\nconst Params = transform('params');\nconst PreFacet = transform('prefacet');\nconst Projection = transform('projection');\nconst Proxy = transform('proxy');\nconst Relay = transform('relay');\nconst Render = transform('render');\nconst Scale = transform('scale');\nconst Sieve = transform('sieve');\nconst SortItems = transform('sortitems');\nconst ViewLayout = transform('viewlayout');\nconst Values = transform('values');\n\nlet FIELD_REF_ID = 0;\nconst MULTIDOMAIN_SORT_OPS = {\n  min: 'min',\n  max: 'max',\n  count: 'sum'\n};\nfunction initScale(spec, scope) {\n  const type = spec.type || 'linear';\n\n  if (!isValidScaleType(type)) {\n    error('Unrecognized scale type: ' + stringValue(type));\n  }\n\n  scope.addScale(spec.name, {\n    type,\n    domain: undefined\n  });\n}\nfunction parseScale(spec, scope) {\n  const params = scope.getScale(spec.name).params;\n  let key;\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n\n  if (spec.nice != null) {\n    params.nice = parseScaleNice(spec.nice);\n  }\n\n  if (spec.bins != null) {\n    params.bins = parseScaleBins(spec.bins, scope);\n  }\n\n  for (key in spec) {\n    if (hasOwnProperty(params, key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\n\nfunction parseLiteral(v, scope) {\n  return !isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : error('Unsupported object: ' + stringValue(v));\n}\n\nfunction parseArray(v, scope) {\n  return v.signal ? scope.signalRef(v.signal) : v.map(v => parseLiteral(v, scope));\n}\n\nfunction dataLookupError(name) {\n  error('Can not find data set: ' + stringValue(name));\n} // -- SCALE DOMAIN ----\n\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      error('No scale domain defined for domainMin/domainMax to override.');\n    }\n\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal) : (isArray(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);\n}\n\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(v => parseLiteral(v, scope));\n}\n\nfunction singularDomain(domain, spec, scope) {\n  const data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n  return isDiscrete(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : isQuantile(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);\n}\n\nfunction multipleDomain(domain, spec, scope) {\n  const data = domain.data,\n        fields = domain.fields.reduce((dom, d) => {\n    d = isString(d) ? {\n      data: data,\n      field: d\n    } : isArray(d) || d.signal ? fieldRef(d, scope) : d;\n    dom.push(d);\n    return dom;\n  }, []);\n  return (isDiscrete(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);\n}\n\nfunction fieldRef(data, scope) {\n  const name = '_:vega:_' + FIELD_REF_ID++,\n        coll = Collect({});\n\n  if (isArray(data)) {\n    coll.value = {\n      $ingest: data\n    };\n  } else if (data.signal) {\n    const code = 'setdata(' + stringValue(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n\n  scope.addDataPipeline(name, [coll, Sieve({})]);\n  return {\n    data: name,\n    field: 'data'\n  };\n}\n\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  const sort = parseSort(domain.sort, true);\n  let a, v; // get value counts for each domain field\n\n  const counts = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field, sort);\n  }); // aggregate the results from each domain field\n\n  const p = {\n    groupby: keyFieldRef,\n    pulse: counts\n  };\n\n  if (sort) {\n    a = sort.op || 'count';\n    v = sort.field ? aggrField(a, sort.field) : 'count';\n    p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n    p.fields = [scope.fieldRef(v)];\n    p.as = [v];\n  }\n\n  a = scope.add(Aggregate(p)); // collect aggregate output\n\n  const c = scope.add(Collect({\n    pulse: ref(a)\n  })); // extract values for combined domain\n\n  v = scope.add(Values({\n    field: keyFieldRef,\n    sort: scope.sortRef(sort),\n    pulse: ref(c)\n  }));\n  return ref(v);\n}\n\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if (isObject(sort)) sort.field = 'key';else sort = {\n        field: 'key'\n      };\n    } else if (!sort.field && sort.op !== 'count') {\n      error('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n        error('Multiple domain scales can not be sorted using ' + sort.op);\n      }\n    }\n  }\n\n  return sort;\n}\n\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  const values = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  }); // combine value arrays\n\n  return ref(scope.add(MultiValues({\n    values: values\n  })));\n}\n\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  const extents = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  }); // combine extents\n\n  return ref(scope.add(MultiExtent({\n    extents: extents\n  })));\n} // -- SCALE BINS -----\n\n\nfunction parseScaleBins(v, scope) {\n  return v.signal || isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);\n} // -- SCALE NICE -----\n\n\nfunction parseScaleNice(nice) {\n  return isObject(nice) ? {\n    interval: parseLiteral(nice.interval),\n    step: parseLiteral(nice.step)\n  } : parseLiteral(nice);\n} // -- SCALE INTERPOLATION -----\n\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n} // -- SCALE RANGE -----\n\n\nfunction parseScaleRange(spec, scope, params) {\n  const config = scope.config.range;\n  let range = spec.range;\n\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if (isString(range)) {\n    if (config && hasOwnProperty(config, range)) {\n      spec = extend({}, spec, {\n        range: config[range]\n      });\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, {\n        signal: 'width'\n      }];\n    } else if (range === 'height') {\n      range = isDiscrete(spec.type) ? [0, {\n        signal: 'height'\n      }] : [{\n        signal: 'height'\n      }, 0];\n    } else {\n      error('Unrecognized scale range value: ' + stringValue(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = isArray(range.scheme) ? parseArray(range.scheme, scope) : parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isDiscrete(spec.type) && !isArray(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!isArray(range)) {\n    error('Unsupported range type: ' + stringValue(range));\n  }\n\n  return range.map(v => (isArray(v) ? parseArray : parseLiteral)(v, scope));\n}\n\nfunction parseProjection (proj, scope) {\n  const config = scope.config.projection || {},\n        params = {};\n\n  for (const name in proj) {\n    if (name === 'name') continue;\n    params[name] = parseParameter$1(proj[name], name, scope);\n  } // apply projection defaults from config\n\n\n  for (const name in config) {\n    if (params[name] == null) {\n      params[name] = parseParameter$1(config[name], name, scope);\n    }\n  }\n\n  scope.addProjection(proj.name, params);\n}\n\nfunction parseParameter$1(_, name, scope) {\n  return isArray(_) ? _.map(_ => parseParameter$1(_, name, scope)) : !isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === 'fit' ? _ : error('Unsupported parameter object: ' + stringValue(_));\n}\n\nconst Top = 'top';\nconst Left = 'left';\nconst Right = 'right';\nconst Bottom = 'bottom';\nconst Center = 'center';\nconst Vertical = 'vertical';\nconst Start = 'start';\nconst Middle = 'middle';\nconst End = 'end';\nconst Index = 'index';\nconst Label = 'label';\nconst Offset = 'offset';\nconst Perc = 'perc';\nconst Perc2 = 'perc2';\nconst Value = 'value';\nconst GuideLabelStyle = 'guide-label';\nconst GuideTitleStyle = 'guide-title';\nconst GroupTitleStyle = 'group-title';\nconst GroupSubtitleStyle = 'group-subtitle';\nconst Symbols = 'symbol';\nconst Gradient = 'gradient';\nconst Discrete = 'discrete';\nconst Size = 'size';\nconst Shape = 'shape';\nconst Fill = 'fill';\nconst Stroke = 'stroke';\nconst StrokeWidth = 'strokeWidth';\nconst StrokeDash = 'strokeDash';\nconst Opacity = 'opacity'; // Encoding channels supported by legends\n// In priority order of 'canonical' scale\n\nconst LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];\nconst Skip = {\n  name: 1,\n  style: 1,\n  interactive: 1\n};\nconst zero = {\n  value: 0\n};\nconst one = {\n  value: 1\n};\n\nconst GroupMark = 'group';\nconst RectMark = 'rect';\nconst RuleMark = 'rule';\nconst SymbolMark = 'symbol';\nconst TextMark = 'text';\n\nfunction guideGroup (mark) {\n  mark.type = GroupMark;\n  mark.interactive = mark.interactive || false;\n  return mark;\n}\n\nfunction lookup(spec, config) {\n  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));\n\n  _.isVertical = s => Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));\n\n  _.gradientLength = () => value(spec.gradientLength, config.gradientLength || config.gradientWidth);\n\n  _.gradientThickness = () => value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);\n\n  _.entryColumns = () => value(spec.columns, value(config.columns, +_.isVertical(true)));\n\n  return _;\n}\nfunction getEncoding(name, encode) {\n  const v = encode && (encode.update && encode.update[name] || encode.enter && encode.enter[name]);\n  return v && v.signal ? v : v ? v.value : null;\n}\nfunction getStyle(name, scope, style) {\n  const s = scope.config.style[style];\n  return s && s[name];\n}\nfunction anchorExpr(s, e, m) {\n  return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;\n}\nconst alignExpr$1 = anchorExpr(stringValue(Left), stringValue(Right), stringValue(Center));\nfunction tickBand(_) {\n  const v = _('tickBand');\n\n  let offset = _('tickOffset'),\n      band,\n      extra;\n\n  if (!v) {\n    // if no tick band entry, fall back on other properties\n    band = _('bandPosition');\n    extra = _('tickExtra');\n  } else if (v.signal) {\n    // if signal, augment code to interpret values\n    band = {\n      signal: `(${v.signal}) === 'extent' ? 1 : 0.5`\n    };\n    extra = {\n      signal: `(${v.signal}) === 'extent'`\n    };\n\n    if (!isObject(offset)) {\n      offset = {\n        signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`\n      };\n    }\n  } else if (v === 'extent') {\n    // if constant, simply set values\n    band = 1;\n    extra = true;\n    offset = 0;\n  } else {\n    band = 0.5;\n    extra = false;\n  }\n\n  return {\n    extra,\n    band,\n    offset\n  };\n}\nfunction extendOffset(value, offset) {\n  return !offset ? value : !value ? offset : !isObject(value) ? {\n    value,\n    offset\n  } : Object.assign({}, value, {\n    offset: extendOffset(value.offset, offset)\n  });\n}\n\nfunction guideMark (mark, extras) {\n  if (extras) {\n    mark.name = extras.name;\n    mark.style = extras.style || mark.style;\n    mark.interactive = !!extras.interactive;\n    mark.encode = extendEncode(mark.encode, extras, Skip);\n  } else {\n    mark.interactive = false;\n  }\n\n  return mark;\n}\n\nfunction legendGradient (spec, scale, config, userEncode) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let enter, start, stop, width, height;\n\n  if (vertical) {\n    start = [0, 1];\n    stop = [0, 0];\n    width = thickness;\n    height = length;\n  } else {\n    start = [0, 0];\n    stop = [1, 0];\n    width = length;\n    height = thickness;\n  }\n\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      x: zero,\n      y: zero,\n      width: encoder(width),\n      height: encoder(height)\n    },\n    update: extend({}, enter, {\n      opacity: one,\n      fill: {\n        gradient: scale,\n        start: start,\n        stop: stop\n      }\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendGradientRole,\n    encode\n  }, userEncode);\n}\n\nfunction legendGradientDiscrete (spec, scale, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let u,\n      v,\n      uu,\n      vv,\n      adjust = '';\n  vertical ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-') : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\n  const enter = {\n    opacity: zero,\n    fill: {\n      scale: scale,\n      field: Value\n    }\n  };\n  enter[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = zero;\n  enter[uu] = {\n    signal: adjust + 'datum.' + Perc2,\n    mult: length\n  };\n  enter[vv] = encoder(thickness);\n  const encode = {\n    enter: enter,\n    update: extend({}, enter, {\n      opacity: one\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendBandRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nconst alignExpr = `datum.${Perc}<=0?\"${Left}\":datum.${Perc}>=1?\"${Right}\":\"${Center}\"`,\n      baselineExpr = `datum.${Perc}<=0?\"${Bottom}\":datum.${Perc}>=1?\"${Top}\":\"${Middle}\"`;\nfunction legendGradientLabels (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = encoder(_.gradientThickness()),\n        length = _.gradientLength();\n\n  let overlap = _('labelOverlap'),\n      enter,\n      update,\n      u,\n      v,\n      adjust = '';\n\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: value(spec.labelLimit, config.gradientLabelLimit)\n  });\n\n  if (vertical) {\n    enter.align = {\n      value: 'left'\n    };\n    enter.baseline = update.baseline = {\n      signal: baselineExpr\n    };\n    u = 'y';\n    v = 'x';\n    adjust = '1-';\n  } else {\n    enter.align = update.align = {\n      signal: alignExpr\n    };\n    enter.baseline = {\n      value: 'top'\n    };\n    u = 'x';\n    v = 'y';\n  }\n\n  enter[u] = update[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = update[v] = thickness;\n  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\n  overlap = overlap ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.' + Index\n  } : undefined; // type, role, style, key, dataRef, encode, extras\n\n  return guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n\nfunction legendSymbolGroups (spec, config, userEncode, dataRef, columns) {\n  const _ = lookup(spec, config),\n        entries = userEncode.entries,\n        interactive = !!(entries && entries.interactive),\n        name = entries ? entries.name : undefined,\n        height = _('clipHeight'),\n        symbolOffset = _('symbolOffset'),\n        valueRef = {\n    data: 'value'\n  },\n        xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,\n        yEncode = height ? encoder(height) : {\n    field: Size\n  },\n        index = `datum.${Index}`,\n        ncols = `max(1, ${columns})`;\n\n  let encode, enter, update, nrows, sort;\n  yEncode.mult = 0.5; // -- LEGEND SYMBOLS --\n\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        mult: 0.5,\n        offset: symbolOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  let baseFill = null,\n      baseStroke = null;\n\n  if (!spec.fill) {\n    baseFill = config.symbolBaseFillColor;\n    baseStroke = config.symbolBaseStrokeColor;\n  }\n\n  addEncoders(encode, {\n    fill: _('symbolFillColor', baseFill),\n    shape: _('symbolType'),\n    size: _('symbolSize'),\n    stroke: _('symbolStrokeColor', baseStroke),\n    strokeDash: _('symbolDash'),\n    strokeDashOffset: _('symbolDashOffset'),\n    strokeWidth: _('symbolStrokeWidth')\n  }, {\n    // update\n    opacity: _('symbolOpacity')\n  });\n  LegendScales.forEach(scale => {\n    if (spec[scale]) {\n      update[scale] = enter[scale] = {\n        scale: spec[scale],\n        field: Value\n      };\n    }\n  });\n  const symbols = guideMark({\n    type: SymbolMark,\n    role: LegendSymbolRole,\n    key: Value,\n    from: valueRef,\n    clip: height ? true : undefined,\n    encode\n  }, userEncode.symbols); // -- LEGEND LABELS --\n\n  const labelOffset = encoder(symbolOffset);\n  labelOffset.offset = _('labelOffset');\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        offset: labelOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    align: _('labelAlign'),\n    baseline: _('labelBaseline'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: _('labelLimit')\n  });\n  const labels = guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: valueRef,\n    encode\n  }, userEncode.labels); // -- LEGEND ENTRY GROUPS --\n\n  encode = {\n    enter: {\n      noBound: {\n        value: !height\n      },\n      // ignore width/height in bounds calc\n      width: zero,\n      height: height ? encoder(height) : zero,\n      opacity: zero\n    },\n    exit: {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      row: {\n        signal: null\n      },\n      column: {\n        signal: null\n      }\n    }\n  }; // annotate and sort groups to ensure correct ordering\n\n  if (_.isVertical(true)) {\n    nrows = `ceil(item.mark.items.length / ${ncols})`;\n    update.row.signal = `${index}%${nrows}`;\n    update.column.signal = `floor(${index} / ${nrows})`;\n    sort = {\n      field: ['row', index]\n    };\n  } else {\n    update.row.signal = `floor(${index} / ${ncols})`;\n    update.column.signal = `${index} % ${ncols}`;\n    sort = {\n      field: index\n    };\n  } // handle zero column case (implies infinite columns)\n\n\n  update.column.signal = `(${columns})?${update.column.signal}:${index}`; // facet legend entries into sub-groups\n\n  dataRef = {\n    facet: {\n      data: dataRef,\n      name: 'value',\n      groupby: Index\n    }\n  };\n  return guideGroup({\n    role: ScopeRole,\n    from: dataRef,\n    encode: extendEncode(encode, entries, Skip),\n    marks: [symbols, labels],\n    name,\n    interactive,\n    sort\n  });\n}\nfunction legendSymbolLayout(spec, config) {\n  const _ = lookup(spec, config); // layout parameters for legend entries\n\n\n  return {\n    align: _('gridAlign'),\n    columns: _.entryColumns(),\n    center: {\n      row: true,\n      column: false\n    },\n    padding: {\n      row: _('rowPadding'),\n      column: _('columnPadding')\n    }\n  };\n}\n\nconst isL = 'item.orient === \"left\"',\n      isR = 'item.orient === \"right\"',\n      isLR = `(${isL} || ${isR})`,\n      isVG = `datum.vgrad && ${isLR}`,\n      baseline = anchorExpr('\"top\"', '\"bottom\"', '\"middle\"'),\n      alignFlip = anchorExpr('\"right\"', '\"left\"', '\"center\"'),\n      exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? \"left\" : ${alignExpr$1}`,\n      exprAnchor = `item._anchor || (${isLR} ? \"middle\" : \"start\")`,\n      exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,\n      exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? \"bottom\" : \"top\") : ${baseline}) : \"top\"`;\nfunction legendTitle (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config);\n\n  const encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: one,\n      x: {\n        field: {\n          group: 'padding'\n        }\n      },\n      y: {\n        field: {\n          group: 'padding'\n        }\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    orient: _('titleOrient'),\n    _anchor: _('titleAnchor'),\n    anchor: {\n      signal: exprAnchor\n    },\n    angle: {\n      signal: exprAngle\n    },\n    align: {\n      signal: exprAlign\n    },\n    baseline: {\n      signal: exprBaseline\n    },\n    text: spec.title,\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    baseline: _('titleBaseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: LegendTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction clip (clip, scope) {\n  let expr;\n\n  if (isObject(clip)) {\n    if (clip.signal) {\n      expr = clip.signal;\n    } else if (clip.path) {\n      expr = 'pathShape(' + param(clip.path) + ')';\n    } else if (clip.sphere) {\n      expr = 'geoShape(' + param(clip.sphere) + ', {type: \"Sphere\"})';\n    }\n  }\n\n  return expr ? scope.signalRef(expr) : !!clip;\n}\n\nfunction param(value) {\n  return isObject(value) && value.signal ? value.signal : stringValue(value);\n}\n\nfunction getRole (spec) {\n  const role = spec.role || '';\n  return !role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title') ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;\n}\n\nfunction definition (spec) {\n  return {\n    marktype: spec.type,\n    name: spec.name || undefined,\n    role: spec.role || getRole(spec),\n    zindex: +spec.zindex || undefined,\n    aria: spec.aria,\n    description: spec.description\n  };\n}\n\nfunction interactive (spec, scope) {\n  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;\n}\n\n/**\n * Parse a data transform specification.\n */\n\nfunction parseTransform (spec, scope) {\n  const def = definition$1(spec.type);\n  if (!def) error('Unrecognized transform type: ' + stringValue(spec.type));\n  const t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n  return t;\n}\n/**\n * Parse all parameters of a data transform.\n */\n\nfunction parseParameters(def, spec, scope) {\n  const params = {},\n        n = def.params.length;\n\n  for (let i = 0; i < n; ++i) {\n    const pdef = def.params[i];\n    params[pdef.name] = parseParameter(pdef, spec, scope);\n  }\n\n  return params;\n}\n/**\n * Parse a data transform parameter.\n */\n\n\nfunction parseParameter(def, spec, scope) {\n  const type = def.type,\n        value = spec[def.name];\n\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      error('Missing required ' + stringValue(spec.type) + ' parameter: ' + stringValue(def.name));\n    }\n\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n\n  return def.array && !isSignal(value) ? value.map(v => parameterValue(def, v, scope)) : parameterValue(def, value, scope);\n}\n/**\n * Parse a single parameter value.\n */\n\n\nfunction parameterValue(def, value, scope) {\n  const type = def.type;\n\n  if (isSignal(value)) {\n    return isExpr(type) ? error('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);\n  } else {\n    const expr = def.expr || isField(type);\n    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as) : expr && outerField(value) ? fieldRef$1(value.field, value.as) : isExpr(type) ? parseExpression(value, scope) : isData(type) ? ref(scope.getData(value).values) : isField(type) ? fieldRef$1(value) : isCompare(type) ? scope.compareRef(value) : value;\n  }\n}\n/**\n * Parse parameter for accessing an index of another data set.\n */\n\n\nfunction parseIndexParameter(def, spec, scope) {\n  if (!isString(spec.from)) {\n    error('Lookup \"from\" parameter must be a string literal.');\n  }\n\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\n\n\nfunction parseSubParameters(def, spec, scope) {\n  const value = spec[def.name];\n\n  if (def.array) {\n    if (!isArray(value)) {\n      // signals not allowed!\n      error('Expected an array of sub-parameters. Instead: ' + stringValue(value));\n    }\n\n    return value.map(v => parseSubParameter(def, v, scope));\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n/**\n * Parse a sub-parameter object.\n */\n\n\nfunction parseSubParameter(def, value, scope) {\n  const n = def.params.length;\n  let pdef; // loop over defs to find matching key\n\n  for (let i = 0; i < n; ++i) {\n    pdef = def.params[i];\n\n    for (const k in pdef.key) {\n      if (pdef.key[k] !== value[k]) {\n        pdef = null;\n        break;\n      }\n    }\n\n    if (pdef) break;\n  } // raise error if matching key not found\n\n\n  if (!pdef) error('Unsupported parameter: ' + stringValue(value)); // parse params, create Params transform, return ref\n\n  const params = extend(parseParameters(pdef, value, scope), pdef.key);\n  return ref(scope.add(Params(params)));\n} // -- Utilities -----\n\n\nconst outerExpr = _ => _ && _.expr;\nconst outerField = _ => _ && _.field;\nconst isData = _ => _ === 'data';\nconst isExpr = _ => _ === 'expr';\nconst isField = _ => _ === 'field';\nconst isCompare = _ => _ === 'compare';\n\nfunction parseData$1 (from, group, scope) {\n  let facet, key, op, dataRef, parent; // if no source data, generate singleton datum\n\n  if (!from) {\n    dataRef = ref(scope.add(Collect(null, [{}])));\n  } // if faceted, process facet specification\n  else if (facet = from.facet) {\n    if (!group) error('Only group marks can be faceted.'); // use pre-faceted source data, if available\n\n    if (facet.field != null) {\n      dataRef = parent = getDataRef(facet, scope);\n    } else {\n      // generate facet aggregates if no direct data specification\n      if (!from.data) {\n        op = parseTransform(extend({\n          type: 'aggregate',\n          groupby: array(facet.groupby)\n        }, facet.aggregate), scope);\n        op.params.key = scope.keyRef(facet.groupby);\n        op.params.pulse = getDataRef(facet, scope);\n        dataRef = parent = ref(scope.add(op));\n      } else {\n        parent = ref(scope.getData(from.data).aggregate);\n      }\n\n      key = scope.keyRef(facet.groupby, true);\n    }\n  } // if not yet defined, get source data reference\n\n\n  if (!dataRef) {\n    dataRef = getDataRef(from, scope);\n  }\n\n  return {\n    key: key,\n    pulse: dataRef,\n    parent: parent\n  };\n}\nfunction getDataRef(from, scope) {\n  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);\n}\n\nfunction DataScope(scope, input, output, values, aggr) {\n  this.scope = scope; // parent scope object\n\n  this.input = input; // first operator in pipeline (tuple input)\n\n  this.output = output; // last operator in pipeline (tuple output)\n\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n  // last aggregate in transform pipeline\n\n  this.aggregate = aggr; // lookup table of field indices\n\n  this.index = {};\n}\n\nDataScope.fromEntries = function (scope, entries) {\n  const n = entries.length,\n        values = entries[n - 1],\n        output = entries[n - 2];\n  let input = entries[0],\n      aggr = null,\n      i = 1;\n\n  if (input && input.type === 'load') {\n    input = entries[1];\n  } // add operator entries to this scope, wire up pulse chain\n\n\n  scope.add(entries[0]);\n\n  for (; i < n; ++i) {\n    entries[i].params.pulse = ref(entries[i - 1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n\n  return new DataScope(scope, input, output, values, aggr);\n};\n\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\n\nfunction addSortField(scope, p, sort) {\n  const as = aggrField(sort.op, sort.field);\n  let s;\n\n  if (p.ops) {\n    for (let i = 0, n = p.as.length; i < n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n\n  if (sort.op) {\n    p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\n\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  const cache = ds[name] || (ds[name] = {}),\n        sort = sortKey(counts);\n  let k = fieldKey(field),\n      v,\n      op;\n\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n\n  if (!v) {\n    const params = counts ? {\n      field: keyFieldRef,\n      pulse: ds.countsRef(scope, field, counts)\n    } : {\n      field: scope.fieldRef(field),\n      pulse: ref(ds.output)\n    };\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n\n  return v;\n}\n\nDataScope.prototype = {\n  countsRef(scope, field, sort) {\n    const ds = this,\n          cache = ds.counts || (ds.counts = {}),\n          k = fieldKey(field);\n    let v, a, p;\n\n    if (k != null) {\n      scope = ds.scope;\n      v = cache[k];\n    }\n\n    if (!v) {\n      p = {\n        groupby: scope.fieldRef(field, 'key'),\n        pulse: ref(ds.output)\n      };\n      if (sort && sort.field) addSortField(scope, p, sort);\n      a = scope.add(Aggregate(p));\n      v = scope.add(Collect({\n        pulse: ref(a)\n      }));\n      v = {\n        agg: a,\n        ref: ref(v)\n      };\n      if (k != null) cache[k] = v;\n    } else if (sort && sort.field) {\n      addSortField(scope, v.agg.params, sort);\n    }\n\n    return v.ref;\n  },\n\n  tuplesRef() {\n    return ref(this.values);\n  },\n\n  extentRef(scope, field) {\n    return cache(scope, this, 'extent', 'extent', field, false);\n  },\n\n  domainRef(scope, field) {\n    return cache(scope, this, 'domain', 'values', field, false);\n  },\n\n  valuesRef(scope, field, sort) {\n    return cache(scope, this, 'vals', 'values', field, sort || true);\n  },\n\n  lookupRef(scope, field) {\n    return cache(scope, this, 'lookup', 'tupleindex', field, false);\n  },\n\n  indataRef(scope, field) {\n    return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n  }\n\n};\n\nfunction parseFacet (spec, scope, group) {\n  const facet = spec.from.facet,\n        name = facet.name,\n        data = getDataRef(facet, scope);\n  let op;\n\n  if (!facet.name) {\n    error('Facet must have a name: ' + stringValue(facet));\n  }\n\n  if (!facet.data) {\n    error('Facet must reference a data set: ' + stringValue(facet));\n  }\n\n  if (facet.field) {\n    op = scope.add(PreFacet({\n      field: scope.fieldRef(facet.field),\n      pulse: data\n    }));\n  } else if (facet.groupby) {\n    op = scope.add(Facet({\n      key: scope.keyRef(facet.groupby),\n      group: ref(scope.proxy(group.parent)),\n      pulse: data\n    }));\n  } else {\n    error('Facet must specify groupby or field: ' + stringValue(facet));\n  } // initialize facet subscope\n\n\n  const subscope = scope.fork(),\n        source = subscope.add(Collect()),\n        values = subscope.add(Sieve({\n    pulse: ref(source)\n  }));\n  subscope.addData(name, new DataScope(subscope, source, source, values));\n  subscope.addSignal('parent', null); // parse faceted subflow\n\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n\nfunction parseSubflow (spec, scope, input) {\n  const op = scope.add(PreFacet({\n    pulse: input.pulse\n  })),\n        subscope = scope.fork();\n  subscope.add(Sieve());\n  subscope.addSignal('parent', null); // parse group mark subflow\n\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n\nfunction parseTrigger (spec, scope, name) {\n  const remove = spec.remove,\n        insert = spec.insert,\n        toggle = spec.toggle,\n        modify = spec.modify,\n        values = spec.values,\n        op = scope.add(operator());\n  const update = 'if(' + spec.trigger + ',modify(\"' + name + '\",' + [insert, remove, toggle, modify, values].map(_ => _ == null ? 'null' : _).join(',') + '),0)';\n  const expr = parseExpression(update, scope);\n  op.update = expr.$expr;\n  op.params = expr.$params;\n}\n\nfunction parseMark (spec, scope) {\n  const role = getRole(spec),\n        group = spec.type === GroupMark,\n        facet = spec.from && spec.from.facet,\n        overlap = spec.overlap;\n  let layout = spec.layout || role === ScopeRole || role === FrameRole,\n      ops,\n      op,\n      store,\n      enc,\n      name,\n      layoutRef,\n      boundRef;\n  const nested = role === MarkRole || layout || facet; // resolve input data\n\n  const input = parseData$1(spec.from, group, scope); // data join to map tuples to visual items\n\n  op = scope.add(DataJoin({\n    key: input.key || (spec.key ? fieldRef$1(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  const joinRef = ref(op); // collect visual items\n\n  op = store = scope.add(Collect({\n    pulse: joinRef\n  })); // connect visual items to scenegraph\n\n  op = scope.add(Mark({\n    markdef: definition(spec),\n    interactive: interactive(spec.interactive, scope),\n    clip: clip(spec.clip, scope),\n    context: {\n      $context: true\n    },\n    groups: scope.lookup(),\n    parent: scope.signals.parent ? scope.signalRef('parent') : null,\n    index: scope.markpath(),\n    pulse: ref(op)\n  }));\n  const markRef = ref(op); // add visual encoders\n\n  op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {\n    mod: false,\n    pulse: markRef\n  }))); // monitor parent marks to propagate changes\n\n  op.params.parent = scope.encode(); // add post-encoding transforms, if defined\n\n  if (spec.transform) {\n    spec.transform.forEach(_ => {\n      const tx = parseTransform(_, scope),\n            md = tx.metadata;\n\n      if (md.generates || md.changes) {\n        error('Mark transforms should not generate new data.');\n      }\n\n      if (!md.nomod) enc.params.mod = true; // update encode mod handling\n\n      tx.params.pulse = ref(op);\n      scope.add(op = tx);\n    });\n  } // if item sort specified, perform post-encoding\n\n\n  if (spec.sort) {\n    op = scope.add(SortItems({\n      sort: scope.compareRef(spec.sort),\n      pulse: ref(op)\n    }));\n  }\n\n  const encodeRef = ref(op); // add view layout operator if needed\n\n  if (facet || layout) {\n    layout = scope.add(ViewLayout({\n      layout: scope.objectProperty(spec.layout),\n      legends: scope.legends,\n      mark: markRef,\n      pulse: encodeRef\n    }));\n    layoutRef = ref(layout);\n  } // compute bounding boxes\n\n\n  const bound = scope.add(Bound({\n    mark: markRef,\n    pulse: layoutRef || encodeRef\n  }));\n  boundRef = ref(bound); // if group mark, recurse to parse nested content\n\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) {\n      ops = scope.operators;\n      ops.pop();\n      if (layout) ops.pop();\n    }\n\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? parseFacet(spec, scope, input) // explicit facet\n    : nested ? parseSubflow(spec, scope, input) // standard mark group\n    : scope.parse(spec); // guide group, we can avoid nested scopes\n\n    scope.popState();\n\n    if (nested) {\n      if (layout) ops.push(layout);\n      ops.push(bound);\n    }\n  } // if requested, add overlap removal transform\n\n\n  if (overlap) {\n    boundRef = parseOverlap(overlap, boundRef, scope);\n  } // render / sieve items\n\n\n  const render = scope.add(Render({\n    pulse: boundRef\n  })),\n        sieve = scope.add(Sieve({\n    pulse: ref(render)\n  }, undefined, scope.parent())); // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new DataScope(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(on => {\n      if (on.insert || on.remove || on.toggle) {\n        error('Marks only support modify triggers.');\n      }\n\n      parseTrigger(on, scope, name);\n    });\n  }\n}\n\nfunction parseOverlap(overlap, source, scope) {\n  const method = overlap.method,\n        bound = overlap.bound,\n        sep = overlap.separation;\n  const params = {\n    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n    method: isSignal(method) ? scope.signalRef(method.signal) : method,\n    pulse: source\n  };\n\n  if (overlap.order) {\n    params.sort = scope.compareRef({\n      field: overlap.order\n    });\n  }\n\n  if (bound) {\n    const tol = bound.tolerance;\n    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n    params.boundScale = scope.scaleRef(bound.scale);\n    params.boundOrient = bound.orient;\n  }\n\n  return ref(scope.add(Overlap(params)));\n}\n\nfunction parseLegend (spec, scope) {\n  const config = scope.config.legend,\n        encode = spec.encode || {},\n        _ = lookup(spec, config),\n        legendEncode = encode.legend || {},\n        name = legendEncode.name || undefined,\n        interactive = legendEncode.interactive,\n        style = legendEncode.style,\n        scales = {};\n\n  let scale = 0,\n      entryLayout,\n      params,\n      children; // resolve scales and 'canonical' scale name\n\n  LegendScales.forEach(s => spec[s] ? (scales[s] = spec[s], scale = scale || spec[s]) : 0);\n  if (!scale) error('Missing valid scale for legend.'); // resolve legend type (symbol, gradient, or discrete gradient)\n\n  const type = legendType(spec, scope.scaleType(scale)); // single-element data source for legend group\n\n  const datum = {\n    title: spec.title != null,\n    scales: scales,\n    type: type,\n    vgrad: type !== 'symbol' && _.isVertical()\n  };\n  const dataRef = ref(scope.add(Collect(null, [datum]))); // encoding properties for legend entry sub-group\n\n  const entryEncode = {\n    enter: {\n      x: {\n        value: 0\n      },\n      y: {\n        value: 0\n      }\n    }\n  }; // data source for legend values\n\n  const entryRef = ref(scope.add(LegendEntries(params = {\n    type: type,\n    scale: scope.scaleRef(scale),\n    count: scope.objectProperty(_('tickCount')),\n    limit: scope.property(_('symbolLimit')),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // continuous gradient legend\n\n  if (type === Gradient) {\n    children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)]; // adjust default tick count based on the gradient length\n\n    params.count = params.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);\n  } // discrete gradient legend\n  else if (type === Discrete) {\n    children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];\n  } // symbol legend\n  else {\n    // determine legend symbol group layout\n    entryLayout = legendSymbolLayout(spec, config);\n    children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))]; // pass symbol size information to legend entry generator\n\n    params.size = sizeExpression(spec, scope, children[0].marks);\n  } // generate legend marks\n\n\n  children = [guideGroup({\n    role: LegendEntryRole,\n    from: dataRef,\n    encode: entryEncode,\n    marks: children,\n    layout: entryLayout,\n    interactive\n  })]; // include legend title if defined\n\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  } // parse legend specification\n\n\n  return parseMark(guideGroup({\n    role: LegendRole,\n    from: dataRef,\n    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\n\nfunction legendType(spec, scaleType) {\n  let type = spec.type || Symbols;\n\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient : isDiscretizing(scaleType) ? Discrete : Symbols;\n  }\n\n  return type !== Gradient ? type : isDiscretizing(scaleType) ? Discrete : Gradient;\n}\n\nfunction scaleCount(spec) {\n  return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);\n}\n\nfunction buildLegendEncode(_, spec, config) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset'),\n    padding: _('padding'),\n    titlePadding: _('titlePadding'),\n    cornerRadius: _('cornerRadius'),\n    fill: _('fillColor'),\n    stroke: _('strokeColor'),\n    strokeWidth: config.strokeWidth,\n    strokeDash: config.strokeDash,\n    x: _('legendX'),\n    y: _('legendY'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\n\nfunction sizeExpression(spec, scope, marks) {\n  const size = deref(getChannel('size', spec, marks)),\n        strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n        fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n  return parseExpression(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`, scope);\n}\n\nfunction getChannel(name, spec, marks) {\n  return spec[name] ? `scale(\"${spec[name]}\",datum)` : getEncoding(name, marks[0].encode);\n}\n\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}\n\nconst angleExpr = `item.orient===\"${Left}\"?-90:item.orient===\"${Right}\"?90:0`;\nfunction parseTitle (spec, scope) {\n  spec = isString(spec) ? {\n    text: spec\n  } : spec;\n\n  const _ = lookup(spec, scope.config.title),\n        encode = spec.encode || {},\n        userEncode = encode.group || {},\n        name = userEncode.name || undefined,\n        interactive = userEncode.interactive,\n        style = userEncode.style,\n        children = []; // single-element data source for group title\n\n\n  const datum = {},\n        dataRef = ref(scope.add(Collect(null, [datum]))); // include title text\n\n  children.push(buildTitle(spec, _, titleEncode(spec), dataRef)); // include subtitle text\n\n  if (spec.subtitle) {\n    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\n  } // parse title specification\n\n\n  return parseMark(guideGroup({\n    role: TitleRole,\n    from: dataRef,\n    encode: groupEncode(_, userEncode),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n} // provide backwards-compatibility for title custom encode;\n// the top-level encode block has been *deprecated*.\n\nfunction titleEncode(spec) {\n  const encode = spec.encode;\n  return encode && encode.title || extend({\n    name: spec.name,\n    interactive: spec.interactive,\n    style: spec.style\n  }, encode);\n}\n\nfunction groupEncode(_, userEncode) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    anchor: _('anchor'),\n    align: {\n      signal: alignExpr$1\n    },\n    angle: {\n      signal: angleExpr\n    },\n    limit: _('limit'),\n    frame: _('frame'),\n    offset: _('offset') || 0,\n    padding: _('subtitlePadding')\n  });\n  return extendEncode(encode, userEncode, Skip);\n}\n\nfunction buildTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n    value: 0\n  },\n        text = spec.text,\n        encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: {\n        value: 1\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('color'),\n    font: _('font'),\n    fontSize: _('fontSize'),\n    fontStyle: _('fontStyle'),\n    fontWeight: _('fontWeight'),\n    lineHeight: _('lineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleTextRole,\n    style: GroupTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction buildSubTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n    value: 0\n  },\n        text = spec.subtitle,\n        encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: {\n        value: 1\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('subtitleColor'),\n    font: _('subtitleFont'),\n    fontSize: _('subtitleFontSize'),\n    fontStyle: _('subtitleFontStyle'),\n    fontWeight: _('subtitleFontWeight'),\n    lineHeight: _('subtitleLineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleSubtitleRole,\n    style: GroupSubtitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction parseData(data, scope) {\n  const transforms = [];\n\n  if (data.transform) {\n    data.transform.forEach(tx => {\n      transforms.push(parseTransform(tx, scope));\n    });\n  }\n\n  if (data.on) {\n    data.on.forEach(on => {\n      parseTrigger(on, scope, data.name);\n    });\n  }\n\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n/**\n * Analyze a data pipeline, add needed operators.\n */\n\nfunction analyze(data, scope, ops) {\n  const output = [];\n  let source = null,\n      modify = false,\n      generate = false,\n      upstream,\n      i,\n      n,\n      t,\n      m;\n\n  if (data.values) {\n    // hard-wired input data set\n    if (isSignal(data.values) || hasSignal(data.format)) {\n      // if either values is signal or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, ingest upon dataflow init\n      output.push(source = collect({\n        $ingest: data.values,\n        $format: data.format\n      }));\n    }\n  } else if (data.url) {\n    // load data from external source\n    if (hasSignal(data.url) || hasSignal(data.format)) {\n      // if either url or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, request load upon dataflow init\n      output.push(source = collect({\n        $request: data.url,\n        $format: data.format\n      }));\n    }\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = array(data.source).map(d => ref(scope.getData(d).output));\n    output.push(null); // populate later\n  } // scan data transforms, add collectors as needed\n\n\n  for (i = 0, n = ops.length; i < n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n\n    output.push(t);\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n    if (m.source) source = t;else if (m.changes) source = null;\n  }\n\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = Relay({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n\n  if (!source) output.push(collect());\n  output.push(Sieve({}));\n  return output;\n}\n\nfunction collect(values) {\n  const s = Collect({}, values);\n  s.metadata = {\n    source: true\n  };\n  return s;\n}\n\nfunction load(scope, data) {\n  return Load({\n    url: data.url ? scope.property(data.url) : undefined,\n    async: data.async ? scope.property(data.async) : undefined,\n    values: data.values ? scope.property(data.values) : undefined,\n    format: scope.objectProperty(data.format)\n  });\n}\n\nconst isX = orient => orient === Bottom || orient === Top; // get sign coefficient based on axis orient\n\n\nconst getSign = (orient, a, b) => isSignal(orient) ? ifLeftTopExpr(orient.signal, a, b) : orient === Left || orient === Top ? a : b; // condition on axis x-direction\n\nconst ifX = (orient, a, b) => isSignal(orient) ? ifXEnc(orient.signal, a, b) : isX(orient) ? a : b; // condition on axis y-direction\n\nconst ifY = (orient, a, b) => isSignal(orient) ? ifYEnc(orient.signal, a, b) : isX(orient) ? b : a;\nconst ifTop = (orient, a, b) => isSignal(orient) ? ifTopExpr(orient.signal, a, b) : orient === Top ? {\n  value: a\n} : {\n  value: b\n};\nconst ifRight = (orient, a, b) => isSignal(orient) ? ifRightExpr(orient.signal, a, b) : orient === Right ? {\n  value: a\n} : {\n  value: b\n};\n\nconst ifXEnc = ($orient, a, b) => ifEnc(`${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b);\n\nconst ifYEnc = ($orient, a, b) => ifEnc(`${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b);\n\nconst ifLeftTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b);\n\nconst ifTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Top}'`, a, b);\n\nconst ifRightExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Right}'`, a, b);\n\nconst ifEnc = (test, a, b) => {\n  // ensure inputs are encoder objects (or null)\n  a = a != null ? encoder(a) : a;\n  b = b != null ? encoder(b) : b;\n\n  if (isSimple(a) && isSimple(b)) {\n    // if possible generate simple signal expression\n    a = a ? a.signal || stringValue(a.value) : null;\n    b = b ? b.signal || stringValue(b.value) : null;\n    return {\n      signal: `${test} ? (${a}) : (${b})`\n    };\n  } else {\n    // otherwise generate rule set\n    return [extend({\n      test\n    }, a)].concat(b || []);\n  }\n};\n\nconst isSimple = enc => enc == null || Object.keys(enc).length === 1;\n\nconst ifExpr = (test, a, b) => ({\n  signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`\n});\n\nconst ifOrient = ($orient, t, b, l, r) => ({\n  signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '') + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '') + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '') + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '') + '(null)'\n});\n\nconst toExpr = v => isSignal(v) ? v.signal : v == null ? null : stringValue(v);\n\nconst mult = (sign, value) => value === 0 ? 0 : isSignal(sign) ? {\n  signal: `(${sign.signal}) * ${value}`\n} : {\n  value: sign * value\n};\nconst patch = (value, base) => {\n  const s = value.signal;\n  return s && s.endsWith('(null)') ? {\n    signal: s.slice(0, -6) + base.signal\n  } : value;\n};\n\nfunction fallback(prop, config, axisConfig, style) {\n  let styleProp;\n\n  if (config && hasOwnProperty(config, prop)) {\n    return config[prop];\n  } else if (hasOwnProperty(axisConfig, prop)) {\n    return axisConfig[prop];\n  } else if (prop.startsWith('title')) {\n    switch (prop) {\n      case 'titleColor':\n        styleProp = 'fill';\n        break;\n\n      case 'titleFont':\n      case 'titleFontSize':\n      case 'titleFontWeight':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n\n    return style[GuideTitleStyle][styleProp];\n  } else if (prop.startsWith('label')) {\n    switch (prop) {\n      case 'labelColor':\n        styleProp = 'fill';\n        break;\n\n      case 'labelFont':\n      case 'labelFontSize':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n\n    return style[GuideLabelStyle][styleProp];\n  }\n\n  return null;\n}\n\nfunction keys(objects) {\n  const map = {};\n\n  for (const obj of objects) {\n    if (!obj) continue;\n\n    for (const key in obj) map[key] = 1;\n  }\n\n  return Object.keys(map);\n}\n\nfunction axisConfig (spec, scope) {\n  var config = scope.config,\n      style = config.style,\n      axis = config.axis,\n      band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\n      orient = spec.orient,\n      xy,\n      or,\n      key;\n\n  if (isSignal(orient)) {\n    const xyKeys = keys([config.axisX, config.axisY]),\n          orientKeys = keys([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);\n    xy = {};\n\n    for (key of xyKeys) {\n      xy[key] = ifX(orient, fallback(key, config.axisX, axis, style), fallback(key, config.axisY, axis, style));\n    }\n\n    or = {};\n\n    for (key of orientKeys) {\n      or[key] = ifOrient(orient.signal, fallback(key, config.axisTop, axis, style), fallback(key, config.axisBottom, axis, style), fallback(key, config.axisLeft, axis, style), fallback(key, config.axisRight, axis, style));\n    }\n  } else {\n    xy = orient === Top || orient === Bottom ? config.axisX : config.axisY;\n    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\n  }\n\n  const result = xy || or || band ? extend({}, axis, xy, or, band) : axis;\n  return result;\n}\n\nfunction axisDomain (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient;\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('domainColor'),\n    strokeCap: _('domainCap'),\n    strokeDash: _('domainDash'),\n    strokeDashOffset: _('domainDashOffset'),\n    strokeWidth: _('domainWidth'),\n    strokeOpacity: _('domainOpacity')\n  });\n  const pos0 = position(spec, 0);\n  const pos1 = position(spec, 1);\n  enter.x = update.x = ifX(orient, pos0, zero);\n  enter.x2 = update.x2 = ifX(orient, pos1);\n  enter.y = update.y = ifY(orient, pos0, zero);\n  enter.y2 = update.y2 = ifY(orient, pos1);\n  return guideMark({\n    type: RuleMark,\n    role: AxisDomainRole,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction position(spec, pos) {\n  return {\n    scale: spec.scale,\n    range: pos\n  };\n}\n\nfunction axisGrid (spec, config, userEncode, dataRef, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        vscale = spec.gridScale,\n        sign = getSign(orient, 1, -1),\n        offset = offsetValue(spec.offset, sign);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gridColor'),\n    strokeCap: _('gridCap'),\n    strokeDash: _('gridDash'),\n    strokeDashOffset: _('gridDashOffset'),\n    strokeOpacity: _('gridOpacity'),\n    strokeWidth: _('gridWidth')\n  });\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  const sz = ifX(orient, {\n    signal: 'height'\n  }, {\n    signal: 'width'\n  });\n  const gridStart = vscale ? {\n    scale: vscale,\n    range: 0,\n    mult: sign,\n    offset: offset\n  } : {\n    value: 0,\n    offset: offset\n  };\n  const gridEnd = vscale ? {\n    scale: vscale,\n    range: 1,\n    mult: sign,\n    offset: offset\n  } : extend(sz, {\n    mult: sign,\n    offset: offset\n  });\n  enter.x = update.x = ifX(orient, tickPos, gridStart);\n  enter.y = update.y = ifY(orient, tickPos, gridStart);\n  enter.x2 = update.x2 = ifY(orient, gridEnd);\n  enter.y2 = update.y2 = ifX(orient, gridEnd);\n  exit.x = ifX(orient, tickPos);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisGridRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction offsetValue(offset, sign) {\n  if (sign === 1) ; else if (!isObject(offset)) {\n    offset = isSignal(sign) ? {\n      signal: `(${sign.signal}) * (${offset || 0})`\n    } : sign * (offset || 0);\n  } else {\n    let entry = offset = extend({}, offset);\n\n    while (entry.mult != null) {\n      if (!isObject(entry.mult)) {\n        entry.mult = isSignal(sign) // no offset if sign === 1\n        ? {\n          signal: `(${entry.mult}) * (${sign.signal})`\n        } : entry.mult * sign;\n        return offset;\n      } else {\n        entry = entry.mult = extend({}, entry.mult);\n      }\n    }\n\n    entry.mult = sign;\n  }\n\n  return offset;\n}\n\nfunction axisTicks (spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('tickColor'),\n    strokeCap: _('tickCap'),\n    strokeDash: _('tickDash'),\n    strokeDashOffset: _('tickDashOffset'),\n    strokeOpacity: _('tickOpacity'),\n    strokeWidth: _('tickWidth')\n  });\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  update.y = enter.y = ifX(orient, zero, tickPos);\n  update.y2 = enter.y2 = ifX(orient, tickSize);\n  exit.x = ifX(orient, tickPos);\n  update.x = enter.x = ifY(orient, zero, tickPos);\n  update.x2 = enter.x2 = ifY(orient, tickSize);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisTickRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction flushExpr(scale, threshold, a, b, c) {\n  return {\n    signal: 'flush(range(\"' + scale + '\"), ' + 'scale(\"' + scale + '\", datum.value), ' + threshold + ',' + a + ',' + b + ',' + c + ')'\n  };\n}\n\nfunction axisLabels (spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        scale = spec.scale,\n        sign = getSign(orient, -1, 1),\n        flush = deref(_('labelFlush')),\n        flushOffset = deref(_('labelFlushOffset')),\n        labelAlign = _('labelAlign'),\n        labelBaseline = _('labelBaseline');\n\n  let flushOn = flush === 0 || !!flush,\n      update;\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  tickSize.offset = encoder(_('labelPadding') || 0);\n  tickSize.offset.mult = sign;\n  const tickPos = {\n    scale: scale,\n    field: Value,\n    band: 0.5,\n    offset: extendOffset(band.offset, _('labelOffset'))\n  };\n  const align = ifX(orient, flushOn ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"') : {\n    value: 'center'\n  }, ifRight(orient, 'left', 'right'));\n  const baseline = ifX(orient, ifTop(orient, 'bottom', 'top'), flushOn ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"') : {\n    value: 'middle'\n  });\n  const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);\n  flushOn = flushOn && flushOffset;\n  const enter = {\n    opacity: zero,\n    x: ifX(orient, tickPos, tickSize),\n    y: ifY(orient, tickPos, tickSize)\n  };\n  const encode = {\n    enter: enter,\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y,\n      align,\n      baseline\n    },\n    exit: {\n      opacity: zero,\n      x: enter.x,\n      y: enter.y\n    }\n  };\n  addEncoders(encode, {\n    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\n    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\n  });\n  addEncoders(encode, {\n    angle: _('labelAngle'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontWeight: _('labelFontWeight'),\n    fontStyle: _('labelFontStyle'),\n    limit: _('labelLimit'),\n    lineHeight: _('labelLineHeight')\n  }, {\n    align: labelAlign,\n    baseline: labelBaseline\n  });\n\n  const bound = _('labelBound');\n\n  let overlap = _('labelOverlap'); // if overlap method or bound defined, request label overlap removal\n\n\n  overlap = overlap || bound ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.index',\n    bound: bound ? {\n      scale,\n      orient,\n      tolerance: bound\n    } : null\n  } : undefined;\n\n  if (update.align !== align) {\n    update.align = patch(update.align, align);\n  }\n\n  if (update.baseline !== baseline) {\n    update.baseline = patch(update.baseline, baseline);\n  }\n\n  return guideMark({\n    type: TextMark,\n    role: AxisLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n\nfunction axisTitle (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      anchor: encoder(_('titleAnchor', null)),\n      align: {\n        signal: alignExpr$1\n      }\n    },\n    update: update = extend({}, enter, {\n      opacity: one,\n      text: encoder(spec.title)\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  const titlePos = {\n    signal: `lerp(range(\"${spec.scale}\"), ${anchorExpr(0, 1, 0.5)})`\n  };\n  update.x = ifX(orient, titlePos);\n  update.y = ifY(orient, titlePos);\n  enter.angle = ifX(orient, zero, mult(sign, 90));\n  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {\n    value: Bottom\n  });\n  update.angle = enter.angle;\n  update.baseline = enter.baseline;\n  addEncoders(encode, {\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    angle: _('titleAngle'),\n    baseline: _('titleBaseline')\n  });\n  autoLayout(_, orient, encode, userEncode);\n  encode.update.align = patch(encode.update.align, enter.align);\n  encode.update.angle = patch(encode.update.angle, enter.angle);\n  encode.update.baseline = patch(encode.update.baseline, enter.baseline);\n  return guideMark({\n    type: TextMark,\n    role: AxisTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction autoLayout(_, orient, encode, userEncode) {\n  const auto = (value, dim) => value != null ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false) : !has(dim, userEncode) ? true : false;\n\n  const autoY = auto(_('titleX'), 'x'),\n        autoX = auto(_('titleY'), 'y');\n  encode.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient, encoder(autoX), encoder(autoY));\n}\n\nfunction parseAxis (spec, scope) {\n  const config = axisConfig(spec, scope),\n        encode = spec.encode || {},\n        axisEncode = encode.axis || {},\n        name = axisEncode.name || undefined,\n        interactive = axisEncode.interactive,\n        style = axisEncode.style,\n        _ = lookup(spec, config),\n        band = tickBand(_); // single-element data source for axis group\n\n\n  const datum = {\n    scale: spec.scale,\n    ticks: !!_('ticks'),\n    labels: !!_('labels'),\n    grid: !!_('grid'),\n    domain: !!_('domain'),\n    title: spec.title != null\n  };\n  const dataRef = ref(scope.add(Collect({}, [datum]))); // data source for axis ticks\n\n  const ticksRef = ref(scope.add(AxisTicks({\n    scale: scope.scaleRef(spec.scale),\n    extra: scope.property(band.extra),\n    count: scope.objectProperty(spec.tickCount),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // generate axis marks\n\n  const children = [];\n  let size; // include axis gridlines if requested\n\n  if (datum.grid) {\n    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\n  } // include axis ticks if requested\n\n\n  if (datum.ticks) {\n    size = _('tickSize');\n    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\n  } // include axis labels if requested\n\n\n  if (datum.labels) {\n    size = datum.ticks ? size : 0;\n    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\n  } // include axis domain path if requested\n\n\n  if (datum.domain) {\n    children.push(axisDomain(spec, config, encode.domain, dataRef));\n  } // include axis title if defined\n\n\n  if (datum.title) {\n    children.push(axisTitle(spec, config, encode.title, dataRef));\n  } // parse axis specification\n\n\n  return parseMark(guideGroup({\n    role: AxisRole,\n    from: dataRef,\n    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\n\nfunction buildAxisEncode(_, spec) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset') || 0,\n    position: value(spec.position, 0),\n    titlePadding: _('titlePadding'),\n    minExtent: _('minExtent'),\n    maxExtent: _('maxExtent'),\n    range: {\n      signal: `abs(span(range(\"${spec.scale}\")))`\n    },\n    translate: _('translate'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\n\nfunction parseScope (spec, scope, preprocessed) {\n  const signals = array(spec.signals),\n        scales = array(spec.scales); // parse signal definitions, if not already preprocessed\n\n  if (!preprocessed) signals.forEach(_ => parseSignal(_, scope)); // parse cartographic projection definitions\n\n  array(spec.projections).forEach(_ => parseProjection(_, scope)); // initialize scale references\n\n  scales.forEach(_ => initScale(_, scope)); // parse data sources\n\n  array(spec.data).forEach(_ => parseData(_, scope)); // parse scale definitions\n\n  scales.forEach(_ => parseScale(_, scope)); // parse signal updates\n\n  (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope)); // parse axis definitions\n\n  array(spec.axes).forEach(_ => parseAxis(_, scope)); // parse mark definitions\n\n  array(spec.marks).forEach(_ => parseMark(_, scope)); // parse legend definitions\n\n  array(spec.legends).forEach(_ => parseLegend(_, scope)); // parse title, if defined\n\n  if (spec.title) parseTitle(spec.title, scope); // parse collected lambda (anonymous) expressions\n\n  scope.parseLambdas();\n  return scope;\n}\n\nconst rootEncode = spec => extendEncode({\n  enter: {\n    x: {\n      value: 0\n    },\n    y: {\n      value: 0\n    }\n  },\n  update: {\n    width: {\n      signal: 'width'\n    },\n    height: {\n      signal: 'height'\n    }\n  }\n}, spec);\n\nfunction parseView(spec, scope) {\n  const config = scope.config; // add scenegraph root\n\n  const root = ref(scope.root = scope.add(operator())); // parse top-level signal definitions\n\n  const signals = collectSignals(spec, config);\n  signals.forEach(_ => parseSignal(_, scope)); // assign description, event, legend, and locale configuration\n\n  scope.description = spec.description || config.description;\n  scope.eventConfig = config.events;\n  scope.legends = scope.objectProperty(config.legend && config.legend.layout);\n  scope.locale = config.locale; // store root group item\n\n  const input = scope.add(Collect()); // encode root group item\n\n  const encode = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {\n    pulse: ref(input)\n  }))); // perform view layout\n\n  const parent = scope.add(ViewLayout({\n    layout: scope.objectProperty(spec.layout),\n    legends: scope.legends,\n    autosize: scope.signalRef('autosize'),\n    mark: root,\n    pulse: ref(encode)\n  }));\n  scope.operators.pop(); // parse remainder of specification\n\n  scope.pushState(ref(encode), ref(parent), null);\n  parseScope(spec, scope, signals);\n  scope.operators.push(parent); // bound / render / sieve root item\n\n  let op = scope.add(Bound({\n    mark: root,\n    pulse: ref(parent)\n  }));\n  op = scope.add(Render({\n    pulse: ref(op)\n  }));\n  op = scope.add(Sieve({\n    pulse: ref(op)\n  })); // track metadata for root item\n\n  scope.addData('root', new DataScope(scope, input, input, op));\n  return scope;\n}\n\nfunction signalObject(name, value) {\n  return value && value.signal ? {\n    name,\n    update: value.signal\n  } : {\n    name,\n    value\n  };\n}\n/**\n * Collect top-level signals, merging values as needed. Signals\n * defined in the config signals arrays are added only if that\n * signal is not explicitly defined in the specification.\n * Built-in signals (autosize, background, padding, width, height)\n * receive special treatment. They are initialized using the\n * top-level spec property, or, if undefined in the spec, using\n * the corresponding top-level config property. If this property\n * is a signal reference object, the signal expression maps to the\n * signal 'update' property. If the spec's top-level signal array\n * contains an entry that matches a built-in signal, that entry\n * will be merged with the built-in specification, potentially\n * overwriting existing 'value' or 'update' properties.\n */\n\n\nfunction collectSignals(spec, config) {\n  const _ = name => value(spec[name], config[name]),\n        signals = [signalObject('background', _('background')), signalObject('autosize', parseAutosize(_('autosize'))), signalObject('padding', parsePadding(_('padding'))), signalObject('width', _('width') || 0), signalObject('height', _('height') || 0)],\n        pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),\n        map = {}; // add spec signal array\n\n\n  array(spec.signals).forEach(s => {\n    if (hasOwnProperty(pre, s.name)) {\n      // merge if built-in signal\n      s = extend(pre[s.name], s);\n    } else {\n      // otherwise add to signal list\n      signals.push(s);\n    }\n\n    map[s.name] = s;\n  }); // add config signal array\n\n  array(config.signals).forEach(s => {\n    if (!hasOwnProperty(map, s.name) && !hasOwnProperty(pre, s.name)) {\n      // add to signal list if not already defined\n      signals.push(s);\n    }\n  });\n  return signals;\n}\n\nfunction Scope(config, options) {\n  this.config = config || {};\n  this.options = options || {};\n  this.bindings = [];\n  this.field = {};\n  this.signals = {};\n  this.lambdas = {};\n  this.scales = {};\n  this.events = {};\n  this.data = {};\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this.eventConfig = null;\n  this.locale = null;\n  this._id = 0;\n  this._subid = 0;\n  this._nextsub = [0];\n  this._parent = [];\n  this._encode = [];\n  this._lookup = [];\n  this._markpath = [];\n}\n\nfunction Subscope(scope) {\n  this.config = scope.config;\n  this.options = scope.options;\n  this.legends = scope.legends;\n  this.field = Object.create(scope.field);\n  this.signals = Object.create(scope.signals);\n  this.lambdas = Object.create(scope.lambdas);\n  this.scales = Object.create(scope.scales);\n  this.events = Object.create(scope.events);\n  this.data = Object.create(scope.data);\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this._id = 0;\n  this._subid = ++scope._nextsub[0];\n  this._nextsub = scope._nextsub;\n  this._parent = scope._parent.slice();\n  this._encode = scope._encode.slice();\n  this._lookup = scope._lookup.slice();\n  this._markpath = scope._markpath;\n}\n\nScope.prototype = Subscope.prototype = {\n  parse(spec) {\n    return parseScope(spec, this);\n  },\n\n  fork() {\n    return new Subscope(this);\n  },\n\n  isSubscope() {\n    return this._subid > 0;\n  },\n\n  toRuntime() {\n    this.finish();\n    return {\n      description: this.description,\n      operators: this.operators,\n      streams: this.streams,\n      updates: this.updates,\n      bindings: this.bindings,\n      eventConfig: this.eventConfig,\n      locale: this.locale\n    };\n  },\n\n  id() {\n    return (this._subid ? this._subid + ':' : 0) + this._id++;\n  },\n\n  add(op) {\n    this.operators.push(op);\n    op.id = this.id(); // if pre-registration references exist, resolve them now\n\n    if (op.refs) {\n      op.refs.forEach(ref => {\n        ref.$ref = op.id;\n      });\n      op.refs = null;\n    }\n\n    return op;\n  },\n\n  proxy(op) {\n    const vref = op instanceof Entry ? ref(op) : op;\n    return this.add(Proxy({\n      value: vref\n    }));\n  },\n\n  addStream(stream) {\n    this.streams.push(stream);\n    stream.id = this.id();\n    return stream;\n  },\n\n  addUpdate(update) {\n    this.updates.push(update);\n    return update;\n  },\n\n  // Apply metadata\n  finish() {\n    let name, ds; // annotate root\n\n    if (this.root) this.root.root = true; // annotate signals\n\n    for (name in this.signals) {\n      this.signals[name].signal = name;\n    } // annotate scales\n\n\n    for (name in this.scales) {\n      this.scales[name].scale = name;\n    } // annotate data sets\n\n\n    function annotate(op, name, type) {\n      let data, list;\n\n      if (op) {\n        data = op.data || (op.data = {});\n        list = data[name] || (data[name] = []);\n        list.push(type);\n      }\n    }\n\n    for (name in this.data) {\n      ds = this.data[name];\n      annotate(ds.input, name, 'input');\n      annotate(ds.output, name, 'output');\n      annotate(ds.values, name, 'values');\n\n      for (const field in ds.index) {\n        annotate(ds.index[field], name, 'index:' + field);\n      }\n    }\n\n    return this;\n  },\n\n  // ----\n  pushState(encode, parent, lookup) {\n    this._encode.push(ref(this.add(Sieve({\n      pulse: encode\n    }))));\n\n    this._parent.push(parent);\n\n    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n\n    this._markpath.push(-1);\n  },\n\n  popState() {\n    this._encode.pop();\n\n    this._parent.pop();\n\n    this._lookup.pop();\n\n    this._markpath.pop();\n  },\n\n  parent() {\n    return peek(this._parent);\n  },\n\n  encode() {\n    return peek(this._encode);\n  },\n\n  lookup() {\n    return peek(this._lookup);\n  },\n\n  markpath() {\n    const p = this._markpath;\n    return ++p[p.length - 1];\n  },\n\n  // ----\n  fieldRef(field, name) {\n    if (isString(field)) return fieldRef$1(field, name);\n\n    if (!field.signal) {\n      error('Unsupported field reference: ' + stringValue(field));\n    }\n\n    const s = field.signal;\n    let f = this.field[s];\n\n    if (!f) {\n      const params = {\n        name: this.signalRef(s)\n      };\n      if (name) params.as = name;\n      this.field[s] = f = ref(this.add(Field(params)));\n    }\n\n    return f;\n  },\n\n  compareRef(cmp) {\n    let signal = false;\n\n    const check = _ => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, this.exprRef(_.expr)) : _;\n\n    const fields = array(cmp.field).map(check),\n          orders = array(cmp.order).map(check);\n    return signal ? ref(this.add(Compare({\n      fields: fields,\n      orders: orders\n    }))) : compareRef(fields, orders);\n  },\n\n  keyRef(fields, flat) {\n    let signal = false;\n\n    const check = _ => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;\n\n    const sig = this.signals;\n    fields = array(fields).map(check);\n    return signal ? ref(this.add(Key({\n      fields: fields,\n      flat: flat\n    }))) : keyRef(fields, flat);\n  },\n\n  sortRef(sort) {\n    if (!sort) return sort; // including id ensures stable sorting\n\n    const a = aggrField(sort.op, sort.field),\n          o = sort.order || Ascending;\n    return o.signal ? ref(this.add(Compare({\n      fields: a,\n      orders: this.signalRef(o.signal)\n    }))) : compareRef(a, o);\n  },\n\n  // ----\n  event(source, type) {\n    const key = source + ':' + type;\n\n    if (!this.events[key]) {\n      const id = this.id();\n      this.streams.push({\n        id: id,\n        source: source,\n        type: type\n      });\n      this.events[key] = id;\n    }\n\n    return this.events[key];\n  },\n\n  // ----\n  hasOwnSignal(name) {\n    return hasOwnProperty(this.signals, name);\n  },\n\n  addSignal(name, value) {\n    if (this.hasOwnSignal(name)) {\n      error('Duplicate signal name: ' + stringValue(name));\n    }\n\n    const op = value instanceof Entry ? value : this.add(operator(value));\n    return this.signals[name] = op;\n  },\n\n  getSignal(name) {\n    if (!this.signals[name]) {\n      error('Unrecognized signal name: ' + stringValue(name));\n    }\n\n    return this.signals[name];\n  },\n\n  signalRef(s) {\n    if (this.signals[s]) {\n      return ref(this.signals[s]);\n    } else if (!hasOwnProperty(this.lambdas, s)) {\n      this.lambdas[s] = this.add(operator(null));\n    }\n\n    return ref(this.lambdas[s]);\n  },\n\n  parseLambdas() {\n    const code = Object.keys(this.lambdas);\n\n    for (let i = 0, n = code.length; i < n; ++i) {\n      const s = code[i],\n            e = parseExpression(s, this),\n            op = this.lambdas[s];\n      op.params = e.$params;\n      op.update = e.$expr;\n    }\n  },\n\n  property(spec) {\n    return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n  },\n\n  objectProperty(spec) {\n    return !spec || !isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));\n  },\n\n  exprRef(code, name) {\n    const params = {\n      expr: parseExpression(code, this)\n    };\n    if (name) params.expr.$name = name;\n    return ref(this.add(Expression(params)));\n  },\n\n  addBinding(name, bind) {\n    if (!this.bindings) {\n      error('Nested signals do not support binding: ' + stringValue(name));\n    }\n\n    this.bindings.push(extend({\n      signal: name\n    }, bind));\n  },\n\n  // ----\n  addScaleProj(name, transform) {\n    if (hasOwnProperty(this.scales, name)) {\n      error('Duplicate scale or projection name: ' + stringValue(name));\n    }\n\n    this.scales[name] = this.add(transform);\n  },\n\n  addScale(name, params) {\n    this.addScaleProj(name, Scale(params));\n  },\n\n  addProjection(name, params) {\n    this.addScaleProj(name, Projection(params));\n  },\n\n  getScale(name) {\n    if (!this.scales[name]) {\n      error('Unrecognized scale name: ' + stringValue(name));\n    }\n\n    return this.scales[name];\n  },\n\n  scaleRef(name) {\n    return ref(this.getScale(name));\n  },\n\n  scaleType(name) {\n    return this.getScale(name).params.type;\n  },\n\n  projectionRef(name) {\n    return this.scaleRef(name);\n  },\n\n  projectionType(name) {\n    return this.scaleType(name);\n  },\n\n  // ----\n  addData(name, dataScope) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n\n    return this.data[name] = dataScope;\n  },\n\n  getData(name) {\n    if (!this.data[name]) {\n      error('Undefined data set name: ' + stringValue(name));\n    }\n\n    return this.data[name];\n  },\n\n  addDataPipeline(name, entries) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n\n    return this.addData(name, DataScope.fromEntries(this, entries));\n  }\n\n};\n\nfunction propertyLambda(spec) {\n  return (isArray(spec) ? arrayLambda : objectLambda)(spec);\n}\n\nfunction arrayLambda(array) {\n  const n = array.length;\n  let code = '[';\n\n  for (let i = 0; i < n; ++i) {\n    const value = array[i];\n    code += (i > 0 ? ',' : '') + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n\n  return code + ']';\n}\n\nfunction objectLambda(obj) {\n  let code = '{',\n      i = 0,\n      key,\n      value;\n\n  for (key in obj) {\n    value = obj[key];\n    code += (++i > 1 ? ',' : '') + stringValue(key) + ':' + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n\n  return code + '}';\n}\n\n/**\n * Standard configuration defaults for Vega specification parsing.\n * Users can provide their own (sub-)set of these default values\n * by passing in a config object to the top-level parse method.\n */\nfunction defaults () {\n  const defaultFont = 'sans-serif',\n        defaultSymbolSize = 30,\n        defaultStrokeWidth = 2,\n        defaultColor = '#4c78a8',\n        black = '#000',\n        gray = '#888',\n        lightGray = '#ddd';\n  return {\n    // default visualization description\n    description: 'Vega visualization',\n    // default padding around visualization\n    padding: 0,\n    // default for automatic sizing; options: 'none', 'pad', 'fit'\n    // or provide an object (e.g., {'type': 'pad', 'resize': true})\n    autosize: 'pad',\n    // default view background color\n    // covers the entire view component\n    background: null,\n    // default event handling configuration\n    // preventDefault for view-sourced event types except 'wheel'\n    events: {\n      defaults: {\n        allow: ['wheel']\n      }\n    },\n    // defaults for top-level group marks\n    // accepts mark properties (fill, stroke, etc)\n    // covers the data rectangle within group width/height\n    group: null,\n    // defaults for basic mark types\n    // each subset accepts mark properties (fill, stroke, etc)\n    mark: null,\n    arc: {\n      fill: defaultColor\n    },\n    area: {\n      fill: defaultColor\n    },\n    image: null,\n    line: {\n      stroke: defaultColor,\n      strokeWidth: defaultStrokeWidth\n    },\n    path: {\n      stroke: defaultColor\n    },\n    rect: {\n      fill: defaultColor\n    },\n    rule: {\n      stroke: black\n    },\n    shape: {\n      stroke: defaultColor\n    },\n    symbol: {\n      fill: defaultColor,\n      size: 64\n    },\n    text: {\n      fill: black,\n      font: defaultFont,\n      fontSize: 11\n    },\n    trail: {\n      fill: defaultColor,\n      size: defaultStrokeWidth\n    },\n    // style definitions\n    style: {\n      // axis & legend labels\n      'guide-label': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 10\n      },\n      // axis & legend titles\n      'guide-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 11,\n        fontWeight: 'bold'\n      },\n      // headers, including chart title\n      'group-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 13,\n        fontWeight: 'bold'\n      },\n      // chart subtitle\n      'group-subtitle': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 12\n      },\n      // defaults for styled point marks in Vega-Lite\n      point: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'circle'\n      },\n      circle: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth\n      },\n      square: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'square'\n      },\n      // defaults for styled group marks in Vega-Lite\n      cell: {\n        fill: 'transparent',\n        stroke: lightGray\n      }\n    },\n    // defaults for title\n    title: {\n      orient: 'top',\n      anchor: 'middle',\n      offset: 4,\n      subtitlePadding: 3\n    },\n    // defaults for axes\n    axis: {\n      minExtent: 0,\n      maxExtent: 200,\n      bandPosition: 0.5,\n      domain: true,\n      domainWidth: 1,\n      domainColor: gray,\n      grid: false,\n      gridWidth: 1,\n      gridColor: lightGray,\n      labels: true,\n      labelAngle: 0,\n      labelLimit: 180,\n      labelOffset: 0,\n      labelPadding: 2,\n      ticks: true,\n      tickColor: gray,\n      tickOffset: 0,\n      tickRound: true,\n      tickSize: 5,\n      tickWidth: 1,\n      titlePadding: 4\n    },\n    // correction for centering bias\n    axisBand: {\n      tickOffset: -0.5\n    },\n    // defaults for cartographic projection\n    projection: {\n      type: 'mercator'\n    },\n    // defaults for legends\n    legend: {\n      orient: 'right',\n      padding: 0,\n      gridAlign: 'each',\n      columnPadding: 10,\n      rowPadding: 2,\n      symbolDirection: 'vertical',\n      gradientDirection: 'vertical',\n      gradientLength: 200,\n      gradientThickness: 16,\n      gradientStrokeColor: lightGray,\n      gradientStrokeWidth: 0,\n      gradientLabelOffset: 2,\n      labelAlign: 'left',\n      labelBaseline: 'middle',\n      labelLimit: 160,\n      labelOffset: 4,\n      labelOverlap: true,\n      symbolLimit: 30,\n      symbolType: 'circle',\n      symbolSize: 100,\n      symbolOffset: 0,\n      symbolStrokeWidth: 1.5,\n      symbolBaseFillColor: 'transparent',\n      symbolBaseStrokeColor: gray,\n      titleLimit: 180,\n      titleOrient: 'top',\n      titlePadding: 5,\n      layout: {\n        offset: 18,\n        direction: 'horizontal',\n        left: {\n          direction: 'vertical'\n        },\n        right: {\n          direction: 'vertical'\n        }\n      }\n    },\n    // defaults for scale ranges\n    range: {\n      category: {\n        scheme: 'tableau10'\n      },\n      ordinal: {\n        scheme: 'blues'\n      },\n      heatmap: {\n        scheme: 'yellowgreenblue'\n      },\n      ramp: {\n        scheme: 'blues'\n      },\n      diverging: {\n        scheme: 'blueorange',\n        extent: [1, 0]\n      },\n      symbol: ['circle', 'square', 'triangle-up', 'cross', 'diamond', 'triangle-right', 'triangle-down', 'triangle-left']\n    }\n  };\n}\n\nfunction parse (spec, config, options) {\n  if (!isObject(spec)) {\n    error('Input Vega specification must be an object.');\n  }\n\n  config = mergeConfig(defaults(), config, spec.config);\n  return parseView(spec, new Scope(config, options)).toRuntime();\n}\n\nexport { AxisDomainRole, AxisGridRole, AxisLabelRole, AxisRole, AxisTickRole, AxisTitleRole, DataScope, FrameRole, LegendEntryRole, LegendLabelRole, LegendRole, LegendSymbolRole, LegendTitleRole, MarkRole, Scope, ScopeRole, defaults as config, parse, parseSignal as signal, parseSignalUpdates as signalUpdates, parseStream as stream };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}