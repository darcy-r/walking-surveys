{"ast":null,"code":"import { truthy, error, hasOwnProperty, isFunction, isString, stringValue, extend, isArray, isObject, field, peek, identity, array as array$1, isBoolean, isDate, isNumber, isRegExp, toBoolean, toDate, toNumber, toString, flush, lerp, pad, span, inrange, truncate, quarter, utcquarter, extent, clampRange, panLinear, panLog, panPow, panSymlog, zoomLinear, zoomLog, zoomPow, zoomSymlog } from 'vega-util';\nimport { Literal, codegenExpression, constants, functions, parseExpression, CallExpression } from 'vega-expression';\nimport { geoBounds as geoBounds$1, geoCentroid as geoCentroid$1, geoArea as geoArea$1 } from 'd3-geo';\nimport { rgb, lab, hcl, hsl } from 'd3-color';\nimport { isTuple } from 'vega-dataflow';\nimport { bandSpace, scale as scale$1, scaleFraction } from 'vega-scale';\nimport { Gradient, pathRender, pathParse, Bounds, intersect as intersect$1 } from 'vega-scenegraph';\nimport { selectionVisitor, selectionTest, selectionIdTest, selectionResolve, selectionTuples } from 'vega-selections';\nimport { random, cumulativeNormal, cumulativeLogNormal, cumulativeUniform, densityNormal, densityLogNormal, densityUniform, quantileNormal, quantileLogNormal, quantileUniform, sampleNormal, sampleLogNormal, sampleUniform } from 'vega-statistics';\nimport { utcOffset, utcSequence, timeOffset, timeSequence, timeUnitSpecifier, week, utcweek, dayofyear, utcdayofyear } from 'vega-time';\nimport { range as range$1 } from 'd3-array';\n\nfunction data(name) {\n  const data = this.context.data[name];\n  return data ? data.values.value : [];\n}\n\nfunction indata(name, field, value) {\n  const index = this.context.data[name]['index:' + field],\n        entry = index ? index.value.get(value) : undefined;\n  return entry ? entry.count : entry;\n}\n\nfunction setdata(name, tuples) {\n  const df = this.context.dataflow,\n        data = this.context.data[name],\n        input = data.input;\n  df.pulse(input, df.changeset().remove(truthy).insert(tuples));\n  return 1;\n}\n\nfunction encode(item, name, retval) {\n  if (item) {\n    const df = this.context.dataflow,\n          target = item.mark.source;\n    df.pulse(target, df.changeset().encode(item, name));\n  }\n\n  return retval !== undefined ? retval : item;\n}\n\nconst wrap = method => function (value, spec) {\n  const locale = this.context.dataflow.locale();\n  return locale[method](spec)(value);\n};\n\nconst format = wrap('format');\nconst timeFormat = wrap('timeFormat');\nconst utcFormat = wrap('utcFormat');\nconst timeParse = wrap('timeParse');\nconst utcParse = wrap('utcParse');\nconst dateObj = new Date(2000, 0, 1);\n\nfunction time(month, day, specifier) {\n  if (!Number.isInteger(month) || !Number.isInteger(day)) return '';\n  dateObj.setYear(2000);\n  dateObj.setMonth(month);\n  dateObj.setDate(day);\n  return timeFormat.call(this, dateObj, specifier);\n}\n\nfunction monthFormat(month) {\n  return time.call(this, month, 1, '%B');\n}\n\nfunction monthAbbrevFormat(month) {\n  return time.call(this, month, 1, '%b');\n}\n\nfunction dayFormat(day) {\n  return time.call(this, 0, 2 + day, '%A');\n}\n\nfunction dayAbbrevFormat(day) {\n  return time.call(this, 0, 2 + day, '%a');\n}\n\nconst DataPrefix = ':';\nconst IndexPrefix = '@';\nconst ScalePrefix = '%';\nconst SignalPrefix = '$';\n\nfunction dataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) {\n    error('First argument to data functions must be a string literal.');\n  }\n\n  const data = args[0].value,\n        dataName = DataPrefix + data;\n\n  if (!hasOwnProperty(dataName, params)) {\n    try {\n      params[dataName] = scope.getData(data).tuplesRef();\n    } catch (err) {// if data set does not exist, there's nothing to track\n    }\n  }\n}\n\nfunction indataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to indata must be a string literal.');\n  if (args[1].type !== Literal) error('Second argument to indata must be a string literal.');\n  const data = args[0].value,\n        field = args[1].value,\n        indexName = IndexPrefix + field;\n\n  if (!hasOwnProperty(indexName, params)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n}\n\nfunction scaleVisitor(name, args, scope, params) {\n  if (args[0].type === Literal) {\n    // add scale dependency\n    addScaleDependency(scope, params, args[0].value);\n  } else {\n    // indirect scale lookup; add all scales as parameters\n    for (name in scope.scales) {\n      addScaleDependency(scope, params, name);\n    }\n  }\n}\n\nfunction addScaleDependency(scope, params, name) {\n  const scaleName = ScalePrefix + name;\n\n  if (!hasOwnProperty(params, scaleName)) {\n    try {\n      params[scaleName] = scope.scaleRef(name);\n    } catch (err) {// TODO: error handling? warning?\n    }\n  }\n}\n\nfunction getScale(name, ctx) {\n  let s;\n  return isFunction(name) ? name : isString(name) ? (s = ctx.scales[name]) && s.value : undefined;\n}\n\nfunction internalScaleFunctions(codegen, fnctx, visitors) {\n  // add helper method to the 'this' expression function context\n  fnctx.__bandwidth = s => s && s.bandwidth ? s.bandwidth() : 0; // register AST visitors for internal scale functions\n\n\n  visitors._bandwidth = scaleVisitor;\n  visitors._range = scaleVisitor;\n  visitors._scale = scaleVisitor; // resolve scale reference directly to the signal hash argument\n\n  const ref = arg => '_[' + (arg.type === Literal ? stringValue(ScalePrefix + arg.value) : stringValue(ScalePrefix) + '+' + codegen(arg)) + ']'; // define and return internal scale function code generators\n  // these internal functions are called by mark encoders\n\n\n  return {\n    _bandwidth: args => \"this.__bandwidth(\".concat(ref(args[0]), \")\"),\n    _range: args => \"\".concat(ref(args[0]), \".range()\"),\n    _scale: args => \"\".concat(ref(args[0]), \"(\").concat(codegen(args[1]), \")\")\n  };\n}\n\nfunction geoMethod(methodName, globalMethod) {\n  return function (projection, geojson, group) {\n    if (projection) {\n      // projection defined, use it\n      const p = getScale(projection, (group || this).context);\n      return p && p.path[methodName](geojson);\n    } else {\n      // projection undefined, use global method\n      return globalMethod(geojson);\n    }\n  };\n}\n\nconst geoArea = geoMethod('area', geoArea$1);\nconst geoBounds = geoMethod('bounds', geoBounds$1);\nconst geoCentroid = geoMethod('centroid', geoCentroid$1);\n\nfunction inScope(item) {\n  const group = this.context.group;\n  let value = false;\n  if (group) while (item) {\n    if (item === group) {\n      value = true;\n      break;\n    }\n\n    item = item.mark.group;\n  }\n  return value;\n}\n\nfunction log(df, method, args) {\n  try {\n    df[method].apply(df, ['EXPRESSION'].concat([].slice.call(args)));\n  } catch (err) {\n    df.warn(err);\n  }\n\n  return args[args.length - 1];\n}\n\nfunction warn() {\n  return log(this.context.dataflow, 'warn', arguments);\n}\n\nfunction info() {\n  return log(this.context.dataflow, 'info', arguments);\n}\n\nfunction debug() {\n  return log(this.context.dataflow, 'debug', arguments);\n}\n\nfunction channel_luminance_value(channelValue) {\n  const val = channelValue / 255;\n\n  if (val <= 0.03928) {\n    return val / 12.92;\n  }\n\n  return Math.pow((val + 0.055) / 1.055, 2.4);\n}\n\nfunction luminance(color) {\n  const c = rgb(color),\n        r = channel_luminance_value(c.r),\n        g = channel_luminance_value(c.g),\n        b = channel_luminance_value(c.b);\n  return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n} // https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n\n\nfunction contrast(color1, color2) {\n  const lum1 = luminance(color1),\n        lum2 = luminance(color2),\n        lumL = Math.max(lum1, lum2),\n        lumD = Math.min(lum1, lum2);\n  return (lumL + 0.05) / (lumD + 0.05);\n}\n\nfunction merge() {\n  const args = [].slice.call(arguments);\n  args.unshift({});\n  return extend(...args);\n}\n\nfunction equal(a, b) {\n  return a === b || a !== a && b !== b ? true : isArray(a) ? isArray(b) && a.length === b.length ? equalArray(a, b) : false : isObject(a) && isObject(b) ? equalObject(a, b) : false;\n}\n\nfunction equalArray(a, b) {\n  for (let i = 0, n = a.length; i < n; ++i) {\n    if (!equal(a[i], b[i])) return false;\n  }\n\n  return true;\n}\n\nfunction equalObject(a, b) {\n  for (const key in a) {\n    if (!equal(a[key], b[key])) return false;\n  }\n\n  return true;\n}\n\nfunction removePredicate(props) {\n  return _ => equalObject(props, _);\n}\n\nfunction modify(name, insert, remove, toggle, modify, values) {\n  const df = this.context.dataflow,\n        data = this.context.data[name],\n        input = data.input,\n        stamp = df.stamp();\n  let changes = data.changes,\n      predicate,\n      key;\n\n  if (df._trigger === false || !(input.value.length || insert || toggle)) {\n    // nothing to do!\n    return 0;\n  }\n\n  if (!changes || changes.stamp < stamp) {\n    data.changes = changes = df.changeset();\n    changes.stamp = stamp;\n    df.runAfter(() => {\n      data.modified = true;\n      df.pulse(input, changes).run();\n    }, true, 1);\n  }\n\n  if (remove) {\n    predicate = remove === true ? truthy : isArray(remove) || isTuple(remove) ? remove : removePredicate(remove);\n    changes.remove(predicate);\n  }\n\n  if (insert) {\n    changes.insert(insert);\n  }\n\n  if (toggle) {\n    predicate = removePredicate(toggle);\n\n    if (input.value.some(predicate)) {\n      changes.remove(predicate);\n    } else {\n      changes.insert(toggle);\n    }\n  }\n\n  if (modify) {\n    for (key in values) {\n      changes.modify(modify, key, values[key]);\n    }\n  }\n\n  return 1;\n}\n\nfunction pinchDistance(event) {\n  const t = event.touches,\n        dx = t[0].clientX - t[1].clientX,\n        dy = t[0].clientY - t[1].clientY;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction pinchAngle(event) {\n  const t = event.touches;\n  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);\n}\n\nconst accessors = {};\n\nfunction pluck(data, name) {\n  const accessor = accessors[name] || (accessors[name] = field(name));\n  return isArray(data) ? data.map(accessor) : accessor(data);\n}\n\nfunction array(seq) {\n  return isArray(seq) || ArrayBuffer.isView(seq) ? seq : null;\n}\n\nfunction sequence(seq) {\n  return array(seq) || (isString(seq) ? seq : null);\n}\n\nfunction join(seq) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return array(seq).join(...args);\n}\n\nfunction indexof(seq) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  return sequence(seq).indexOf(...args);\n}\n\nfunction lastindexof(seq) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n\n  return sequence(seq).lastIndexOf(...args);\n}\n\nfunction slice(seq) {\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n\n  return sequence(seq).slice(...args);\n}\n\nfunction replace(str, pattern, repl) {\n  if (isFunction(repl)) error('Function argument passed to replace.');\n  return String(str).replace(pattern, repl);\n}\n\nfunction reverse(seq) {\n  return array(seq).slice().reverse();\n}\n\nfunction bandspace(count, paddingInner, paddingOuter) {\n  return bandSpace(count || 0, paddingInner || 0, paddingOuter || 0);\n}\n\nfunction bandwidth(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s && s.bandwidth ? s.bandwidth() : 0;\n}\n\nfunction copy(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s.copy() : undefined;\n}\n\nfunction domain(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s.domain() : [];\n}\n\nfunction invert(name, range, group) {\n  const s = getScale(name, (group || this).context);\n  return !s ? undefined : isArray(range) ? (s.invertRange || s.invert)(range) : (s.invert || s.invertExtent)(range);\n}\n\nfunction range(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s && s.range ? s.range() : [];\n}\n\nfunction scale(name, value, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s(value) : undefined;\n}\n\nfunction scaleGradient(scale, p0, p1, count, group) {\n  scale = getScale(scale, (group || this).context);\n  const gradient = Gradient(p0, p1);\n  let stops = scale.domain(),\n      min = stops[0],\n      max = peek(stops),\n      fraction = identity;\n\n  if (!(max - min)) {\n    // expand scale if domain has zero span, fix #1479\n    scale = (scale.interpolator ? scale$1('sequential')().interpolator(scale.interpolator()) : scale$1('linear')().interpolate(scale.interpolate()).range(scale.range())).domain([min = 0, max = 1]);\n  } else {\n    fraction = scaleFraction(scale, min, max);\n  }\n\n  if (scale.ticks) {\n    stops = scale.ticks(+count || 15);\n    if (min !== stops[0]) stops.unshift(min);\n    if (max !== peek(stops)) stops.push(max);\n  }\n\n  stops.forEach(_ => gradient.stop(fraction(_), scale(_)));\n  return gradient;\n}\n\nfunction geoShape(projection, geojson, group) {\n  const p = getScale(projection, (group || this).context);\n  return function (context) {\n    return p ? p.path.context(context)(geojson) : '';\n  };\n}\n\nfunction pathShape(path) {\n  let p = null;\n  return function (context) {\n    return context ? pathRender(context, p = p || pathParse(path)) : path;\n  };\n}\n\nconst datum = d => d.data;\n\nfunction treeNodes(name, context) {\n  const tree = data.call(context, name);\n  return tree.root && tree.root.lookup || {};\n}\n\nfunction treePath(name, source, target) {\n  const nodes = treeNodes(name, this),\n        s = nodes[source],\n        t = nodes[target];\n  return s && t ? s.path(t).map(datum) : undefined;\n}\n\nfunction treeAncestors(name, node) {\n  const n = treeNodes(name, this)[node];\n  return n ? n.ancestors().map(datum) : undefined;\n}\n\nconst _window = () => typeof window !== 'undefined' && window || null;\n\nfunction screen() {\n  const w = _window();\n\n  return w ? w.screen : {};\n}\n\nfunction windowSize() {\n  const w = _window();\n\n  return w ? [w.innerWidth, w.innerHeight] : [undefined, undefined];\n}\n\nfunction containerSize() {\n  const view = this.context.dataflow,\n        el = view.container && view.container();\n  return el ? [el.clientWidth, el.clientHeight] : [undefined, undefined];\n}\n\nfunction intersect(b, opt, group) {\n  if (!b) return [];\n  const [u, v] = b,\n        box = new Bounds().set(u[0], u[1], v[0], v[1]),\n        scene = group || this.context.dataflow.scenegraph().root;\n  return intersect$1(scene, box, filter(opt));\n}\n\nfunction filter(opt) {\n  let p = null;\n\n  if (opt) {\n    const types = array$1(opt.marktype),\n          names = array$1(opt.markname);\n\n    p = _ => (!types.length || types.some(t => _.marktype === t)) && (!names.length || names.some(s => _.name === s));\n  }\n\n  return p;\n}\n/**\n * Appends a new point to the lasso\n * \n * @param {*} lasso the lasso in pixel space\n * @param {*} x the x coordinate in pixel space\n * @param {*} y the y coordinate in pixel space\n * @param {*} minDist the minimum distance, in pixels, that thenew point needs to be apart from the last point\n * @returns a new array containing the lasso with the new point\n */\n\n\nfunction lassoAppend(lasso, x, y) {\n  let minDist = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;\n  const last = lasso[lasso.length - 1]; // Add point to lasso if distance to last point exceed minDist or its the first point\n\n  if (last === undefined || Math.sqrt((last[0] - x) ** 2 + (last[1] - y) ** 2) > minDist) {\n    lasso.push([x, y]);\n    return [...lasso];\n  }\n\n  return lasso;\n}\n/**\n * Generates a svg path command which draws a lasso\n * \n * @param {*} lasso the lasso in pixel space in the form [[x,y], [x,y], ...]\n * @returns the svg path command that draws the lasso\n */\n\n\nfunction lassoPath(lasso) {\n  return (lasso !== null && lasso !== void 0 ? lasso : []).reduce((svg, _ref, i) => {\n    let [x, y] = _ref;\n    return svg += i == 0 ? \"M \".concat(x, \",\").concat(y, \" \") : i === lasso.length - 1 ? ' Z' : \"L \".concat(x, \",\").concat(y, \" \");\n  }, '');\n}\n/**\n * Inverts the lasso from pixel space to an array of vega scenegraph tuples\n * \n * @param {*} data the dataset\n * @param {*} pixelLasso the lasso in pixel space, [[x,y], [x,y], ...]\n * @param {*} unit the unit where the lasso is defined\n * \n * @returns an array of vega scenegraph tuples\n */\n\n\nfunction intersectLasso(markname, pixelLasso, unit) {\n  const {\n    x,\n    y,\n    mark\n  } = unit;\n  const bb = new Bounds().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER); // Get bounding box around lasso\n\n  for (const [px, py] of pixelLasso) {\n    if (px < bb.x1) bb.x1 = px;\n    if (px > bb.x2) bb.x2 = px;\n    if (py < bb.y1) bb.y1 = py;\n    if (py > bb.y2) bb.y2 = py;\n  } // Translate bb against unit coordinates\n\n\n  bb.translate(x, y);\n  const intersection = intersect([[bb.x1, bb.y1], [bb.x2, bb.y2]], markname, mark); // Check every point against the lasso\n\n  return intersection.filter(tuple => pointInPolygon(tuple.x, tuple.y, pixelLasso));\n}\n/**\n * Performs a test if a point is inside a polygon based on the idea from\n * https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\n * \n * This method will not need the same start/end point since it wraps around the edges of the array\n * \n * @param {*} test a point to test against\n * @param {*} polygon a polygon in the form [[x,y], [x,y], ...]\n * @returns true if the point lies inside the polygon, false otherwise\n */\n\n\nfunction pointInPolygon(testx, testy, polygon) {\n  let intersections = 0;\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const [prevX, prevY] = polygon[j];\n    const [x, y] = polygon[i]; // count intersections\n\n    if (y > testy != prevY > testy && testx < (prevX - x) * (testy - y) / (prevY - y) + x) {\n      intersections++;\n    }\n  } // point is in polygon if intersection count is odd\n\n\n  return intersections & 1;\n}\n\nconst functionContext = {\n  random() {\n    return random();\n  },\n\n  // override default\n  cumulativeNormal,\n  cumulativeLogNormal,\n  cumulativeUniform,\n  densityNormal,\n  densityLogNormal,\n  densityUniform,\n  quantileNormal,\n  quantileLogNormal,\n  quantileUniform,\n  sampleNormal,\n  sampleLogNormal,\n  sampleUniform,\n  isArray,\n  isBoolean,\n  isDate,\n\n  isDefined(_) {\n    return _ !== undefined;\n  },\n\n  isNumber,\n  isObject,\n  isRegExp,\n  isString,\n  isTuple,\n\n  isValid(_) {\n    return _ != null && _ === _;\n  },\n\n  toBoolean,\n\n  toDate(_) {\n    return toDate(_);\n  },\n\n  // suppress extra arguments\n  toNumber,\n  toString,\n  indexof,\n  join,\n  lastindexof,\n  replace,\n  reverse,\n  slice,\n  flush,\n  lerp,\n  merge,\n  pad,\n  peek,\n  pluck,\n  span,\n  inrange,\n  truncate,\n  rgb,\n  lab,\n  hcl,\n  hsl,\n  luminance,\n  contrast,\n  sequence: range$1,\n  format,\n  utcFormat,\n  utcParse,\n  utcOffset,\n  utcSequence,\n  timeFormat,\n  timeParse,\n  timeOffset,\n  timeSequence,\n  timeUnitSpecifier,\n  monthFormat,\n  monthAbbrevFormat,\n  dayFormat,\n  dayAbbrevFormat,\n  quarter,\n  utcquarter,\n  week,\n  utcweek,\n  dayofyear,\n  utcdayofyear,\n  warn,\n  info,\n  debug,\n\n  extent(_) {\n    return extent(_);\n  },\n\n  // suppress extra arguments\n  inScope,\n  intersect,\n  clampRange,\n  pinchDistance,\n  pinchAngle,\n  screen,\n  containerSize,\n  windowSize,\n  bandspace,\n  setdata,\n  pathShape,\n  panLinear,\n  panLog,\n  panPow,\n  panSymlog,\n  zoomLinear,\n  zoomLog,\n  zoomPow,\n  zoomSymlog,\n  encode,\n  modify,\n  lassoAppend,\n  lassoPath,\n  intersectLasso\n};\nconst eventFunctions = ['view', 'item', 'group', 'xy', 'x', 'y'],\n      // event functions\neventPrefix = 'event.vega.',\n      // event function prefix\nthisPrefix = 'this.',\n      // function context prefix\nastVisitors = {}; // AST visitors for dependency analysis\n// export code generator parameters\n\nconst codegenParams = {\n  forbidden: ['_'],\n  allowed: ['datum', 'event', 'item'],\n  fieldvar: 'datum',\n  globalvar: id => \"_[\".concat(stringValue(SignalPrefix + id), \"]\"),\n  functions: buildFunctions,\n  constants: constants,\n  visitors: astVisitors\n}; // export code generator\n\nconst codeGenerator = codegenExpression(codegenParams); // Build expression function registry\n\nfunction buildFunctions(codegen) {\n  const fn = functions(codegen);\n  eventFunctions.forEach(name => fn[name] = eventPrefix + name);\n\n  for (const name in functionContext) {\n    fn[name] = thisPrefix + name;\n  }\n\n  extend(fn, internalScaleFunctions(codegen, functionContext, astVisitors));\n  return fn;\n} // Register an expression function\n\n\nfunction expressionFunction(name, fn, visitor) {\n  if (arguments.length === 1) {\n    return functionContext[name];\n  } // register with the functionContext\n\n\n  functionContext[name] = fn; // if there is an astVisitor register that, too\n\n  if (visitor) astVisitors[name] = visitor; // if the code generator has already been initialized,\n  // we need to also register the function with it\n\n  if (codeGenerator) codeGenerator.functions[name] = thisPrefix + name;\n  return this;\n} // register expression functions with ast visitors\n\n\nexpressionFunction('bandwidth', bandwidth, scaleVisitor);\nexpressionFunction('copy', copy, scaleVisitor);\nexpressionFunction('domain', domain, scaleVisitor);\nexpressionFunction('range', range, scaleVisitor);\nexpressionFunction('invert', invert, scaleVisitor);\nexpressionFunction('scale', scale, scaleVisitor);\nexpressionFunction('gradient', scaleGradient, scaleVisitor);\nexpressionFunction('geoArea', geoArea, scaleVisitor);\nexpressionFunction('geoBounds', geoBounds, scaleVisitor);\nexpressionFunction('geoCentroid', geoCentroid, scaleVisitor);\nexpressionFunction('geoShape', geoShape, scaleVisitor);\nexpressionFunction('indata', indata, indataVisitor);\nexpressionFunction('data', data, dataVisitor);\nexpressionFunction('treePath', treePath, dataVisitor);\nexpressionFunction('treeAncestors', treeAncestors, dataVisitor); // register Vega-Lite selection functions\n\nexpressionFunction('vlSelectionTest', selectionTest, selectionVisitor);\nexpressionFunction('vlSelectionIdTest', selectionIdTest, selectionVisitor);\nexpressionFunction('vlSelectionResolve', selectionResolve, selectionVisitor);\nexpressionFunction('vlSelectionTuples', selectionTuples);\n\nfunction parser(expr, scope) {\n  const params = {}; // parse the expression to an abstract syntax tree (ast)\n\n  let ast;\n\n  try {\n    expr = isString(expr) ? expr : stringValue(expr) + '';\n    ast = parseExpression(expr);\n  } catch (err) {\n    error('Expression parse error: ' + expr);\n  } // analyze ast function calls for dependencies\n\n\n  ast.visit(node => {\n    if (node.type !== CallExpression) return;\n    const name = node.callee.name,\n          visit = codegenParams.visitors[name];\n    if (visit) visit(name, node.arguments, scope, params);\n  }); // perform code generation\n\n  const gen = codeGenerator(ast); // collect signal dependencies\n\n  gen.globals.forEach(name => {\n    const signalName = SignalPrefix + name;\n\n    if (!hasOwnProperty(params, signalName) && scope.getSignal(name)) {\n      params[signalName] = scope.signalRef(name);\n    }\n  }); // return generated expression code and dependencies\n\n  return {\n    $expr: extend({\n      code: gen.code\n    }, scope.options.ast ? {\n      ast\n    } : null),\n    $fields: gen.fields,\n    $params: params\n  };\n}\n\nexport { DataPrefix, IndexPrefix, ScalePrefix, SignalPrefix, bandspace, bandwidth, codeGenerator, codegenParams, containerSize, contrast, copy, data, dataVisitor, dayAbbrevFormat, dayFormat, debug, domain, encode, expressionFunction, format, functionContext, geoArea, geoBounds, geoCentroid, geoShape, inScope, indata, indataVisitor, indexof, info, invert, join, lastindexof, luminance, merge, modify, monthAbbrevFormat, monthFormat, parser as parseExpression, pathShape, pinchAngle, pinchDistance, pluck, range, replace, reverse, scale, scaleGradient, scaleVisitor, screen, setdata, slice, timeFormat, timeParse, treeAncestors, treePath, utcFormat, utcParse, warn, windowSize };","map":{"version":3,"names":["truthy","error","hasOwnProperty","isFunction","isString","stringValue","extend","isArray","isObject","field","peek","identity","array","array$1","isBoolean","isDate","isNumber","isRegExp","toBoolean","toDate","toNumber","toString","flush","lerp","pad","span","inrange","truncate","quarter","utcquarter","extent","clampRange","panLinear","panLog","panPow","panSymlog","zoomLinear","zoomLog","zoomPow","zoomSymlog","Literal","codegenExpression","constants","functions","parseExpression","CallExpression","geoBounds","geoBounds$1","geoCentroid","geoCentroid$1","geoArea","geoArea$1","rgb","lab","hcl","hsl","isTuple","bandSpace","scale","scale$1","scaleFraction","Gradient","pathRender","pathParse","Bounds","intersect","intersect$1","selectionVisitor","selectionTest","selectionIdTest","selectionResolve","selectionTuples","random","cumulativeNormal","cumulativeLogNormal","cumulativeUniform","densityNormal","densityLogNormal","densityUniform","quantileNormal","quantileLogNormal","quantileUniform","sampleNormal","sampleLogNormal","sampleUniform","utcOffset","utcSequence","timeOffset","timeSequence","timeUnitSpecifier","week","utcweek","dayofyear","utcdayofyear","range","range$1","data","name","context","values","value","indata","index","entry","get","undefined","count","setdata","tuples","df","dataflow","input","pulse","changeset","remove","insert","encode","item","retval","target","mark","source","wrap","method","spec","locale","format","timeFormat","utcFormat","timeParse","utcParse","dateObj","Date","time","month","day","specifier","Number","isInteger","setYear","setMonth","setDate","call","monthFormat","monthAbbrevFormat","dayFormat","dayAbbrevFormat","DataPrefix","IndexPrefix","ScalePrefix","SignalPrefix","dataVisitor","args","scope","params","type","dataName","getData","tuplesRef","err","indataVisitor","indexName","indataRef","scaleVisitor","addScaleDependency","scales","scaleName","scaleRef","getScale","ctx","s","internalScaleFunctions","codegen","fnctx","visitors","__bandwidth","bandwidth","_bandwidth","_range","_scale","ref","arg","concat","geoMethod","methodName","globalMethod","projection","geojson","group","p","path","inScope","log","apply","slice","warn","length","arguments","info","debug","channel_luminance_value","channelValue","val","Math","pow","luminance","color","c","r","g","b","contrast","color1","color2","lum1","lum2","lumL","max","lumD","min","merge","unshift","equal","a","equalArray","equalObject","i","n","key","removePredicate","props","_","modify","toggle","stamp","changes","predicate","_trigger","runAfter","modified","run","some","pinchDistance","event","t","touches","dx","clientX","dy","clientY","sqrt","pinchAngle","atan2","accessors","pluck","accessor","map","seq","ArrayBuffer","isView","sequence","join","_len","Array","_key","indexof","_len2","_key2","indexOf","lastindexof","_len3","_key3","lastIndexOf","_len4","_key4","replace","str","pattern","repl","String","reverse","bandspace","paddingInner","paddingOuter","copy","domain","invert","invertRange","invertExtent","scaleGradient","p0","p1","gradient","stops","fraction","interpolator","interpolate","ticks","push","forEach","stop","geoShape","pathShape","datum","d","treeNodes","tree","root","lookup","treePath","nodes","treeAncestors","node","ancestors","_window","window","screen","w","windowSize","innerWidth","innerHeight","containerSize","view","el","container","clientWidth","clientHeight","opt","u","v","box","set","scene","scenegraph","filter","types","marktype","names","markname","lassoAppend","lasso","x","y","minDist","last","lassoPath","reduce","svg","_ref","intersectLasso","pixelLasso","unit","bb","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","px","py","x1","x2","y1","y2","translate","intersection","tuple","pointInPolygon","testx","testy","polygon","intersections","j","prevX","prevY","functionContext","isDefined","isValid","eventFunctions","eventPrefix","thisPrefix","astVisitors","codegenParams","forbidden","allowed","fieldvar","globalvar","id","buildFunctions","codeGenerator","fn","expressionFunction","visitor","parser","expr","ast","visit","callee","gen","globals","signalName","getSignal","signalRef","$expr","code","options","$fields","fields","$params"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-functions/build/vega-functions.module.js"],"sourcesContent":["import { truthy, error, hasOwnProperty, isFunction, isString, stringValue, extend, isArray, isObject, field, peek, identity, array as array$1, isBoolean, isDate, isNumber, isRegExp, toBoolean, toDate, toNumber, toString, flush, lerp, pad, span, inrange, truncate, quarter, utcquarter, extent, clampRange, panLinear, panLog, panPow, panSymlog, zoomLinear, zoomLog, zoomPow, zoomSymlog } from 'vega-util';\nimport { Literal, codegenExpression, constants, functions, parseExpression, CallExpression } from 'vega-expression';\nimport { geoBounds as geoBounds$1, geoCentroid as geoCentroid$1, geoArea as geoArea$1 } from 'd3-geo';\nimport { rgb, lab, hcl, hsl } from 'd3-color';\nimport { isTuple } from 'vega-dataflow';\nimport { bandSpace, scale as scale$1, scaleFraction } from 'vega-scale';\nimport { Gradient, pathRender, pathParse, Bounds, intersect as intersect$1 } from 'vega-scenegraph';\nimport { selectionVisitor, selectionTest, selectionIdTest, selectionResolve, selectionTuples } from 'vega-selections';\nimport { random, cumulativeNormal, cumulativeLogNormal, cumulativeUniform, densityNormal, densityLogNormal, densityUniform, quantileNormal, quantileLogNormal, quantileUniform, sampleNormal, sampleLogNormal, sampleUniform } from 'vega-statistics';\nimport { utcOffset, utcSequence, timeOffset, timeSequence, timeUnitSpecifier, week, utcweek, dayofyear, utcdayofyear } from 'vega-time';\nimport { range as range$1 } from 'd3-array';\n\nfunction data(name) {\n  const data = this.context.data[name];\n  return data ? data.values.value : [];\n}\nfunction indata(name, field, value) {\n  const index = this.context.data[name]['index:' + field],\n        entry = index ? index.value.get(value) : undefined;\n  return entry ? entry.count : entry;\n}\nfunction setdata(name, tuples) {\n  const df = this.context.dataflow,\n        data = this.context.data[name],\n        input = data.input;\n  df.pulse(input, df.changeset().remove(truthy).insert(tuples));\n  return 1;\n}\n\nfunction encode (item, name, retval) {\n  if (item) {\n    const df = this.context.dataflow,\n          target = item.mark.source;\n    df.pulse(target, df.changeset().encode(item, name));\n  }\n\n  return retval !== undefined ? retval : item;\n}\n\nconst wrap = method => function (value, spec) {\n  const locale = this.context.dataflow.locale();\n  return locale[method](spec)(value);\n};\n\nconst format = wrap('format');\nconst timeFormat = wrap('timeFormat');\nconst utcFormat = wrap('utcFormat');\nconst timeParse = wrap('timeParse');\nconst utcParse = wrap('utcParse');\nconst dateObj = new Date(2000, 0, 1);\n\nfunction time(month, day, specifier) {\n  if (!Number.isInteger(month) || !Number.isInteger(day)) return '';\n  dateObj.setYear(2000);\n  dateObj.setMonth(month);\n  dateObj.setDate(day);\n  return timeFormat.call(this, dateObj, specifier);\n}\n\nfunction monthFormat(month) {\n  return time.call(this, month, 1, '%B');\n}\nfunction monthAbbrevFormat(month) {\n  return time.call(this, month, 1, '%b');\n}\nfunction dayFormat(day) {\n  return time.call(this, 0, 2 + day, '%A');\n}\nfunction dayAbbrevFormat(day) {\n  return time.call(this, 0, 2 + day, '%a');\n}\n\nconst DataPrefix = ':';\nconst IndexPrefix = '@';\nconst ScalePrefix = '%';\nconst SignalPrefix = '$';\n\nfunction dataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) {\n    error('First argument to data functions must be a string literal.');\n  }\n\n  const data = args[0].value,\n        dataName = DataPrefix + data;\n\n  if (!hasOwnProperty(dataName, params)) {\n    try {\n      params[dataName] = scope.getData(data).tuplesRef();\n    } catch (err) {// if data set does not exist, there's nothing to track\n    }\n  }\n}\nfunction indataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to indata must be a string literal.');\n  if (args[1].type !== Literal) error('Second argument to indata must be a string literal.');\n  const data = args[0].value,\n        field = args[1].value,\n        indexName = IndexPrefix + field;\n\n  if (!hasOwnProperty(indexName, params)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n}\nfunction scaleVisitor(name, args, scope, params) {\n  if (args[0].type === Literal) {\n    // add scale dependency\n    addScaleDependency(scope, params, args[0].value);\n  } else {\n    // indirect scale lookup; add all scales as parameters\n    for (name in scope.scales) {\n      addScaleDependency(scope, params, name);\n    }\n  }\n}\n\nfunction addScaleDependency(scope, params, name) {\n  const scaleName = ScalePrefix + name;\n\n  if (!hasOwnProperty(params, scaleName)) {\n    try {\n      params[scaleName] = scope.scaleRef(name);\n    } catch (err) {// TODO: error handling? warning?\n    }\n  }\n}\n\nfunction getScale(name, ctx) {\n  let s;\n  return isFunction(name) ? name : isString(name) ? (s = ctx.scales[name]) && s.value : undefined;\n}\nfunction internalScaleFunctions(codegen, fnctx, visitors) {\n  // add helper method to the 'this' expression function context\n  fnctx.__bandwidth = s => s && s.bandwidth ? s.bandwidth() : 0; // register AST visitors for internal scale functions\n\n\n  visitors._bandwidth = scaleVisitor;\n  visitors._range = scaleVisitor;\n  visitors._scale = scaleVisitor; // resolve scale reference directly to the signal hash argument\n\n  const ref = arg => '_[' + (arg.type === Literal ? stringValue(ScalePrefix + arg.value) : stringValue(ScalePrefix) + '+' + codegen(arg)) + ']'; // define and return internal scale function code generators\n  // these internal functions are called by mark encoders\n\n\n  return {\n    _bandwidth: args => \"this.__bandwidth(\".concat(ref(args[0]), \")\"),\n    _range: args => \"\".concat(ref(args[0]), \".range()\"),\n    _scale: args => \"\".concat(ref(args[0]), \"(\").concat(codegen(args[1]), \")\")\n  };\n}\n\nfunction geoMethod(methodName, globalMethod) {\n  return function (projection, geojson, group) {\n    if (projection) {\n      // projection defined, use it\n      const p = getScale(projection, (group || this).context);\n      return p && p.path[methodName](geojson);\n    } else {\n      // projection undefined, use global method\n      return globalMethod(geojson);\n    }\n  };\n}\n\nconst geoArea = geoMethod('area', geoArea$1);\nconst geoBounds = geoMethod('bounds', geoBounds$1);\nconst geoCentroid = geoMethod('centroid', geoCentroid$1);\n\nfunction inScope (item) {\n  const group = this.context.group;\n  let value = false;\n  if (group) while (item) {\n    if (item === group) {\n      value = true;\n      break;\n    }\n\n    item = item.mark.group;\n  }\n  return value;\n}\n\nfunction log(df, method, args) {\n  try {\n    df[method].apply(df, ['EXPRESSION'].concat([].slice.call(args)));\n  } catch (err) {\n    df.warn(err);\n  }\n\n  return args[args.length - 1];\n}\n\nfunction warn() {\n  return log(this.context.dataflow, 'warn', arguments);\n}\nfunction info() {\n  return log(this.context.dataflow, 'info', arguments);\n}\nfunction debug() {\n  return log(this.context.dataflow, 'debug', arguments);\n}\n\nfunction channel_luminance_value(channelValue) {\n  const val = channelValue / 255;\n\n  if (val <= 0.03928) {\n    return val / 12.92;\n  }\n\n  return Math.pow((val + 0.055) / 1.055, 2.4);\n}\n\nfunction luminance(color) {\n  const c = rgb(color),\n        r = channel_luminance_value(c.r),\n        g = channel_luminance_value(c.g),\n        b = channel_luminance_value(c.b);\n  return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n} // https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n\nfunction contrast(color1, color2) {\n  const lum1 = luminance(color1),\n        lum2 = luminance(color2),\n        lumL = Math.max(lum1, lum2),\n        lumD = Math.min(lum1, lum2);\n  return (lumL + 0.05) / (lumD + 0.05);\n}\n\nfunction merge () {\n  const args = [].slice.call(arguments);\n  args.unshift({});\n  return extend(...args);\n}\n\nfunction equal(a, b) {\n  return a === b || a !== a && b !== b ? true : isArray(a) ? isArray(b) && a.length === b.length ? equalArray(a, b) : false : isObject(a) && isObject(b) ? equalObject(a, b) : false;\n}\n\nfunction equalArray(a, b) {\n  for (let i = 0, n = a.length; i < n; ++i) {\n    if (!equal(a[i], b[i])) return false;\n  }\n\n  return true;\n}\n\nfunction equalObject(a, b) {\n  for (const key in a) {\n    if (!equal(a[key], b[key])) return false;\n  }\n\n  return true;\n}\n\nfunction removePredicate(props) {\n  return _ => equalObject(props, _);\n}\n\nfunction modify (name, insert, remove, toggle, modify, values) {\n  const df = this.context.dataflow,\n        data = this.context.data[name],\n        input = data.input,\n        stamp = df.stamp();\n  let changes = data.changes,\n      predicate,\n      key;\n\n  if (df._trigger === false || !(input.value.length || insert || toggle)) {\n    // nothing to do!\n    return 0;\n  }\n\n  if (!changes || changes.stamp < stamp) {\n    data.changes = changes = df.changeset();\n    changes.stamp = stamp;\n    df.runAfter(() => {\n      data.modified = true;\n      df.pulse(input, changes).run();\n    }, true, 1);\n  }\n\n  if (remove) {\n    predicate = remove === true ? truthy : isArray(remove) || isTuple(remove) ? remove : removePredicate(remove);\n    changes.remove(predicate);\n  }\n\n  if (insert) {\n    changes.insert(insert);\n  }\n\n  if (toggle) {\n    predicate = removePredicate(toggle);\n\n    if (input.value.some(predicate)) {\n      changes.remove(predicate);\n    } else {\n      changes.insert(toggle);\n    }\n  }\n\n  if (modify) {\n    for (key in values) {\n      changes.modify(modify, key, values[key]);\n    }\n  }\n\n  return 1;\n}\n\nfunction pinchDistance(event) {\n  const t = event.touches,\n        dx = t[0].clientX - t[1].clientX,\n        dy = t[0].clientY - t[1].clientY;\n  return Math.sqrt(dx * dx + dy * dy);\n}\nfunction pinchAngle(event) {\n  const t = event.touches;\n  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);\n}\n\nconst accessors = {};\nfunction pluck (data, name) {\n  const accessor = accessors[name] || (accessors[name] = field(name));\n  return isArray(data) ? data.map(accessor) : accessor(data);\n}\n\nfunction array(seq) {\n  return isArray(seq) || ArrayBuffer.isView(seq) ? seq : null;\n}\n\nfunction sequence(seq) {\n  return array(seq) || (isString(seq) ? seq : null);\n}\n\nfunction join(seq) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return array(seq).join(...args);\n}\nfunction indexof(seq) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  return sequence(seq).indexOf(...args);\n}\nfunction lastindexof(seq) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n\n  return sequence(seq).lastIndexOf(...args);\n}\nfunction slice(seq) {\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n\n  return sequence(seq).slice(...args);\n}\nfunction replace(str, pattern, repl) {\n  if (isFunction(repl)) error('Function argument passed to replace.');\n  return String(str).replace(pattern, repl);\n}\nfunction reverse(seq) {\n  return array(seq).slice().reverse();\n}\n\nfunction bandspace(count, paddingInner, paddingOuter) {\n  return bandSpace(count || 0, paddingInner || 0, paddingOuter || 0);\n}\nfunction bandwidth(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s && s.bandwidth ? s.bandwidth() : 0;\n}\nfunction copy(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s.copy() : undefined;\n}\nfunction domain(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s.domain() : [];\n}\nfunction invert(name, range, group) {\n  const s = getScale(name, (group || this).context);\n  return !s ? undefined : isArray(range) ? (s.invertRange || s.invert)(range) : (s.invert || s.invertExtent)(range);\n}\nfunction range(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s && s.range ? s.range() : [];\n}\nfunction scale(name, value, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s(value) : undefined;\n}\n\nfunction scaleGradient (scale, p0, p1, count, group) {\n  scale = getScale(scale, (group || this).context);\n  const gradient = Gradient(p0, p1);\n  let stops = scale.domain(),\n      min = stops[0],\n      max = peek(stops),\n      fraction = identity;\n\n  if (!(max - min)) {\n    // expand scale if domain has zero span, fix #1479\n    scale = (scale.interpolator ? scale$1('sequential')().interpolator(scale.interpolator()) : scale$1('linear')().interpolate(scale.interpolate()).range(scale.range())).domain([min = 0, max = 1]);\n  } else {\n    fraction = scaleFraction(scale, min, max);\n  }\n\n  if (scale.ticks) {\n    stops = scale.ticks(+count || 15);\n    if (min !== stops[0]) stops.unshift(min);\n    if (max !== peek(stops)) stops.push(max);\n  }\n\n  stops.forEach(_ => gradient.stop(fraction(_), scale(_)));\n  return gradient;\n}\n\nfunction geoShape(projection, geojson, group) {\n  const p = getScale(projection, (group || this).context);\n  return function (context) {\n    return p ? p.path.context(context)(geojson) : '';\n  };\n}\nfunction pathShape(path) {\n  let p = null;\n  return function (context) {\n    return context ? pathRender(context, p = p || pathParse(path)) : path;\n  };\n}\n\nconst datum = d => d.data;\n\nfunction treeNodes(name, context) {\n  const tree = data.call(context, name);\n  return tree.root && tree.root.lookup || {};\n}\n\nfunction treePath(name, source, target) {\n  const nodes = treeNodes(name, this),\n        s = nodes[source],\n        t = nodes[target];\n  return s && t ? s.path(t).map(datum) : undefined;\n}\nfunction treeAncestors(name, node) {\n  const n = treeNodes(name, this)[node];\n  return n ? n.ancestors().map(datum) : undefined;\n}\n\nconst _window = () => typeof window !== 'undefined' && window || null;\n\nfunction screen() {\n  const w = _window();\n\n  return w ? w.screen : {};\n}\nfunction windowSize() {\n  const w = _window();\n\n  return w ? [w.innerWidth, w.innerHeight] : [undefined, undefined];\n}\nfunction containerSize() {\n  const view = this.context.dataflow,\n        el = view.container && view.container();\n  return el ? [el.clientWidth, el.clientHeight] : [undefined, undefined];\n}\n\nfunction intersect (b, opt, group) {\n  if (!b) return [];\n  const [u, v] = b,\n        box = new Bounds().set(u[0], u[1], v[0], v[1]),\n        scene = group || this.context.dataflow.scenegraph().root;\n  return intersect$1(scene, box, filter(opt));\n}\n\nfunction filter(opt) {\n  let p = null;\n\n  if (opt) {\n    const types = array$1(opt.marktype),\n          names = array$1(opt.markname);\n\n    p = _ => (!types.length || types.some(t => _.marktype === t)) && (!names.length || names.some(s => _.name === s));\n  }\n\n  return p;\n}\n\n/**\n * Appends a new point to the lasso\n * \n * @param {*} lasso the lasso in pixel space\n * @param {*} x the x coordinate in pixel space\n * @param {*} y the y coordinate in pixel space\n * @param {*} minDist the minimum distance, in pixels, that thenew point needs to be apart from the last point\n * @returns a new array containing the lasso with the new point\n */\n\nfunction lassoAppend(lasso, x, y) {\n  let minDist = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;\n  const last = lasso[lasso.length - 1]; // Add point to lasso if distance to last point exceed minDist or its the first point\n\n  if (last === undefined || Math.sqrt((last[0] - x) ** 2 + (last[1] - y) ** 2) > minDist) {\n    lasso.push([x, y]);\n    return [...lasso];\n  }\n\n  return lasso;\n}\n/**\n * Generates a svg path command which draws a lasso\n * \n * @param {*} lasso the lasso in pixel space in the form [[x,y], [x,y], ...]\n * @returns the svg path command that draws the lasso\n */\n\nfunction lassoPath(lasso) {\n  return (lasso !== null && lasso !== void 0 ? lasso : []).reduce((svg, _ref, i) => {\n    let [x, y] = _ref;\n    return svg += i == 0 ? \"M \".concat(x, \",\").concat(y, \" \") : i === lasso.length - 1 ? ' Z' : \"L \".concat(x, \",\").concat(y, \" \");\n  }, '');\n}\n/**\n * Inverts the lasso from pixel space to an array of vega scenegraph tuples\n * \n * @param {*} data the dataset\n * @param {*} pixelLasso the lasso in pixel space, [[x,y], [x,y], ...]\n * @param {*} unit the unit where the lasso is defined\n * \n * @returns an array of vega scenegraph tuples\n */\n\nfunction intersectLasso(markname, pixelLasso, unit) {\n  const {\n    x,\n    y,\n    mark\n  } = unit;\n  const bb = new Bounds().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER); // Get bounding box around lasso\n\n  for (const [px, py] of pixelLasso) {\n    if (px < bb.x1) bb.x1 = px;\n    if (px > bb.x2) bb.x2 = px;\n    if (py < bb.y1) bb.y1 = py;\n    if (py > bb.y2) bb.y2 = py;\n  } // Translate bb against unit coordinates\n\n\n  bb.translate(x, y);\n  const intersection = intersect([[bb.x1, bb.y1], [bb.x2, bb.y2]], markname, mark); // Check every point against the lasso\n\n  return intersection.filter(tuple => pointInPolygon(tuple.x, tuple.y, pixelLasso));\n}\n/**\n * Performs a test if a point is inside a polygon based on the idea from\n * https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\n * \n * This method will not need the same start/end point since it wraps around the edges of the array\n * \n * @param {*} test a point to test against\n * @param {*} polygon a polygon in the form [[x,y], [x,y], ...]\n * @returns true if the point lies inside the polygon, false otherwise\n */\n\nfunction pointInPolygon(testx, testy, polygon) {\n  let intersections = 0;\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const [prevX, prevY] = polygon[j];\n    const [x, y] = polygon[i]; // count intersections\n\n    if (y > testy != prevY > testy && testx < (prevX - x) * (testy - y) / (prevY - y) + x) {\n      intersections++;\n    }\n  } // point is in polygon if intersection count is odd\n\n\n  return intersections & 1;\n}\n\nconst functionContext = {\n  random() {\n    return random();\n  },\n\n  // override default\n  cumulativeNormal,\n  cumulativeLogNormal,\n  cumulativeUniform,\n  densityNormal,\n  densityLogNormal,\n  densityUniform,\n  quantileNormal,\n  quantileLogNormal,\n  quantileUniform,\n  sampleNormal,\n  sampleLogNormal,\n  sampleUniform,\n  isArray,\n  isBoolean,\n  isDate,\n\n  isDefined(_) {\n    return _ !== undefined;\n  },\n\n  isNumber,\n  isObject,\n  isRegExp,\n  isString,\n  isTuple,\n\n  isValid(_) {\n    return _ != null && _ === _;\n  },\n\n  toBoolean,\n\n  toDate(_) {\n    return toDate(_);\n  },\n\n  // suppress extra arguments\n  toNumber,\n  toString,\n  indexof,\n  join,\n  lastindexof,\n  replace,\n  reverse,\n  slice,\n  flush,\n  lerp,\n  merge,\n  pad,\n  peek,\n  pluck,\n  span,\n  inrange,\n  truncate,\n  rgb,\n  lab,\n  hcl,\n  hsl,\n  luminance,\n  contrast,\n  sequence: range$1,\n  format,\n  utcFormat,\n  utcParse,\n  utcOffset,\n  utcSequence,\n  timeFormat,\n  timeParse,\n  timeOffset,\n  timeSequence,\n  timeUnitSpecifier,\n  monthFormat,\n  monthAbbrevFormat,\n  dayFormat,\n  dayAbbrevFormat,\n  quarter,\n  utcquarter,\n  week,\n  utcweek,\n  dayofyear,\n  utcdayofyear,\n  warn,\n  info,\n  debug,\n\n  extent(_) {\n    return extent(_);\n  },\n\n  // suppress extra arguments\n  inScope,\n  intersect,\n  clampRange,\n  pinchDistance,\n  pinchAngle,\n  screen,\n  containerSize,\n  windowSize,\n  bandspace,\n  setdata,\n  pathShape,\n  panLinear,\n  panLog,\n  panPow,\n  panSymlog,\n  zoomLinear,\n  zoomLog,\n  zoomPow,\n  zoomSymlog,\n  encode,\n  modify,\n  lassoAppend,\n  lassoPath,\n  intersectLasso\n};\nconst eventFunctions = ['view', 'item', 'group', 'xy', 'x', 'y'],\n      // event functions\neventPrefix = 'event.vega.',\n      // event function prefix\nthisPrefix = 'this.',\n      // function context prefix\nastVisitors = {}; // AST visitors for dependency analysis\n// export code generator parameters\n\nconst codegenParams = {\n  forbidden: ['_'],\n  allowed: ['datum', 'event', 'item'],\n  fieldvar: 'datum',\n  globalvar: id => \"_[\".concat(stringValue(SignalPrefix + id), \"]\"),\n  functions: buildFunctions,\n  constants: constants,\n  visitors: astVisitors\n}; // export code generator\n\nconst codeGenerator = codegenExpression(codegenParams); // Build expression function registry\n\nfunction buildFunctions(codegen) {\n  const fn = functions(codegen);\n  eventFunctions.forEach(name => fn[name] = eventPrefix + name);\n\n  for (const name in functionContext) {\n    fn[name] = thisPrefix + name;\n  }\n\n  extend(fn, internalScaleFunctions(codegen, functionContext, astVisitors));\n  return fn;\n} // Register an expression function\n\n\nfunction expressionFunction(name, fn, visitor) {\n  if (arguments.length === 1) {\n    return functionContext[name];\n  } // register with the functionContext\n\n\n  functionContext[name] = fn; // if there is an astVisitor register that, too\n\n  if (visitor) astVisitors[name] = visitor; // if the code generator has already been initialized,\n  // we need to also register the function with it\n\n  if (codeGenerator) codeGenerator.functions[name] = thisPrefix + name;\n  return this;\n} // register expression functions with ast visitors\n\nexpressionFunction('bandwidth', bandwidth, scaleVisitor);\nexpressionFunction('copy', copy, scaleVisitor);\nexpressionFunction('domain', domain, scaleVisitor);\nexpressionFunction('range', range, scaleVisitor);\nexpressionFunction('invert', invert, scaleVisitor);\nexpressionFunction('scale', scale, scaleVisitor);\nexpressionFunction('gradient', scaleGradient, scaleVisitor);\nexpressionFunction('geoArea', geoArea, scaleVisitor);\nexpressionFunction('geoBounds', geoBounds, scaleVisitor);\nexpressionFunction('geoCentroid', geoCentroid, scaleVisitor);\nexpressionFunction('geoShape', geoShape, scaleVisitor);\nexpressionFunction('indata', indata, indataVisitor);\nexpressionFunction('data', data, dataVisitor);\nexpressionFunction('treePath', treePath, dataVisitor);\nexpressionFunction('treeAncestors', treeAncestors, dataVisitor); // register Vega-Lite selection functions\n\nexpressionFunction('vlSelectionTest', selectionTest, selectionVisitor);\nexpressionFunction('vlSelectionIdTest', selectionIdTest, selectionVisitor);\nexpressionFunction('vlSelectionResolve', selectionResolve, selectionVisitor);\nexpressionFunction('vlSelectionTuples', selectionTuples);\n\nfunction parser (expr, scope) {\n  const params = {}; // parse the expression to an abstract syntax tree (ast)\n\n  let ast;\n\n  try {\n    expr = isString(expr) ? expr : stringValue(expr) + '';\n    ast = parseExpression(expr);\n  } catch (err) {\n    error('Expression parse error: ' + expr);\n  } // analyze ast function calls for dependencies\n\n\n  ast.visit(node => {\n    if (node.type !== CallExpression) return;\n    const name = node.callee.name,\n          visit = codegenParams.visitors[name];\n    if (visit) visit(name, node.arguments, scope, params);\n  }); // perform code generation\n\n  const gen = codeGenerator(ast); // collect signal dependencies\n\n  gen.globals.forEach(name => {\n    const signalName = SignalPrefix + name;\n\n    if (!hasOwnProperty(params, signalName) && scope.getSignal(name)) {\n      params[signalName] = scope.signalRef(name);\n    }\n  }); // return generated expression code and dependencies\n\n  return {\n    $expr: extend({\n      code: gen.code\n    }, scope.options.ast ? {\n      ast\n    } : null),\n    $fields: gen.fields,\n    $params: params\n  };\n}\n\nexport { DataPrefix, IndexPrefix, ScalePrefix, SignalPrefix, bandspace, bandwidth, codeGenerator, codegenParams, containerSize, contrast, copy, data, dataVisitor, dayAbbrevFormat, dayFormat, debug, domain, encode, expressionFunction, format, functionContext, geoArea, geoBounds, geoCentroid, geoShape, inScope, indata, indataVisitor, indexof, info, invert, join, lastindexof, luminance, merge, modify, monthAbbrevFormat, monthFormat, parser as parseExpression, pathShape, pinchAngle, pinchDistance, pluck, range, replace, reverse, scale, scaleGradient, scaleVisitor, screen, setdata, slice, timeFormat, timeParse, treeAncestors, treePath, utcFormat, utcParse, warn, windowSize };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}