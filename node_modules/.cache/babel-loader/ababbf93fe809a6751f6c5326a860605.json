{"ast":null,"code":"import { bisector, union, intersection } from 'd3-array';\nimport { field, isDate, toNumber, isArray, inrange, extend, array, error, peek, hasOwnProperty } from 'vega-util';\nimport { Literal } from 'vega-expression';\nconst Intersect = 'intersect';\nconst Union = 'union';\nconst VlMulti = 'vlMulti';\nconst VlPoint = 'vlPoint';\nconst Or = 'or';\nconst And = 'and';\nconst SelectionId = '_vgsid_';\nconst $selectionId = field(SelectionId);\nconst TYPE_ENUM = 'E',\n      TYPE_RANGE_INC = 'R',\n      TYPE_RANGE_EXC = 'R-E',\n      TYPE_RANGE_LE = 'R-LE',\n      TYPE_RANGE_RE = 'R-RE',\n      UNIT_INDEX = 'index:unit'; // TODO: revisit date coercion?\n\nfunction testPoint(datum, entry) {\n  var fields = entry.fields,\n      values = entry.values,\n      n = fields.length,\n      i = 0,\n      dval,\n      f;\n\n  for (; i < n; ++i) {\n    f = fields[i];\n    f.getter = field.getter || field(f.field);\n    dval = f.getter(datum);\n    if (isDate(dval)) dval = toNumber(dval);\n    if (isDate(values[i])) values[i] = toNumber(values[i]);\n    if (isDate(values[i][0])) values[i] = values[i].map(toNumber);\n\n    if (f.type === TYPE_ENUM) {\n      // Enumerated fields can either specify individual values (single/multi selections)\n      // or an array of values (interval selections).\n      if (isArray(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {\n        return false;\n      }\n    } else {\n      if (f.type === TYPE_RANGE_INC) {\n        if (!inrange(dval, values[i])) return false;\n      } else if (f.type === TYPE_RANGE_RE) {\n        // Discrete selection of bins test within the range [bin_start, bin_end).\n        if (!inrange(dval, values[i], true, false)) return false;\n      } else if (f.type === TYPE_RANGE_EXC) {\n        // 'R-E'/'R-LE' included for completeness.\n        if (!inrange(dval, values[i], false, false)) return false;\n      } else if (f.type === TYPE_RANGE_LE) {\n        if (!inrange(dval, values[i], false, true)) return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Tests if a tuple is contained within an interactive selection.\n * @param {string} name - The name of the data set representing the selection.\n *  Tuples in the dataset are of the form\n *  {unit: string, fields: array<fielddef>, values: array<*>}.\n *  Fielddef is of the form\n *  {field: string, channel: string, type: 'E' | 'R'} where\n *  'type' identifies whether tuples in the dataset enumerate\n *  values for the field, or specify a continuous range.\n * @param {object} datum - The tuple to test for inclusion.\n * @param {string} op - The set operation for combining selections.\n *   One of 'intersect' or 'union' (default).\n * @return {boolean} - True if the datum is in the selection, false otherwise.\n */\n\n\nfunction selectionTest(name, datum, op) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      n = entries.length,\n      i = 0,\n      entry,\n      miss,\n      count,\n      unit,\n      b;\n\n  for (; i < n; ++i) {\n    entry = entries[i];\n\n    if (unitIdx && intersect) {\n      // multi selections union within the same unit and intersect across units.\n      miss = miss || {};\n      count = miss[unit = entry.unit] || 0; // if we've already matched this unit, skip.\n\n      if (count === -1) continue;\n      b = testPoint(datum, entry);\n      miss[unit] = b ? -1 : ++count; // if we match and there are no other units return true\n      // if we've missed against all tuples in this unit return false\n\n      if (b && unitIdx.size === 1) return true;\n      if (!b && count === unitIdx.get(unit).count) return false;\n    } else {\n      b = testPoint(datum, entry); // if we find a miss and we do require intersection return false\n      // if we find a match and we don't require intersection return true\n\n      if (intersect ^ b) return b;\n    }\n  } // if intersecting and we made it here, then we saw no misses\n  // if not intersecting, then we saw no matches\n  // if no active selections, return false\n\n\n  return n && intersect;\n}\n\nconst bisect = bisector($selectionId),\n      bisectLeft = bisect.left,\n      bisectRight = bisect.right;\n\nfunction selectionIdTest(name, datum, op) {\n  const data = this.context.data[name],\n        entries = data ? data.values.value : [],\n        unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n        intersect = op === Intersect,\n        value = $selectionId(datum),\n        index = bisectLeft(entries, value);\n  if (index === entries.length) return false;\n  if ($selectionId(entries[index]) !== value) return false;\n\n  if (unitIdx && intersect) {\n    if (unitIdx.size === 1) return true;\n    if (bisectRight(entries, value) - index < unitIdx.size) return false;\n  }\n\n  return true;\n}\n/**\n * Maps an array of scene graph items to an array of selection tuples.\n * @param {string} name  - The name of the dataset representing the selection.\n * @param {string} base  - The base object that generated tuples extend.\n *\n * @returns {array} An array of selection entries for the given unit.\n */\n\n\nfunction selectionTuples(array, base) {\n  return array.map(x => extend(base.fields ? {\n    values: base.fields.map(f => (f.getter || (f.getter = field(f.field)))(x.datum))\n  } : {\n    [SelectionId]: $selectionId(x.datum)\n  }, base));\n}\n/**\n * Resolves selection for use as a scale domain or reads via the API.\n * @param {string} name - The name of the dataset representing the selection\n * @param {string} [op='union'] - The set operation for combining selections.\n *                 One of 'intersect' or 'union' (default).\n * @param {boolean} isMulti - Identifies a \"multi\" selection to perform more\n *                 expensive resolution computation.\n * @param {boolean} vl5 - With Vega-Lite v5, \"multi\" selections are now called \"point\"\n *                 selections, and thus the resolved tuple should reflect this name.\n *                 This parameter allows us to reflect this change without triggering\n *                 a major version bump for Vega.\n * @returns {object} An object of selected fields and values.\n */\n\n\nfunction selectionResolve(name, op, isMulti, vl5) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      resolved = {},\n      multiRes = {},\n      types = {},\n      entry,\n      fields,\n      values,\n      unit,\n      field,\n      value,\n      res,\n      resUnit,\n      type,\n      union,\n      n = entries.length,\n      i = 0,\n      j,\n      m; // First union all entries within the same unit.\n\n  for (; i < n; ++i) {\n    entry = entries[i];\n    unit = entry.unit;\n    fields = entry.fields;\n    values = entry.values;\n\n    if (fields && values) {\n      // Intentional selection stores\n      for (j = 0, m = fields.length; j < m; ++j) {\n        field = fields[j];\n        res = resolved[field.field] || (resolved[field.field] = {});\n        resUnit = res[unit] || (res[unit] = []);\n        types[field.field] = type = field.type.charAt(0);\n        union = ops[\"\".concat(type, \"_union\")];\n        res[unit] = union(resUnit, array(values[j]));\n      } // If the same multi-selection is repeated over views and projected over\n      // an encoding, it may operate over different fields making it especially\n      // tricky to reliably resolve it. At best, we can de-dupe identical entries\n      // but doing so may be more computationally expensive than it is worth.\n      // Instead, for now, we simply transform our store representation into\n      // a more human-friendly one.\n\n\n      if (isMulti) {\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\n        resUnit.push(array(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));\n      }\n    } else {\n      // Short circuit extensional selectionId stores which hold sorted IDs unique to each unit.\n      field = SelectionId;\n      value = $selectionId(entry);\n      res = resolved[field] || (resolved[field] = {});\n      resUnit = res[unit] || (res[unit] = []);\n      resUnit.push(value);\n\n      if (isMulti) {\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\n        resUnit.push({\n          [SelectionId]: value\n        });\n      }\n    }\n  } // Then resolve fields across units as per the op.\n\n\n  op = op || Union;\n\n  if (resolved[SelectionId]) {\n    resolved[SelectionId] = ops[\"\".concat(SelectionId, \"_\").concat(op)](...Object.values(resolved[SelectionId]));\n  } else {\n    Object.keys(resolved).forEach(field => {\n      resolved[field] = Object.keys(resolved[field]).map(unit => resolved[field][unit]).reduce((acc, curr) => acc === undefined ? curr : ops[\"\".concat(types[field], \"_\").concat(op)](acc, curr));\n    });\n  }\n\n  entries = Object.keys(multiRes);\n\n  if (isMulti && entries.length) {\n    const key = vl5 ? VlPoint : VlMulti;\n    resolved[key] = op === Union ? {\n      [Or]: entries.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])\n    } : {\n      [And]: entries.map(k => ({\n        [Or]: multiRes[k]\n      }))\n    };\n  }\n\n  return resolved;\n}\n\nvar ops = {\n  [\"\".concat(SelectionId, \"_union\")]: union,\n  [\"\".concat(SelectionId, \"_intersect\")]: intersection,\n  E_union: function (base, value) {\n    if (!base.length) return value;\n    var i = 0,\n        n = value.length;\n\n    for (; i < n; ++i) if (base.indexOf(value[i]) < 0) base.push(value[i]);\n\n    return base;\n  },\n  E_intersect: function (base, value) {\n    return !base.length ? value : base.filter(v => value.indexOf(v) >= 0);\n  },\n  R_union: function (base, value) {\n    var lo = toNumber(value[0]),\n        hi = toNumber(value[1]);\n\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (base[0] > lo) base[0] = lo;\n    if (base[1] < hi) base[1] = hi;\n    return base;\n  },\n  R_intersect: function (base, value) {\n    var lo = toNumber(value[0]),\n        hi = toNumber(value[1]);\n\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n\n    if (hi < base[0] || base[1] < lo) {\n      return [];\n    } else {\n      if (base[0] < lo) base[0] = lo;\n      if (base[1] > hi) base[1] = hi;\n    }\n\n    return base;\n  }\n};\nconst DataPrefix = ':',\n      IndexPrefix = '@';\n\nfunction selectionVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to selection functions must be a string literal.');\n  const data = args[0].value,\n        op = args.length >= 2 && peek(args).value,\n        field = 'unit',\n        indexName = IndexPrefix + field,\n        dataName = DataPrefix + data; // eslint-disable-next-line no-prototype-builtins\n\n  if (op === Intersect && !hasOwnProperty(params, indexName)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  } // eslint-disable-next-line no-prototype-builtins\n\n\n  if (!hasOwnProperty(params, dataName)) {\n    params[dataName] = scope.getData(data).tuplesRef();\n  }\n}\n\nexport { selectionIdTest, selectionResolve, selectionTest, selectionTuples, selectionVisitor };","map":{"version":3,"names":["bisector","union","intersection","field","isDate","toNumber","isArray","inrange","extend","array","error","peek","hasOwnProperty","Literal","Intersect","Union","VlMulti","VlPoint","Or","And","SelectionId","$selectionId","TYPE_ENUM","TYPE_RANGE_INC","TYPE_RANGE_EXC","TYPE_RANGE_LE","TYPE_RANGE_RE","UNIT_INDEX","testPoint","datum","entry","fields","values","n","length","i","dval","f","getter","map","type","indexOf","selectionTest","name","op","data","context","entries","value","unitIdx","undefined","intersect","miss","count","unit","b","size","get","bisect","bisectLeft","left","bisectRight","right","selectionIdTest","index","selectionTuples","base","x","selectionResolve","isMulti","vl5","resolved","multiRes","types","res","resUnit","j","m","charAt","ops","concat","push","reduce","obj","curr","Object","keys","forEach","acc","key","k","E_union","E_intersect","filter","v","R_union","lo","hi","R_intersect","DataPrefix","IndexPrefix","selectionVisitor","args","scope","params","indexName","dataName","getData","indataRef","tuplesRef"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-selections/build/vega-selection.module.js"],"sourcesContent":["import { bisector, union, intersection } from 'd3-array';\nimport { field, isDate, toNumber, isArray, inrange, extend, array, error, peek, hasOwnProperty } from 'vega-util';\nimport { Literal } from 'vega-expression';\n\nconst Intersect = 'intersect';\nconst Union = 'union';\nconst VlMulti = 'vlMulti';\nconst VlPoint = 'vlPoint';\nconst Or = 'or';\nconst And = 'and';\nconst SelectionId = '_vgsid_';\nconst $selectionId = field(SelectionId);\n\nconst TYPE_ENUM = 'E',\n      TYPE_RANGE_INC = 'R',\n      TYPE_RANGE_EXC = 'R-E',\n      TYPE_RANGE_LE = 'R-LE',\n      TYPE_RANGE_RE = 'R-RE',\n      UNIT_INDEX = 'index:unit'; // TODO: revisit date coercion?\n\nfunction testPoint(datum, entry) {\n  var fields = entry.fields,\n      values = entry.values,\n      n = fields.length,\n      i = 0,\n      dval,\n      f;\n\n  for (; i < n; ++i) {\n    f = fields[i];\n    f.getter = field.getter || field(f.field);\n    dval = f.getter(datum);\n    if (isDate(dval)) dval = toNumber(dval);\n    if (isDate(values[i])) values[i] = toNumber(values[i]);\n    if (isDate(values[i][0])) values[i] = values[i].map(toNumber);\n\n    if (f.type === TYPE_ENUM) {\n      // Enumerated fields can either specify individual values (single/multi selections)\n      // or an array of values (interval selections).\n      if (isArray(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {\n        return false;\n      }\n    } else {\n      if (f.type === TYPE_RANGE_INC) {\n        if (!inrange(dval, values[i])) return false;\n      } else if (f.type === TYPE_RANGE_RE) {\n        // Discrete selection of bins test within the range [bin_start, bin_end).\n        if (!inrange(dval, values[i], true, false)) return false;\n      } else if (f.type === TYPE_RANGE_EXC) {\n        // 'R-E'/'R-LE' included for completeness.\n        if (!inrange(dval, values[i], false, false)) return false;\n      } else if (f.type === TYPE_RANGE_LE) {\n        if (!inrange(dval, values[i], false, true)) return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Tests if a tuple is contained within an interactive selection.\n * @param {string} name - The name of the data set representing the selection.\n *  Tuples in the dataset are of the form\n *  {unit: string, fields: array<fielddef>, values: array<*>}.\n *  Fielddef is of the form\n *  {field: string, channel: string, type: 'E' | 'R'} where\n *  'type' identifies whether tuples in the dataset enumerate\n *  values for the field, or specify a continuous range.\n * @param {object} datum - The tuple to test for inclusion.\n * @param {string} op - The set operation for combining selections.\n *   One of 'intersect' or 'union' (default).\n * @return {boolean} - True if the datum is in the selection, false otherwise.\n */\n\n\nfunction selectionTest(name, datum, op) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      n = entries.length,\n      i = 0,\n      entry,\n      miss,\n      count,\n      unit,\n      b;\n\n  for (; i < n; ++i) {\n    entry = entries[i];\n\n    if (unitIdx && intersect) {\n      // multi selections union within the same unit and intersect across units.\n      miss = miss || {};\n      count = miss[unit = entry.unit] || 0; // if we've already matched this unit, skip.\n\n      if (count === -1) continue;\n      b = testPoint(datum, entry);\n      miss[unit] = b ? -1 : ++count; // if we match and there are no other units return true\n      // if we've missed against all tuples in this unit return false\n\n      if (b && unitIdx.size === 1) return true;\n      if (!b && count === unitIdx.get(unit).count) return false;\n    } else {\n      b = testPoint(datum, entry); // if we find a miss and we do require intersection return false\n      // if we find a match and we don't require intersection return true\n\n      if (intersect ^ b) return b;\n    }\n  } // if intersecting and we made it here, then we saw no misses\n  // if not intersecting, then we saw no matches\n  // if no active selections, return false\n\n\n  return n && intersect;\n}\nconst bisect = bisector($selectionId),\n      bisectLeft = bisect.left,\n      bisectRight = bisect.right;\nfunction selectionIdTest(name, datum, op) {\n  const data = this.context.data[name],\n        entries = data ? data.values.value : [],\n        unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n        intersect = op === Intersect,\n        value = $selectionId(datum),\n        index = bisectLeft(entries, value);\n  if (index === entries.length) return false;\n  if ($selectionId(entries[index]) !== value) return false;\n\n  if (unitIdx && intersect) {\n    if (unitIdx.size === 1) return true;\n    if (bisectRight(entries, value) - index < unitIdx.size) return false;\n  }\n\n  return true;\n}\n\n/**\n * Maps an array of scene graph items to an array of selection tuples.\n * @param {string} name  - The name of the dataset representing the selection.\n * @param {string} base  - The base object that generated tuples extend.\n *\n * @returns {array} An array of selection entries for the given unit.\n */\n\nfunction selectionTuples(array, base) {\n  return array.map(x => extend(base.fields ? {\n    values: base.fields.map(f => (f.getter || (f.getter = field(f.field)))(x.datum))\n  } : {\n    [SelectionId]: $selectionId(x.datum)\n  }, base));\n}\n\n/**\n * Resolves selection for use as a scale domain or reads via the API.\n * @param {string} name - The name of the dataset representing the selection\n * @param {string} [op='union'] - The set operation for combining selections.\n *                 One of 'intersect' or 'union' (default).\n * @param {boolean} isMulti - Identifies a \"multi\" selection to perform more\n *                 expensive resolution computation.\n * @param {boolean} vl5 - With Vega-Lite v5, \"multi\" selections are now called \"point\"\n *                 selections, and thus the resolved tuple should reflect this name.\n *                 This parameter allows us to reflect this change without triggering\n *                 a major version bump for Vega.\n * @returns {object} An object of selected fields and values.\n */\n\nfunction selectionResolve(name, op, isMulti, vl5) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      resolved = {},\n      multiRes = {},\n      types = {},\n      entry,\n      fields,\n      values,\n      unit,\n      field,\n      value,\n      res,\n      resUnit,\n      type,\n      union,\n      n = entries.length,\n      i = 0,\n      j,\n      m; // First union all entries within the same unit.\n\n  for (; i < n; ++i) {\n    entry = entries[i];\n    unit = entry.unit;\n    fields = entry.fields;\n    values = entry.values;\n\n    if (fields && values) {\n      // Intentional selection stores\n      for (j = 0, m = fields.length; j < m; ++j) {\n        field = fields[j];\n        res = resolved[field.field] || (resolved[field.field] = {});\n        resUnit = res[unit] || (res[unit] = []);\n        types[field.field] = type = field.type.charAt(0);\n        union = ops[\"\".concat(type, \"_union\")];\n        res[unit] = union(resUnit, array(values[j]));\n      } // If the same multi-selection is repeated over views and projected over\n      // an encoding, it may operate over different fields making it especially\n      // tricky to reliably resolve it. At best, we can de-dupe identical entries\n      // but doing so may be more computationally expensive than it is worth.\n      // Instead, for now, we simply transform our store representation into\n      // a more human-friendly one.\n\n\n      if (isMulti) {\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\n        resUnit.push(array(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));\n      }\n    } else {\n      // Short circuit extensional selectionId stores which hold sorted IDs unique to each unit.\n      field = SelectionId;\n      value = $selectionId(entry);\n      res = resolved[field] || (resolved[field] = {});\n      resUnit = res[unit] || (res[unit] = []);\n      resUnit.push(value);\n\n      if (isMulti) {\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\n        resUnit.push({\n          [SelectionId]: value\n        });\n      }\n    }\n  } // Then resolve fields across units as per the op.\n\n\n  op = op || Union;\n\n  if (resolved[SelectionId]) {\n    resolved[SelectionId] = ops[\"\".concat(SelectionId, \"_\").concat(op)](...Object.values(resolved[SelectionId]));\n  } else {\n    Object.keys(resolved).forEach(field => {\n      resolved[field] = Object.keys(resolved[field]).map(unit => resolved[field][unit]).reduce((acc, curr) => acc === undefined ? curr : ops[\"\".concat(types[field], \"_\").concat(op)](acc, curr));\n    });\n  }\n\n  entries = Object.keys(multiRes);\n\n  if (isMulti && entries.length) {\n    const key = vl5 ? VlPoint : VlMulti;\n    resolved[key] = op === Union ? {\n      [Or]: entries.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])\n    } : {\n      [And]: entries.map(k => ({\n        [Or]: multiRes[k]\n      }))\n    };\n  }\n\n  return resolved;\n}\nvar ops = {\n  [\"\".concat(SelectionId, \"_union\")]: union,\n  [\"\".concat(SelectionId, \"_intersect\")]: intersection,\n  E_union: function (base, value) {\n    if (!base.length) return value;\n    var i = 0,\n        n = value.length;\n\n    for (; i < n; ++i) if (base.indexOf(value[i]) < 0) base.push(value[i]);\n\n    return base;\n  },\n  E_intersect: function (base, value) {\n    return !base.length ? value : base.filter(v => value.indexOf(v) >= 0);\n  },\n  R_union: function (base, value) {\n    var lo = toNumber(value[0]),\n        hi = toNumber(value[1]);\n\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (base[0] > lo) base[0] = lo;\n    if (base[1] < hi) base[1] = hi;\n    return base;\n  },\n  R_intersect: function (base, value) {\n    var lo = toNumber(value[0]),\n        hi = toNumber(value[1]);\n\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n\n    if (hi < base[0] || base[1] < lo) {\n      return [];\n    } else {\n      if (base[0] < lo) base[0] = lo;\n      if (base[1] > hi) base[1] = hi;\n    }\n\n    return base;\n  }\n};\n\nconst DataPrefix = ':',\n      IndexPrefix = '@';\nfunction selectionVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to selection functions must be a string literal.');\n  const data = args[0].value,\n        op = args.length >= 2 && peek(args).value,\n        field = 'unit',\n        indexName = IndexPrefix + field,\n        dataName = DataPrefix + data; // eslint-disable-next-line no-prototype-builtins\n\n  if (op === Intersect && !hasOwnProperty(params, indexName)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  } // eslint-disable-next-line no-prototype-builtins\n\n\n  if (!hasOwnProperty(params, dataName)) {\n    params[dataName] = scope.getData(data).tuplesRef();\n  }\n}\n\nexport { selectionIdTest, selectionResolve, selectionTest, selectionTuples, selectionVisitor };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}