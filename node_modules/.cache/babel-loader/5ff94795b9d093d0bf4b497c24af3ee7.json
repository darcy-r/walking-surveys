{"ast":null,"code":"import { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel } from '../../../channel';\nimport { isFieldOrDatumDef } from '../../../channeldef';\nimport * as log from '../../../log';\nimport { isRelativeBandSize } from '../../../mark';\nimport { getMarkStyleConfig } from '../../common';\nimport { positionOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPosition, pointPositionDefaultRef } from './position-point';\nimport * as ref from './valueref';\n/**\n * Utility for area/rule position, which can be either point or range.\n * (One of the axes should be point and the other should be range.)\n */\n\nexport function pointOrRangePosition(channel, model, _ref) {\n  let {\n    defaultPos,\n    defaultPos2,\n    range\n  } = _ref;\n\n  if (range) {\n    return rangePosition(channel, model, {\n      defaultPos,\n      defaultPos2\n    });\n  }\n\n  return pointPosition(channel, model, {\n    defaultPos\n  });\n}\nexport function rangePosition(channel, model, _ref2) {\n  let {\n    defaultPos,\n    defaultPos2\n  } = _ref2;\n  const {\n    markDef,\n    config\n  } = model;\n  const channel2 = getSecondaryRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n  const pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);\n  const vgChannel = pos2Mixins[sizeChannel] ? // If there is width/height, we need to position the marks based on the alignment.\n  vgAlignedPositionChannel(channel, markDef, config) : // Otherwise, make sure to apply to the right Vg Channel (for arc mark)\n  getVgPositionChannel(channel);\n  return Object.assign(Object.assign({}, pointPosition(channel, model, {\n    defaultPos,\n    vgChannel\n  })), pos2Mixins);\n}\n/**\n * Return encode for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\n\nfunction pointPosition2OrSize(model, defaultPos, channel) {\n  const {\n    encoding,\n    mark,\n    markDef,\n    stack,\n    config\n  } = model;\n  const baseChannel = getMainRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n  const channelDef = encoding[baseChannel];\n  const scaleName = model.scaleName(baseChannel);\n  const scale = model.getScaleComponent(baseChannel);\n  const {\n    offset\n  } = channel in encoding || channel in markDef ? positionOffset({\n    channel,\n    markDef,\n    encoding,\n    model\n  }) : positionOffset({\n    channel: baseChannel,\n    markDef,\n    encoding,\n    model\n  });\n\n  if (!channelDef && (channel === 'x2' || channel === 'y2') && (encoding.latitude || encoding.longitude)) {\n    const vgSizeChannel = getSizeChannel(channel);\n    const size = model.markDef[vgSizeChannel];\n\n    if (size != null) {\n      return {\n        [vgSizeChannel]: {\n          value: size\n        }\n      };\n    } else {\n      return {\n        [vgChannel]: {\n          field: model.getName(channel)\n        }\n      };\n    }\n  }\n\n  const valueRef = position2Ref({\n    channel,\n    channelDef,\n    channel2Def: encoding[channel],\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: undefined\n  });\n\n  if (valueRef !== undefined) {\n    return {\n      [vgChannel]: valueRef\n    };\n  } // TODO: check width/height encoding here once we add them\n  // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n  // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n\n\n  return position2orSize(channel, markDef) || position2orSize(channel, {\n    [channel]: getMarkStyleConfig(channel, markDef, config.style),\n    [sizeChannel]: getMarkStyleConfig(sizeChannel, markDef, config.style)\n  }) || position2orSize(channel, config[mark]) || position2orSize(channel, config.mark) || {\n    [vgChannel]: pointPositionDefaultRef({\n      model,\n      defaultPos,\n      channel,\n      scaleName,\n      scale\n    })()\n  };\n}\n\nexport function position2Ref(_ref3) {\n  let {\n    channel,\n    channelDef,\n    channel2Def,\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef\n  } = _ref3;\n\n  if (isFieldOrDatumDef(channelDef) && stack && // If fieldChannel is X and channel is X2 (or Y and Y2)\n  channel.charAt(0) === stack.fieldChannel.charAt(0)) {\n    return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, {\n      suffix: 'start'\n    }, {\n      offset\n    });\n  }\n\n  return ref.midPointRefWithPositionInvalidTest({\n    channel,\n    channelDef: channel2Def,\n    scaleName,\n    scale,\n    stack,\n    markDef,\n    config,\n    offset,\n    defaultRef\n  });\n}\n\nfunction position2orSize(channel, markDef) {\n  const sizeChannel = getSizeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n\n  if (markDef[vgChannel] !== undefined) {\n    return {\n      [vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[vgChannel])\n    };\n  } else if (markDef[channel] !== undefined) {\n    return {\n      [vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[channel])\n    };\n  } else if (markDef[sizeChannel]) {\n    const dimensionSize = markDef[sizeChannel];\n\n    if (isRelativeBandSize(dimensionSize)) {\n      log.warn(log.message.relativeBandSizeNotSupported(sizeChannel));\n    } else {\n      return {\n        [sizeChannel]: ref.widthHeightValueOrSignalRef(channel, dimensionSize)\n      };\n    }\n  }\n\n  return undefined;\n}","map":{"version":3,"mappings":"AACA,SAAQA,mBAAR,EAA6BC,wBAA7B,EAAuDC,cAAvD,EAAuEC,oBAAvE,QAAkG,kBAAlG;AACA,SAAQC,iBAAR,QAAgC,qBAAhC;AACA,OAAO,KAAKC,GAAZ,MAAqB,cAArB;AACA,SAAQC,kBAAR,QAA4D,eAA5D;AAEA,SAAQC,kBAAR,QAAiC,cAAjC;AAEA,SAAQC,cAAR,QAA6B,UAA7B;AACA,SAAQC,wBAAR,QAAuC,kBAAvC;AACA,SAAQC,aAAR,EAAuBC,uBAAvB,QAAqD,kBAArD;AACA,OAAO,KAAKC,GAAZ,MAAqB,YAArB;AAEA;;;;;AAIA,OAAM,SAAUC,oBAAV,CACJC,OADI,EAEJC,KAFI,QAWH;EAAA,IARD;IACEC,UADF;IAEEC,WAFF;IAGEC;EAHF,CAQC;;EAED,IAAIA,KAAJ,EAAW;IACT,OAAOC,aAAa,CAACL,OAAD,EAAUC,KAAV,EAAiB;MAACC,UAAD;MAAaC;IAAb,CAAjB,CAApB;EACD;;EACD,OAAOP,aAAa,CAACI,OAAD,EAAUC,KAAV,EAAiB;IAACC;EAAD,CAAjB,CAApB;AACD;AAED,OAAM,SAAUG,aAAV,CACJL,OADI,EAEJC,KAFI,SASH;EAAA,IAND;IACEC,UADF;IAEEC;EAFF,CAMC;EAED,MAAM;IAACG,OAAD;IAAUC;EAAV,IAAoBN,KAA1B;EACA,MAAMO,QAAQ,GAAGrB,wBAAwB,CAACa,OAAD,CAAzC;EACA,MAAMS,WAAW,GAAGrB,cAAc,CAACY,OAAD,CAAlC;EAEA,MAAMU,UAAU,GAAGC,oBAAoB,CAACV,KAAD,EAAQE,WAAR,EAAqBK,QAArB,CAAvC;EAEA,MAAMI,SAAS,GAAGF,UAAU,CAACD,WAAD,CAAV,GACd;EACAd,wBAAwB,CAACK,OAAD,EAAUM,OAAV,EAAmBC,MAAnB,CAFV,GAGd;EACAlB,oBAAoB,CAACW,OAAD,CAJxB;EAMA,uCACKJ,aAAa,CAACI,OAAD,EAAUC,KAAV,EAAiB;IAACC,UAAD;IAAaU;EAAb,CAAjB,CADlB,GAEKF,UAFL;AAID;AAED;;;;;AAIA,SAASC,oBAAT,CACEV,KADF,EAEEC,UAFF,EAGEF,OAHF,EAG6C;EAE3C,MAAM;IAACa,QAAD;IAAWC,IAAX;IAAiBR,OAAjB;IAA0BS,KAA1B;IAAiCR;EAAjC,IAA2CN,KAAjD;EAEA,MAAMe,WAAW,GAAG9B,mBAAmB,CAACc,OAAD,CAAvC;EACA,MAAMS,WAAW,GAAGrB,cAAc,CAACY,OAAD,CAAlC;EACA,MAAMY,SAAS,GAAGvB,oBAAoB,CAACW,OAAD,CAAtC;EAEA,MAAMiB,UAAU,GAAGJ,QAAQ,CAACG,WAAD,CAA3B;EACA,MAAME,SAAS,GAAGjB,KAAK,CAACiB,SAAN,CAAgBF,WAAhB,CAAlB;EACA,MAAMG,KAAK,GAAGlB,KAAK,CAACmB,iBAAN,CAAwBJ,WAAxB,CAAd;EAEA,MAAM;IAACK;EAAD,IACJrB,OAAO,IAAIa,QAAX,IAAuBb,OAAO,IAAIM,OAAlC,GACIZ,cAAc,CAAC;IAACM,OAAD;IAAUM,OAAV;IAAmBO,QAAnB;IAA6BZ;EAA7B,CAAD,CADlB,GAEIP,cAAc,CAAC;IAACM,OAAO,EAAEgB,WAAV;IAAuBV,OAAvB;IAAgCO,QAAhC;IAA0CZ;EAA1C,CAAD,CAHpB;;EAKA,IAAI,CAACgB,UAAD,KAAgBjB,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,IAAhD,MAA0Da,QAAQ,CAACS,QAAT,IAAqBT,QAAQ,CAACU,SAAxF,CAAJ,EAAwG;IACtG,MAAMC,aAAa,GAAGpC,cAAc,CAACY,OAAD,CAApC;IAEA,MAAMyB,IAAI,GAAGxB,KAAK,CAACK,OAAN,CAAckB,aAAd,CAAb;;IACA,IAAIC,IAAI,IAAI,IAAZ,EAAkB;MAChB,OAAO;QACL,CAACD,aAAD,GAAiB;UAACE,KAAK,EAAED;QAAR;MADZ,CAAP;IAGD,CAJD,MAIO;MACL,OAAO;QACL,CAACb,SAAD,GAAa;UAACe,KAAK,EAAE1B,KAAK,CAAC2B,OAAN,CAAc5B,OAAd;QAAR;MADR,CAAP;IAGD;EACF;;EAED,MAAM6B,QAAQ,GAAGC,YAAY,CAAC;IAC5B9B,OAD4B;IAE5BiB,UAF4B;IAG5Bc,WAAW,EAAElB,QAAQ,CAACb,OAAD,CAHO;IAI5BM,OAJ4B;IAK5BC,MAL4B;IAM5BW,SAN4B;IAO5BC,KAP4B;IAQ5BJ,KAR4B;IAS5BM,MAT4B;IAU5BW,UAAU,EAAEC;EAVgB,CAAD,CAA7B;;EAaA,IAAIJ,QAAQ,KAAKI,SAAjB,EAA4B;IAC1B,OAAO;MAAC,CAACrB,SAAD,GAAaiB;IAAd,CAAP;EACD,CA/C0C,CAiD3C;EAEA;EACA;;;EAEA,OACEK,eAAe,CAAClC,OAAD,EAAUM,OAAV,CAAf,IACA4B,eAAe,CAAClC,OAAD,EAAU;IACvB,CAACA,OAAD,GAAWP,kBAAkB,CAACO,OAAD,EAAUM,OAAV,EAAmBC,MAAM,CAAC4B,KAA1B,CADN;IAEvB,CAAC1B,WAAD,GAAehB,kBAAkB,CAACgB,WAAD,EAAcH,OAAd,EAAuBC,MAAM,CAAC4B,KAA9B;EAFV,CAAV,CADf,IAKAD,eAAe,CAAClC,OAAD,EAAUO,MAAM,CAACO,IAAD,CAAhB,CALf,IAMAoB,eAAe,CAAClC,OAAD,EAAUO,MAAM,CAACO,IAAjB,CANf,IAMyC;IACvC,CAACF,SAAD,GAAaf,uBAAuB,CAAC;MACnCI,KADmC;MAEnCC,UAFmC;MAGnCF,OAHmC;MAInCkB,SAJmC;MAKnCC;IALmC,CAAD,CAAvB;EAD0B,CAP3C;AAiBD;;AAED,OAAM,SAAUW,YAAV,QAaL;EAAA,IAb4B;IAC3B9B,OAD2B;IAE3BiB,UAF2B;IAG3Bc,WAH2B;IAI3BzB,OAJ2B;IAK3BC,MAL2B;IAM3BW,SAN2B;IAO3BC,KAP2B;IAQ3BJ,KAR2B;IAS3BM,MAT2B;IAU3BW;EAV2B,CAa5B;;EACC,IACE1C,iBAAiB,CAAC2B,UAAD,CAAjB,IACAF,KADA,IAEA;EACAf,OAAO,CAACoC,MAAR,CAAe,CAAf,MAAsBrB,KAAK,CAACsB,YAAN,CAAmBD,MAAnB,CAA0B,CAA1B,CAJxB,EAKE;IACA,OAAOtC,GAAG,CAACwC,0BAAJ,CAA+BrB,UAA/B,EAA2CC,SAA3C,EAAsD;MAACqB,MAAM,EAAE;IAAT,CAAtD,EAAyE;MAAClB;IAAD,CAAzE,CAAP;EACD;;EACD,OAAOvB,GAAG,CAAC0C,kCAAJ,CAAuC;IAC5CxC,OAD4C;IAE5CiB,UAAU,EAAEc,WAFgC;IAG5Cb,SAH4C;IAI5CC,KAJ4C;IAK5CJ,KAL4C;IAM5CT,OAN4C;IAO5CC,MAP4C;IAQ5Cc,MAR4C;IAS5CW;EAT4C,CAAvC,CAAP;AAWD;;AAED,SAASE,eAAT,CACElC,OADF,EAEEM,OAFF,EAE2D;EAEzD,MAAMG,WAAW,GAAGrB,cAAc,CAACY,OAAD,CAAlC;EACA,MAAMY,SAAS,GAAGvB,oBAAoB,CAACW,OAAD,CAAtC;;EACA,IAAIM,OAAO,CAACM,SAAD,CAAP,KAAuBqB,SAA3B,EAAsC;IACpC,OAAO;MAAC,CAACrB,SAAD,GAAad,GAAG,CAAC2C,2BAAJ,CAAgCzC,OAAhC,EAAyCM,OAAO,CAACM,SAAD,CAAhD;IAAd,CAAP;EACD,CAFD,MAEO,IAAIN,OAAO,CAACN,OAAD,CAAP,KAAqBiC,SAAzB,EAAoC;IACzC,OAAO;MAAC,CAACrB,SAAD,GAAad,GAAG,CAAC2C,2BAAJ,CAAgCzC,OAAhC,EAAyCM,OAAO,CAACN,OAAD,CAAhD;IAAd,CAAP;EACD,CAFM,MAEA,IAAIM,OAAO,CAACG,WAAD,CAAX,EAA0B;IAC/B,MAAMiC,aAAa,GAAGpC,OAAO,CAACG,WAAD,CAA7B;;IACA,IAAIjB,kBAAkB,CAACkD,aAAD,CAAtB,EAAuC;MACrCnD,GAAG,CAACoD,IAAJ,CAASpD,GAAG,CAACqD,OAAJ,CAAYC,4BAAZ,CAAyCpC,WAAzC,CAAT;IACD,CAFD,MAEO;MACL,OAAO;QAAC,CAACA,WAAD,GAAeX,GAAG,CAAC2C,2BAAJ,CAAgCzC,OAAhC,EAAyC0C,aAAzC;MAAhB,CAAP;IACD;EACF;;EACD,OAAOT,SAAP;AACD","names":["getMainRangeChannel","getSecondaryRangeChannel","getSizeChannel","getVgPositionChannel","isFieldOrDatumDef","log","isRelativeBandSize","getMarkStyleConfig","positionOffset","vgAlignedPositionChannel","pointPosition","pointPositionDefaultRef","ref","pointOrRangePosition","channel","model","defaultPos","defaultPos2","range","rangePosition","markDef","config","channel2","sizeChannel","pos2Mixins","pointPosition2OrSize","vgChannel","encoding","mark","stack","baseChannel","channelDef","scaleName","scale","getScaleComponent","offset","latitude","longitude","vgSizeChannel","size","value","field","getName","valueRef","position2Ref","channel2Def","defaultRef","undefined","position2orSize","style","charAt","fieldChannel","valueRefForFieldOrDatumDef","suffix","midPointRefWithPositionInvalidTest","widthHeightValueOrSignalRef","dimensionSize","warn","message","relativeBandSizeNotSupported"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/mark/encode/position-range.ts"],"sourcesContent":["import {SignalRef} from 'vega';\nimport {getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel} from '../../../channel';\nimport {isFieldOrDatumDef} from '../../../channeldef';\nimport * as log from '../../../log';\nimport {isRelativeBandSize, Mark, MarkConfig, MarkDef} from '../../../mark';\nimport {VgEncodeEntry, VgValueRef} from '../../../vega.schema';\nimport {getMarkStyleConfig} from '../../common';\nimport {UnitModel} from '../../unit';\nimport {positionOffset} from './offset';\nimport {vgAlignedPositionChannel} from './position-align';\nimport {pointPosition, pointPositionDefaultRef} from './position-point';\nimport * as ref from './valueref';\n\n/**\n * Utility for area/rule position, which can be either point or range.\n * (One of the axes should be point and the other should be range.)\n */\nexport function pointOrRangePosition(\n  channel: 'x' | 'y',\n  model: UnitModel,\n  {\n    defaultPos,\n    defaultPos2,\n    range\n  }: {\n    defaultPos: 'zeroOrMin' | 'zeroOrMax' | 'mid';\n    defaultPos2: 'zeroOrMin' | 'zeroOrMax';\n    range: boolean;\n  }\n) {\n  if (range) {\n    return rangePosition(channel, model, {defaultPos, defaultPos2});\n  }\n  return pointPosition(channel, model, {defaultPos});\n}\n\nexport function rangePosition(\n  channel: 'x' | 'y' | 'theta' | 'radius',\n  model: UnitModel,\n  {\n    defaultPos,\n    defaultPos2\n  }: {\n    defaultPos: 'zeroOrMin' | 'zeroOrMax' | 'mid';\n    defaultPos2: 'zeroOrMin' | 'zeroOrMax';\n  }\n): VgEncodeEntry {\n  const {markDef, config} = model;\n  const channel2 = getSecondaryRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n\n  const pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);\n\n  const vgChannel = pos2Mixins[sizeChannel]\n    ? // If there is width/height, we need to position the marks based on the alignment.\n      vgAlignedPositionChannel(channel, markDef, config)\n    : // Otherwise, make sure to apply to the right Vg Channel (for arc mark)\n      getVgPositionChannel(channel);\n\n  return {\n    ...pointPosition(channel, model, {defaultPos, vgChannel}),\n    ...pos2Mixins\n  };\n}\n\n/**\n * Return encode for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\nfunction pointPosition2OrSize(\n  model: UnitModel,\n  defaultPos: 'zeroOrMin' | 'zeroOrMax',\n  channel: 'x2' | 'y2' | 'radius2' | 'theta2'\n) {\n  const {encoding, mark, markDef, stack, config} = model;\n\n  const baseChannel = getMainRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n\n  const channelDef = encoding[baseChannel];\n  const scaleName = model.scaleName(baseChannel);\n  const scale = model.getScaleComponent(baseChannel);\n\n  const {offset} =\n    channel in encoding || channel in markDef\n      ? positionOffset({channel, markDef, encoding, model})\n      : positionOffset({channel: baseChannel, markDef, encoding, model});\n\n  if (!channelDef && (channel === 'x2' || channel === 'y2') && (encoding.latitude || encoding.longitude)) {\n    const vgSizeChannel = getSizeChannel(channel);\n\n    const size = model.markDef[vgSizeChannel];\n    if (size != null) {\n      return {\n        [vgSizeChannel]: {value: size}\n      };\n    } else {\n      return {\n        [vgChannel]: {field: model.getName(channel)}\n      };\n    }\n  }\n\n  const valueRef = position2Ref({\n    channel,\n    channelDef,\n    channel2Def: encoding[channel],\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: undefined\n  });\n\n  if (valueRef !== undefined) {\n    return {[vgChannel]: valueRef};\n  }\n\n  // TODO: check width/height encoding here once we add them\n\n  // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n  // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n\n  return (\n    position2orSize(channel, markDef) ||\n    position2orSize(channel, {\n      [channel]: getMarkStyleConfig(channel, markDef, config.style),\n      [sizeChannel]: getMarkStyleConfig(sizeChannel, markDef, config.style)\n    }) ||\n    position2orSize(channel, config[mark]) ||\n    position2orSize(channel, config.mark) || {\n      [vgChannel]: pointPositionDefaultRef({\n        model,\n        defaultPos,\n        channel,\n        scaleName,\n        scale\n      })()\n    }\n  );\n}\n\nexport function position2Ref({\n  channel,\n  channelDef,\n  channel2Def,\n  markDef,\n  config,\n  scaleName,\n  scale,\n  stack,\n  offset,\n  defaultRef\n}: ref.MidPointParams & {\n  channel: 'x2' | 'y2' | 'radius2' | 'theta2';\n}): VgValueRef | VgValueRef[] {\n  if (\n    isFieldOrDatumDef(channelDef) &&\n    stack &&\n    // If fieldChannel is X and channel is X2 (or Y and Y2)\n    channel.charAt(0) === stack.fieldChannel.charAt(0)\n  ) {\n    return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, {suffix: 'start'}, {offset});\n  }\n  return ref.midPointRefWithPositionInvalidTest({\n    channel,\n    channelDef: channel2Def,\n    scaleName,\n    scale,\n    stack,\n    markDef,\n    config,\n    offset,\n    defaultRef\n  });\n}\n\nfunction position2orSize(\n  channel: 'x2' | 'y2' | 'radius2' | 'theta2',\n  markDef: MarkConfig<SignalRef> | MarkDef<Mark, SignalRef>\n) {\n  const sizeChannel = getSizeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n  if (markDef[vgChannel] !== undefined) {\n    return {[vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[vgChannel])};\n  } else if (markDef[channel] !== undefined) {\n    return {[vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[channel])};\n  } else if (markDef[sizeChannel]) {\n    const dimensionSize = markDef[sizeChannel];\n    if (isRelativeBandSize(dimensionSize)) {\n      log.warn(log.message.relativeBandSizeNotSupported(sizeChannel));\n    } else {\n      return {[sizeChannel]: ref.widthHeightValueOrSignalRef(channel, dimensionSize)};\n    }\n  }\n  return undefined;\n}\n"]},"metadata":{},"sourceType":"module"}