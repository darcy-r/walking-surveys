{"ast":null,"code":"import { toSet, stringValue, error, isArray, isObject, hasOwnProperty, accessor, key, field, array, compare, truthy } from 'vega-util';\nimport { tupleid } from 'vega-dataflow';\n/**\n * Parse a serialized dataflow specification.\n */\n\nfunction parse(spec) {\n  const ctx = this,\n        operators = spec.operators || []; // parse background\n\n  if (spec.background) {\n    ctx.background = spec.background;\n  } // parse event configuration\n\n\n  if (spec.eventConfig) {\n    ctx.eventConfig = spec.eventConfig;\n  } // parse locale configuration\n\n\n  if (spec.locale) {\n    ctx.locale = spec.locale;\n  } // parse operators\n\n\n  operators.forEach(entry => ctx.parseOperator(entry)); // parse operator parameters\n\n  operators.forEach(entry => ctx.parseOperatorParameters(entry)); // parse streams\n\n  (spec.streams || []).forEach(entry => ctx.parseStream(entry)); // parse updates\n\n  (spec.updates || []).forEach(entry => ctx.parseUpdate(entry));\n  return ctx.resolve();\n}\n\nconst Skip = toSet(['rule']),\n      Swap = toSet(['group', 'image', 'rect']);\n\nfunction adjustSpatial(encode, marktype) {\n  let code = '';\n  if (Skip[marktype]) return code;\n\n  if (encode.x2) {\n    if (encode.x) {\n      if (Swap[marktype]) {\n        code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';\n      }\n\n      code += 'o.width=o.x2-o.x;';\n    } else {\n      code += 'o.x=o.x2-(o.width||0);';\n    }\n  }\n\n  if (encode.xc) {\n    code += 'o.x=o.xc-(o.width||0)/2;';\n  }\n\n  if (encode.y2) {\n    if (encode.y) {\n      if (Swap[marktype]) {\n        code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';\n      }\n\n      code += 'o.height=o.y2-o.y;';\n    } else {\n      code += 'o.y=o.y2-(o.height||0);';\n    }\n  }\n\n  if (encode.yc) {\n    code += 'o.y=o.yc-(o.height||0)/2;';\n  }\n\n  return code;\n}\n\nfunction canonicalType(type) {\n  return (type + '').toLowerCase();\n}\n\nfunction isOperator(type) {\n  return canonicalType(type) === 'operator';\n}\n\nfunction isCollect(type) {\n  return canonicalType(type) === 'collect';\n}\n\nfunction expression(ctx, args, code) {\n  // wrap code in return statement if expression does not terminate\n  if (code[code.length - 1] !== ';') {\n    code = 'return(' + code + ');';\n  }\n\n  const fn = Function(...args.concat(code));\n  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;\n} // generate code for comparing a single field\n\n\nfunction _compare(u, v, lt, gt) {\n  return \"((u = \".concat(u, \") < (v = \").concat(v, \") || u == null) && v != null ? \").concat(lt, \"\\n  : (u > v || v == null) && u != null ? \").concat(gt, \"\\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? \").concat(lt, \"\\n  : v !== v && u === u ? \").concat(gt, \" : \");\n}\n\nvar expressionCodegen = {\n  /**\n   * Parse an expression used to update an operator value.\n   */\n  operator: (ctx, expr) => expression(ctx, ['_'], expr.code),\n\n  /**\n   * Parse an expression provided as an operator parameter value.\n   */\n  parameter: (ctx, expr) => expression(ctx, ['datum', '_'], expr.code),\n\n  /**\n   * Parse an expression applied to an event stream.\n   */\n  event: (ctx, expr) => expression(ctx, ['event'], expr.code),\n\n  /**\n   * Parse an expression used to handle an event-driven operator update.\n   */\n  handler: (ctx, expr) => {\n    const code = \"var datum=event.item&&event.item.datum;return \".concat(expr.code, \";\");\n    return expression(ctx, ['_', 'event'], code);\n  },\n\n  /**\n   * Parse an expression that performs visual encoding.\n   */\n  encode: (ctx, encode) => {\n    const {\n      marktype,\n      channels\n    } = encode;\n    let code = 'var o=item,datum=o.datum,m=0,$;';\n\n    for (const name in channels) {\n      const o = 'o[' + stringValue(name) + ']';\n      code += \"$=\".concat(channels[name].code, \";if(\").concat(o, \"!==$)\").concat(o, \"=$,m=1;\");\n    }\n\n    code += adjustSpatial(channels, marktype);\n    code += 'return m;';\n    return expression(ctx, ['item', '_'], code);\n  },\n\n  /**\n   * Optimized code generators for access and comparison.\n   */\n  codegen: {\n    get(path) {\n      const ref = \"[\".concat(path.map(stringValue).join(']['), \"]\");\n      const get = Function('_', \"return _\".concat(ref, \";\"));\n      get.path = ref;\n      return get;\n    },\n\n    comparator(fields, orders) {\n      let t;\n\n      const map = (f, i) => {\n        const o = orders[i];\n        let u, v;\n\n        if (f.path) {\n          u = \"a\".concat(f.path);\n          v = \"b\".concat(f.path);\n        } else {\n          (t = t || {})['f' + i] = f;\n          u = \"this.f\".concat(i, \"(a)\");\n          v = \"this.f\".concat(i, \"(b)\");\n        }\n\n        return _compare(u, v, -o, o);\n      };\n\n      const fn = Function('a', 'b', 'var u, v; return ' + fields.map(map).join('') + '0;');\n      return t ? fn.bind(t) : fn;\n    }\n\n  }\n};\n/**\n * Parse a dataflow operator.\n */\n\nfunction parseOperator(spec) {\n  const ctx = this;\n\n  if (isOperator(spec.type) || !spec.type) {\n    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);\n  } else {\n    ctx.transform(spec, spec.type);\n  }\n}\n/**\n * Parse and assign operator parameters.\n */\n\n\nfunction parseOperatorParameters(spec) {\n  const ctx = this;\n\n  if (spec.params) {\n    const op = ctx.get(spec.id);\n    if (!op) error('Invalid operator id: ' + spec.id);\n    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));\n  }\n}\n/**\n * Parse a set of operator parameters.\n */\n\n\nfunction parseParameters(spec, params) {\n  params = params || {};\n  const ctx = this;\n\n  for (const key in spec) {\n    const value = spec[key];\n    params[key] = isArray(value) ? value.map(v => parseParameter(v, ctx, params)) : parseParameter(value, ctx, params);\n  }\n\n  return params;\n}\n/**\n * Parse a single parameter.\n */\n\n\nfunction parseParameter(spec, ctx, params) {\n  if (!spec || !isObject(spec)) return spec;\n\n  for (let i = 0, n = PARSERS.length, p; i < n; ++i) {\n    p = PARSERS[i];\n\n    if (hasOwnProperty(spec, p.key)) {\n      return p.parse(spec, ctx, params);\n    }\n  }\n\n  return spec;\n}\n/** Reference parsers. */\n\n\nvar PARSERS = [{\n  key: '$ref',\n  parse: getOperator\n}, {\n  key: '$key',\n  parse: getKey\n}, {\n  key: '$expr',\n  parse: getExpression\n}, {\n  key: '$field',\n  parse: getField\n}, {\n  key: '$encode',\n  parse: getEncode\n}, {\n  key: '$compare',\n  parse: getCompare\n}, {\n  key: '$context',\n  parse: getContext\n}, {\n  key: '$subflow',\n  parse: getSubflow\n}, {\n  key: '$tupleid',\n  parse: getTupleId\n}];\n/**\n * Resolve an operator reference.\n */\n\nfunction getOperator(_, ctx) {\n  return ctx.get(_.$ref) || error('Operator not defined: ' + _.$ref);\n}\n/**\n * Resolve an expression reference.\n */\n\n\nfunction getExpression(_, ctx, params) {\n  if (_.$params) {\n    // parse expression parameters\n    ctx.parseParameters(_.$params, params);\n  }\n\n  const k = 'e:' + _.$expr.code + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = accessor(ctx.parameterExpression(_.$expr), _.$fields, _.$name));\n}\n/**\n * Resolve a key accessor reference.\n */\n\n\nfunction getKey(_, ctx) {\n  const k = 'k:' + _.$key + '_' + !!_.$flat;\n  return ctx.fn[k] || (ctx.fn[k] = key(_.$key, _.$flat, ctx.expr.codegen));\n}\n/**\n * Resolve a field accessor reference.\n */\n\n\nfunction getField(_, ctx) {\n  if (!_.$field) return null;\n  const k = 'f:' + _.$field + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = field(_.$field, _.$name, ctx.expr.codegen));\n}\n/**\n * Resolve a comparator function reference.\n */\n\n\nfunction getCompare(_, ctx) {\n  // As of Vega 5.5.3, $tupleid sort is no longer used.\n  // Keep here for now for backwards compatibility.\n  const k = 'c:' + _.$compare + '_' + _.$order,\n        c = array(_.$compare).map(_ => _ && _.$tupleid ? tupleid : _);\n  return ctx.fn[k] || (ctx.fn[k] = compare(c, _.$order, ctx.expr.codegen));\n}\n/**\n * Resolve an encode operator reference.\n */\n\n\nfunction getEncode(_, ctx) {\n  const spec = _.$encode,\n        encode = {};\n\n  for (const name in spec) {\n    const enc = spec[name];\n    encode[name] = accessor(ctx.encodeExpression(enc.$expr), enc.$fields);\n    encode[name].output = enc.$output;\n  }\n\n  return encode;\n}\n/**\n * Resolve a context reference.\n */\n\n\nfunction getContext(_, ctx) {\n  return ctx;\n}\n/**\n * Resolve a recursive subflow specification.\n */\n\n\nfunction getSubflow(_, ctx) {\n  const spec = _.$subflow;\n  return function (dataflow, key, parent) {\n    const subctx = ctx.fork().parse(spec),\n          op = subctx.get(spec.operators[0].id),\n          p = subctx.signals.parent;\n    if (p) p.set(parent);\n\n    op.detachSubflow = () => ctx.detach(subctx);\n\n    return op;\n  };\n}\n/**\n * Resolve a tuple id reference.\n */\n\n\nfunction getTupleId() {\n  return tupleid;\n}\n/**\n * Parse an event stream specification.\n */\n\n\nfunction parseStream(spec) {\n  var ctx = this,\n      filter = spec.filter != null ? ctx.eventExpression(spec.filter) : undefined,\n      stream = spec.stream != null ? ctx.get(spec.stream) : undefined,\n      args;\n\n  if (spec.source) {\n    stream = ctx.events(spec.source, spec.type, filter);\n  } else if (spec.merge) {\n    args = spec.merge.map(_ => ctx.get(_));\n    stream = args[0].merge.apply(args[0], args.slice(1));\n  }\n\n  if (spec.between) {\n    args = spec.between.map(_ => ctx.get(_));\n    stream = stream.between(args[0], args[1]);\n  }\n\n  if (spec.filter) {\n    stream = stream.filter(filter);\n  }\n\n  if (spec.throttle != null) {\n    stream = stream.throttle(+spec.throttle);\n  }\n\n  if (spec.debounce != null) {\n    stream = stream.debounce(+spec.debounce);\n  }\n\n  if (stream == null) {\n    error('Invalid stream definition: ' + JSON.stringify(spec));\n  }\n\n  if (spec.consume) stream.consume(true);\n  ctx.stream(spec, stream);\n}\n/**\n * Parse an event-driven operator update.\n */\n\n\nfunction parseUpdate(spec) {\n  var ctx = this,\n      srcid = isObject(srcid = spec.source) ? srcid.$ref : srcid,\n      source = ctx.get(srcid),\n      target = null,\n      update = spec.update,\n      params = undefined;\n  if (!source) error('Source not defined: ' + spec.source);\n  target = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);\n\n  if (update && update.$expr) {\n    if (update.$params) {\n      params = ctx.parseParameters(update.$params);\n    }\n\n    update = ctx.handlerExpression(update.$expr);\n  }\n\n  ctx.update(spec, source, target, update, params);\n}\n\nconst SKIP = {\n  skip: true\n};\n\nfunction getState(options) {\n  var ctx = this,\n      state = {};\n\n  if (options.signals) {\n    var signals = state.signals = {};\n    Object.keys(ctx.signals).forEach(key => {\n      const op = ctx.signals[key];\n\n      if (options.signals(key, op)) {\n        signals[key] = op.value;\n      }\n    });\n  }\n\n  if (options.data) {\n    var data = state.data = {};\n    Object.keys(ctx.data).forEach(key => {\n      const dataset = ctx.data[key];\n\n      if (options.data(key, dataset)) {\n        data[key] = dataset.input.value;\n      }\n    });\n  }\n\n  if (ctx.subcontext && options.recurse !== false) {\n    state.subcontext = ctx.subcontext.map(ctx => ctx.getState(options));\n  }\n\n  return state;\n}\n\nfunction setState(state) {\n  var ctx = this,\n      df = ctx.dataflow,\n      data = state.data,\n      signals = state.signals;\n  Object.keys(signals || {}).forEach(key => {\n    df.update(ctx.signals[key], signals[key], SKIP);\n  });\n  Object.keys(data || {}).forEach(key => {\n    df.pulse(ctx.data[key].input, df.changeset().remove(truthy).insert(data[key]));\n  });\n  (state.subcontext || []).forEach((substate, i) => {\n    const subctx = ctx.subcontext[i];\n    if (subctx) subctx.setState(substate);\n  });\n}\n/**\n * Context objects store the current parse state.\n * Enables lookup of parsed operators, event streams, accessors, etc.\n * Provides a 'fork' method for creating child contexts for subflows.\n */\n\n\nfunction context(df, transforms, functions, expr) {\n  return new Context(df, transforms, functions, expr);\n}\n\nfunction Context(df, transforms, functions, expr) {\n  this.dataflow = df;\n  this.transforms = transforms;\n  this.events = df.events.bind(df);\n  this.expr = expr || expressionCodegen, this.signals = {};\n  this.scales = {};\n  this.nodes = {};\n  this.data = {};\n  this.fn = {};\n\n  if (functions) {\n    this.functions = Object.create(functions);\n    this.functions.context = this;\n  }\n}\n\nfunction Subcontext(ctx) {\n  this.dataflow = ctx.dataflow;\n  this.transforms = ctx.transforms;\n  this.events = ctx.events;\n  this.expr = ctx.expr;\n  this.signals = Object.create(ctx.signals);\n  this.scales = Object.create(ctx.scales);\n  this.nodes = Object.create(ctx.nodes);\n  this.data = Object.create(ctx.data);\n  this.fn = Object.create(ctx.fn);\n\n  if (ctx.functions) {\n    this.functions = Object.create(ctx.functions);\n    this.functions.context = this;\n  }\n}\n\nContext.prototype = Subcontext.prototype = {\n  fork() {\n    const ctx = new Subcontext(this);\n    (this.subcontext || (this.subcontext = [])).push(ctx);\n    return ctx;\n  },\n\n  detach(ctx) {\n    this.subcontext = this.subcontext.filter(c => c !== ctx); // disconnect all nodes in the subcontext\n    // wipe out targets first for better efficiency\n\n    const keys = Object.keys(ctx.nodes);\n\n    for (const key of keys) ctx.nodes[key]._targets = null;\n\n    for (const key of keys) ctx.nodes[key].detach();\n\n    ctx.nodes = null;\n  },\n\n  get(id) {\n    return this.nodes[id];\n  },\n\n  set(id, node) {\n    return this.nodes[id] = node;\n  },\n\n  add(spec, op) {\n    const ctx = this,\n          df = ctx.dataflow,\n          data = spec.value;\n    ctx.set(spec.id, op);\n\n    if (isCollect(spec.type) && data) {\n      if (data.$ingest) {\n        df.ingest(op, data.$ingest, data.$format);\n      } else if (data.$request) {\n        df.preload(op, data.$request, data.$format);\n      } else {\n        df.pulse(op, df.changeset().insert(data));\n      }\n    }\n\n    if (spec.root) {\n      ctx.root = op;\n    }\n\n    if (spec.parent) {\n      let p = ctx.get(spec.parent.$ref);\n\n      if (p) {\n        df.connect(p, [op]);\n        op.targets().add(p);\n      } else {\n        (ctx.unresolved = ctx.unresolved || []).push(() => {\n          p = ctx.get(spec.parent.$ref);\n          df.connect(p, [op]);\n          op.targets().add(p);\n        });\n      }\n    }\n\n    if (spec.signal) {\n      ctx.signals[spec.signal] = op;\n    }\n\n    if (spec.scale) {\n      ctx.scales[spec.scale] = op;\n    }\n\n    if (spec.data) {\n      for (const name in spec.data) {\n        const data = ctx.data[name] || (ctx.data[name] = {});\n        spec.data[name].forEach(role => data[role] = op);\n      }\n    }\n  },\n\n  resolve() {\n    (this.unresolved || []).forEach(fn => fn());\n    delete this.unresolved;\n    return this;\n  },\n\n  operator(spec, update) {\n    this.add(spec, this.dataflow.add(spec.value, update));\n  },\n\n  transform(spec, type) {\n    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));\n  },\n\n  stream(spec, stream) {\n    this.set(spec.id, stream);\n  },\n\n  update(spec, stream, target, update, params) {\n    this.dataflow.on(stream, target, update, params, spec.options);\n  },\n\n  // expression parsing\n  operatorExpression(expr) {\n    return this.expr.operator(this, expr);\n  },\n\n  parameterExpression(expr) {\n    return this.expr.parameter(this, expr);\n  },\n\n  eventExpression(expr) {\n    return this.expr.event(this, expr);\n  },\n\n  handlerExpression(expr) {\n    return this.expr.handler(this, expr);\n  },\n\n  encodeExpression(encode) {\n    return this.expr.encode(this, encode);\n  },\n\n  // parse methods\n  parse,\n  parseOperator,\n  parseOperatorParameters,\n  parseParameters,\n  parseStream,\n  parseUpdate,\n  // state methods\n  getState,\n  setState\n};\nexport { context };","map":{"version":3,"names":["toSet","stringValue","error","isArray","isObject","hasOwnProperty","accessor","key","field","array","compare","truthy","tupleid","parse","spec","ctx","operators","background","eventConfig","locale","forEach","entry","parseOperator","parseOperatorParameters","streams","parseStream","updates","parseUpdate","resolve","Skip","Swap","adjustSpatial","encode","marktype","code","x2","x","xc","y2","y","yc","canonicalType","type","toLowerCase","isOperator","isCollect","expression","args","length","fn","Function","concat","functions","bind","_compare","u","v","lt","gt","expressionCodegen","operator","expr","parameter","event","handler","channels","name","o","codegen","get","path","ref","map","join","comparator","fields","orders","t","f","i","update","operatorExpression","transform","params","op","id","dataflow","connect","parameters","parseParameters","react","initonly","value","parseParameter","n","PARSERS","p","getOperator","getKey","getExpression","getField","getEncode","getCompare","getContext","getSubflow","getTupleId","_","$ref","$params","k","$expr","$name","parameterExpression","$fields","$key","$flat","$field","$compare","$order","c","$tupleid","$encode","enc","encodeExpression","output","$output","$subflow","parent","subctx","fork","signals","set","detachSubflow","detach","filter","eventExpression","undefined","stream","source","events","merge","apply","slice","between","throttle","debounce","JSON","stringify","consume","srcid","target","handlerExpression","SKIP","skip","getState","options","state","Object","keys","data","dataset","input","subcontext","recurse","setState","df","pulse","changeset","remove","insert","substate","context","transforms","Context","scales","nodes","create","Subcontext","prototype","push","_targets","node","add","$ingest","ingest","$format","$request","preload","root","targets","unresolved","signal","scale","role","on"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-runtime/build/vega-runtime.module.js"],"sourcesContent":["import { toSet, stringValue, error, isArray, isObject, hasOwnProperty, accessor, key, field, array, compare, truthy } from 'vega-util';\nimport { tupleid } from 'vega-dataflow';\n\n/**\n * Parse a serialized dataflow specification.\n */\nfunction parse (spec) {\n  const ctx = this,\n        operators = spec.operators || []; // parse background\n\n  if (spec.background) {\n    ctx.background = spec.background;\n  } // parse event configuration\n\n\n  if (spec.eventConfig) {\n    ctx.eventConfig = spec.eventConfig;\n  } // parse locale configuration\n\n\n  if (spec.locale) {\n    ctx.locale = spec.locale;\n  } // parse operators\n\n\n  operators.forEach(entry => ctx.parseOperator(entry)); // parse operator parameters\n\n  operators.forEach(entry => ctx.parseOperatorParameters(entry)); // parse streams\n\n  (spec.streams || []).forEach(entry => ctx.parseStream(entry)); // parse updates\n\n  (spec.updates || []).forEach(entry => ctx.parseUpdate(entry));\n  return ctx.resolve();\n}\n\nconst Skip = toSet(['rule']),\n      Swap = toSet(['group', 'image', 'rect']);\nfunction adjustSpatial(encode, marktype) {\n  let code = '';\n  if (Skip[marktype]) return code;\n\n  if (encode.x2) {\n    if (encode.x) {\n      if (Swap[marktype]) {\n        code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';\n      }\n\n      code += 'o.width=o.x2-o.x;';\n    } else {\n      code += 'o.x=o.x2-(o.width||0);';\n    }\n  }\n\n  if (encode.xc) {\n    code += 'o.x=o.xc-(o.width||0)/2;';\n  }\n\n  if (encode.y2) {\n    if (encode.y) {\n      if (Swap[marktype]) {\n        code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';\n      }\n\n      code += 'o.height=o.y2-o.y;';\n    } else {\n      code += 'o.y=o.y2-(o.height||0);';\n    }\n  }\n\n  if (encode.yc) {\n    code += 'o.y=o.yc-(o.height||0)/2;';\n  }\n\n  return code;\n}\nfunction canonicalType(type) {\n  return (type + '').toLowerCase();\n}\nfunction isOperator(type) {\n  return canonicalType(type) === 'operator';\n}\nfunction isCollect(type) {\n  return canonicalType(type) === 'collect';\n}\n\nfunction expression(ctx, args, code) {\n  // wrap code in return statement if expression does not terminate\n  if (code[code.length - 1] !== ';') {\n    code = 'return(' + code + ');';\n  }\n\n  const fn = Function(...args.concat(code));\n  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;\n} // generate code for comparing a single field\n\n\nfunction _compare(u, v, lt, gt) {\n  return \"((u = \".concat(u, \") < (v = \").concat(v, \") || u == null) && v != null ? \").concat(lt, \"\\n  : (u > v || v == null) && u != null ? \").concat(gt, \"\\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? \").concat(lt, \"\\n  : v !== v && u === u ? \").concat(gt, \" : \");\n}\n\nvar expressionCodegen = {\n  /**\n   * Parse an expression used to update an operator value.\n   */\n  operator: (ctx, expr) => expression(ctx, ['_'], expr.code),\n\n  /**\n   * Parse an expression provided as an operator parameter value.\n   */\n  parameter: (ctx, expr) => expression(ctx, ['datum', '_'], expr.code),\n\n  /**\n   * Parse an expression applied to an event stream.\n   */\n  event: (ctx, expr) => expression(ctx, ['event'], expr.code),\n\n  /**\n   * Parse an expression used to handle an event-driven operator update.\n   */\n  handler: (ctx, expr) => {\n    const code = \"var datum=event.item&&event.item.datum;return \".concat(expr.code, \";\");\n    return expression(ctx, ['_', 'event'], code);\n  },\n\n  /**\n   * Parse an expression that performs visual encoding.\n   */\n  encode: (ctx, encode) => {\n    const {\n      marktype,\n      channels\n    } = encode;\n    let code = 'var o=item,datum=o.datum,m=0,$;';\n\n    for (const name in channels) {\n      const o = 'o[' + stringValue(name) + ']';\n      code += \"$=\".concat(channels[name].code, \";if(\").concat(o, \"!==$)\").concat(o, \"=$,m=1;\");\n    }\n\n    code += adjustSpatial(channels, marktype);\n    code += 'return m;';\n    return expression(ctx, ['item', '_'], code);\n  },\n\n  /**\n   * Optimized code generators for access and comparison.\n   */\n  codegen: {\n    get(path) {\n      const ref = \"[\".concat(path.map(stringValue).join(']['), \"]\");\n      const get = Function('_', \"return _\".concat(ref, \";\"));\n      get.path = ref;\n      return get;\n    },\n\n    comparator(fields, orders) {\n      let t;\n\n      const map = (f, i) => {\n        const o = orders[i];\n        let u, v;\n\n        if (f.path) {\n          u = \"a\".concat(f.path);\n          v = \"b\".concat(f.path);\n        } else {\n          (t = t || {})['f' + i] = f;\n          u = \"this.f\".concat(i, \"(a)\");\n          v = \"this.f\".concat(i, \"(b)\");\n        }\n\n        return _compare(u, v, -o, o);\n      };\n\n      const fn = Function('a', 'b', 'var u, v; return ' + fields.map(map).join('') + '0;');\n      return t ? fn.bind(t) : fn;\n    }\n\n  }\n};\n\n/**\n * Parse a dataflow operator.\n */\n\nfunction parseOperator(spec) {\n  const ctx = this;\n\n  if (isOperator(spec.type) || !spec.type) {\n    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);\n  } else {\n    ctx.transform(spec, spec.type);\n  }\n}\n/**\n * Parse and assign operator parameters.\n */\n\nfunction parseOperatorParameters(spec) {\n  const ctx = this;\n\n  if (spec.params) {\n    const op = ctx.get(spec.id);\n    if (!op) error('Invalid operator id: ' + spec.id);\n    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));\n  }\n}\n\n/**\n * Parse a set of operator parameters.\n */\n\nfunction parseParameters(spec, params) {\n  params = params || {};\n  const ctx = this;\n\n  for (const key in spec) {\n    const value = spec[key];\n    params[key] = isArray(value) ? value.map(v => parseParameter(v, ctx, params)) : parseParameter(value, ctx, params);\n  }\n\n  return params;\n}\n/**\n * Parse a single parameter.\n */\n\nfunction parseParameter(spec, ctx, params) {\n  if (!spec || !isObject(spec)) return spec;\n\n  for (let i = 0, n = PARSERS.length, p; i < n; ++i) {\n    p = PARSERS[i];\n\n    if (hasOwnProperty(spec, p.key)) {\n      return p.parse(spec, ctx, params);\n    }\n  }\n\n  return spec;\n}\n/** Reference parsers. */\n\n\nvar PARSERS = [{\n  key: '$ref',\n  parse: getOperator\n}, {\n  key: '$key',\n  parse: getKey\n}, {\n  key: '$expr',\n  parse: getExpression\n}, {\n  key: '$field',\n  parse: getField\n}, {\n  key: '$encode',\n  parse: getEncode\n}, {\n  key: '$compare',\n  parse: getCompare\n}, {\n  key: '$context',\n  parse: getContext\n}, {\n  key: '$subflow',\n  parse: getSubflow\n}, {\n  key: '$tupleid',\n  parse: getTupleId\n}];\n/**\n * Resolve an operator reference.\n */\n\nfunction getOperator(_, ctx) {\n  return ctx.get(_.$ref) || error('Operator not defined: ' + _.$ref);\n}\n/**\n * Resolve an expression reference.\n */\n\n\nfunction getExpression(_, ctx, params) {\n  if (_.$params) {\n    // parse expression parameters\n    ctx.parseParameters(_.$params, params);\n  }\n\n  const k = 'e:' + _.$expr.code + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = accessor(ctx.parameterExpression(_.$expr), _.$fields, _.$name));\n}\n/**\n * Resolve a key accessor reference.\n */\n\n\nfunction getKey(_, ctx) {\n  const k = 'k:' + _.$key + '_' + !!_.$flat;\n  return ctx.fn[k] || (ctx.fn[k] = key(_.$key, _.$flat, ctx.expr.codegen));\n}\n/**\n * Resolve a field accessor reference.\n */\n\n\nfunction getField(_, ctx) {\n  if (!_.$field) return null;\n  const k = 'f:' + _.$field + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = field(_.$field, _.$name, ctx.expr.codegen));\n}\n/**\n * Resolve a comparator function reference.\n */\n\n\nfunction getCompare(_, ctx) {\n  // As of Vega 5.5.3, $tupleid sort is no longer used.\n  // Keep here for now for backwards compatibility.\n  const k = 'c:' + _.$compare + '_' + _.$order,\n        c = array(_.$compare).map(_ => _ && _.$tupleid ? tupleid : _);\n  return ctx.fn[k] || (ctx.fn[k] = compare(c, _.$order, ctx.expr.codegen));\n}\n/**\n * Resolve an encode operator reference.\n */\n\n\nfunction getEncode(_, ctx) {\n  const spec = _.$encode,\n        encode = {};\n\n  for (const name in spec) {\n    const enc = spec[name];\n    encode[name] = accessor(ctx.encodeExpression(enc.$expr), enc.$fields);\n    encode[name].output = enc.$output;\n  }\n\n  return encode;\n}\n/**\n * Resolve a context reference.\n */\n\n\nfunction getContext(_, ctx) {\n  return ctx;\n}\n/**\n * Resolve a recursive subflow specification.\n */\n\n\nfunction getSubflow(_, ctx) {\n  const spec = _.$subflow;\n  return function (dataflow, key, parent) {\n    const subctx = ctx.fork().parse(spec),\n          op = subctx.get(spec.operators[0].id),\n          p = subctx.signals.parent;\n    if (p) p.set(parent);\n\n    op.detachSubflow = () => ctx.detach(subctx);\n\n    return op;\n  };\n}\n/**\n * Resolve a tuple id reference.\n */\n\n\nfunction getTupleId() {\n  return tupleid;\n}\n\n/**\n * Parse an event stream specification.\n */\n\nfunction parseStream (spec) {\n  var ctx = this,\n      filter = spec.filter != null ? ctx.eventExpression(spec.filter) : undefined,\n      stream = spec.stream != null ? ctx.get(spec.stream) : undefined,\n      args;\n\n  if (spec.source) {\n    stream = ctx.events(spec.source, spec.type, filter);\n  } else if (spec.merge) {\n    args = spec.merge.map(_ => ctx.get(_));\n    stream = args[0].merge.apply(args[0], args.slice(1));\n  }\n\n  if (spec.between) {\n    args = spec.between.map(_ => ctx.get(_));\n    stream = stream.between(args[0], args[1]);\n  }\n\n  if (spec.filter) {\n    stream = stream.filter(filter);\n  }\n\n  if (spec.throttle != null) {\n    stream = stream.throttle(+spec.throttle);\n  }\n\n  if (spec.debounce != null) {\n    stream = stream.debounce(+spec.debounce);\n  }\n\n  if (stream == null) {\n    error('Invalid stream definition: ' + JSON.stringify(spec));\n  }\n\n  if (spec.consume) stream.consume(true);\n  ctx.stream(spec, stream);\n}\n\n/**\n * Parse an event-driven operator update.\n */\n\nfunction parseUpdate (spec) {\n  var ctx = this,\n      srcid = isObject(srcid = spec.source) ? srcid.$ref : srcid,\n      source = ctx.get(srcid),\n      target = null,\n      update = spec.update,\n      params = undefined;\n  if (!source) error('Source not defined: ' + spec.source);\n  target = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);\n\n  if (update && update.$expr) {\n    if (update.$params) {\n      params = ctx.parseParameters(update.$params);\n    }\n\n    update = ctx.handlerExpression(update.$expr);\n  }\n\n  ctx.update(spec, source, target, update, params);\n}\n\nconst SKIP = {\n  skip: true\n};\nfunction getState(options) {\n  var ctx = this,\n      state = {};\n\n  if (options.signals) {\n    var signals = state.signals = {};\n    Object.keys(ctx.signals).forEach(key => {\n      const op = ctx.signals[key];\n\n      if (options.signals(key, op)) {\n        signals[key] = op.value;\n      }\n    });\n  }\n\n  if (options.data) {\n    var data = state.data = {};\n    Object.keys(ctx.data).forEach(key => {\n      const dataset = ctx.data[key];\n\n      if (options.data(key, dataset)) {\n        data[key] = dataset.input.value;\n      }\n    });\n  }\n\n  if (ctx.subcontext && options.recurse !== false) {\n    state.subcontext = ctx.subcontext.map(ctx => ctx.getState(options));\n  }\n\n  return state;\n}\nfunction setState(state) {\n  var ctx = this,\n      df = ctx.dataflow,\n      data = state.data,\n      signals = state.signals;\n  Object.keys(signals || {}).forEach(key => {\n    df.update(ctx.signals[key], signals[key], SKIP);\n  });\n  Object.keys(data || {}).forEach(key => {\n    df.pulse(ctx.data[key].input, df.changeset().remove(truthy).insert(data[key]));\n  });\n  (state.subcontext || []).forEach((substate, i) => {\n    const subctx = ctx.subcontext[i];\n    if (subctx) subctx.setState(substate);\n  });\n}\n\n/**\n * Context objects store the current parse state.\n * Enables lookup of parsed operators, event streams, accessors, etc.\n * Provides a 'fork' method for creating child contexts for subflows.\n */\n\nfunction context (df, transforms, functions, expr) {\n  return new Context(df, transforms, functions, expr);\n}\n\nfunction Context(df, transforms, functions, expr) {\n  this.dataflow = df;\n  this.transforms = transforms;\n  this.events = df.events.bind(df);\n  this.expr = expr || expressionCodegen, this.signals = {};\n  this.scales = {};\n  this.nodes = {};\n  this.data = {};\n  this.fn = {};\n\n  if (functions) {\n    this.functions = Object.create(functions);\n    this.functions.context = this;\n  }\n}\n\nfunction Subcontext(ctx) {\n  this.dataflow = ctx.dataflow;\n  this.transforms = ctx.transforms;\n  this.events = ctx.events;\n  this.expr = ctx.expr;\n  this.signals = Object.create(ctx.signals);\n  this.scales = Object.create(ctx.scales);\n  this.nodes = Object.create(ctx.nodes);\n  this.data = Object.create(ctx.data);\n  this.fn = Object.create(ctx.fn);\n\n  if (ctx.functions) {\n    this.functions = Object.create(ctx.functions);\n    this.functions.context = this;\n  }\n}\n\nContext.prototype = Subcontext.prototype = {\n  fork() {\n    const ctx = new Subcontext(this);\n    (this.subcontext || (this.subcontext = [])).push(ctx);\n    return ctx;\n  },\n\n  detach(ctx) {\n    this.subcontext = this.subcontext.filter(c => c !== ctx); // disconnect all nodes in the subcontext\n    // wipe out targets first for better efficiency\n\n    const keys = Object.keys(ctx.nodes);\n\n    for (const key of keys) ctx.nodes[key]._targets = null;\n\n    for (const key of keys) ctx.nodes[key].detach();\n\n    ctx.nodes = null;\n  },\n\n  get(id) {\n    return this.nodes[id];\n  },\n\n  set(id, node) {\n    return this.nodes[id] = node;\n  },\n\n  add(spec, op) {\n    const ctx = this,\n          df = ctx.dataflow,\n          data = spec.value;\n    ctx.set(spec.id, op);\n\n    if (isCollect(spec.type) && data) {\n      if (data.$ingest) {\n        df.ingest(op, data.$ingest, data.$format);\n      } else if (data.$request) {\n        df.preload(op, data.$request, data.$format);\n      } else {\n        df.pulse(op, df.changeset().insert(data));\n      }\n    }\n\n    if (spec.root) {\n      ctx.root = op;\n    }\n\n    if (spec.parent) {\n      let p = ctx.get(spec.parent.$ref);\n\n      if (p) {\n        df.connect(p, [op]);\n        op.targets().add(p);\n      } else {\n        (ctx.unresolved = ctx.unresolved || []).push(() => {\n          p = ctx.get(spec.parent.$ref);\n          df.connect(p, [op]);\n          op.targets().add(p);\n        });\n      }\n    }\n\n    if (spec.signal) {\n      ctx.signals[spec.signal] = op;\n    }\n\n    if (spec.scale) {\n      ctx.scales[spec.scale] = op;\n    }\n\n    if (spec.data) {\n      for (const name in spec.data) {\n        const data = ctx.data[name] || (ctx.data[name] = {});\n        spec.data[name].forEach(role => data[role] = op);\n      }\n    }\n  },\n\n  resolve() {\n    (this.unresolved || []).forEach(fn => fn());\n    delete this.unresolved;\n    return this;\n  },\n\n  operator(spec, update) {\n    this.add(spec, this.dataflow.add(spec.value, update));\n  },\n\n  transform(spec, type) {\n    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));\n  },\n\n  stream(spec, stream) {\n    this.set(spec.id, stream);\n  },\n\n  update(spec, stream, target, update, params) {\n    this.dataflow.on(stream, target, update, params, spec.options);\n  },\n\n  // expression parsing\n  operatorExpression(expr) {\n    return this.expr.operator(this, expr);\n  },\n\n  parameterExpression(expr) {\n    return this.expr.parameter(this, expr);\n  },\n\n  eventExpression(expr) {\n    return this.expr.event(this, expr);\n  },\n\n  handlerExpression(expr) {\n    return this.expr.handler(this, expr);\n  },\n\n  encodeExpression(encode) {\n    return this.expr.encode(this, encode);\n  },\n\n  // parse methods\n  parse,\n  parseOperator,\n  parseOperatorParameters,\n  parseParameters,\n  parseStream,\n  parseUpdate,\n  // state methods\n  getState,\n  setState\n};\n\nexport { context };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}