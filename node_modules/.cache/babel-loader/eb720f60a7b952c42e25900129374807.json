{"ast":null,"code":"/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { keys } from './util'; // Facet\n\nexport const ROW = 'row';\nexport const COLUMN = 'column';\nexport const FACET = 'facet'; // Position\n\nexport const X = 'x';\nexport const Y = 'y';\nexport const X2 = 'x2';\nexport const Y2 = 'y2'; // Position Offset\n\nexport const XOFFSET = 'xOffset';\nexport const YOFFSET = 'yOffset'; // Arc-Position\n\nexport const RADIUS = 'radius';\nexport const RADIUS2 = 'radius2';\nexport const THETA = 'theta';\nexport const THETA2 = 'theta2'; // Geo Position\n\nexport const LATITUDE = 'latitude';\nexport const LONGITUDE = 'longitude';\nexport const LATITUDE2 = 'latitude2';\nexport const LONGITUDE2 = 'longitude2'; // Mark property with scale\n\nexport const COLOR = 'color';\nexport const FILL = 'fill';\nexport const STROKE = 'stroke';\nexport const SHAPE = 'shape';\nexport const SIZE = 'size';\nexport const ANGLE = 'angle';\nexport const OPACITY = 'opacity';\nexport const FILLOPACITY = 'fillOpacity';\nexport const STROKEOPACITY = 'strokeOpacity';\nexport const STROKEWIDTH = 'strokeWidth';\nexport const STROKEDASH = 'strokeDash'; // Non-scale channel\n\nexport const TEXT = 'text';\nexport const ORDER = 'order';\nexport const DETAIL = 'detail';\nexport const KEY = 'key';\nexport const TOOLTIP = 'tooltip';\nexport const HREF = 'href';\nexport const URL = 'url';\nexport const DESCRIPTION = 'description';\nconst POSITION_CHANNEL_INDEX = {\n  x: 1,\n  y: 1,\n  x2: 1,\n  y2: 1\n};\nconst POLAR_POSITION_CHANNEL_INDEX = {\n  theta: 1,\n  theta2: 1,\n  radius: 1,\n  radius2: 1\n};\nexport function isPolarPositionChannel(c) {\n  return c in POLAR_POSITION_CHANNEL_INDEX;\n}\nconst GEO_POSIITON_CHANNEL_INDEX = {\n  longitude: 1,\n  longitude2: 1,\n  latitude: 1,\n  latitude2: 1\n};\nexport function getPositionChannelFromLatLong(channel) {\n  switch (channel) {\n    case LATITUDE:\n      return 'y';\n\n    case LATITUDE2:\n      return 'y2';\n\n    case LONGITUDE:\n      return 'x';\n\n    case LONGITUDE2:\n      return 'x2';\n  }\n}\nexport function isGeoPositionChannel(c) {\n  return c in GEO_POSIITON_CHANNEL_INDEX;\n}\nexport const GEOPOSITION_CHANNELS = keys(GEO_POSIITON_CHANNEL_INDEX);\nconst UNIT_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign(Object.assign({}, POSITION_CHANNEL_INDEX), POLAR_POSITION_CHANNEL_INDEX), GEO_POSIITON_CHANNEL_INDEX), {\n  xOffset: 1,\n  yOffset: 1,\n  // color\n  color: 1,\n  fill: 1,\n  stroke: 1,\n  // other non-position with scale\n  opacity: 1,\n  fillOpacity: 1,\n  strokeOpacity: 1,\n  strokeWidth: 1,\n  strokeDash: 1,\n  size: 1,\n  angle: 1,\n  shape: 1,\n  // channels without scales\n  order: 1,\n  text: 1,\n  detail: 1,\n  key: 1,\n  tooltip: 1,\n  href: 1,\n  url: 1,\n  description: 1\n});\nexport function isColorChannel(channel) {\n  return channel === COLOR || channel === FILL || channel === STROKE;\n}\nconst FACET_CHANNEL_INDEX = {\n  row: 1,\n  column: 1,\n  facet: 1\n};\nexport const FACET_CHANNELS = keys(FACET_CHANNEL_INDEX);\nconst CHANNEL_INDEX = Object.assign(Object.assign({}, UNIT_CHANNEL_INDEX), FACET_CHANNEL_INDEX);\nexport const CHANNELS = keys(CHANNEL_INDEX);\n\nconst {\n  order: _o,\n  detail: _d,\n  tooltip: _tt1\n} = CHANNEL_INDEX,\n      SINGLE_DEF_CHANNEL_INDEX = __rest(CHANNEL_INDEX, [\"order\", \"detail\", \"tooltip\"]);\n\nconst {\n  row: _r,\n  column: _c,\n  facet: _f\n} = SINGLE_DEF_CHANNEL_INDEX,\n      SINGLE_DEF_UNIT_CHANNEL_INDEX = __rest(SINGLE_DEF_CHANNEL_INDEX, [\"row\", \"column\", \"facet\"]);\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them. Similarly, selection projection won't work with \"detail\" and \"order\".)\n */\n\n\nexport const SINGLE_DEF_CHANNELS = keys(SINGLE_DEF_CHANNEL_INDEX);\nexport const SINGLE_DEF_UNIT_CHANNELS = keys(SINGLE_DEF_UNIT_CHANNEL_INDEX);\nexport function isSingleDefUnitChannel(str) {\n  return !!SINGLE_DEF_UNIT_CHANNEL_INDEX[str];\n}\nexport function isChannel(str) {\n  return !!CHANNEL_INDEX[str];\n}\nexport const SECONDARY_RANGE_CHANNEL = [X2, Y2, LATITUDE2, LONGITUDE2, THETA2, RADIUS2];\nexport function isSecondaryRangeChannel(c) {\n  const main = getMainRangeChannel(c);\n  return main !== c;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\n\nexport function getMainRangeChannel(channel) {\n  switch (channel) {\n    case X2:\n      return X;\n\n    case Y2:\n      return Y;\n\n    case LATITUDE2:\n      return LATITUDE;\n\n    case LONGITUDE2:\n      return LONGITUDE;\n\n    case THETA2:\n      return THETA;\n\n    case RADIUS2:\n      return RADIUS;\n  }\n\n  return channel;\n}\nexport function getVgPositionChannel(channel) {\n  if (isPolarPositionChannel(channel)) {\n    switch (channel) {\n      case THETA:\n        return 'startAngle';\n\n      case THETA2:\n        return 'endAngle';\n\n      case RADIUS:\n        return 'outerRadius';\n\n      case RADIUS2:\n        return 'innerRadius';\n    }\n  }\n\n  return channel;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\n\nexport function getSecondaryRangeChannel(channel) {\n  switch (channel) {\n    case X:\n      return X2;\n\n    case Y:\n      return Y2;\n\n    case LATITUDE:\n      return LATITUDE2;\n\n    case LONGITUDE:\n      return LONGITUDE2;\n\n    case THETA:\n      return THETA2;\n\n    case RADIUS:\n      return RADIUS2;\n  }\n\n  return undefined;\n}\nexport function getSizeChannel(channel) {\n  switch (channel) {\n    case X:\n    case X2:\n      return 'width';\n\n    case Y:\n    case Y2:\n      return 'height';\n  }\n\n  return undefined;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\n\nexport function getOffsetChannel(channel) {\n  switch (channel) {\n    case X:\n      return 'xOffset';\n\n    case Y:\n      return 'yOffset';\n\n    case X2:\n      return 'x2Offset';\n\n    case Y2:\n      return 'y2Offset';\n\n    case THETA:\n      return 'thetaOffset';\n\n    case RADIUS:\n      return 'radiusOffset';\n\n    case THETA2:\n      return 'theta2Offset';\n\n    case RADIUS2:\n      return 'radius2Offset';\n  }\n\n  return undefined;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\n\nexport function getOffsetScaleChannel(channel) {\n  switch (channel) {\n    case X:\n      return 'xOffset';\n\n    case Y:\n      return 'yOffset';\n  }\n\n  return undefined;\n}\nexport function getMainChannelFromOffsetChannel(channel) {\n  switch (channel) {\n    case 'xOffset':\n      return 'x';\n\n    case 'yOffset':\n      return 'y';\n  }\n} // CHANNELS without COLUMN, ROW\n\nexport const UNIT_CHANNELS = keys(UNIT_CHANNEL_INDEX); // NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\n\nconst {\n  x: _x,\n  y: _y,\n  // x2 and y2 share the same scale as x and y\n  x2: _x2,\n  y2: _y2,\n  //\n  xOffset: _xo,\n  yOffset: _yo,\n  latitude: _latitude,\n  longitude: _longitude,\n  latitude2: _latitude2,\n  longitude2: _longitude2,\n  theta: _theta,\n  theta2: _theta2,\n  radius: _radius,\n  radius2: _radius2\n} = UNIT_CHANNEL_INDEX,\n      // The rest of unit channels then have scale\nNONPOSITION_CHANNEL_INDEX = __rest(UNIT_CHANNEL_INDEX, [\"x\", \"y\", \"x2\", \"y2\", \"xOffset\", \"yOffset\", \"latitude\", \"longitude\", \"latitude2\", \"longitude2\", \"theta\", \"theta2\", \"radius\", \"radius2\"]);\n\nexport const NONPOSITION_CHANNELS = keys(NONPOSITION_CHANNEL_INDEX);\nconst POSITION_SCALE_CHANNEL_INDEX = {\n  x: 1,\n  y: 1\n};\nexport const POSITION_SCALE_CHANNELS = keys(POSITION_SCALE_CHANNEL_INDEX);\nexport function isXorY(channel) {\n  return channel in POSITION_SCALE_CHANNEL_INDEX;\n}\nexport const POLAR_POSITION_SCALE_CHANNEL_INDEX = {\n  theta: 1,\n  radius: 1\n};\nexport const POLAR_POSITION_SCALE_CHANNELS = keys(POLAR_POSITION_SCALE_CHANNEL_INDEX);\nexport function getPositionScaleChannel(sizeType) {\n  return sizeType === 'width' ? X : Y;\n}\nconst OFFSET_SCALE_CHANNEL_INDEX = {\n  xOffset: 1,\n  yOffset: 1\n};\nexport const OFFSET_SCALE_CHANNELS = keys(OFFSET_SCALE_CHANNEL_INDEX);\nexport function isXorYOffset(channel) {\n  return channel in OFFSET_SCALE_CHANNEL_INDEX;\n} // NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without position / offset\n\nconst {\n  // x2 and y2 share the same scale as x and y\n  // text and tooltip have format instead of scale,\n  // href has neither format, nor scale\n  text: _t,\n  tooltip: _tt,\n  href: _hr,\n  url: _u,\n  description: _al,\n  // detail and order have no scale\n  detail: _dd,\n  key: _k,\n  order: _oo\n} = NONPOSITION_CHANNEL_INDEX,\n      NONPOSITION_SCALE_CHANNEL_INDEX = __rest(NONPOSITION_CHANNEL_INDEX, [\"text\", \"tooltip\", \"href\", \"url\", \"description\", \"detail\", \"key\", \"order\"]);\n\nexport const NONPOSITION_SCALE_CHANNELS = keys(NONPOSITION_SCALE_CHANNEL_INDEX);\nexport function isNonPositionScaleChannel(channel) {\n  return !!NONPOSITION_CHANNEL_INDEX[channel];\n}\n/**\n * @returns whether Vega supports legends for a particular channel\n */\n\nexport function supportLegend(channel) {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case SIZE:\n    case SHAPE:\n    case OPACITY:\n    case STROKEWIDTH:\n    case STROKEDASH:\n      return true;\n\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case ANGLE:\n      return false;\n  }\n} // Declare SCALE_CHANNEL_INDEX\n\nconst SCALE_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign(Object.assign({}, POSITION_SCALE_CHANNEL_INDEX), POLAR_POSITION_SCALE_CHANNEL_INDEX), OFFSET_SCALE_CHANNEL_INDEX), NONPOSITION_SCALE_CHANNEL_INDEX);\n/** List of channels with scales */\n\nexport const SCALE_CHANNELS = keys(SCALE_CHANNEL_INDEX);\nexport function isScaleChannel(channel) {\n  return !!SCALE_CHANNEL_INDEX[channel];\n}\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\n\nexport function supportMark(channel, mark) {\n  return getSupportedMark(channel)[mark];\n}\nconst ALL_MARKS = {\n  // all marks\n  arc: 'always',\n  area: 'always',\n  bar: 'always',\n  circle: 'always',\n  geoshape: 'always',\n  image: 'always',\n  line: 'always',\n  rule: 'always',\n  point: 'always',\n  rect: 'always',\n  square: 'always',\n  trail: 'always',\n  text: 'always',\n  tick: 'always'\n};\n\nconst {\n  geoshape: _g\n} = ALL_MARKS,\n      ALL_MARKS_EXCEPT_GEOSHAPE = __rest(ALL_MARKS, [\"geoshape\"]);\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to 'always', 'binned', or undefined\n */\n\n\nfunction getSupportedMark(channel) {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE: // falls through\n\n    case DESCRIPTION:\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case STROKEWIDTH: // falls through\n\n    case FACET:\n    case ROW: // falls through\n\n    case COLUMN:\n      return ALL_MARKS;\n\n    case X:\n    case Y:\n    case XOFFSET:\n    case YOFFSET:\n    case LATITUDE:\n    case LONGITUDE:\n      // all marks except geoshape. geoshape does not use X, Y -- it uses a projection\n      return ALL_MARKS_EXCEPT_GEOSHAPE;\n\n    case X2:\n    case Y2:\n    case LATITUDE2:\n    case LONGITUDE2:\n      return {\n        area: 'always',\n        bar: 'always',\n        image: 'always',\n        rect: 'always',\n        rule: 'always',\n        circle: 'binned',\n        point: 'binned',\n        square: 'binned',\n        tick: 'binned',\n        line: 'binned',\n        trail: 'binned'\n      };\n\n    case SIZE:\n      return {\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        text: 'always',\n        line: 'always',\n        trail: 'always'\n      };\n\n    case STROKEDASH:\n      return {\n        line: 'always',\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        geoshape: 'always'\n      };\n\n    case SHAPE:\n      return {\n        point: 'always',\n        geoshape: 'always'\n      };\n\n    case TEXT:\n      return {\n        text: 'always'\n      };\n\n    case ANGLE:\n      return {\n        point: 'always',\n        square: 'always',\n        text: 'always'\n      };\n\n    case URL:\n      return {\n        image: 'always'\n      };\n\n    case THETA:\n      return {\n        text: 'always',\n        arc: 'always'\n      };\n\n    case RADIUS:\n      return {\n        text: 'always',\n        arc: 'always'\n      };\n\n    case THETA2:\n    case RADIUS2:\n      return {\n        arc: 'always'\n      };\n  }\n}\n\nexport function rangeType(channel) {\n  switch (channel) {\n    case X:\n    case Y:\n    case THETA:\n    case RADIUS:\n    case XOFFSET:\n    case YOFFSET:\n    case SIZE:\n    case ANGLE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY: // X2 and Y2 use X and Y scales, so they similarly have continuous range. [falls through]\n\n    case X2:\n    case Y2:\n    case THETA2:\n    case RADIUS2:\n      return undefined;\n\n    case FACET:\n    case ROW:\n    case COLUMN:\n    case SHAPE:\n    case STROKEDASH: // TEXT, TOOLTIP, URL, and HREF have no scale but have discrete output [falls through]\n\n    case TEXT:\n    case TOOLTIP:\n    case HREF:\n    case URL:\n    case DESCRIPTION:\n      return 'discrete';\n    // Color can be either continuous or discrete, depending on scale type.\n\n    case COLOR:\n    case FILL:\n    case STROKE:\n      return 'flexible';\n    // No scale, no range type.\n\n    case LATITUDE:\n    case LONGITUDE:\n    case LATITUDE2:\n    case LONGITUDE2:\n    case DETAIL:\n    case KEY:\n    case ORDER:\n      return undefined;\n  }\n}","map":{"version":3,"mappings":"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","names":["keys","ROW","COLUMN","FACET","X","Y","X2","Y2","XOFFSET","YOFFSET","RADIUS","RADIUS2","THETA","THETA2","LATITUDE","LONGITUDE","LATITUDE2","LONGITUDE2","COLOR","FILL","STROKE","SHAPE","SIZE","ANGLE","OPACITY","FILLOPACITY","STROKEOPACITY","STROKEWIDTH","STROKEDASH","TEXT","ORDER","DETAIL","KEY","TOOLTIP","HREF","URL","DESCRIPTION","POSITION_CHANNEL_INDEX","x","y","x2","y2","POLAR_POSITION_CHANNEL_INDEX","theta","theta2","radius","radius2","isPolarPositionChannel","c","GEO_POSIITON_CHANNEL_INDEX","longitude","longitude2","latitude","latitude2","getPositionChannelFromLatLong","channel","isGeoPositionChannel","GEOPOSITION_CHANNELS","UNIT_CHANNEL_INDEX","xOffset","yOffset","color","fill","stroke","opacity","fillOpacity","strokeOpacity","strokeWidth","strokeDash","size","angle","shape","order","text","detail","key","tooltip","href","url","description","isColorChannel","FACET_CHANNEL_INDEX","row","column","facet","FACET_CHANNELS","CHANNEL_INDEX","CHANNELS","_o","_d","_tt1","SINGLE_DEF_CHANNEL_INDEX","_r","_c","_f","SINGLE_DEF_UNIT_CHANNEL_INDEX","SINGLE_DEF_CHANNELS","SINGLE_DEF_UNIT_CHANNELS","isSingleDefUnitChannel","str","isChannel","SECONDARY_RANGE_CHANNEL","isSecondaryRangeChannel","main","getMainRangeChannel","getVgPositionChannel","getSecondaryRangeChannel","undefined","getSizeChannel","getOffsetChannel","getOffsetScaleChannel","getMainChannelFromOffsetChannel","UNIT_CHANNELS","_x","_y","_x2","_y2","_xo","_yo","_latitude","_longitude","_latitude2","_longitude2","_theta","_theta2","_radius","_radius2","NONPOSITION_CHANNEL_INDEX","NONPOSITION_CHANNELS","POSITION_SCALE_CHANNEL_INDEX","POSITION_SCALE_CHANNELS","isXorY","POLAR_POSITION_SCALE_CHANNEL_INDEX","POLAR_POSITION_SCALE_CHANNELS","getPositionScaleChannel","sizeType","OFFSET_SCALE_CHANNEL_INDEX","OFFSET_SCALE_CHANNELS","isXorYOffset","_t","_tt","_hr","_u","_al","_dd","_k","_oo","NONPOSITION_SCALE_CHANNEL_INDEX","NONPOSITION_SCALE_CHANNELS","isNonPositionScaleChannel","supportLegend","SCALE_CHANNEL_INDEX","SCALE_CHANNELS","isScaleChannel","supportMark","mark","getSupportedMark","ALL_MARKS","arc","area","bar","circle","geoshape","image","line","rule","point","rect","square","trail","tick","_g","ALL_MARKS_EXCEPT_GEOSHAPE","rangeType"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/channel.ts"],"sourcesContent":["/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\n\nimport {RangeType} from './compile/scale/type';\nimport {Encoding} from './encoding';\nimport {Mark} from './mark';\nimport {EncodingFacetMapping} from './spec/facet';\nimport {Flag, keys} from './util';\n\nexport type Channel = keyof Encoding<any>;\nexport type ExtendedChannel = Channel | FacetChannel;\n\n// Facet\nexport const ROW = 'row' as const;\nexport const COLUMN = 'column' as const;\n\nexport const FACET = 'facet' as const;\n\n// Position\nexport const X = 'x' as const;\nexport const Y = 'y' as const;\nexport const X2 = 'x2' as const;\nexport const Y2 = 'y2' as const;\n\n// Position Offset\nexport const XOFFSET = 'xOffset' as const;\nexport const YOFFSET = 'yOffset' as const;\n\n// Arc-Position\nexport const RADIUS = 'radius' as const;\nexport const RADIUS2 = 'radius2' as const;\nexport const THETA = 'theta' as const;\nexport const THETA2 = 'theta2' as const;\n\n// Geo Position\nexport const LATITUDE = 'latitude' as const;\nexport const LONGITUDE = 'longitude' as const;\nexport const LATITUDE2 = 'latitude2' as const;\nexport const LONGITUDE2 = 'longitude2' as const;\n\n// Mark property with scale\nexport const COLOR = 'color' as const;\n\nexport const FILL = 'fill' as const;\n\nexport const STROKE = 'stroke' as const;\n\nexport const SHAPE = 'shape' as const;\nexport const SIZE = 'size' as const;\n\nexport const ANGLE = 'angle' as const;\n\nexport const OPACITY = 'opacity' as const;\nexport const FILLOPACITY = 'fillOpacity' as const;\n\nexport const STROKEOPACITY = 'strokeOpacity' as const;\n\nexport const STROKEWIDTH = 'strokeWidth' as const;\nexport const STROKEDASH = 'strokeDash' as const;\n\n// Non-scale channel\nexport const TEXT = 'text' as const;\nexport const ORDER = 'order' as const;\nexport const DETAIL = 'detail' as const;\nexport const KEY = 'key' as const;\n\nexport const TOOLTIP = 'tooltip' as const;\nexport const HREF = 'href' as const;\n\nexport const URL = 'url' as const;\nexport const DESCRIPTION = 'description' as const;\n\nconst POSITION_CHANNEL_INDEX = {\n  x: 1,\n  y: 1,\n  x2: 1,\n  y2: 1\n} as const;\n\nexport type PositionChannel = keyof typeof POSITION_CHANNEL_INDEX;\n\nconst POLAR_POSITION_CHANNEL_INDEX = {\n  theta: 1,\n  theta2: 1,\n  radius: 1,\n  radius2: 1\n} as const;\n\nexport type PolarPositionChannel = keyof typeof POLAR_POSITION_CHANNEL_INDEX;\n\nexport function isPolarPositionChannel(c: Channel): c is PolarPositionChannel {\n  return c in POLAR_POSITION_CHANNEL_INDEX;\n}\n\nconst GEO_POSIITON_CHANNEL_INDEX = {\n  longitude: 1,\n  longitude2: 1,\n  latitude: 1,\n  latitude2: 1\n} as const;\n\nexport type GeoPositionChannel = keyof typeof GEO_POSIITON_CHANNEL_INDEX;\n\nexport function getPositionChannelFromLatLong(channel: GeoPositionChannel): PositionChannel {\n  switch (channel) {\n    case LATITUDE:\n      return 'y';\n    case LATITUDE2:\n      return 'y2';\n    case LONGITUDE:\n      return 'x';\n    case LONGITUDE2:\n      return 'x2';\n  }\n}\n\nexport function isGeoPositionChannel(c: Channel): c is GeoPositionChannel {\n  return c in GEO_POSIITON_CHANNEL_INDEX;\n}\n\nexport const GEOPOSITION_CHANNELS = keys(GEO_POSIITON_CHANNEL_INDEX);\n\nconst UNIT_CHANNEL_INDEX: Flag<Channel> = {\n  ...POSITION_CHANNEL_INDEX,\n  ...POLAR_POSITION_CHANNEL_INDEX,\n\n  ...GEO_POSIITON_CHANNEL_INDEX,\n  xOffset: 1,\n  yOffset: 1,\n\n  // color\n  color: 1,\n  fill: 1,\n  stroke: 1,\n\n  // other non-position with scale\n  opacity: 1,\n  fillOpacity: 1,\n  strokeOpacity: 1,\n\n  strokeWidth: 1,\n  strokeDash: 1,\n  size: 1,\n  angle: 1,\n  shape: 1,\n\n  // channels without scales\n  order: 1,\n  text: 1,\n  detail: 1,\n  key: 1,\n  tooltip: 1,\n  href: 1,\n  url: 1,\n  description: 1\n};\n\nexport type ColorChannel = 'color' | 'fill' | 'stroke';\n\nexport function isColorChannel(channel: Channel): channel is ColorChannel {\n  return channel === COLOR || channel === FILL || channel === STROKE;\n}\n\nexport type FacetChannel = keyof EncodingFacetMapping<any, any>;\n\nconst FACET_CHANNEL_INDEX: Flag<keyof EncodingFacetMapping<any, any>> = {\n  row: 1,\n  column: 1,\n  facet: 1\n};\n\nexport const FACET_CHANNELS = keys(FACET_CHANNEL_INDEX);\n\nconst CHANNEL_INDEX = {\n  ...UNIT_CHANNEL_INDEX,\n  ...FACET_CHANNEL_INDEX\n};\n\nexport const CHANNELS = keys(CHANNEL_INDEX);\n\nconst {order: _o, detail: _d, tooltip: _tt1, ...SINGLE_DEF_CHANNEL_INDEX} = CHANNEL_INDEX;\nconst {row: _r, column: _c, facet: _f, ...SINGLE_DEF_UNIT_CHANNEL_INDEX} = SINGLE_DEF_CHANNEL_INDEX;\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them. Similarly, selection projection won't work with \"detail\" and \"order\".)\n */\n\nexport const SINGLE_DEF_CHANNELS = keys(SINGLE_DEF_CHANNEL_INDEX);\n\nexport type SingleDefChannel = typeof SINGLE_DEF_CHANNELS[number];\n\nexport const SINGLE_DEF_UNIT_CHANNELS = keys(SINGLE_DEF_UNIT_CHANNEL_INDEX);\n\nexport type SingleDefUnitChannel = typeof SINGLE_DEF_UNIT_CHANNELS[number];\n\nexport function isSingleDefUnitChannel(str: string): str is SingleDefUnitChannel {\n  return !!SINGLE_DEF_UNIT_CHANNEL_INDEX[str];\n}\n\nexport function isChannel(str: string): str is Channel {\n  return !!CHANNEL_INDEX[str];\n}\n\nexport type SecondaryRangeChannel = 'x2' | 'y2' | 'latitude2' | 'longitude2' | 'theta2' | 'radius2';\n\nexport const SECONDARY_RANGE_CHANNEL: SecondaryRangeChannel[] = [X2, Y2, LATITUDE2, LONGITUDE2, THETA2, RADIUS2];\n\nexport function isSecondaryRangeChannel(c: ExtendedChannel): c is SecondaryRangeChannel {\n  const main = getMainRangeChannel(c);\n  return main !== c;\n}\n\nexport type MainChannelOf<C extends ExtendedChannel> = C extends 'x2'\n  ? 'x'\n  : C extends 'y2'\n  ? 'y'\n  : C extends 'latitude2'\n  ? 'latitude'\n  : C extends 'longitude2'\n  ? 'longitude'\n  : C extends 'theta2'\n  ? 'theta'\n  : C extends 'radius2'\n  ? 'radius'\n  : C;\n\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getMainRangeChannel<C extends ExtendedChannel>(channel: C): MainChannelOf<C> {\n  switch (channel) {\n    case X2:\n      return X as MainChannelOf<C>;\n    case Y2:\n      return Y as MainChannelOf<C>;\n    case LATITUDE2:\n      return LATITUDE as MainChannelOf<C>;\n    case LONGITUDE2:\n      return LONGITUDE as MainChannelOf<C>;\n    case THETA2:\n      return THETA as MainChannelOf<C>;\n    case RADIUS2:\n      return RADIUS as MainChannelOf<C>;\n  }\n  return channel as MainChannelOf<C>;\n}\n\nexport type SecondaryChannelOf<C extends Channel> = C extends 'x'\n  ? 'x2'\n  : C extends 'y'\n  ? 'y2'\n  : C extends 'latitude'\n  ? 'latitude2'\n  : C extends 'longitude'\n  ? 'longitude2'\n  : C extends 'theta'\n  ? 'theta2'\n  : C extends 'radius'\n  ? 'radius2'\n  : undefined;\n\nexport function getVgPositionChannel(channel: PolarPositionChannel | PositionChannel) {\n  if (isPolarPositionChannel(channel)) {\n    switch (channel) {\n      case THETA:\n        return 'startAngle';\n      case THETA2:\n        return 'endAngle';\n      case RADIUS:\n        return 'outerRadius';\n      case RADIUS2:\n        return 'innerRadius';\n    }\n  }\n  return channel;\n}\n\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getSecondaryRangeChannel<C extends Channel>(channel: C): SecondaryChannelOf<C> | undefined {\n  switch (channel) {\n    case X:\n      return X2 as SecondaryChannelOf<C>;\n    case Y:\n      return Y2 as SecondaryChannelOf<C>;\n    case LATITUDE:\n      return LATITUDE2 as SecondaryChannelOf<C>;\n    case LONGITUDE:\n      return LONGITUDE2 as SecondaryChannelOf<C>;\n    case THETA:\n      return THETA2 as SecondaryChannelOf<C>;\n    case RADIUS:\n      return RADIUS2 as SecondaryChannelOf<C>;\n  }\n  return undefined;\n}\n\nexport function getSizeChannel(channel: PositionChannel): 'width' | 'height';\nexport function getSizeChannel(channel: Channel): 'width' | 'height' | undefined;\nexport function getSizeChannel(channel: Channel): 'width' | 'height' | undefined {\n  switch (channel) {\n    case X:\n    case X2:\n      return 'width';\n    case Y:\n    case Y2:\n      return 'height';\n  }\n  return undefined;\n}\n\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getOffsetChannel(channel: Channel) {\n  switch (channel) {\n    case X:\n      return 'xOffset';\n    case Y:\n      return 'yOffset';\n    case X2:\n      return 'x2Offset';\n    case Y2:\n      return 'y2Offset';\n    case THETA:\n      return 'thetaOffset';\n    case RADIUS:\n      return 'radiusOffset';\n    case THETA2:\n      return 'theta2Offset';\n    case RADIUS2:\n      return 'radius2Offset';\n  }\n  return undefined;\n}\n\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getOffsetScaleChannel(channel: Channel): OffsetScaleChannel {\n  switch (channel) {\n    case X:\n      return 'xOffset';\n    case Y:\n      return 'yOffset';\n  }\n  return undefined;\n}\n\nexport function getMainChannelFromOffsetChannel(channel: OffsetScaleChannel): PositionScaleChannel {\n  switch (channel) {\n    case 'xOffset':\n      return 'x';\n    case 'yOffset':\n      return 'y';\n  }\n}\n\n// CHANNELS without COLUMN, ROW\nexport const UNIT_CHANNELS = keys(UNIT_CHANNEL_INDEX);\n\n// NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\nconst {\n  x: _x,\n  y: _y,\n  // x2 and y2 share the same scale as x and y\n  x2: _x2,\n  y2: _y2,\n  //\n  xOffset: _xo,\n  yOffset: _yo,\n  latitude: _latitude,\n  longitude: _longitude,\n  latitude2: _latitude2,\n  longitude2: _longitude2,\n  theta: _theta,\n  theta2: _theta2,\n  radius: _radius,\n  radius2: _radius2,\n  // The rest of unit channels then have scale\n  ...NONPOSITION_CHANNEL_INDEX\n} = UNIT_CHANNEL_INDEX;\n\nexport const NONPOSITION_CHANNELS = keys(NONPOSITION_CHANNEL_INDEX);\nexport type NonPositionChannel = typeof NONPOSITION_CHANNELS[number];\n\nconst POSITION_SCALE_CHANNEL_INDEX = {\n  x: 1,\n  y: 1\n} as const;\nexport const POSITION_SCALE_CHANNELS = keys(POSITION_SCALE_CHANNEL_INDEX);\nexport type PositionScaleChannel = keyof typeof POSITION_SCALE_CHANNEL_INDEX;\n\nexport function isXorY(channel: ExtendedChannel): channel is PositionScaleChannel {\n  return channel in POSITION_SCALE_CHANNEL_INDEX;\n}\n\nexport const POLAR_POSITION_SCALE_CHANNEL_INDEX = {\n  theta: 1,\n  radius: 1\n} as const;\n\nexport const POLAR_POSITION_SCALE_CHANNELS = keys(POLAR_POSITION_SCALE_CHANNEL_INDEX);\nexport type PolarPositionScaleChannel = keyof typeof POLAR_POSITION_SCALE_CHANNEL_INDEX;\n\nexport function getPositionScaleChannel(sizeType: 'width' | 'height'): PositionScaleChannel {\n  return sizeType === 'width' ? X : Y;\n}\n\nconst OFFSET_SCALE_CHANNEL_INDEX: {xOffset: 1; yOffset: 1} = {xOffset: 1, yOffset: 1};\n\nexport const OFFSET_SCALE_CHANNELS = keys(OFFSET_SCALE_CHANNEL_INDEX);\n\nexport type OffsetScaleChannel = typeof OFFSET_SCALE_CHANNELS[0];\n\nexport function isXorYOffset(channel: Channel): channel is OffsetScaleChannel {\n  return channel in OFFSET_SCALE_CHANNEL_INDEX;\n}\n\n// NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without position / offset\nconst {\n  // x2 and y2 share the same scale as x and y\n  // text and tooltip have format instead of scale,\n  // href has neither format, nor scale\n  text: _t,\n  tooltip: _tt,\n  href: _hr,\n  url: _u,\n  description: _al,\n  // detail and order have no scale\n  detail: _dd,\n  key: _k,\n  order: _oo,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n} = NONPOSITION_CHANNEL_INDEX;\nexport const NONPOSITION_SCALE_CHANNELS = keys(NONPOSITION_SCALE_CHANNEL_INDEX);\nexport type NonPositionScaleChannel = typeof NONPOSITION_SCALE_CHANNELS[number];\n\nexport function isNonPositionScaleChannel(channel: Channel): channel is NonPositionScaleChannel {\n  return !!NONPOSITION_CHANNEL_INDEX[channel];\n}\n\n/**\n * @returns whether Vega supports legends for a particular channel\n */\nexport function supportLegend(channel: NonPositionScaleChannel) {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case SIZE:\n    case SHAPE:\n    case OPACITY:\n    case STROKEWIDTH:\n    case STROKEDASH:\n      return true;\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case ANGLE:\n      return false;\n  }\n}\n\n// Declare SCALE_CHANNEL_INDEX\nconst SCALE_CHANNEL_INDEX = {\n  ...POSITION_SCALE_CHANNEL_INDEX,\n  ...POLAR_POSITION_SCALE_CHANNEL_INDEX,\n  ...OFFSET_SCALE_CHANNEL_INDEX,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n};\n\n/** List of channels with scales */\nexport const SCALE_CHANNELS = keys(SCALE_CHANNEL_INDEX);\nexport type ScaleChannel = typeof SCALE_CHANNELS[number];\n\nexport function isScaleChannel(channel: Channel): channel is ScaleChannel {\n  return !!SCALE_CHANNEL_INDEX[channel];\n}\n\nexport type SupportedMark = Partial<Record<Mark, 'always' | 'binned'>>;\n\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nexport function supportMark(channel: ExtendedChannel, mark: Mark) {\n  return getSupportedMark(channel)[mark];\n}\n\nconst ALL_MARKS: Record<Mark, 'always'> = {\n  // all marks\n  arc: 'always',\n  area: 'always',\n  bar: 'always',\n  circle: 'always',\n  geoshape: 'always',\n  image: 'always',\n  line: 'always',\n  rule: 'always',\n  point: 'always',\n  rect: 'always',\n  square: 'always',\n  trail: 'always',\n  text: 'always',\n  tick: 'always'\n};\n\nconst {geoshape: _g, ...ALL_MARKS_EXCEPT_GEOSHAPE} = ALL_MARKS;\n\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to 'always', 'binned', or undefined\n */\nfunction getSupportedMark(channel: ExtendedChannel): SupportedMark {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n    // falls through\n\n    case DESCRIPTION:\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case STROKEWIDTH:\n\n    // falls through\n\n    case FACET:\n    case ROW: // falls through\n    case COLUMN:\n      return ALL_MARKS;\n    case X:\n    case Y:\n    case XOFFSET:\n    case YOFFSET:\n    case LATITUDE:\n    case LONGITUDE:\n      // all marks except geoshape. geoshape does not use X, Y -- it uses a projection\n      return ALL_MARKS_EXCEPT_GEOSHAPE;\n    case X2:\n    case Y2:\n    case LATITUDE2:\n    case LONGITUDE2:\n      return {\n        area: 'always',\n        bar: 'always',\n        image: 'always',\n        rect: 'always',\n        rule: 'always',\n        circle: 'binned',\n        point: 'binned',\n        square: 'binned',\n        tick: 'binned',\n        line: 'binned',\n        trail: 'binned'\n      };\n    case SIZE:\n      return {\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        text: 'always',\n        line: 'always',\n        trail: 'always'\n      };\n    case STROKEDASH:\n      return {\n        line: 'always',\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        geoshape: 'always'\n      };\n    case SHAPE:\n      return {point: 'always', geoshape: 'always'};\n    case TEXT:\n      return {text: 'always'};\n    case ANGLE:\n      return {point: 'always', square: 'always', text: 'always'};\n    case URL:\n      return {image: 'always'};\n    case THETA:\n      return {text: 'always', arc: 'always'};\n    case RADIUS:\n      return {text: 'always', arc: 'always'};\n    case THETA2:\n    case RADIUS2:\n      return {arc: 'always'};\n  }\n}\n\nexport function rangeType(channel: ExtendedChannel): RangeType {\n  switch (channel) {\n    case X:\n    case Y:\n    case THETA:\n    case RADIUS:\n    case XOFFSET:\n    case YOFFSET:\n    case SIZE:\n    case ANGLE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n\n    // X2 and Y2 use X and Y scales, so they similarly have continuous range. [falls through]\n    case X2:\n    case Y2:\n    case THETA2:\n    case RADIUS2:\n      return undefined;\n\n    case FACET:\n    case ROW:\n    case COLUMN:\n    case SHAPE:\n    case STROKEDASH:\n    // TEXT, TOOLTIP, URL, and HREF have no scale but have discrete output [falls through]\n    case TEXT:\n    case TOOLTIP:\n    case HREF:\n    case URL:\n    case DESCRIPTION:\n      return 'discrete';\n\n    // Color can be either continuous or discrete, depending on scale type.\n    case COLOR:\n    case FILL:\n    case STROKE:\n      return 'flexible';\n\n    // No scale, no range type.\n\n    case LATITUDE:\n    case LONGITUDE:\n    case LATITUDE2:\n    case LONGITUDE2:\n    case DETAIL:\n    case KEY:\n    case ORDER:\n      return undefined;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}