{"ast":null,"code":"import { Marks, textMetrics } from 'vega-scenegraph';\nimport { canvas } from 'vega-canvas';\nimport { rederive, Transform } from 'vega-dataflow';\nimport { inherits, isFunction, error, array } from 'vega-util';\nconst ALPHA_MASK = 0xff000000;\n\nfunction baseBitmaps($, data) {\n  const bitmap = $.bitmap(); // when there is no base mark but data points are to be avoided\n\n  (data || []).forEach(d => bitmap.set($(d.boundary[0]), $(d.boundary[3])));\n  return [bitmap, undefined];\n}\n\nfunction markBitmaps($, baseMark, avoidMarks, labelInside, isGroupArea) {\n  // create canvas\n  const width = $.width,\n        height = $.height,\n        border = labelInside || isGroupArea,\n        context = canvas(width, height).getContext('2d'),\n        baseMarkContext = canvas(width, height).getContext('2d'),\n        strokeContext = border && canvas(width, height).getContext('2d'); // render all marks to be avoided into canvas\n\n  avoidMarks.forEach(items => draw(context, items, false));\n  draw(baseMarkContext, baseMark, false);\n\n  if (border) {\n    draw(strokeContext, baseMark, true);\n  } // get canvas buffer, create bitmaps\n\n\n  const buffer = getBuffer(context, width, height),\n        baseMarkBuffer = getBuffer(baseMarkContext, width, height),\n        strokeBuffer = border && getBuffer(strokeContext, width, height),\n        layer1 = $.bitmap(),\n        layer2 = border && $.bitmap(); // populate bitmap layers\n\n  let x, y, u, v, index, alpha, strokeAlpha, baseMarkAlpha;\n\n  for (y = 0; y < height; ++y) {\n    for (x = 0; x < width; ++x) {\n      index = y * width + x;\n      alpha = buffer[index] & ALPHA_MASK;\n      baseMarkAlpha = baseMarkBuffer[index] & ALPHA_MASK;\n      strokeAlpha = border && strokeBuffer[index] & ALPHA_MASK;\n\n      if (alpha || strokeAlpha || baseMarkAlpha) {\n        u = $(x);\n        v = $(y);\n        if (!isGroupArea && (alpha || baseMarkAlpha)) layer1.set(u, v); // update interior bitmap\n\n        if (border && (alpha || strokeAlpha)) layer2.set(u, v); // update border bitmap\n      }\n    }\n  }\n\n  return [layer1, layer2];\n}\n\nfunction getBuffer(context, width, height) {\n  return new Uint32Array(context.getImageData(0, 0, width, height).data.buffer);\n}\n\nfunction draw(context, items, interior) {\n  if (!items.length) return;\n  const type = items[0].mark.marktype;\n\n  if (type === 'group') {\n    items.forEach(group => {\n      group.items.forEach(mark => draw(context, mark.items, interior));\n    });\n  } else {\n    Marks[type].draw(context, {\n      items: interior ? items.map(prepare) : items\n    });\n  }\n}\n/**\n * Prepare item before drawing into canvas (setting stroke and opacity)\n * @param {object} source item to be prepared\n * @returns prepared item\n */\n\n\nfunction prepare(source) {\n  const item = rederive(source, {});\n\n  if (item.stroke && item.strokeOpacity !== 0 || item.fill && item.fillOpacity !== 0) {\n    return { ...item,\n      strokeOpacity: 1,\n      stroke: '#000',\n      fillOpacity: 0\n    };\n  }\n\n  return item;\n}\n\nconst DIV = 5,\n      // bit shift from x, y index to bit vector array index\nMOD = 31,\n      // bit mask for index lookup within a bit vector\nSIZE = 32,\n      // individual bit vector size\nRIGHT0 = new Uint32Array(SIZE + 1),\n      // left-anchored bit vectors, full -> 0\nRIGHT1 = new Uint32Array(SIZE + 1); // right-anchored bit vectors, 0 -> full\n\nRIGHT1[0] = 0;\nRIGHT0[0] = ~RIGHT1[0];\n\nfor (let i = 1; i <= SIZE; ++i) {\n  RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;\n  RIGHT0[i] = ~RIGHT1[i];\n}\n\nfunction Bitmap(w, h) {\n  const array = new Uint32Array(~~((w * h + SIZE) / SIZE));\n\n  function _set(index, mask) {\n    array[index] |= mask;\n  }\n\n  function _clear(index, mask) {\n    array[index] &= mask;\n  }\n\n  return {\n    array: array,\n    get: (x, y) => {\n      const index = y * w + x;\n      return array[index >>> DIV] & 1 << (index & MOD);\n    },\n    set: (x, y) => {\n      const index = y * w + x;\n\n      _set(index >>> DIV, 1 << (index & MOD));\n    },\n    clear: (x, y) => {\n      const index = y * w + x;\n\n      _clear(index >>> DIV, ~(1 << (index & MOD)));\n    },\n    getRange: (x, y, x2, y2) => {\n      let r = y2,\n          start,\n          end,\n          indexStart,\n          indexEnd;\n\n      for (; r >= y; --r) {\n        start = r * w + x;\n        end = r * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n\n        if (indexStart === indexEnd) {\n          if (array[indexStart] & RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]) {\n            return true;\n          }\n        } else {\n          if (array[indexStart] & RIGHT0[start & MOD]) return true;\n          if (array[indexEnd] & RIGHT1[(end & MOD) + 1]) return true;\n\n          for (let i = indexStart + 1; i < indexEnd; ++i) {\n            if (array[i]) return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    setRange: (x, y, x2, y2) => {\n      let start, end, indexStart, indexEnd, i;\n\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n\n        if (indexStart === indexEnd) {\n          _set(indexStart, RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]);\n        } else {\n          _set(indexStart, RIGHT0[start & MOD]);\n\n          _set(indexEnd, RIGHT1[(end & MOD) + 1]);\n\n          for (i = indexStart + 1; i < indexEnd; ++i) _set(i, 0xffffffff);\n        }\n      }\n    },\n    clearRange: (x, y, x2, y2) => {\n      let start, end, indexStart, indexEnd, i;\n\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n\n        if (indexStart === indexEnd) {\n          _clear(indexStart, RIGHT1[start & MOD] | RIGHT0[(end & MOD) + 1]);\n        } else {\n          _clear(indexStart, RIGHT1[start & MOD]);\n\n          _clear(indexEnd, RIGHT0[(end & MOD) + 1]);\n\n          for (i = indexStart + 1; i < indexEnd; ++i) _clear(i, 0);\n        }\n      }\n    },\n    outOfBounds: (x, y, x2, y2) => x < 0 || y < 0 || y2 >= h || x2 >= w\n  };\n}\n\nfunction scaler(width, height, padding) {\n  const ratio = Math.max(1, Math.sqrt(width * height / 1e6)),\n        w = ~~((width + 2 * padding + ratio) / ratio),\n        h = ~~((height + 2 * padding + ratio) / ratio),\n        scale = _ => ~~((_ + padding) / ratio);\n\n  scale.invert = _ => _ * ratio - padding;\n\n  scale.bitmap = () => Bitmap(w, h);\n\n  scale.ratio = ratio;\n  scale.padding = padding;\n  scale.width = width;\n  scale.height = height;\n  return scale;\n}\n\nfunction placeAreaLabelNaive($, bitmaps, avoidBaseMark, markIndex) {\n  const width = $.width,\n        height = $.height; // try to place a label within an input area mark\n\n  return function (d) {\n    const items = d.datum.datum.items[markIndex].items,\n          // area points\n    n = items.length,\n          // number of points\n    textHeight = d.datum.fontSize,\n          // label width\n    textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    let maxAreaWidth = 0,\n        x1,\n        x2,\n        y1,\n        y2,\n        x,\n        y,\n        areaWidth; // for each area sample point\n\n    for (let i = 0; i < n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n      x = (x1 + x2) / 2;\n      y = (y1 + y2) / 2;\n      areaWidth = Math.abs(x2 - x1 + y2 - y1);\n\n      if (areaWidth >= maxAreaWidth) {\n        maxAreaWidth = areaWidth;\n        d.x = x;\n        d.y = y;\n      }\n    }\n\n    x = textWidth / 2;\n    y = textHeight / 2;\n    x1 = d.x - x;\n    x2 = d.x + x;\n    y1 = d.y - y;\n    y2 = d.y + y;\n    d.align = 'center';\n\n    if (x1 < 0 && x2 <= width) {\n      d.align = 'left';\n    } else if (0 <= x1 && width < x2) {\n      d.align = 'right';\n    }\n\n    d.baseline = 'middle';\n\n    if (y1 < 0 && y2 <= height) {\n      d.baseline = 'top';\n    } else if (0 <= y1 && height < y2) {\n      d.baseline = 'bottom';\n    }\n\n    return true;\n  };\n}\n\nfunction outOfBounds(x, y, textWidth, textHeight, width, height) {\n  let r = textWidth / 2;\n  return x - r < 0 || x + r > width || y - (r = textHeight / 2) < 0 || y + r > height;\n}\n\nfunction collision($, x, y, textHeight, textWidth, h, bm0, bm1) {\n  const w = textWidth * h / (textHeight * 2),\n        x1 = $(x - w),\n        x2 = $(x + w),\n        y1 = $(y - (h = h / 2)),\n        y2 = $(y + h);\n  return bm0.outOfBounds(x1, y1, x2, y2) || bm0.getRange(x1, y1, x2, y2) || bm1 && bm1.getRange(x1, y1, x2, y2);\n}\n\nfunction placeAreaLabelReducedSearch($, bitmaps, avoidBaseMark, markIndex) {\n  const width = $.width,\n        height = $.height,\n        bm0 = bitmaps[0],\n        // where labels have been placed\n  bm1 = bitmaps[1]; // area outlines\n\n  function tryLabel(_x, _y, maxSize, textWidth, textHeight) {\n    const x = $.invert(_x),\n          y = $.invert(_y);\n    let lo = maxSize,\n        hi = height,\n        mid;\n\n    if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n      // if the label fits at the current sample point,\n      // perform binary search to find the largest font size that fits\n      while (hi - lo >= 1) {\n        mid = (lo + hi) / 2;\n\n        if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n          hi = mid;\n        } else {\n          lo = mid;\n        }\n      } // place label if current lower bound exceeds prior max font size\n\n\n      if (lo > maxSize) {\n        return [x, y, lo, true];\n      }\n    }\n  } // try to place a label within an input area mark\n\n\n  return function (d) {\n    const items = d.datum.datum.items[markIndex].items,\n          // area points\n    n = items.length,\n          // number of points\n    textHeight = d.datum.fontSize,\n          // label width\n    textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    let maxSize = avoidBaseMark ? textHeight : 0,\n        labelPlaced = false,\n        labelPlaced2 = false,\n        maxAreaWidth = 0,\n        x1,\n        x2,\n        y1,\n        y2,\n        x,\n        y,\n        _x,\n        _y,\n        _x1,\n        _xMid,\n        _x2,\n        _y1,\n        _yMid,\n        _y2,\n        areaWidth,\n        result,\n        swapTmp; // for each area sample point\n\n\n    for (let i = 0; i < n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n\n      if (x1 > x2) {\n        swapTmp = x1;\n        x1 = x2;\n        x2 = swapTmp;\n      }\n\n      if (y1 > y2) {\n        swapTmp = y1;\n        y1 = y2;\n        y2 = swapTmp;\n      }\n\n      _x1 = $(x1);\n      _x2 = $(x2);\n      _xMid = ~~((_x1 + _x2) / 2);\n      _y1 = $(y1);\n      _y2 = $(y2);\n      _yMid = ~~((_y1 + _y2) / 2); // search along the line from mid point between the 2 border to lower border\n\n      for (_x = _xMid; _x >= _x1; --_x) {\n        for (_y = _yMid; _y >= _y1; --_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n\n          if (result) {\n            [d.x, d.y, maxSize, labelPlaced] = result;\n          }\n        }\n      } // search along the line from mid point between the 2 border to upper border\n\n\n      for (_x = _xMid; _x <= _x2; ++_x) {\n        for (_y = _yMid; _y <= _y2; ++_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n\n          if (result) {\n            [d.x, d.y, maxSize, labelPlaced] = result;\n          }\n        }\n      } // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n\n\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2; // place label if it fits and improves the max area width\n\n        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    } // record current label placement information, update label bitmap\n\n\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\n\nconst X_DIR = [-1, -1, 1, 1];\nconst Y_DIR = [-1, 1, -1, 1];\n\nfunction placeAreaLabelFloodFill($, bitmaps, avoidBaseMark, markIndex) {\n  const width = $.width,\n        height = $.height,\n        bm0 = bitmaps[0],\n        // where labels have been placed\n  bm1 = bitmaps[1],\n        // area outlines\n  bm2 = $.bitmap(); // flood-fill visitations\n  // try to place a label within an input area mark\n\n  return function (d) {\n    const items = d.datum.datum.items[markIndex].items,\n          // area points\n    n = items.length,\n          // number of points\n    textHeight = d.datum.fontSize,\n          // label width\n    textWidth = textMetrics.width(d.datum, d.datum.text),\n          // label height\n    stack = []; // flood fill stack\n\n    let maxSize = avoidBaseMark ? textHeight : 0,\n        labelPlaced = false,\n        labelPlaced2 = false,\n        maxAreaWidth = 0,\n        x1,\n        x2,\n        y1,\n        y2,\n        x,\n        y,\n        _x,\n        _y,\n        lo,\n        hi,\n        mid,\n        areaWidth; // for each area sample point\n\n\n    for (let i = 0; i < n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2; // add scaled center point to stack\n\n      stack.push([$((x1 + x2) / 2), $((y1 + y2) / 2)]); // perform flood fill, visit points\n\n      while (stack.length) {\n        [_x, _y] = stack.pop(); // exit if point already marked\n\n        if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y)) continue; // mark point in flood fill bitmap\n        // add search points for all (in bound) directions\n\n        bm2.set(_x, _y);\n\n        for (let j = 0; j < 4; ++j) {\n          x = _x + X_DIR[j];\n          y = _y + Y_DIR[j];\n          if (!bm2.outOfBounds(x, y, x, y)) stack.push([x, y]);\n        } // unscale point back to x, y space\n\n\n        x = $.invert(_x);\n        y = $.invert(_y);\n        lo = maxSize;\n        hi = height; // TODO: make this bound smaller\n\n        if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          // if the label fits at the current sample point,\n          // perform binary search to find the largest font size that fits\n          while (hi - lo >= 1) {\n            mid = (lo + hi) / 2;\n\n            if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n              hi = mid;\n            } else {\n              lo = mid;\n            }\n          } // place label if current lower bound exceeds prior max font size\n\n\n          if (lo > maxSize) {\n            d.x = x;\n            d.y = y;\n            maxSize = lo;\n            labelPlaced = true;\n          }\n        }\n      } // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n\n\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2; // place label if it fits and improves the max area width\n\n        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    } // record current label placement information, update label bitmap\n\n\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\n\nconst Aligns = ['right', 'center', 'left'],\n      Baselines = ['bottom', 'middle', 'top'];\n\nfunction placeMarkLabel($, bitmaps, anchors, offsets) {\n  const width = $.width,\n        height = $.height,\n        bm0 = bitmaps[0],\n        bm1 = bitmaps[1],\n        n = offsets.length;\n  return function (d) {\n    var _d$textWidth;\n\n    const boundary = d.boundary,\n          textHeight = d.datum.fontSize; // can not be placed if the mark is not visible in the graph bound\n\n    if (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width || boundary[3] > height) {\n      return false;\n    }\n\n    let textWidth = (_d$textWidth = d.textWidth) !== null && _d$textWidth !== void 0 ? _d$textWidth : 0,\n        dx,\n        dy,\n        isInside,\n        sizeFactor,\n        insideFactor,\n        x1,\n        x2,\n        y1,\n        y2,\n        xc,\n        yc,\n        _x1,\n        _x2,\n        _y1,\n        _y2; // for each anchor and offset\n\n\n    for (let i = 0; i < n; ++i) {\n      dx = (anchors[i] & 0x3) - 1;\n      dy = (anchors[i] >>> 0x2 & 0x3) - 1;\n      isInside = dx === 0 && dy === 0 || offsets[i] < 0;\n      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;\n      insideFactor = offsets[i] < 0 ? -1 : 1;\n      x1 = boundary[1 + dx] + offsets[i] * dx * sizeFactor;\n      yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets[i] * dy * sizeFactor;\n      y1 = yc - textHeight / 2;\n      y2 = yc + textHeight / 2;\n      _x1 = $(x1);\n      _y1 = $(y1);\n      _y2 = $(y2);\n\n      if (!textWidth) {\n        // to avoid finding width of text label,\n        if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x1, x1, y1, y2, boundary, isInside)) {\n          // skip this anchor/offset option if we fail to place a label with 1px width\n          continue;\n        } else {\n          // Otherwise, find the label width\n          textWidth = textMetrics.width(d.datum, d.datum.text);\n        }\n      }\n\n      xc = x1 + insideFactor * textWidth * dx / 2;\n      x1 = xc - textWidth / 2;\n      x2 = xc + textWidth / 2;\n      _x1 = $(x1);\n      _x2 = $(x2);\n\n      if (test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside)) {\n        // place label if the position is placeable\n        d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x1;\n        d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y1;\n        d.align = Aligns[dx * insideFactor + 1];\n        d.baseline = Baselines[dy * insideFactor + 1];\n        bm0.setRange(_x1, _y1, _x2, _y2);\n        return true;\n      }\n    }\n\n    return false;\n  };\n} // Test if a label with the given dimensions can be added without overlap\n\n\nfunction test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside) {\n  return !(bm0.outOfBounds(_x1, _y1, _x2, _y2) || (isInside && bm1 || bm0).getRange(_x1, _y1, _x2, _y2));\n}\n\nconst TOP = 0x0,\n      MIDDLE = 0x4,\n      BOTTOM = 0x8,\n      LEFT = 0x0,\n      CENTER = 0x1,\n      RIGHT = 0x2; // Mapping from text anchor to number representation\n\nconst anchorCode = {\n  'top-left': TOP + LEFT,\n  'top': TOP + CENTER,\n  'top-right': TOP + RIGHT,\n  'left': MIDDLE + LEFT,\n  'middle': MIDDLE + CENTER,\n  'right': MIDDLE + RIGHT,\n  'bottom-left': BOTTOM + LEFT,\n  'bottom': BOTTOM + CENTER,\n  'bottom-right': BOTTOM + RIGHT\n};\nconst placeAreaLabel = {\n  'naive': placeAreaLabelNaive,\n  'reduced-search': placeAreaLabelReducedSearch,\n  'floodfill': placeAreaLabelFloodFill\n};\n\nfunction labelLayout(texts, size, compare, offset, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding, method) {\n  // early exit for empty data\n  if (!texts.length) return texts;\n  const positions = Math.max(offset.length, anchor.length),\n        offsets = getOffsets(offset, positions),\n        anchors = getAnchors(anchor, positions),\n        marktype = markType(texts[0].datum),\n        grouptype = marktype === 'group' && texts[0].datum.items[markIndex].marktype,\n        isGroupArea = grouptype === 'area',\n        boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex),\n        infPadding = padding === null || padding === Infinity,\n        isNaiveGroupArea = isGroupArea && method === 'naive';\n  let maxTextWidth = -1,\n      maxTextHeight = -1; // prepare text mark data for placing\n\n  const data = texts.map(d => {\n    const textWidth = infPadding ? textMetrics.width(d, d.text) : undefined;\n    maxTextWidth = Math.max(maxTextWidth, textWidth);\n    maxTextHeight = Math.max(maxTextHeight, d.fontSize);\n    return {\n      datum: d,\n      opacity: 0,\n      x: undefined,\n      y: undefined,\n      align: undefined,\n      baseline: undefined,\n      boundary: boundary(d),\n      textWidth\n    };\n  });\n  padding = padding === null || padding === Infinity ? Math.max(maxTextWidth, maxTextHeight) + Math.max(...offset) : padding;\n  const $ = scaler(size[0], size[1], padding);\n  let bitmaps;\n\n  if (!isNaiveGroupArea) {\n    // sort labels in priority order, if comparator is provided\n    if (compare) {\n      data.sort((a, b) => compare(a.datum, b.datum));\n    } // flag indicating if label can be placed inside its base mark\n\n\n    let labelInside = false;\n\n    for (let i = 0; i < anchors.length && !labelInside; ++i) {\n      // label inside if anchor is at center\n      // label inside if offset to be inside the mark bound\n      labelInside = anchors[i] === 0x5 || offsets[i] < 0;\n    } // extract data information from base mark when base mark is to be avoided\n    // base mark is implicitly avoided if it is a group area\n\n\n    const baseMark = (marktype && avoidBaseMark || isGroupArea) && texts.map(d => d.datum); // generate bitmaps for layout calculation\n\n    bitmaps = avoidMarks.length || baseMark ? markBitmaps($, baseMark || [], avoidMarks, labelInside, isGroupArea) : baseBitmaps($, avoidBaseMark && data);\n  } // generate label placement function\n\n\n  const place = isGroupArea ? placeAreaLabel[method]($, bitmaps, avoidBaseMark, markIndex) : placeMarkLabel($, bitmaps, anchors, offsets); // place all labels\n\n  data.forEach(d => d.opacity = +place(d));\n  return data;\n}\n\nfunction getOffsets(_, count) {\n  const offsets = new Float64Array(count),\n        n = _.length;\n\n  for (let i = 0; i < n; ++i) offsets[i] = _[i] || 0;\n\n  for (let i = n; i < count; ++i) offsets[i] = offsets[n - 1];\n\n  return offsets;\n}\n\nfunction getAnchors(_, count) {\n  const anchors = new Int8Array(count),\n        n = _.length;\n\n  for (let i = 0; i < n; ++i) anchors[i] |= anchorCode[_[i]];\n\n  for (let i = n; i < count; ++i) anchors[i] = anchors[n - 1];\n\n  return anchors;\n}\n\nfunction markType(item) {\n  return item && item.mark && item.mark.marktype;\n}\n/**\n * Factory function for function for getting base mark boundary, depending\n * on mark and group type. When mark type is undefined, line or area: boundary\n * is the coordinate of each data point. When base mark is grouped line,\n * boundary is either at the start or end of the line depending on the\n * value of lineAnchor. Otherwise, use bounds of base mark.\n */\n\n\nfunction markBoundary(marktype, grouptype, lineAnchor, markIndex) {\n  const xy = d => [d.x, d.x, d.x, d.y, d.y, d.y];\n\n  if (!marktype) {\n    return xy; // no reactive geometry\n  } else if (marktype === 'line' || marktype === 'area') {\n    return d => xy(d.datum);\n  } else if (grouptype === 'line') {\n    return d => {\n      const items = d.datum.items[markIndex].items;\n      return xy(items.length ? items[lineAnchor === 'start' ? 0 : items.length - 1] : {\n        x: NaN,\n        y: NaN\n      });\n    };\n  } else {\n    return d => {\n      const b = d.datum.bounds;\n      return [b.x1, (b.x1 + b.x2) / 2, b.x2, b.y1, (b.y1 + b.y2) / 2, b.y2];\n    };\n  }\n}\n\nconst Output = ['x', 'y', 'opacity', 'align', 'baseline'];\nconst Anchors = ['top-left', 'left', 'bottom-left', 'top', 'bottom', 'top-right', 'right', 'bottom-right'];\n/**\n * Compute text label layout to annotate marks.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The size of the layout, provided as a [width, height] array.\n * @param {function(*,*): number} [params.sort] - An optional\n *   comparator function for sorting label data in priority order.\n * @param {Array<string>} [params.anchor] - Label anchor points relative to the base mark bounding box.\n *   The available options are 'top-left', 'left', 'bottom-left', 'top',\n *   'bottom', 'top-right', 'right', 'bottom-right', 'middle'.\n * @param {Array<number>} [params.offset] - Label offsets (in pixels) from the base mark bounding box.\n *   This parameter is parallel to the list of anchor points.\n * @param {number | null} [params.padding=0] - The amount (in pixels) that a label may exceed the layout size.\n *   If this parameter is null, a label may exceed the layout size without any boundary.\n * @param {string} [params.lineAnchor='end'] - For group line mark labels only, indicates the anchor\n *   position for labels. One of 'start' or 'end'.\n * @param {string} [params.markIndex=0] - For group mark labels only, an index indicating\n *   which mark within the group should be labeled.\n * @param {Array<number>} [params.avoidMarks] - A list of additional mark names for which the label\n *   layout should avoid overlap.\n * @param {boolean} [params.avoidBaseMark=true] - Boolean flag indicating if labels should avoid\n *   overlap with the underlying base mark being labeled.\n * @param {string} [params.method='naive'] - For area make labels only, a method for\n *   place labels. One of 'naive', 'reduced-search', or 'floodfill'.\n * @param {Array<string>} [params.as] - The output fields written by the transform.\n *   The default is ['x', 'y', 'opacity', 'align', 'baseline'].\n */\n\nfunction Label(params) {\n  Transform.call(this, null, params);\n}\n\nLabel.Definition = {\n  type: 'Label',\n  metadata: {\n    modifies: true\n  },\n  params: [{\n    name: 'size',\n    type: 'number',\n    array: true,\n    length: 2,\n    required: true\n  }, {\n    name: 'sort',\n    type: 'compare'\n  }, {\n    name: 'anchor',\n    type: 'string',\n    array: true,\n    default: Anchors\n  }, {\n    name: 'offset',\n    type: 'number',\n    array: true,\n    default: [1]\n  }, {\n    name: 'padding',\n    type: 'number',\n    default: 0,\n    null: true\n  }, {\n    name: 'lineAnchor',\n    type: 'string',\n    values: ['start', 'end'],\n    default: 'end'\n  }, {\n    name: 'markIndex',\n    type: 'number',\n    default: 0\n  }, {\n    name: 'avoidBaseMark',\n    type: 'boolean',\n    default: true\n  }, {\n    name: 'avoidMarks',\n    type: 'data',\n    array: true\n  }, {\n    name: 'method',\n    type: 'string',\n    default: 'naive'\n  }, {\n    name: 'as',\n    type: 'string',\n    array: true,\n    length: Output.length,\n    default: Output\n  }]\n};\ninherits(Label, Transform, {\n  transform(_, pulse) {\n    function modp(param) {\n      const p = _[param];\n      return isFunction(p) && pulse.modified(p.fields);\n    }\n\n    const mod = _.modified();\n\n    if (!(mod || pulse.changed(pulse.ADD_REM) || modp('sort'))) return;\n\n    if (!_.size || _.size.length !== 2) {\n      error('Size parameter should be specified as a [width, height] array.');\n    }\n\n    const as = _.as || Output; // run label layout\n\n    labelLayout(pulse.materialize(pulse.SOURCE).source || [], _.size, _.sort, array(_.offset == null ? 1 : _.offset), array(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark !== false, _.lineAnchor || 'end', _.markIndex || 0, _.padding === undefined ? 0 : _.padding, _.method || 'naive').forEach(l => {\n      // write layout results to data stream\n      const t = l.datum;\n      t[as[0]] = l.x;\n      t[as[1]] = l.y;\n      t[as[2]] = l.opacity;\n      t[as[3]] = l.align;\n      t[as[4]] = l.baseline;\n    });\n    return pulse.reflow(mod).modifies(as);\n  }\n\n});\nexport { Label as label };","map":{"version":3,"names":["Marks","textMetrics","canvas","rederive","Transform","inherits","isFunction","error","array","ALPHA_MASK","baseBitmaps","$","data","bitmap","forEach","d","set","boundary","undefined","markBitmaps","baseMark","avoidMarks","labelInside","isGroupArea","width","height","border","context","getContext","baseMarkContext","strokeContext","items","draw","buffer","getBuffer","baseMarkBuffer","strokeBuffer","layer1","layer2","x","y","u","v","index","alpha","strokeAlpha","baseMarkAlpha","Uint32Array","getImageData","interior","length","type","mark","marktype","group","map","prepare","source","item","stroke","strokeOpacity","fill","fillOpacity","DIV","MOD","SIZE","RIGHT0","RIGHT1","i","Bitmap","w","h","_set","mask","_clear","get","clear","getRange","x2","y2","r","start","end","indexStart","indexEnd","setRange","clearRange","outOfBounds","scaler","padding","ratio","Math","max","sqrt","scale","_","invert","placeAreaLabelNaive","bitmaps","avoidBaseMark","markIndex","datum","n","textHeight","fontSize","textWidth","text","maxAreaWidth","x1","y1","areaWidth","abs","align","baseline","collision","bm0","bm1","placeAreaLabelReducedSearch","tryLabel","_x","_y","maxSize","lo","hi","mid","labelPlaced","labelPlaced2","_x1","_xMid","_x2","_y1","_yMid","_y2","result","swapTmp","X_DIR","Y_DIR","placeAreaLabelFloodFill","bm2","stack","push","pop","j","Aligns","Baselines","placeMarkLabel","anchors","offsets","_d$textWidth","dx","dy","isInside","sizeFactor","insideFactor","xc","yc","SQRT1_2","test","TOP","MIDDLE","BOTTOM","LEFT","CENTER","RIGHT","anchorCode","placeAreaLabel","labelLayout","texts","size","compare","offset","anchor","lineAnchor","method","positions","getOffsets","getAnchors","markType","grouptype","markBoundary","infPadding","Infinity","isNaiveGroupArea","maxTextWidth","maxTextHeight","opacity","sort","a","b","place","count","Float64Array","Int8Array","xy","NaN","bounds","Output","Anchors","Label","params","call","Definition","metadata","modifies","name","required","default","null","values","transform","pulse","modp","param","p","modified","fields","mod","changed","ADD_REM","as","materialize","SOURCE","l","t","reflow","label"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-label/build/vega-label.module.js"],"sourcesContent":["import { Marks, textMetrics } from 'vega-scenegraph';\nimport { canvas } from 'vega-canvas';\nimport { rederive, Transform } from 'vega-dataflow';\nimport { inherits, isFunction, error, array } from 'vega-util';\n\nconst ALPHA_MASK = 0xff000000;\nfunction baseBitmaps($, data) {\n  const bitmap = $.bitmap(); // when there is no base mark but data points are to be avoided\n\n  (data || []).forEach(d => bitmap.set($(d.boundary[0]), $(d.boundary[3])));\n  return [bitmap, undefined];\n}\nfunction markBitmaps($, baseMark, avoidMarks, labelInside, isGroupArea) {\n  // create canvas\n  const width = $.width,\n        height = $.height,\n        border = labelInside || isGroupArea,\n        context = canvas(width, height).getContext('2d'),\n        baseMarkContext = canvas(width, height).getContext('2d'),\n        strokeContext = border && canvas(width, height).getContext('2d'); // render all marks to be avoided into canvas\n\n  avoidMarks.forEach(items => draw(context, items, false));\n  draw(baseMarkContext, baseMark, false);\n\n  if (border) {\n    draw(strokeContext, baseMark, true);\n  } // get canvas buffer, create bitmaps\n\n\n  const buffer = getBuffer(context, width, height),\n        baseMarkBuffer = getBuffer(baseMarkContext, width, height),\n        strokeBuffer = border && getBuffer(strokeContext, width, height),\n        layer1 = $.bitmap(),\n        layer2 = border && $.bitmap(); // populate bitmap layers\n\n  let x, y, u, v, index, alpha, strokeAlpha, baseMarkAlpha;\n\n  for (y = 0; y < height; ++y) {\n    for (x = 0; x < width; ++x) {\n      index = y * width + x;\n      alpha = buffer[index] & ALPHA_MASK;\n      baseMarkAlpha = baseMarkBuffer[index] & ALPHA_MASK;\n      strokeAlpha = border && strokeBuffer[index] & ALPHA_MASK;\n\n      if (alpha || strokeAlpha || baseMarkAlpha) {\n        u = $(x);\n        v = $(y);\n        if (!isGroupArea && (alpha || baseMarkAlpha)) layer1.set(u, v); // update interior bitmap\n\n        if (border && (alpha || strokeAlpha)) layer2.set(u, v); // update border bitmap\n      }\n    }\n  }\n\n  return [layer1, layer2];\n}\n\nfunction getBuffer(context, width, height) {\n  return new Uint32Array(context.getImageData(0, 0, width, height).data.buffer);\n}\n\nfunction draw(context, items, interior) {\n  if (!items.length) return;\n  const type = items[0].mark.marktype;\n\n  if (type === 'group') {\n    items.forEach(group => {\n      group.items.forEach(mark => draw(context, mark.items, interior));\n    });\n  } else {\n    Marks[type].draw(context, {\n      items: interior ? items.map(prepare) : items\n    });\n  }\n}\n/**\n * Prepare item before drawing into canvas (setting stroke and opacity)\n * @param {object} source item to be prepared\n * @returns prepared item\n */\n\n\nfunction prepare(source) {\n  const item = rederive(source, {});\n\n  if (item.stroke && item.strokeOpacity !== 0 || item.fill && item.fillOpacity !== 0) {\n    return { ...item,\n      strokeOpacity: 1,\n      stroke: '#000',\n      fillOpacity: 0\n    };\n  }\n\n  return item;\n}\n\nconst DIV = 5,\n      // bit shift from x, y index to bit vector array index\nMOD = 31,\n      // bit mask for index lookup within a bit vector\nSIZE = 32,\n      // individual bit vector size\nRIGHT0 = new Uint32Array(SIZE + 1),\n      // left-anchored bit vectors, full -> 0\nRIGHT1 = new Uint32Array(SIZE + 1); // right-anchored bit vectors, 0 -> full\n\nRIGHT1[0] = 0;\nRIGHT0[0] = ~RIGHT1[0];\n\nfor (let i = 1; i <= SIZE; ++i) {\n  RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;\n  RIGHT0[i] = ~RIGHT1[i];\n}\n\nfunction Bitmap (w, h) {\n  const array = new Uint32Array(~~((w * h + SIZE) / SIZE));\n\n  function _set(index, mask) {\n    array[index] |= mask;\n  }\n\n  function _clear(index, mask) {\n    array[index] &= mask;\n  }\n\n  return {\n    array: array,\n    get: (x, y) => {\n      const index = y * w + x;\n      return array[index >>> DIV] & 1 << (index & MOD);\n    },\n    set: (x, y) => {\n      const index = y * w + x;\n\n      _set(index >>> DIV, 1 << (index & MOD));\n    },\n    clear: (x, y) => {\n      const index = y * w + x;\n\n      _clear(index >>> DIV, ~(1 << (index & MOD)));\n    },\n    getRange: (x, y, x2, y2) => {\n      let r = y2,\n          start,\n          end,\n          indexStart,\n          indexEnd;\n\n      for (; r >= y; --r) {\n        start = r * w + x;\n        end = r * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n\n        if (indexStart === indexEnd) {\n          if (array[indexStart] & RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]) {\n            return true;\n          }\n        } else {\n          if (array[indexStart] & RIGHT0[start & MOD]) return true;\n          if (array[indexEnd] & RIGHT1[(end & MOD) + 1]) return true;\n\n          for (let i = indexStart + 1; i < indexEnd; ++i) {\n            if (array[i]) return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    setRange: (x, y, x2, y2) => {\n      let start, end, indexStart, indexEnd, i;\n\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n\n        if (indexStart === indexEnd) {\n          _set(indexStart, RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]);\n        } else {\n          _set(indexStart, RIGHT0[start & MOD]);\n\n          _set(indexEnd, RIGHT1[(end & MOD) + 1]);\n\n          for (i = indexStart + 1; i < indexEnd; ++i) _set(i, 0xffffffff);\n        }\n      }\n    },\n    clearRange: (x, y, x2, y2) => {\n      let start, end, indexStart, indexEnd, i;\n\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n\n        if (indexStart === indexEnd) {\n          _clear(indexStart, RIGHT1[start & MOD] | RIGHT0[(end & MOD) + 1]);\n        } else {\n          _clear(indexStart, RIGHT1[start & MOD]);\n\n          _clear(indexEnd, RIGHT0[(end & MOD) + 1]);\n\n          for (i = indexStart + 1; i < indexEnd; ++i) _clear(i, 0);\n        }\n      }\n    },\n    outOfBounds: (x, y, x2, y2) => x < 0 || y < 0 || y2 >= h || x2 >= w\n  };\n}\n\nfunction scaler (width, height, padding) {\n  const ratio = Math.max(1, Math.sqrt(width * height / 1e6)),\n        w = ~~((width + 2 * padding + ratio) / ratio),\n        h = ~~((height + 2 * padding + ratio) / ratio),\n        scale = _ => ~~((_ + padding) / ratio);\n\n  scale.invert = _ => _ * ratio - padding;\n\n  scale.bitmap = () => Bitmap(w, h);\n\n  scale.ratio = ratio;\n  scale.padding = padding;\n  scale.width = width;\n  scale.height = height;\n  return scale;\n}\n\nfunction placeAreaLabelNaive ($, bitmaps, avoidBaseMark, markIndex) {\n  const width = $.width,\n        height = $.height; // try to place a label within an input area mark\n\n  return function (d) {\n    const items = d.datum.datum.items[markIndex].items,\n          // area points\n    n = items.length,\n          // number of points\n    textHeight = d.datum.fontSize,\n          // label width\n    textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    let maxAreaWidth = 0,\n        x1,\n        x2,\n        y1,\n        y2,\n        x,\n        y,\n        areaWidth; // for each area sample point\n\n    for (let i = 0; i < n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n      x = (x1 + x2) / 2;\n      y = (y1 + y2) / 2;\n      areaWidth = Math.abs(x2 - x1 + y2 - y1);\n\n      if (areaWidth >= maxAreaWidth) {\n        maxAreaWidth = areaWidth;\n        d.x = x;\n        d.y = y;\n      }\n    }\n\n    x = textWidth / 2;\n    y = textHeight / 2;\n    x1 = d.x - x;\n    x2 = d.x + x;\n    y1 = d.y - y;\n    y2 = d.y + y;\n    d.align = 'center';\n\n    if (x1 < 0 && x2 <= width) {\n      d.align = 'left';\n    } else if (0 <= x1 && width < x2) {\n      d.align = 'right';\n    }\n\n    d.baseline = 'middle';\n\n    if (y1 < 0 && y2 <= height) {\n      d.baseline = 'top';\n    } else if (0 <= y1 && height < y2) {\n      d.baseline = 'bottom';\n    }\n\n    return true;\n  };\n}\n\nfunction outOfBounds(x, y, textWidth, textHeight, width, height) {\n  let r = textWidth / 2;\n  return x - r < 0 || x + r > width || y - (r = textHeight / 2) < 0 || y + r > height;\n}\nfunction collision($, x, y, textHeight, textWidth, h, bm0, bm1) {\n  const w = textWidth * h / (textHeight * 2),\n        x1 = $(x - w),\n        x2 = $(x + w),\n        y1 = $(y - (h = h / 2)),\n        y2 = $(y + h);\n  return bm0.outOfBounds(x1, y1, x2, y2) || bm0.getRange(x1, y1, x2, y2) || bm1 && bm1.getRange(x1, y1, x2, y2);\n}\n\nfunction placeAreaLabelReducedSearch ($, bitmaps, avoidBaseMark, markIndex) {\n  const width = $.width,\n        height = $.height,\n        bm0 = bitmaps[0],\n        // where labels have been placed\n  bm1 = bitmaps[1]; // area outlines\n\n  function tryLabel(_x, _y, maxSize, textWidth, textHeight) {\n    const x = $.invert(_x),\n          y = $.invert(_y);\n    let lo = maxSize,\n        hi = height,\n        mid;\n\n    if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n      // if the label fits at the current sample point,\n      // perform binary search to find the largest font size that fits\n      while (hi - lo >= 1) {\n        mid = (lo + hi) / 2;\n\n        if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n          hi = mid;\n        } else {\n          lo = mid;\n        }\n      } // place label if current lower bound exceeds prior max font size\n\n\n      if (lo > maxSize) {\n        return [x, y, lo, true];\n      }\n    }\n  } // try to place a label within an input area mark\n\n\n  return function (d) {\n    const items = d.datum.datum.items[markIndex].items,\n          // area points\n    n = items.length,\n          // number of points\n    textHeight = d.datum.fontSize,\n          // label width\n    textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    let maxSize = avoidBaseMark ? textHeight : 0,\n        labelPlaced = false,\n        labelPlaced2 = false,\n        maxAreaWidth = 0,\n        x1,\n        x2,\n        y1,\n        y2,\n        x,\n        y,\n        _x,\n        _y,\n        _x1,\n        _xMid,\n        _x2,\n        _y1,\n        _yMid,\n        _y2,\n        areaWidth,\n        result,\n        swapTmp; // for each area sample point\n\n\n    for (let i = 0; i < n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n\n      if (x1 > x2) {\n        swapTmp = x1;\n        x1 = x2;\n        x2 = swapTmp;\n      }\n\n      if (y1 > y2) {\n        swapTmp = y1;\n        y1 = y2;\n        y2 = swapTmp;\n      }\n\n      _x1 = $(x1);\n      _x2 = $(x2);\n      _xMid = ~~((_x1 + _x2) / 2);\n      _y1 = $(y1);\n      _y2 = $(y2);\n      _yMid = ~~((_y1 + _y2) / 2); // search along the line from mid point between the 2 border to lower border\n\n      for (_x = _xMid; _x >= _x1; --_x) {\n        for (_y = _yMid; _y >= _y1; --_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n\n          if (result) {\n            [d.x, d.y, maxSize, labelPlaced] = result;\n          }\n        }\n      } // search along the line from mid point between the 2 border to upper border\n\n\n      for (_x = _xMid; _x <= _x2; ++_x) {\n        for (_y = _yMid; _y <= _y2; ++_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n\n          if (result) {\n            [d.x, d.y, maxSize, labelPlaced] = result;\n          }\n        }\n      } // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n\n\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2; // place label if it fits and improves the max area width\n\n        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    } // record current label placement information, update label bitmap\n\n\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\n\nconst X_DIR = [-1, -1, 1, 1];\nconst Y_DIR = [-1, 1, -1, 1];\nfunction placeAreaLabelFloodFill ($, bitmaps, avoidBaseMark, markIndex) {\n  const width = $.width,\n        height = $.height,\n        bm0 = bitmaps[0],\n        // where labels have been placed\n  bm1 = bitmaps[1],\n        // area outlines\n  bm2 = $.bitmap(); // flood-fill visitations\n  // try to place a label within an input area mark\n\n  return function (d) {\n    const items = d.datum.datum.items[markIndex].items,\n          // area points\n    n = items.length,\n          // number of points\n    textHeight = d.datum.fontSize,\n          // label width\n    textWidth = textMetrics.width(d.datum, d.datum.text),\n          // label height\n    stack = []; // flood fill stack\n\n    let maxSize = avoidBaseMark ? textHeight : 0,\n        labelPlaced = false,\n        labelPlaced2 = false,\n        maxAreaWidth = 0,\n        x1,\n        x2,\n        y1,\n        y2,\n        x,\n        y,\n        _x,\n        _y,\n        lo,\n        hi,\n        mid,\n        areaWidth; // for each area sample point\n\n\n    for (let i = 0; i < n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2; // add scaled center point to stack\n\n      stack.push([$((x1 + x2) / 2), $((y1 + y2) / 2)]); // perform flood fill, visit points\n\n      while (stack.length) {\n        [_x, _y] = stack.pop(); // exit if point already marked\n\n        if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y)) continue; // mark point in flood fill bitmap\n        // add search points for all (in bound) directions\n\n        bm2.set(_x, _y);\n\n        for (let j = 0; j < 4; ++j) {\n          x = _x + X_DIR[j];\n          y = _y + Y_DIR[j];\n          if (!bm2.outOfBounds(x, y, x, y)) stack.push([x, y]);\n        } // unscale point back to x, y space\n\n\n        x = $.invert(_x);\n        y = $.invert(_y);\n        lo = maxSize;\n        hi = height; // TODO: make this bound smaller\n\n        if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          // if the label fits at the current sample point,\n          // perform binary search to find the largest font size that fits\n          while (hi - lo >= 1) {\n            mid = (lo + hi) / 2;\n\n            if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n              hi = mid;\n            } else {\n              lo = mid;\n            }\n          } // place label if current lower bound exceeds prior max font size\n\n\n          if (lo > maxSize) {\n            d.x = x;\n            d.y = y;\n            maxSize = lo;\n            labelPlaced = true;\n          }\n        }\n      } // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n\n\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2; // place label if it fits and improves the max area width\n\n        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    } // record current label placement information, update label bitmap\n\n\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\n\nconst Aligns = ['right', 'center', 'left'],\n      Baselines = ['bottom', 'middle', 'top'];\nfunction placeMarkLabel ($, bitmaps, anchors, offsets) {\n  const width = $.width,\n        height = $.height,\n        bm0 = bitmaps[0],\n        bm1 = bitmaps[1],\n        n = offsets.length;\n  return function (d) {\n    var _d$textWidth;\n\n    const boundary = d.boundary,\n          textHeight = d.datum.fontSize; // can not be placed if the mark is not visible in the graph bound\n\n    if (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width || boundary[3] > height) {\n      return false;\n    }\n\n    let textWidth = (_d$textWidth = d.textWidth) !== null && _d$textWidth !== void 0 ? _d$textWidth : 0,\n        dx,\n        dy,\n        isInside,\n        sizeFactor,\n        insideFactor,\n        x1,\n        x2,\n        y1,\n        y2,\n        xc,\n        yc,\n        _x1,\n        _x2,\n        _y1,\n        _y2; // for each anchor and offset\n\n\n    for (let i = 0; i < n; ++i) {\n      dx = (anchors[i] & 0x3) - 1;\n      dy = (anchors[i] >>> 0x2 & 0x3) - 1;\n      isInside = dx === 0 && dy === 0 || offsets[i] < 0;\n      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;\n      insideFactor = offsets[i] < 0 ? -1 : 1;\n      x1 = boundary[1 + dx] + offsets[i] * dx * sizeFactor;\n      yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets[i] * dy * sizeFactor;\n      y1 = yc - textHeight / 2;\n      y2 = yc + textHeight / 2;\n      _x1 = $(x1);\n      _y1 = $(y1);\n      _y2 = $(y2);\n\n      if (!textWidth) {\n        // to avoid finding width of text label,\n        if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x1, x1, y1, y2, boundary, isInside)) {\n          // skip this anchor/offset option if we fail to place a label with 1px width\n          continue;\n        } else {\n          // Otherwise, find the label width\n          textWidth = textMetrics.width(d.datum, d.datum.text);\n        }\n      }\n\n      xc = x1 + insideFactor * textWidth * dx / 2;\n      x1 = xc - textWidth / 2;\n      x2 = xc + textWidth / 2;\n      _x1 = $(x1);\n      _x2 = $(x2);\n\n      if (test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside)) {\n        // place label if the position is placeable\n        d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x1;\n        d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y1;\n        d.align = Aligns[dx * insideFactor + 1];\n        d.baseline = Baselines[dy * insideFactor + 1];\n        bm0.setRange(_x1, _y1, _x2, _y2);\n        return true;\n      }\n    }\n\n    return false;\n  };\n} // Test if a label with the given dimensions can be added without overlap\n\nfunction test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside) {\n  return !(bm0.outOfBounds(_x1, _y1, _x2, _y2) || (isInside && bm1 || bm0).getRange(_x1, _y1, _x2, _y2));\n}\n\nconst TOP = 0x0,\n      MIDDLE = 0x4,\n      BOTTOM = 0x8,\n      LEFT = 0x0,\n      CENTER = 0x1,\n      RIGHT = 0x2; // Mapping from text anchor to number representation\n\nconst anchorCode = {\n  'top-left': TOP + LEFT,\n  'top': TOP + CENTER,\n  'top-right': TOP + RIGHT,\n  'left': MIDDLE + LEFT,\n  'middle': MIDDLE + CENTER,\n  'right': MIDDLE + RIGHT,\n  'bottom-left': BOTTOM + LEFT,\n  'bottom': BOTTOM + CENTER,\n  'bottom-right': BOTTOM + RIGHT\n};\nconst placeAreaLabel = {\n  'naive': placeAreaLabelNaive,\n  'reduced-search': placeAreaLabelReducedSearch,\n  'floodfill': placeAreaLabelFloodFill\n};\nfunction labelLayout (texts, size, compare, offset, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding, method) {\n  // early exit for empty data\n  if (!texts.length) return texts;\n  const positions = Math.max(offset.length, anchor.length),\n        offsets = getOffsets(offset, positions),\n        anchors = getAnchors(anchor, positions),\n        marktype = markType(texts[0].datum),\n        grouptype = marktype === 'group' && texts[0].datum.items[markIndex].marktype,\n        isGroupArea = grouptype === 'area',\n        boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex),\n        infPadding = padding === null || padding === Infinity,\n        isNaiveGroupArea = isGroupArea && method === 'naive';\n  let maxTextWidth = -1,\n      maxTextHeight = -1; // prepare text mark data for placing\n\n  const data = texts.map(d => {\n    const textWidth = infPadding ? textMetrics.width(d, d.text) : undefined;\n    maxTextWidth = Math.max(maxTextWidth, textWidth);\n    maxTextHeight = Math.max(maxTextHeight, d.fontSize);\n    return {\n      datum: d,\n      opacity: 0,\n      x: undefined,\n      y: undefined,\n      align: undefined,\n      baseline: undefined,\n      boundary: boundary(d),\n      textWidth\n    };\n  });\n  padding = padding === null || padding === Infinity ? Math.max(maxTextWidth, maxTextHeight) + Math.max(...offset) : padding;\n  const $ = scaler(size[0], size[1], padding);\n  let bitmaps;\n\n  if (!isNaiveGroupArea) {\n    // sort labels in priority order, if comparator is provided\n    if (compare) {\n      data.sort((a, b) => compare(a.datum, b.datum));\n    } // flag indicating if label can be placed inside its base mark\n\n\n    let labelInside = false;\n\n    for (let i = 0; i < anchors.length && !labelInside; ++i) {\n      // label inside if anchor is at center\n      // label inside if offset to be inside the mark bound\n      labelInside = anchors[i] === 0x5 || offsets[i] < 0;\n    } // extract data information from base mark when base mark is to be avoided\n    // base mark is implicitly avoided if it is a group area\n\n\n    const baseMark = (marktype && avoidBaseMark || isGroupArea) && texts.map(d => d.datum); // generate bitmaps for layout calculation\n\n    bitmaps = avoidMarks.length || baseMark ? markBitmaps($, baseMark || [], avoidMarks, labelInside, isGroupArea) : baseBitmaps($, avoidBaseMark && data);\n  } // generate label placement function\n\n\n  const place = isGroupArea ? placeAreaLabel[method]($, bitmaps, avoidBaseMark, markIndex) : placeMarkLabel($, bitmaps, anchors, offsets); // place all labels\n\n  data.forEach(d => d.opacity = +place(d));\n  return data;\n}\n\nfunction getOffsets(_, count) {\n  const offsets = new Float64Array(count),\n        n = _.length;\n\n  for (let i = 0; i < n; ++i) offsets[i] = _[i] || 0;\n\n  for (let i = n; i < count; ++i) offsets[i] = offsets[n - 1];\n\n  return offsets;\n}\n\nfunction getAnchors(_, count) {\n  const anchors = new Int8Array(count),\n        n = _.length;\n\n  for (let i = 0; i < n; ++i) anchors[i] |= anchorCode[_[i]];\n\n  for (let i = n; i < count; ++i) anchors[i] = anchors[n - 1];\n\n  return anchors;\n}\n\nfunction markType(item) {\n  return item && item.mark && item.mark.marktype;\n}\n/**\n * Factory function for function for getting base mark boundary, depending\n * on mark and group type. When mark type is undefined, line or area: boundary\n * is the coordinate of each data point. When base mark is grouped line,\n * boundary is either at the start or end of the line depending on the\n * value of lineAnchor. Otherwise, use bounds of base mark.\n */\n\n\nfunction markBoundary(marktype, grouptype, lineAnchor, markIndex) {\n  const xy = d => [d.x, d.x, d.x, d.y, d.y, d.y];\n\n  if (!marktype) {\n    return xy; // no reactive geometry\n  } else if (marktype === 'line' || marktype === 'area') {\n    return d => xy(d.datum);\n  } else if (grouptype === 'line') {\n    return d => {\n      const items = d.datum.items[markIndex].items;\n      return xy(items.length ? items[lineAnchor === 'start' ? 0 : items.length - 1] : {\n        x: NaN,\n        y: NaN\n      });\n    };\n  } else {\n    return d => {\n      const b = d.datum.bounds;\n      return [b.x1, (b.x1 + b.x2) / 2, b.x2, b.y1, (b.y1 + b.y2) / 2, b.y2];\n    };\n  }\n}\n\nconst Output = ['x', 'y', 'opacity', 'align', 'baseline'];\nconst Anchors = ['top-left', 'left', 'bottom-left', 'top', 'bottom', 'top-right', 'right', 'bottom-right'];\n/**\n * Compute text label layout to annotate marks.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The size of the layout, provided as a [width, height] array.\n * @param {function(*,*): number} [params.sort] - An optional\n *   comparator function for sorting label data in priority order.\n * @param {Array<string>} [params.anchor] - Label anchor points relative to the base mark bounding box.\n *   The available options are 'top-left', 'left', 'bottom-left', 'top',\n *   'bottom', 'top-right', 'right', 'bottom-right', 'middle'.\n * @param {Array<number>} [params.offset] - Label offsets (in pixels) from the base mark bounding box.\n *   This parameter is parallel to the list of anchor points.\n * @param {number | null} [params.padding=0] - The amount (in pixels) that a label may exceed the layout size.\n *   If this parameter is null, a label may exceed the layout size without any boundary.\n * @param {string} [params.lineAnchor='end'] - For group line mark labels only, indicates the anchor\n *   position for labels. One of 'start' or 'end'.\n * @param {string} [params.markIndex=0] - For group mark labels only, an index indicating\n *   which mark within the group should be labeled.\n * @param {Array<number>} [params.avoidMarks] - A list of additional mark names for which the label\n *   layout should avoid overlap.\n * @param {boolean} [params.avoidBaseMark=true] - Boolean flag indicating if labels should avoid\n *   overlap with the underlying base mark being labeled.\n * @param {string} [params.method='naive'] - For area make labels only, a method for\n *   place labels. One of 'naive', 'reduced-search', or 'floodfill'.\n * @param {Array<string>} [params.as] - The output fields written by the transform.\n *   The default is ['x', 'y', 'opacity', 'align', 'baseline'].\n */\n\nfunction Label(params) {\n  Transform.call(this, null, params);\n}\nLabel.Definition = {\n  type: 'Label',\n  metadata: {\n    modifies: true\n  },\n  params: [{\n    name: 'size',\n    type: 'number',\n    array: true,\n    length: 2,\n    required: true\n  }, {\n    name: 'sort',\n    type: 'compare'\n  }, {\n    name: 'anchor',\n    type: 'string',\n    array: true,\n    default: Anchors\n  }, {\n    name: 'offset',\n    type: 'number',\n    array: true,\n    default: [1]\n  }, {\n    name: 'padding',\n    type: 'number',\n    default: 0,\n    null: true\n  }, {\n    name: 'lineAnchor',\n    type: 'string',\n    values: ['start', 'end'],\n    default: 'end'\n  }, {\n    name: 'markIndex',\n    type: 'number',\n    default: 0\n  }, {\n    name: 'avoidBaseMark',\n    type: 'boolean',\n    default: true\n  }, {\n    name: 'avoidMarks',\n    type: 'data',\n    array: true\n  }, {\n    name: 'method',\n    type: 'string',\n    default: 'naive'\n  }, {\n    name: 'as',\n    type: 'string',\n    array: true,\n    length: Output.length,\n    default: Output\n  }]\n};\ninherits(Label, Transform, {\n  transform(_, pulse) {\n    function modp(param) {\n      const p = _[param];\n      return isFunction(p) && pulse.modified(p.fields);\n    }\n\n    const mod = _.modified();\n\n    if (!(mod || pulse.changed(pulse.ADD_REM) || modp('sort'))) return;\n\n    if (!_.size || _.size.length !== 2) {\n      error('Size parameter should be specified as a [width, height] array.');\n    }\n\n    const as = _.as || Output; // run label layout\n\n    labelLayout(pulse.materialize(pulse.SOURCE).source || [], _.size, _.sort, array(_.offset == null ? 1 : _.offset), array(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark !== false, _.lineAnchor || 'end', _.markIndex || 0, _.padding === undefined ? 0 : _.padding, _.method || 'naive').forEach(l => {\n      // write layout results to data stream\n      const t = l.datum;\n      t[as[0]] = l.x;\n      t[as[1]] = l.y;\n      t[as[2]] = l.opacity;\n      t[as[3]] = l.align;\n      t[as[4]] = l.baseline;\n    });\n    return pulse.reflow(mod).modifies(as);\n  }\n\n});\n\nexport { Label as label };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}