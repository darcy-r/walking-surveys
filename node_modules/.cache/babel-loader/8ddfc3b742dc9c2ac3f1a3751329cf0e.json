{"ast":null,"code":"import { isArray, isString } from 'vega';\nimport { isSelectionParameter } from '../selection';\nimport { isUnitSpec } from '../spec';\nimport { SpecMapper } from '../spec/map';\nexport class TopLevelSelectionsNormalizer extends SpecMapper {\n  map(spec, normParams) {\n    var _a;\n\n    const selections = (_a = normParams.selections) !== null && _a !== void 0 ? _a : [];\n\n    if (spec.params && !isUnitSpec(spec)) {\n      const params = [];\n\n      for (const param of spec.params) {\n        if (isSelectionParameter(param)) {\n          selections.push(param);\n        } else {\n          params.push(param);\n        }\n      }\n\n      spec.params = params;\n    }\n\n    normParams.selections = selections;\n    return super.map(spec, addSpecNameToParams(spec, normParams));\n  }\n\n  mapUnit(spec, normParams) {\n    var _a;\n\n    const selections = normParams.selections;\n    if (!selections || !selections.length) return spec;\n    const path = ((_a = normParams.path) !== null && _a !== void 0 ? _a : []).concat(spec.name);\n    const params = [];\n\n    for (const selection of selections) {\n      // By default, apply selections to all unit views.\n      if (!selection.views || !selection.views.length) {\n        params.push(selection);\n      } else {\n        for (const view of selection.views) {\n          // view is either a specific unit name, or a partial path through the spec tree.\n          if (isString(view) && (view === spec.name || path.indexOf(view) >= 0) || isArray(view) && view.map(v => path.indexOf(v)).every((v, i, arr) => v !== -1 && (i === 0 || v > arr[i - 1]))) {\n            params.push(selection);\n          }\n        }\n      }\n    }\n\n    if (params.length) spec.params = params;\n    return spec;\n  }\n\n}\n\nfor (const method of ['mapFacet', 'mapRepeat', 'mapHConcat', 'mapVConcat', 'mapLayer']) {\n  const proto = TopLevelSelectionsNormalizer.prototype[method];\n\n  TopLevelSelectionsNormalizer.prototype[method] = function (spec, params) {\n    return proto.call(this, spec, addSpecNameToParams(spec, params));\n  };\n}\n\nfunction addSpecNameToParams(spec, params) {\n  var _a;\n\n  return spec.name ? Object.assign(Object.assign({}, params), {\n    path: ((_a = params.path) !== null && _a !== void 0 ? _a : []).concat(spec.name)\n  }) : params;\n}","map":{"version":3,"mappings":"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","names":["isArray","isString","isSelectionParameter","isUnitSpec","SpecMapper","TopLevelSelectionsNormalizer","map","spec","normParams","selections","_a","params","param","push","addSpecNameToParams","mapUnit","length","path","concat","name","selection","views","view","indexOf","v","every","i","arr","method","proto","prototype","call","Object"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/normalize/toplevelselection.ts"],"sourcesContent":["import {isArray, isString} from 'vega';\nimport {Field} from '../channeldef';\nimport {VariableParameter} from '../parameter';\nimport {isSelectionParameter, SelectionParameter} from '../selection';\nimport {\n  BaseSpec,\n  isUnitSpec,\n  NormalizedLayerSpec,\n  NormalizedSpec,\n  NormalizedUnitSpec,\n  TopLevel,\n  UnitSpec\n} from '../spec';\nimport {SpecMapper} from '../spec/map';\nimport {NormalizerParams} from './base';\n\nexport class TopLevelSelectionsNormalizer extends SpecMapper<NormalizerParams, NormalizedUnitSpec> {\n  public map(spec: TopLevel<NormalizedSpec>, normParams: NormalizerParams): TopLevel<NormalizedSpec> {\n    const selections = normParams.selections ?? [];\n    if (spec.params && !isUnitSpec(spec)) {\n      const params: VariableParameter[] = [];\n      for (const param of spec.params) {\n        if (isSelectionParameter(param)) {\n          selections.push(param);\n        } else {\n          params.push(param);\n        }\n      }\n\n      spec.params = params;\n    }\n\n    normParams.selections = selections;\n    return super.map(spec, addSpecNameToParams(spec, normParams));\n  }\n\n  public mapUnit(spec: UnitSpec<Field>, normParams: NormalizerParams): NormalizedUnitSpec | NormalizedLayerSpec {\n    const selections = normParams.selections;\n    if (!selections || !selections.length) return spec as NormalizedUnitSpec;\n\n    const path = (normParams.path ?? []).concat(spec.name);\n    const params: SelectionParameter[] = [];\n\n    for (const selection of selections) {\n      // By default, apply selections to all unit views.\n      if (!selection.views || !selection.views.length) {\n        params.push(selection);\n      } else {\n        for (const view of selection.views) {\n          // view is either a specific unit name, or a partial path through the spec tree.\n          if (\n            (isString(view) && (view === spec.name || path.indexOf(view) >= 0)) ||\n            (isArray(view) &&\n              view.map(v => path.indexOf(v)).every((v, i, arr) => v !== -1 && (i === 0 || v > arr[i - 1])))\n          ) {\n            params.push(selection);\n          }\n        }\n      }\n    }\n\n    if (params.length) spec.params = params;\n    return spec as NormalizedUnitSpec;\n  }\n}\n\nfor (const method of ['mapFacet', 'mapRepeat', 'mapHConcat', 'mapVConcat', 'mapLayer']) {\n  const proto = TopLevelSelectionsNormalizer.prototype[method];\n  TopLevelSelectionsNormalizer.prototype[method] = function (spec: BaseSpec, params: NormalizerParams) {\n    return proto.call(this, spec, addSpecNameToParams(spec, params));\n  };\n}\n\nfunction addSpecNameToParams(spec: BaseSpec, params: NormalizerParams) {\n  return spec.name\n    ? {\n        ...params,\n        path: (params.path ?? []).concat(spec.name)\n      }\n    : params;\n}\n"]},"metadata":{},"sourceType":"module"}