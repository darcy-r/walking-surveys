{"ast":null,"code":"import { isString } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { channelDefType, isFieldDef, isFieldOrDatumDefForTimeFormat, isScaleFieldDef, vgField } from '../channeldef';\nimport { fieldValidPredicate } from '../predicate';\nimport { ScaleType } from '../scale';\nimport { formatExpression, normalizeTimeUnit, timeUnitSpecifierExpression } from '../timeunit';\nimport { QUANTITATIVE } from '../type';\nimport { stringify } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { datumDefToExpr } from './mark/encode/valueref';\nexport function isCustomFormatType(formatType) {\n  return formatType && formatType !== 'number' && formatType !== 'time';\n}\n\nfunction customFormatExpr(formatType, field, format) {\n  return `${formatType}(${field}${format ? `, ${stringify(format)}` : ''})`;\n}\n\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\nexport function formatSignalRef(_ref) {\n  let {\n    fieldOrDatumDef,\n    format,\n    formatType,\n    expr,\n    normalizeStack,\n    config\n  } = _ref;\n\n  var _a, _b;\n\n  if (isCustomFormatType(formatType)) {\n    return formatCustomType({\n      fieldOrDatumDef,\n      format,\n      formatType,\n      expr,\n      config\n    });\n  }\n\n  const field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    const signal = timeFormatExpression(field, isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined, format, config.timeFormat, isScaleFieldDef(fieldOrDatumDef) && ((_b = fieldOrDatumDef.scale) === null || _b === void 0 ? void 0 : _b.type) === ScaleType.UTC);\n    return signal ? {\n      signal\n    } : undefined;\n  }\n\n  format = numberFormat(channelDefType(fieldOrDatumDef), format, config);\n\n  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n    const endField = vgField(fieldOrDatumDef, {\n      expr,\n      binSuffix: 'end'\n    });\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  } else if (format || channelDefType(fieldOrDatumDef) === 'quantitative') {\n    return {\n      signal: `${formatExpr(field, format)}`\n    };\n  } else {\n    return {\n      signal: `isValid(${field}) ? ${field} : \"\"+${field}`\n    };\n  }\n}\n\nfunction fieldToFormat(fieldOrDatumDef, expr, normalizeStack) {\n  if (isFieldDef(fieldOrDatumDef)) {\n    if (normalizeStack) {\n      return `${vgField(fieldOrDatumDef, {\n        expr,\n        suffix: 'end'\n      })}-${vgField(fieldOrDatumDef, {\n        expr,\n        suffix: 'start'\n      })}`;\n    } else {\n      return vgField(fieldOrDatumDef, {\n        expr\n      });\n    }\n  } else {\n    return datumDefToExpr(fieldOrDatumDef);\n  }\n}\n\nexport function formatCustomType(_ref2) {\n  let {\n    fieldOrDatumDef,\n    format,\n    formatType,\n    expr,\n    normalizeStack,\n    config,\n    field\n  } = _ref2;\n  field !== null && field !== void 0 ? field : field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n\n  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n    const endField = vgField(fieldOrDatumDef, {\n      expr,\n      binSuffix: 'end'\n    });\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  }\n\n  return {\n    signal: customFormatExpr(formatType, field, format)\n  };\n}\nexport function guideFormat(fieldOrDatumDef, type, format, formatType, config, omitTimeFormatConfig // axis doesn't use config.timeFormat\n) {\n  var _a;\n\n  if (isCustomFormatType(formatType)) {\n    return undefined; // handled in encode block\n  }\n\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined;\n    return timeFormat(format, timeUnit, config, omitTimeFormatConfig);\n  }\n\n  return numberFormat(type, format, config);\n}\nexport function guideFormatType(formatType, fieldOrDatumDef, scaleType) {\n  if (formatType && (isSignalRef(formatType) || formatType === 'number' || formatType === 'time')) {\n    return formatType;\n  }\n\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType !== 'time' && scaleType !== 'utc') {\n    return 'time';\n  }\n\n  return undefined;\n}\n/**\n * Returns number format for a fieldDef.\n */\n\nexport function numberFormat(type, specifiedFormat, config) {\n  // Specified format in axis/legend has higher precedence than fieldDef.format\n  if (isString(specifiedFormat)) {\n    return specifiedFormat;\n  }\n\n  if (type === QUANTITATIVE) {\n    // we only apply the default if the field is quantitative\n    return config.numberFormat;\n  }\n\n  return undefined;\n}\n/**\n * Returns time format for a fieldDef for use in guides.\n */\n\nexport function timeFormat(specifiedFormat, timeUnit, config, omitTimeFormatConfig) {\n  if (specifiedFormat) {\n    return specifiedFormat;\n  }\n\n  if (timeUnit) {\n    return {\n      signal: timeUnitSpecifierExpression(timeUnit)\n    };\n  }\n\n  return omitTimeFormatConfig ? undefined : config.timeFormat;\n}\n\nfunction formatExpr(field, format) {\n  return `format(${field}, \"${format || ''}\")`;\n}\n\nfunction binNumberFormatExpr(field, format, formatType, config) {\n  var _a;\n\n  if (isCustomFormatType(formatType)) {\n    return customFormatExpr(formatType, field, format);\n  }\n\n  return formatExpr(field, (_a = isString(format) ? format : undefined) !== null && _a !== void 0 ? _a : config.numberFormat);\n}\n\nexport function binFormatExpression(startField, endField, format, formatType, config) {\n  const start = binNumberFormatExpr(startField, format, formatType, config);\n  const end = binNumberFormatExpr(endField, format, formatType, config);\n  return `${fieldValidPredicate(startField, false)} ? \"null\" : ${start} + \"${BIN_RANGE_DELIMITER}\" + ${end}`;\n}\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\n\nexport function timeFormatExpression(field, timeUnit, format, rawTimeFormat, // should be provided only for actual text and headers, not axis/legend labels\nisUTCScale) {\n  if (!timeUnit || format) {\n    // If there is no time unit, or if user explicitly specifies format for axis/legend/text.\n    format = isString(format) ? format : rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n\n    return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;\n  } else {\n    return formatExpression(timeUnit, field, isUTCScale);\n  }\n}","map":{"version":3,"mappings":"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","names":["isString","isBinning","channelDefType","isFieldDef","isFieldOrDatumDefForTimeFormat","isScaleFieldDef","vgField","fieldValidPredicate","ScaleType","formatExpression","normalizeTimeUnit","timeUnitSpecifierExpression","QUANTITATIVE","stringify","isSignalRef","datumDefToExpr","isCustomFormatType","formatType","customFormatExpr","field","format","BIN_RANGE_DELIMITER","formatSignalRef","fieldOrDatumDef","expr","normalizeStack","config","formatCustomType","fieldToFormat","signal","timeFormatExpression","timeUnit","_a","unit","undefined","timeFormat","scale","_b","type","UTC","numberFormat","bin","endField","binSuffix","binFormatExpression","formatExpr","suffix","guideFormat","omitTimeFormatConfig","guideFormatType","scaleType","specifiedFormat","binNumberFormatExpr","startField","start","end","rawTimeFormat","isUTCScale"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/format.ts"],"sourcesContent":["import {SignalRef} from 'vega';\nimport {isString} from 'vega-util';\nimport {isBinning} from '../bin';\nimport {\n  channelDefType,\n  DatumDef,\n  FieldDef,\n  isFieldDef,\n  isFieldOrDatumDefForTimeFormat,\n  isScaleFieldDef,\n  vgField\n} from '../channeldef';\nimport {Config} from '../config';\nimport {fieldValidPredicate} from '../predicate';\nimport {ScaleType} from '../scale';\nimport {formatExpression, normalizeTimeUnit, timeUnitSpecifierExpression} from '../timeunit';\nimport {QUANTITATIVE, Type} from '../type';\nimport {Dict, stringify} from '../util';\nimport {isSignalRef} from '../vega.schema';\nimport {TimeUnit} from './../timeunit';\nimport {datumDefToExpr} from './mark/encode/valueref';\n\nexport function isCustomFormatType(formatType: string) {\n  return formatType && formatType !== 'number' && formatType !== 'time';\n}\n\nfunction customFormatExpr(formatType: string, field: string, format: string | Dict<unknown>) {\n  return `${formatType}(${field}${format ? `, ${stringify(format)}` : ''})`;\n}\n\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\n\nexport function formatSignalRef({\n  fieldOrDatumDef,\n  format,\n  formatType,\n  expr,\n  normalizeStack,\n  config\n}: {\n  fieldOrDatumDef: FieldDef<string> | DatumDef<string>;\n  format: string | Dict<unknown>;\n  formatType: string;\n  expr?: 'datum' | 'parent' | 'datum.datum';\n  normalizeStack?: boolean;\n  config: Config;\n}) {\n  if (isCustomFormatType(formatType)) {\n    return formatCustomType({\n      fieldOrDatumDef,\n      format,\n      formatType,\n      expr,\n      config\n    });\n  }\n\n  const field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    const signal = timeFormatExpression(\n      field,\n      isFieldDef(fieldOrDatumDef) ? normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit : undefined,\n      format,\n      config.timeFormat,\n      isScaleFieldDef(fieldOrDatumDef) && fieldOrDatumDef.scale?.type === ScaleType.UTC\n    );\n    return signal ? {signal} : undefined;\n  }\n\n  format = numberFormat(channelDefType(fieldOrDatumDef), format, config);\n  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n    const endField = vgField(fieldOrDatumDef, {expr, binSuffix: 'end'});\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  } else if (format || channelDefType(fieldOrDatumDef) === 'quantitative') {\n    return {\n      signal: `${formatExpr(field, format)}`\n    };\n  } else {\n    return {signal: `isValid(${field}) ? ${field} : \"\"+${field}`};\n  }\n}\n\nfunction fieldToFormat(\n  fieldOrDatumDef: FieldDef<string> | DatumDef<string>,\n  expr: 'datum' | 'parent' | 'datum.datum',\n  normalizeStack: boolean\n) {\n  if (isFieldDef(fieldOrDatumDef)) {\n    if (normalizeStack) {\n      return `${vgField(fieldOrDatumDef, {expr, suffix: 'end'})}-${vgField(fieldOrDatumDef, {\n        expr,\n        suffix: 'start'\n      })}`;\n    } else {\n      return vgField(fieldOrDatumDef, {expr});\n    }\n  } else {\n    return datumDefToExpr(fieldOrDatumDef);\n  }\n}\n\nexport function formatCustomType({\n  fieldOrDatumDef,\n  format,\n  formatType,\n  expr,\n  normalizeStack,\n  config,\n  field\n}: {\n  fieldOrDatumDef: FieldDef<string> | DatumDef<string>;\n  format: string | Dict<unknown>;\n  formatType: string;\n  expr?: 'datum' | 'parent' | 'datum.datum';\n  normalizeStack?: boolean;\n  config: Config;\n  field?: string; // axis/legend \"use datum.value\"\n}) {\n  field ??= fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n\n  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n    const endField = vgField(fieldOrDatumDef, {expr, binSuffix: 'end'});\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  }\n  return {signal: customFormatExpr(formatType, field, format)};\n}\n\nexport function guideFormat(\n  fieldOrDatumDef: FieldDef<string> | DatumDef<string>,\n  type: Type,\n  format: string | Dict<unknown>,\n  formatType: string,\n  config: Config,\n  omitTimeFormatConfig: boolean // axis doesn't use config.timeFormat\n) {\n  if (isCustomFormatType(formatType)) {\n    return undefined; // handled in encode block\n  }\n\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    const timeUnit = isFieldDef(fieldOrDatumDef) ? normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit : undefined;\n\n    return timeFormat(format as string, timeUnit, config, omitTimeFormatConfig);\n  }\n\n  return numberFormat(type, format, config);\n}\n\nexport function guideFormatType(\n  formatType: string | SignalRef,\n  fieldOrDatumDef: FieldDef<string> | DatumDef<string>,\n  scaleType: ScaleType\n) {\n  if (formatType && (isSignalRef(formatType) || formatType === 'number' || formatType === 'time')) {\n    return formatType;\n  }\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType !== 'time' && scaleType !== 'utc') {\n    return 'time';\n  }\n  return undefined;\n}\n\n/**\n * Returns number format for a fieldDef.\n */\nexport function numberFormat(type: Type, specifiedFormat: string | Dict<unknown>, config: Config) {\n  // Specified format in axis/legend has higher precedence than fieldDef.format\n  if (isString(specifiedFormat)) {\n    return specifiedFormat;\n  }\n\n  if (type === QUANTITATIVE) {\n    // we only apply the default if the field is quantitative\n    return config.numberFormat;\n  }\n  return undefined;\n}\n\n/**\n * Returns time format for a fieldDef for use in guides.\n */\nexport function timeFormat(specifiedFormat: string, timeUnit: TimeUnit, config: Config, omitTimeFormatConfig: boolean) {\n  if (specifiedFormat) {\n    return specifiedFormat;\n  }\n\n  if (timeUnit) {\n    return {\n      signal: timeUnitSpecifierExpression(timeUnit)\n    };\n  }\n\n  return omitTimeFormatConfig ? undefined : config.timeFormat;\n}\n\nfunction formatExpr(field: string, format: string) {\n  return `format(${field}, \"${format || ''}\")`;\n}\n\nfunction binNumberFormatExpr(field: string, format: string | Dict<unknown>, formatType: string, config: Config) {\n  if (isCustomFormatType(formatType)) {\n    return customFormatExpr(formatType, field, format);\n  }\n\n  return formatExpr(field, (isString(format) ? format : undefined) ?? config.numberFormat);\n}\n\nexport function binFormatExpression(\n  startField: string,\n  endField: string,\n  format: string | Dict<unknown>,\n  formatType: string,\n  config: Config\n) {\n  const start = binNumberFormatExpr(startField, format, formatType, config);\n  const end = binNumberFormatExpr(endField, format, formatType, config);\n  return `${fieldValidPredicate(startField, false)} ? \"null\" : ${start} + \"${BIN_RANGE_DELIMITER}\" + ${end}`;\n}\n\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression(\n  field: string,\n  timeUnit: TimeUnit,\n  format: string | Dict<unknown>,\n  rawTimeFormat: string, // should be provided only for actual text and headers, not axis/legend labels\n  isUTCScale: boolean\n): string {\n  if (!timeUnit || format) {\n    // If there is no time unit, or if user explicitly specifies format for axis/legend/text.\n    format = isString(format) ? format : rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n    return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;\n  } else {\n    return formatExpression(timeUnit, field, isUTCScale);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}