{"ast":null,"code":"import { normalizeEncoding } from '../encoding';\nimport * as log from '../log';\nimport { CompositeMarkNormalizer } from './base';\nimport { makeCompositeAggregatePartFactory } from './common';\nimport { errorBarParams } from './errorbar';\nexport const ERRORBAND = 'errorband';\nexport const ERRORBAND_PARTS = ['band', 'borders'];\nexport const errorBandNormalizer = new CompositeMarkNormalizer(ERRORBAND, normalizeErrorBand);\nexport function normalizeErrorBand(spec, _ref) {\n  let {\n    config\n  } = _ref;\n  // Need to initEncoding first so we can infer type\n  spec = Object.assign(Object.assign({}, spec), {\n    encoding: normalizeEncoding(spec.encoding, config)\n  });\n  const {\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    markDef,\n    outerSpec,\n    tooltipEncoding\n  } = errorBarParams(spec, ERRORBAND, config);\n  const errorBandDef = markDef;\n  const makeErrorBandPart = makeCompositeAggregatePartFactory(errorBandDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorband);\n  const is2D = spec.encoding.x !== undefined && spec.encoding.y !== undefined;\n  let bandMark = {\n    type: is2D ? 'area' : 'rect'\n  };\n  let bordersMark = {\n    type: is2D ? 'line' : 'rule'\n  };\n  const interpolate = Object.assign(Object.assign({}, errorBandDef.interpolate ? {\n    interpolate: errorBandDef.interpolate\n  } : {}), errorBandDef.tension && errorBandDef.interpolate ? {\n    tension: errorBandDef.tension\n  } : {});\n\n  if (is2D) {\n    bandMark = Object.assign(Object.assign(Object.assign({}, bandMark), interpolate), {\n      ariaRoleDescription: 'errorband'\n    });\n    bordersMark = Object.assign(Object.assign(Object.assign({}, bordersMark), interpolate), {\n      aria: false\n    });\n  } else if (errorBandDef.interpolate) {\n    log.warn(log.message.errorBand1DNotSupport('interpolate'));\n  } else if (errorBandDef.tension) {\n    log.warn(log.message.errorBand1DNotSupport('tension'));\n  }\n\n  return Object.assign(Object.assign({}, outerSpec), {\n    transform,\n    layer: [...makeErrorBandPart({\n      partName: 'band',\n      mark: bandMark,\n      positionPrefix: 'lower',\n      endPositionPrefix: 'upper',\n      extraEncoding: tooltipEncoding\n    }), ...makeErrorBandPart({\n      partName: 'borders',\n      mark: bordersMark,\n      positionPrefix: 'lower',\n      extraEncoding: tooltipEncoding\n    }), ...makeErrorBandPart({\n      partName: 'borders',\n      mark: bordersMark,\n      positionPrefix: 'upper',\n      extraEncoding: tooltipEncoding\n    })]\n  });\n}","map":{"version":3,"mappings":"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","names":["normalizeEncoding","log","CompositeMarkNormalizer","makeCompositeAggregatePartFactory","errorBarParams","ERRORBAND","ERRORBAND_PARTS","errorBandNormalizer","normalizeErrorBand","spec","config","encoding","transform","continuousAxisChannelDef","continuousAxis","encodingWithoutContinuousAxis","markDef","outerSpec","tooltipEncoding","errorBandDef","makeErrorBandPart","errorband","is2D","x","undefined","y","bandMark","type","bordersMark","interpolate","tension","ariaRoleDescription","aria","warn","message","errorBand1DNotSupport","layer","partName","mark","positionPrefix","endPositionPrefix","extraEncoding"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compositemark/errorband.ts"],"sourcesContent":["import {Interpolate, Orientation} from 'vega';\nimport {Field} from '../channeldef';\nimport {Encoding, normalizeEncoding} from '../encoding';\nimport * as log from '../log';\nimport {MarkDef} from '../mark';\nimport {NormalizerParams} from '../normalize';\nimport {GenericUnitSpec, NormalizedLayerSpec} from '../spec';\nimport {CompositeMarkNormalizer} from './base';\nimport {GenericCompositeMarkDef, makeCompositeAggregatePartFactory, PartsMixins} from './common';\nimport {ErrorBarCenter, ErrorBarExtent, errorBarParams, ErrorEncoding} from './errorbar';\n\nexport type ErrorBandUnitSpec<\n  EE = undefined // extra encoding parameter (for faceted composite unit spec)\n> = GenericUnitSpec<ErrorEncoding<Field> & EE, ErrorBand | ErrorBandDef>;\n\nexport const ERRORBAND = 'errorband' as const;\nexport type ErrorBand = typeof ERRORBAND;\n\nexport const ERRORBAND_PARTS = ['band', 'borders'] as const;\n\ntype ErrorBandPart = typeof ERRORBAND_PARTS[number];\n\nexport type ErrorBandPartsMixins = PartsMixins<ErrorBandPart>;\n\nexport interface ErrorBandConfig extends ErrorBandPartsMixins {\n  /**\n   * The center of the error band. Available options include:\n   * - `\"mean\"`: the mean of the data points.\n   * - `\"median\"`: the median of the data points.\n   *\n   * __Default value:__ `\"mean\"`.\n   * @hidden\n   */\n\n  // center is not needed right now but will be added back to the schema if future features require it.\n  center?: ErrorBarCenter;\n\n  /**\n   * The extent of the band. Available options include:\n   * - `\"ci\"`: Extend the band to the confidence interval of the mean.\n   * - `\"stderr\"`: The size of band are set to the value of standard error, extending from the mean.\n   * - `\"stdev\"`: The size of band are set to the value of standard deviation, extending from the mean.\n   * - `\"iqr\"`: Extend the band to the q1 and q3.\n   *\n   * __Default value:__ `\"stderr\"`.\n   */\n  extent?: ErrorBarExtent;\n\n  /**\n   * The line interpolation method for the error band. One of the following:\n   * - `\"linear\"`: piecewise linear segments, as in a polyline.\n   * - `\"linear-closed\"`: close the linear segments to form a polygon.\n   * - `\"step\"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes at the midpoint of each pair of adjacent x-values.\n   * - `\"step-before\"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes before the x-value.\n   * - `\"step-after\"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes after the x-value.\n   * - `\"basis\"`: a B-spline, with control point duplication on the ends.\n   * - `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n   * - `\"basis-closed\"`: a closed B-spline, as in a loop.\n   * - `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n   * - `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n   * - `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n   * - `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n   * - `\"monotone\"`: cubic interpolation that preserves monotonicity in y.\n   */\n  interpolate?: Interpolate;\n\n  /**\n   * The tension parameter for the interpolation type of the error band.\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  tension?: number;\n}\n\nexport type ErrorBandDef = GenericCompositeMarkDef<ErrorBand> &\n  ErrorBandConfig & {\n    /**\n     * Orientation of the error band. This is normally automatically determined, but can be specified when the orientation is ambiguous and cannot be automatically determined.\n     */\n    orient?: Orientation;\n  };\n\nexport interface ErrorBandConfigMixins {\n  /**\n   * ErrorBand Config\n   */\n  errorband?: ErrorBandConfig;\n}\n\nexport const errorBandNormalizer = new CompositeMarkNormalizer(ERRORBAND, normalizeErrorBand);\n\nexport function normalizeErrorBand(\n  spec: GenericUnitSpec<Encoding<string>, ErrorBand | ErrorBandDef>,\n  {config}: NormalizerParams\n): NormalizedLayerSpec {\n  // Need to initEncoding first so we can infer type\n  spec = {\n    ...spec,\n    encoding: normalizeEncoding(spec.encoding, config)\n  };\n\n  const {\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    markDef,\n    outerSpec,\n    tooltipEncoding\n  } = errorBarParams(spec, ERRORBAND, config);\n  const errorBandDef: ErrorBandDef = markDef;\n\n  const makeErrorBandPart = makeCompositeAggregatePartFactory<ErrorBandPartsMixins>(\n    errorBandDef,\n    continuousAxis,\n    continuousAxisChannelDef,\n    encodingWithoutContinuousAxis,\n    config.errorband\n  );\n\n  const is2D = spec.encoding.x !== undefined && spec.encoding.y !== undefined;\n\n  let bandMark: MarkDef = {type: is2D ? 'area' : 'rect'};\n  let bordersMark: MarkDef = {type: is2D ? 'line' : 'rule'};\n  const interpolate = {\n    ...(errorBandDef.interpolate ? {interpolate: errorBandDef.interpolate} : {}),\n    ...(errorBandDef.tension && errorBandDef.interpolate ? {tension: errorBandDef.tension} : {})\n  };\n\n  if (is2D) {\n    bandMark = {\n      ...bandMark,\n      ...interpolate,\n      ariaRoleDescription: 'errorband'\n    };\n    bordersMark = {\n      ...bordersMark,\n      ...interpolate,\n      aria: false\n    };\n  } else if (errorBandDef.interpolate) {\n    log.warn(log.message.errorBand1DNotSupport('interpolate'));\n  } else if (errorBandDef.tension) {\n    log.warn(log.message.errorBand1DNotSupport('tension'));\n  }\n\n  return {\n    ...outerSpec,\n    transform,\n    layer: [\n      ...makeErrorBandPart({\n        partName: 'band',\n        mark: bandMark,\n        positionPrefix: 'lower',\n        endPositionPrefix: 'upper',\n        extraEncoding: tooltipEncoding\n      }),\n      ...makeErrorBandPart({\n        partName: 'borders',\n        mark: bordersMark,\n        positionPrefix: 'lower',\n\n        extraEncoding: tooltipEncoding\n      }),\n      ...makeErrorBandPart({\n        partName: 'borders',\n        mark: bordersMark,\n        positionPrefix: 'upper',\n        extraEncoding: tooltipEncoding\n      })\n    ]\n  };\n}\n"]},"metadata":{},"sourceType":"module"}