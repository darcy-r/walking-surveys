{"ast":null,"code":"import { isArray, isObject } from 'vega-util';\nimport { isBinned, isBinning } from '../../bin';\nimport { X } from '../../channel';\nimport { isDiscrete, isFieldDef, toFieldDefBase, valueArray } from '../../channeldef';\nimport { hasDiscreteDomain } from '../../scale';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport { NOMINAL, ORDINAL } from '../../type';\nimport { contains, normalizeAngle } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeTitle, mergeTitleFieldDefs } from '../common';\nimport { guideFormat, guideFormatType } from '../format';\nimport { getAxisConfig } from './config';\nexport const axisRules = {\n  scale: _ref => {\n    let {\n      model,\n      channel\n    } = _ref;\n    return model.scaleName(channel);\n  },\n  format: _ref2 => {\n    let {\n      fieldOrDatumDef,\n      config,\n      axis\n    } = _ref2;\n    const {\n      format,\n      formatType\n    } = axis;\n    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, true);\n  },\n  formatType: _ref3 => {\n    let {\n      axis,\n      fieldOrDatumDef,\n      scaleType\n    } = _ref3;\n    const {\n      formatType\n    } = axis;\n    return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n  },\n  grid: _ref4 => {\n    let {\n      fieldOrDatumDef,\n      axis,\n      scaleType\n    } = _ref4;\n\n    var _a;\n\n    return (_a = axis.grid) !== null && _a !== void 0 ? _a : defaultGrid(scaleType, fieldOrDatumDef);\n  },\n  gridScale: _ref5 => {\n    let {\n      model,\n      channel\n    } = _ref5;\n    return gridScale(model, channel);\n  },\n  labelAlign: _ref6 => {\n    let {\n      axis,\n      labelAngle,\n      orient,\n      channel\n    } = _ref6;\n    return axis.labelAlign || defaultLabelAlign(labelAngle, orient, channel);\n  },\n  labelAngle: _ref7 => {\n    let {\n      labelAngle\n    } = _ref7;\n    return labelAngle;\n  },\n  labelBaseline: _ref8 => {\n    let {\n      axis,\n      labelAngle,\n      orient,\n      channel\n    } = _ref8;\n    return axis.labelBaseline || defaultLabelBaseline(labelAngle, orient, channel);\n  },\n  labelFlush: _ref9 => {\n    let {\n      axis,\n      fieldOrDatumDef,\n      channel\n    } = _ref9;\n\n    var _a;\n\n    return (_a = axis.labelFlush) !== null && _a !== void 0 ? _a : defaultLabelFlush(fieldOrDatumDef.type, channel);\n  },\n  labelOverlap: _ref10 => {\n    let {\n      axis,\n      fieldOrDatumDef,\n      scaleType\n    } = _ref10;\n\n    var _a;\n\n    return (_a = axis.labelOverlap) !== null && _a !== void 0 ? _a : defaultLabelOverlap(fieldOrDatumDef.type, scaleType, isFieldDef(fieldOrDatumDef) && !!fieldOrDatumDef.timeUnit, isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined);\n  },\n  // we already calculate orient in parse\n  orient: _ref11 => {\n    let {\n      orient\n    } = _ref11;\n    return orient;\n  },\n  tickCount: _ref12 => {\n    let {\n      channel,\n      model,\n      axis,\n      fieldOrDatumDef,\n      scaleType\n    } = _ref12;\n\n    var _a;\n\n    const sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n    const size = sizeType ? model.getSizeSignalRef(sizeType) : undefined;\n    return (_a = axis.tickCount) !== null && _a !== void 0 ? _a : defaultTickCount({\n      fieldOrDatumDef,\n      scaleType,\n      size,\n      values: axis.values\n    });\n  },\n  title: _ref13 => {\n    let {\n      axis,\n      model,\n      channel\n    } = _ref13;\n\n    if (axis.title !== undefined) {\n      return axis.title;\n    }\n\n    const fieldDefTitle = getFieldDefTitle(model, channel);\n\n    if (fieldDefTitle !== undefined) {\n      return fieldDefTitle;\n    }\n\n    const fieldDef = model.typedFieldDef(channel);\n    const channel2 = channel === 'x' ? 'x2' : 'y2';\n    const fieldDef2 = model.fieldDef(channel2); // If title not specified, store base parts of fieldDef (and fieldDef2 if exists)\n\n    return mergeTitleFieldDefs(fieldDef ? [toFieldDefBase(fieldDef)] : [], isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []);\n  },\n  values: _ref14 => {\n    let {\n      axis,\n      fieldOrDatumDef\n    } = _ref14;\n    return values(axis, fieldOrDatumDef);\n  },\n  zindex: _ref15 => {\n    let {\n      axis,\n      fieldOrDatumDef,\n      mark\n    } = _ref15;\n\n    var _a;\n\n    return (_a = axis.zindex) !== null && _a !== void 0 ? _a : defaultZindex(mark, fieldOrDatumDef);\n  }\n}; // TODO: we need to refactor this method after we take care of config refactoring\n\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\n\nexport function defaultGrid(scaleType, fieldDef) {\n  return !hasDiscreteDomain(scaleType) && isFieldDef(fieldDef) && !isBinning(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) && !isBinned(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin);\n}\nexport function gridScale(model, channel) {\n  const gridChannel = channel === 'x' ? 'y' : 'x';\n\n  if (model.getScaleComponent(gridChannel)) {\n    return model.scaleName(gridChannel);\n  }\n\n  return undefined;\n}\nexport function getLabelAngle(fieldOrDatumDef, axis, channel, styleConfig, axisConfigs) {\n  const labelAngle = axis === null || axis === void 0 ? void 0 : axis.labelAngle; // try axis value\n\n  if (labelAngle !== undefined) {\n    return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);\n  } else {\n    // try axis config value\n    const {\n      configValue: angle\n    } = getAxisConfig('labelAngle', styleConfig, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs);\n\n    if (angle !== undefined) {\n      return normalizeAngle(angle);\n    } else {\n      // get default value\n      if (channel === X && contains([NOMINAL, ORDINAL], fieldOrDatumDef.type) && !(isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit)) {\n        return 270;\n      } // no default\n\n\n      return undefined;\n    }\n  }\n}\nexport function normalizeAngleExpr(angle) {\n  return `(((${angle.signal} % 360) + 360) % 360)`;\n}\nexport function defaultLabelBaseline(angle, orient, channel, alwaysIncludeMiddle) {\n  if (angle !== undefined) {\n    if (channel === 'x') {\n      if (isSignalRef(angle)) {\n        const a = normalizeAngleExpr(angle);\n        const orientIsTop = isSignalRef(orient) ? `(${orient.signal} === \"top\")` : orient === 'top';\n        return {\n          signal: `(45 < ${a} && ${a} < 135) || (225 < ${a} && ${a} < 315) ? \"middle\" :` + `(${a} <= 45 || 315 <= ${a}) === ${orientIsTop} ? \"bottom\" : \"top\"`\n        };\n      }\n\n      if (45 < angle && angle < 135 || 225 < angle && angle < 315) {\n        return 'middle';\n      }\n\n      if (isSignalRef(orient)) {\n        const op = angle <= 45 || 315 <= angle ? '===' : '!==';\n        return {\n          signal: `${orient.signal} ${op} \"top\" ? \"bottom\" : \"top\"`\n        };\n      }\n\n      return (angle <= 45 || 315 <= angle) === (orient === 'top') ? 'bottom' : 'top';\n    } else {\n      if (isSignalRef(angle)) {\n        const a = normalizeAngleExpr(angle);\n        const orientIsLeft = isSignalRef(orient) ? `(${orient.signal} === \"left\")` : orient === 'left';\n        const middle = alwaysIncludeMiddle ? '\"middle\"' : 'null';\n        return {\n          signal: `${a} <= 45 || 315 <= ${a} || (135 <= ${a} && ${a} <= 225) ? ${middle} : (45 <= ${a} && ${a} <= 135) === ${orientIsLeft} ? \"top\" : \"bottom\"`\n        };\n      }\n\n      if (angle <= 45 || 315 <= angle || 135 <= angle && angle <= 225) {\n        return alwaysIncludeMiddle ? 'middle' : null;\n      }\n\n      if (isSignalRef(orient)) {\n        const op = 45 <= angle && angle <= 135 ? '===' : '!==';\n        return {\n          signal: `${orient.signal} ${op} \"left\" ? \"top\" : \"bottom\"`\n        };\n      }\n\n      return (45 <= angle && angle <= 135) === (orient === 'left') ? 'top' : 'bottom';\n    }\n  }\n\n  return undefined;\n}\nexport function defaultLabelAlign(angle, orient, channel) {\n  if (angle === undefined) {\n    return undefined;\n  }\n\n  const isX = channel === 'x';\n  const startAngle = isX ? 0 : 90;\n  const mainOrient = isX ? 'bottom' : 'left';\n\n  if (isSignalRef(angle)) {\n    const a = normalizeAngleExpr(angle);\n    const orientIsMain = isSignalRef(orient) ? `(${orient.signal} === \"${mainOrient}\")` : orient === mainOrient;\n    return {\n      signal: `(${startAngle ? `(${a} + 90)` : a} % 180 === 0) ? ${isX ? null : '\"center\"'} :` + `(${startAngle} < ${a} && ${a} < ${180 + startAngle}) === ${orientIsMain} ? \"left\" : \"right\"`\n    };\n  }\n\n  if ((angle + startAngle) % 180 === 0) {\n    // For bottom, use default label align so label flush still works\n    return isX ? null : 'center';\n  }\n\n  if (isSignalRef(orient)) {\n    const op = startAngle < angle && angle < 180 + startAngle ? '===' : '!==';\n    const orientIsMain = `${orient.signal} ${op} \"${mainOrient}\"`;\n    return {\n      signal: `${orientIsMain} ? \"left\" : \"right\"`\n    };\n  }\n\n  if ((startAngle < angle && angle < 180 + startAngle) === (orient === mainOrient)) {\n    return 'left';\n  }\n\n  return 'right';\n}\nexport function defaultLabelFlush(type, channel) {\n  if (channel === 'x' && contains(['quantitative', 'temporal'], type)) {\n    return true;\n  }\n\n  return undefined;\n}\nexport function defaultLabelOverlap(type, scaleType, hasTimeUnit, sort) {\n  // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n  if (hasTimeUnit && !isObject(sort) || type !== 'nominal' && type !== 'ordinal') {\n    if (scaleType === 'log' || scaleType === 'symlog') {\n      return 'greedy';\n    }\n\n    return true;\n  }\n\n  return undefined;\n}\nexport function defaultOrient(channel) {\n  return channel === 'x' ? 'bottom' : 'left';\n}\nexport function defaultTickCount(_ref16) {\n  let {\n    fieldOrDatumDef,\n    scaleType,\n    size,\n    values: vals\n  } = _ref16;\n\n  var _a;\n\n  if (!vals && !hasDiscreteDomain(scaleType) && scaleType !== 'log') {\n    if (isFieldDef(fieldOrDatumDef)) {\n      if (isBinning(fieldOrDatumDef.bin)) {\n        // for binned data, we don't want more ticks than maxbins\n        return {\n          signal: `ceil(${size.signal}/10)`\n        };\n      }\n\n      if (fieldOrDatumDef.timeUnit && contains(['month', 'hours', 'day', 'quarter'], (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit)) {\n        return undefined;\n      }\n    }\n\n    return {\n      signal: `ceil(${size.signal}/40)`\n    };\n  }\n\n  return undefined;\n}\nexport function getFieldDefTitle(model, channel) {\n  const channel2 = channel === 'x' ? 'x2' : 'y2';\n  const fieldDef = model.fieldDef(channel);\n  const fieldDef2 = model.fieldDef(channel2);\n  const title1 = fieldDef ? fieldDef.title : undefined;\n  const title2 = fieldDef2 ? fieldDef2.title : undefined;\n\n  if (title1 && title2) {\n    return mergeTitle(title1, title2);\n  } else if (title1) {\n    return title1;\n  } else if (title2) {\n    return title2;\n  } else if (title1 !== undefined) {\n    // falsy value to disable config\n    return title1;\n  } else if (title2 !== undefined) {\n    // falsy value to disable config\n    return title2;\n  }\n\n  return undefined;\n}\nexport function values(axis, fieldOrDatumDef) {\n  const vals = axis.values;\n\n  if (isArray(vals)) {\n    return valueArray(fieldOrDatumDef, vals);\n  } else if (isSignalRef(vals)) {\n    return vals;\n  }\n\n  return undefined;\n}\nexport function defaultZindex(mark, fieldDef) {\n  if (mark === 'rect' && isDiscrete(fieldDef)) {\n    return 1;\n  }\n\n  return 0;\n}","map":{"version":3,"mappings":"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","names":["isArray","isObject","isBinned","isBinning","X","isDiscrete","isFieldDef","toFieldDefBase","valueArray","hasDiscreteDomain","normalizeTimeUnit","NOMINAL","ORDINAL","contains","normalizeAngle","isSignalRef","mergeTitle","mergeTitleFieldDefs","guideFormat","guideFormatType","getAxisConfig","axisRules","scale","model","channel","scaleName","format","fieldOrDatumDef","config","axis","formatType","type","scaleType","grid","_a","defaultGrid","gridScale","labelAlign","labelAngle","orient","defaultLabelAlign","labelBaseline","defaultLabelBaseline","labelFlush","defaultLabelFlush","labelOverlap","defaultLabelOverlap","timeUnit","sort","undefined","tickCount","sizeType","size","getSizeSignalRef","defaultTickCount","values","title","fieldDefTitle","getFieldDefTitle","fieldDef","typedFieldDef","channel2","fieldDef2","zindex","mark","defaultZindex","bin","gridChannel","getScaleComponent","getLabelAngle","styleConfig","axisConfigs","configValue","angle","style","normalizeAngleExpr","signal","alwaysIncludeMiddle","a","orientIsTop","op","orientIsLeft","middle","isX","startAngle","mainOrient","orientIsMain","hasTimeUnit","defaultOrient","vals","unit","title1","title2"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/axis/properties.ts"],"sourcesContent":["import {Align, AxisOrient, Orient, SignalRef} from 'vega';\nimport {isArray, isObject} from 'vega-util';\nimport {AxisInternal} from '../../axis';\nimport {isBinned, isBinning} from '../../bin';\nimport {PositionScaleChannel, X} from '../../channel';\nimport {\n  DatumDef,\n  isDiscrete,\n  isFieldDef,\n  PositionDatumDef,\n  PositionFieldDef,\n  toFieldDefBase,\n  TypedFieldDef,\n  valueArray\n} from '../../channeldef';\nimport {Config, StyleConfigIndex} from '../../config';\nimport {Mark} from '../../mark';\nimport {hasDiscreteDomain} from '../../scale';\nimport {Sort} from '../../sort';\nimport {normalizeTimeUnit} from '../../timeunit';\nimport {NOMINAL, ORDINAL, Type} from '../../type';\nimport {contains, normalizeAngle} from '../../util';\nimport {isSignalRef} from '../../vega.schema';\nimport {mergeTitle, mergeTitleFieldDefs} from '../common';\nimport {guideFormat, guideFormatType} from '../format';\nimport {UnitModel} from '../unit';\nimport {ScaleType} from './../../scale';\nimport {AxisComponentProps} from './component';\nimport {AxisConfigs, getAxisConfig} from './config';\n\nexport interface AxisRuleParams {\n  fieldOrDatumDef: PositionFieldDef<string> | PositionDatumDef<string>;\n  axis: AxisInternal;\n  channel: PositionScaleChannel;\n  model: UnitModel;\n\n  mark: Mark;\n  scaleType: ScaleType;\n  orient: Orient | SignalRef;\n  labelAngle: number | SignalRef;\n  config: Config;\n}\n\nexport const axisRules: {\n  [k in keyof AxisComponentProps]?: (params: AxisRuleParams) => AxisComponentProps[k];\n} = {\n  scale: ({model, channel}) => model.scaleName(channel),\n\n  format: ({fieldOrDatumDef, config, axis}) => {\n    const {format, formatType} = axis;\n    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, true);\n  },\n\n  formatType: ({axis, fieldOrDatumDef, scaleType}) => {\n    const {formatType} = axis;\n    return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n  },\n\n  grid: ({fieldOrDatumDef, axis, scaleType}) => axis.grid ?? defaultGrid(scaleType, fieldOrDatumDef),\n\n  gridScale: ({model, channel}) => gridScale(model, channel),\n\n  labelAlign: ({axis, labelAngle, orient, channel}) =>\n    axis.labelAlign || defaultLabelAlign(labelAngle, orient, channel),\n\n  labelAngle: ({labelAngle}) => labelAngle, // we already calculate this in parse\n\n  labelBaseline: ({axis, labelAngle, orient, channel}) =>\n    axis.labelBaseline || defaultLabelBaseline(labelAngle, orient, channel),\n\n  labelFlush: ({axis, fieldOrDatumDef, channel}) => axis.labelFlush ?? defaultLabelFlush(fieldOrDatumDef.type, channel),\n\n  labelOverlap: ({axis, fieldOrDatumDef, scaleType}) =>\n    axis.labelOverlap ??\n    defaultLabelOverlap(\n      fieldOrDatumDef.type,\n      scaleType,\n      isFieldDef(fieldOrDatumDef) && !!fieldOrDatumDef.timeUnit,\n      isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined\n    ),\n\n  // we already calculate orient in parse\n  orient: ({orient}) => orient as AxisOrient, // Need to cast until Vega supports signal\n\n  tickCount: ({channel, model, axis, fieldOrDatumDef, scaleType}) => {\n    const sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n    const size = sizeType ? model.getSizeSignalRef(sizeType) : undefined;\n    return axis.tickCount ?? defaultTickCount({fieldOrDatumDef, scaleType, size, values: axis.values});\n  },\n\n  title: ({axis, model, channel}) => {\n    if (axis.title !== undefined) {\n      return axis.title;\n    }\n    const fieldDefTitle = getFieldDefTitle(model, channel);\n    if (fieldDefTitle !== undefined) {\n      return fieldDefTitle;\n    }\n    const fieldDef = model.typedFieldDef(channel);\n    const channel2 = channel === 'x' ? 'x2' : 'y2';\n    const fieldDef2 = model.fieldDef(channel2);\n\n    // If title not specified, store base parts of fieldDef (and fieldDef2 if exists)\n    return mergeTitleFieldDefs(\n      fieldDef ? [toFieldDefBase(fieldDef)] : [],\n      isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []\n    );\n  },\n\n  values: ({axis, fieldOrDatumDef}) => values(axis, fieldOrDatumDef),\n\n  zindex: ({axis, fieldOrDatumDef, mark}) => axis.zindex ?? defaultZindex(mark, fieldOrDatumDef)\n};\n\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\n\nexport function defaultGrid(scaleType: ScaleType, fieldDef: TypedFieldDef<string> | DatumDef) {\n  return !hasDiscreteDomain(scaleType) && isFieldDef(fieldDef) && !isBinning(fieldDef?.bin) && !isBinned(fieldDef?.bin);\n}\n\nexport function gridScale(model: UnitModel, channel: PositionScaleChannel) {\n  const gridChannel: PositionScaleChannel = channel === 'x' ? 'y' : 'x';\n  if (model.getScaleComponent(gridChannel)) {\n    return model.scaleName(gridChannel);\n  }\n  return undefined;\n}\n\nexport function getLabelAngle(\n  fieldOrDatumDef: PositionFieldDef<string> | PositionDatumDef<string>,\n  axis: AxisInternal,\n  channel: PositionScaleChannel,\n  styleConfig: StyleConfigIndex<SignalRef>,\n  axisConfigs?: AxisConfigs\n) {\n  const labelAngle = axis?.labelAngle;\n  // try axis value\n  if (labelAngle !== undefined) {\n    return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);\n  } else {\n    // try axis config value\n    const {configValue: angle} = getAxisConfig('labelAngle', styleConfig, axis?.style, axisConfigs);\n    if (angle !== undefined) {\n      return normalizeAngle(angle);\n    } else {\n      // get default value\n      if (\n        channel === X &&\n        contains([NOMINAL, ORDINAL], fieldOrDatumDef.type) &&\n        !(isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit)\n      ) {\n        return 270;\n      }\n      // no default\n      return undefined;\n    }\n  }\n}\n\nexport function normalizeAngleExpr(angle: SignalRef) {\n  return `(((${angle.signal} % 360) + 360) % 360)`;\n}\n\nexport function defaultLabelBaseline(\n  angle: number | SignalRef,\n  orient: AxisOrient | SignalRef,\n  channel: 'x' | 'y',\n  alwaysIncludeMiddle?: boolean\n) {\n  if (angle !== undefined) {\n    if (channel === 'x') {\n      if (isSignalRef(angle)) {\n        const a = normalizeAngleExpr(angle);\n        const orientIsTop = isSignalRef(orient) ? `(${orient.signal} === \"top\")` : orient === 'top';\n        return {\n          signal:\n            `(45 < ${a} && ${a} < 135) || (225 < ${a} && ${a} < 315) ? \"middle\" :` +\n            `(${a} <= 45 || 315 <= ${a}) === ${orientIsTop} ? \"bottom\" : \"top\"`\n        };\n      }\n\n      if ((45 < angle && angle < 135) || (225 < angle && angle < 315)) {\n        return 'middle';\n      }\n\n      if (isSignalRef(orient)) {\n        const op = angle <= 45 || 315 <= angle ? '===' : '!==';\n        return {signal: `${orient.signal} ${op} \"top\" ? \"bottom\" : \"top\"`};\n      }\n\n      return (angle <= 45 || 315 <= angle) === (orient === 'top') ? 'bottom' : 'top';\n    } else {\n      if (isSignalRef(angle)) {\n        const a = normalizeAngleExpr(angle);\n        const orientIsLeft = isSignalRef(orient) ? `(${orient.signal} === \"left\")` : orient === 'left';\n        const middle = alwaysIncludeMiddle ? '\"middle\"' : 'null';\n        return {\n          signal: `${a} <= 45 || 315 <= ${a} || (135 <= ${a} && ${a} <= 225) ? ${middle} : (45 <= ${a} && ${a} <= 135) === ${orientIsLeft} ? \"top\" : \"bottom\"`\n        };\n      }\n\n      if (angle <= 45 || 315 <= angle || (135 <= angle && angle <= 225)) {\n        return alwaysIncludeMiddle ? 'middle' : null;\n      }\n\n      if (isSignalRef(orient)) {\n        const op = 45 <= angle && angle <= 135 ? '===' : '!==';\n        return {signal: `${orient.signal} ${op} \"left\" ? \"top\" : \"bottom\"`};\n      }\n\n      return (45 <= angle && angle <= 135) === (orient === 'left') ? 'top' : 'bottom';\n    }\n  }\n  return undefined;\n}\n\nexport function defaultLabelAlign(\n  angle: number | SignalRef,\n  orient: AxisOrient | SignalRef,\n  channel: 'x' | 'y'\n): Align | SignalRef {\n  if (angle === undefined) {\n    return undefined;\n  }\n\n  const isX = channel === 'x';\n  const startAngle = isX ? 0 : 90;\n  const mainOrient = isX ? 'bottom' : 'left';\n\n  if (isSignalRef(angle)) {\n    const a = normalizeAngleExpr(angle);\n    const orientIsMain = isSignalRef(orient) ? `(${orient.signal} === \"${mainOrient}\")` : orient === mainOrient;\n    return {\n      signal:\n        `(${startAngle ? `(${a} + 90)` : a} % 180 === 0) ? ${isX ? null : '\"center\"'} :` +\n        `(${startAngle} < ${a} && ${a} < ${180 + startAngle}) === ${orientIsMain} ? \"left\" : \"right\"`\n    };\n  }\n\n  if ((angle + startAngle) % 180 === 0) {\n    // For bottom, use default label align so label flush still works\n    return isX ? null : 'center';\n  }\n\n  if (isSignalRef(orient)) {\n    const op = startAngle < angle && angle < 180 + startAngle ? '===' : '!==';\n    const orientIsMain = `${orient.signal} ${op} \"${mainOrient}\"`;\n    return {\n      signal: `${orientIsMain} ? \"left\" : \"right\"`\n    };\n  }\n\n  if ((startAngle < angle && angle < 180 + startAngle) === (orient === mainOrient)) {\n    return 'left';\n  }\n\n  return 'right';\n}\n\nexport function defaultLabelFlush(type: Type, channel: PositionScaleChannel) {\n  if (channel === 'x' && contains(['quantitative', 'temporal'], type)) {\n    return true;\n  }\n  return undefined;\n}\n\nexport function defaultLabelOverlap(type: Type, scaleType: ScaleType, hasTimeUnit: boolean, sort?: Sort<string>) {\n  // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n  if ((hasTimeUnit && !isObject(sort)) || (type !== 'nominal' && type !== 'ordinal')) {\n    if (scaleType === 'log' || scaleType === 'symlog') {\n      return 'greedy';\n    }\n    return true;\n  }\n  return undefined;\n}\n\nexport function defaultOrient(channel: PositionScaleChannel) {\n  return channel === 'x' ? 'bottom' : 'left';\n}\n\nexport function defaultTickCount({\n  fieldOrDatumDef,\n  scaleType,\n  size,\n  values: vals\n}: {\n  fieldOrDatumDef: TypedFieldDef<string> | DatumDef;\n  scaleType: ScaleType;\n  size?: SignalRef;\n  values?: AxisInternal['values'];\n}) {\n  if (!vals && !hasDiscreteDomain(scaleType) && scaleType !== 'log') {\n    if (isFieldDef(fieldOrDatumDef)) {\n      if (isBinning(fieldOrDatumDef.bin)) {\n        // for binned data, we don't want more ticks than maxbins\n        return {signal: `ceil(${size.signal}/10)`};\n      }\n\n      if (\n        fieldOrDatumDef.timeUnit &&\n        contains(['month', 'hours', 'day', 'quarter'], normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit)\n      ) {\n        return undefined;\n      }\n    }\n\n    return {signal: `ceil(${size.signal}/40)`};\n  }\n\n  return undefined;\n}\n\nexport function getFieldDefTitle(model: UnitModel, channel: 'x' | 'y') {\n  const channel2 = channel === 'x' ? 'x2' : 'y2';\n  const fieldDef = model.fieldDef(channel);\n  const fieldDef2 = model.fieldDef(channel2);\n\n  const title1 = fieldDef ? fieldDef.title : undefined;\n  const title2 = fieldDef2 ? fieldDef2.title : undefined;\n\n  if (title1 && title2) {\n    return mergeTitle(title1, title2);\n  } else if (title1) {\n    return title1;\n  } else if (title2) {\n    return title2;\n  } else if (title1 !== undefined) {\n    // falsy value to disable config\n    return title1;\n  } else if (title2 !== undefined) {\n    // falsy value to disable config\n    return title2;\n  }\n\n  return undefined;\n}\n\nexport function values(axis: AxisInternal, fieldOrDatumDef: TypedFieldDef<string> | DatumDef) {\n  const vals = axis.values;\n\n  if (isArray(vals)) {\n    return valueArray(fieldOrDatumDef, vals);\n  } else if (isSignalRef(vals)) {\n    return vals;\n  }\n\n  return undefined;\n}\n\nexport function defaultZindex(mark: Mark, fieldDef: TypedFieldDef<string> | DatumDef) {\n  if (mark === 'rect' && isDiscrete(fieldDef)) {\n    return 1;\n  }\n  return 0;\n}\n"]},"metadata":{},"sourceType":"module"}