{"ast":null,"code":"import { isArgmaxDef, isArgminDef } from '../../aggregate';\nimport { getPositionChannelFromLatLong, getSecondaryRangeChannel, isGeoPositionChannel, isScaleChannel } from '../../channel';\nimport { binRequiresRange, hasBandEnd, isScaleFieldDef, isTypedFieldDef, vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { isFieldRange } from '../../scale';\nimport { duplicate, hash, keys, replacePathInField, setEqual } from '../../util';\nimport { isUnitModel } from '../model';\nimport { DataFlowNode } from './dataflow';\n\nfunction addDimension(dims, channel, fieldDef, model) {\n  var _a;\n\n  const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined;\n\n  if (isTypedFieldDef(fieldDef) && isUnitModel(model) && hasBandEnd(fieldDef, channelDef2, model.markDef, model.config)) {\n    dims.add(vgField(fieldDef, {}));\n    dims.add(vgField(fieldDef, {\n      suffix: 'end'\n    }));\n\n    if (fieldDef.bin && binRequiresRange(fieldDef, channel)) {\n      dims.add(vgField(fieldDef, {\n        binSuffix: 'range'\n      }));\n    }\n  } else if (isGeoPositionChannel(channel)) {\n    const posChannel = getPositionChannelFromLatLong(channel);\n    dims.add(model.getName(posChannel));\n  } else {\n    dims.add(vgField(fieldDef));\n  }\n\n  if (isScaleFieldDef(fieldDef) && isFieldRange((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.range)) {\n    dims.add(fieldDef.scale.range.field);\n  }\n\n  return dims;\n}\n\nfunction mergeMeasures(parentMeasures, childMeasures) {\n  var _a;\n\n  for (const field of keys(childMeasures)) {\n    // when we merge a measure, we either have to add an aggregation operator or even a new field\n    const ops = childMeasures[field];\n\n    for (const op of keys(ops)) {\n      if (field in parentMeasures) {\n        // add operator to existing measure field\n        parentMeasures[field][op] = new Set([...((_a = parentMeasures[field][op]) !== null && _a !== void 0 ? _a : []), ...ops[op]]);\n      } else {\n        parentMeasures[field] = {\n          [op]: ops[op]\n        };\n      }\n    }\n  }\n}\n\nexport class AggregateNode extends DataFlowNode {\n  /**\n   * @param dimensions string set for dimensions\n   * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n   */\n  constructor(parent, dimensions, measures) {\n    super(parent);\n    this.dimensions = dimensions;\n    this.measures = measures;\n  }\n\n  clone() {\n    return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));\n  }\n\n  get groupBy() {\n    return this.dimensions;\n  }\n\n  static makeFromEncoding(parent, model) {\n    let isAggregate = false;\n    model.forEachFieldDef(fd => {\n      if (fd.aggregate) {\n        isAggregate = true;\n      }\n    });\n    const meas = {};\n    const dims = new Set();\n\n    if (!isAggregate) {\n      // no need to create this node if the model has no aggregation\n      return null;\n    }\n\n    model.forEachFieldDef((fieldDef, channel) => {\n      var _a, _b, _c, _d;\n\n      const {\n        aggregate,\n        field\n      } = fieldDef;\n\n      if (aggregate) {\n        if (aggregate === 'count') {\n          (_a = meas['*']) !== null && _a !== void 0 ? _a : meas['*'] = {};\n          meas['*']['count'] = new Set([vgField(fieldDef, {\n            forAs: true\n          })]);\n        } else {\n          if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n            const op = isArgminDef(aggregate) ? 'argmin' : 'argmax';\n            const argField = aggregate[op];\n            (_b = meas[argField]) !== null && _b !== void 0 ? _b : meas[argField] = {};\n            meas[argField][op] = new Set([vgField({\n              op,\n              field: argField\n            }, {\n              forAs: true\n            })]);\n          } else {\n            (_c = meas[field]) !== null && _c !== void 0 ? _c : meas[field] = {};\n            meas[field][aggregate] = new Set([vgField(fieldDef, {\n              forAs: true\n            })]);\n          } // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n\n\n          if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n            (_d = meas[field]) !== null && _d !== void 0 ? _d : meas[field] = {};\n            meas[field]['min'] = new Set([vgField({\n              field,\n              aggregate: 'min'\n            }, {\n              forAs: true\n            })]);\n            meas[field]['max'] = new Set([vgField({\n              field,\n              aggregate: 'max'\n            }, {\n              forAs: true\n            })]);\n          }\n        }\n      } else {\n        addDimension(dims, channel, fieldDef, model);\n      }\n    });\n\n    if (dims.size + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  static makeFromTransform(parent, t) {\n    var _a, _b, _c;\n\n    const dims = new Set();\n    const meas = {};\n\n    for (const s of t.aggregate) {\n      const {\n        op,\n        field,\n        as\n      } = s;\n\n      if (op) {\n        if (op === 'count') {\n          (_a = meas['*']) !== null && _a !== void 0 ? _a : meas['*'] = {};\n          meas['*']['count'] = new Set([as ? as : vgField(s, {\n            forAs: true\n          })]);\n        } else {\n          (_b = meas[field]) !== null && _b !== void 0 ? _b : meas[field] = {};\n          meas[field][op] = new Set([as ? as : vgField(s, {\n            forAs: true\n          })]);\n        }\n      }\n    }\n\n    for (const s of (_c = t.groupby) !== null && _c !== void 0 ? _c : []) {\n      dims.add(s);\n    }\n\n    if (dims.size + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  merge(other) {\n    if (setEqual(this.dimensions, other.dimensions)) {\n      mergeMeasures(this.measures, other.measures);\n      return true;\n    }\n\n    log.debug('different dimensions, cannot merge');\n    return false;\n  }\n\n  addDimensions(fields) {\n    fields.forEach(this.dimensions.add, this.dimensions);\n  }\n\n  dependentFields() {\n    return new Set([...this.dimensions, ...keys(this.measures)]);\n  }\n\n  producedFields() {\n    const out = new Set();\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        const m = this.measures[field][op];\n\n        if (m.size === 0) {\n          out.add(`${op}_${field}`);\n        } else {\n          m.forEach(out.add, out);\n        }\n      }\n    }\n\n    return out;\n  }\n\n  hash() {\n    return `Aggregate ${hash({\n      dimensions: this.dimensions,\n      measures: this.measures\n    })}`;\n  }\n\n  assemble() {\n    const ops = [];\n    const fields = [];\n    const as = [];\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        for (const alias of this.measures[field][op]) {\n          as.push(alias);\n          ops.push(op);\n          fields.push(field === '*' ? null : replacePathInField(field));\n        }\n      }\n    }\n\n    const result = {\n      type: 'aggregate',\n      groupby: [...this.dimensions].map(replacePathInField),\n      ops,\n      fields,\n      as\n    };\n    return result;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["isArgmaxDef","isArgminDef","getPositionChannelFromLatLong","getSecondaryRangeChannel","isGeoPositionChannel","isScaleChannel","binRequiresRange","hasBandEnd","isScaleFieldDef","isTypedFieldDef","vgField","log","isFieldRange","duplicate","hash","keys","replacePathInField","setEqual","isUnitModel","DataFlowNode","addDimension","dims","channel","fieldDef","model","channelDef2","encoding","undefined","markDef","config","add","suffix","bin","binSuffix","posChannel","getName","scale","_a","range","field","mergeMeasures","parentMeasures","childMeasures","ops","op","Set","AggregateNode","constructor","parent","dimensions","measures","clone","groupBy","makeFromEncoding","isAggregate","forEachFieldDef","fd","aggregate","meas","forAs","argField","_b","_c","scaleDomain","_d","size","length","makeFromTransform","t","s","as","groupby","merge","other","debug","addDimensions","fields","forEach","dependentFields","producedFields","out","m","assemble","alias","push","result","type","map"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/data/aggregate.ts"],"sourcesContent":["import {AggregateOp, AggregateTransform as VgAggregateTransform} from 'vega';\nimport {isArgmaxDef, isArgminDef} from '../../aggregate';\nimport {\n  Channel,\n  getPositionChannelFromLatLong,\n  getSecondaryRangeChannel,\n  isGeoPositionChannel,\n  isScaleChannel\n} from '../../channel';\nimport {binRequiresRange, FieldDef, hasBandEnd, isScaleFieldDef, isTypedFieldDef, vgField} from '../../channeldef';\nimport * as log from '../../log';\nimport {isFieldRange} from '../../scale';\nimport {AggregateTransform} from '../../transform';\nimport {Dict, duplicate, hash, keys, replacePathInField, setEqual} from '../../util';\nimport {isUnitModel, ModelWithField} from '../model';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\ntype Measures = Dict<Partial<Record<AggregateOp, Set<string>>>>;\n\nfunction addDimension(dims: Set<string>, channel: Channel, fieldDef: FieldDef<string>, model: ModelWithField) {\n  const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined;\n\n  if (\n    isTypedFieldDef(fieldDef) &&\n    isUnitModel(model) &&\n    hasBandEnd(fieldDef, channelDef2, model.markDef, model.config)\n  ) {\n    dims.add(vgField(fieldDef, {}));\n    dims.add(vgField(fieldDef, {suffix: 'end'}));\n\n    if (fieldDef.bin && binRequiresRange(fieldDef, channel)) {\n      dims.add(vgField(fieldDef, {binSuffix: 'range'}));\n    }\n  } else if (isGeoPositionChannel(channel)) {\n    const posChannel = getPositionChannelFromLatLong(channel);\n    dims.add(model.getName(posChannel));\n  } else {\n    dims.add(vgField(fieldDef));\n  }\n  if (isScaleFieldDef(fieldDef) && isFieldRange(fieldDef.scale?.range)) {\n    dims.add(fieldDef.scale.range.field);\n  }\n  return dims;\n}\n\nfunction mergeMeasures(parentMeasures: Measures, childMeasures: Measures) {\n  for (const field of keys(childMeasures)) {\n    // when we merge a measure, we either have to add an aggregation operator or even a new field\n    const ops = childMeasures[field];\n    for (const op of keys(ops)) {\n      if (field in parentMeasures) {\n        // add operator to existing measure field\n        parentMeasures[field][op] = new Set([...(parentMeasures[field][op] ?? []), ...ops[op]]);\n      } else {\n        parentMeasures[field] = {[op]: ops[op]};\n      }\n    }\n  }\n}\n\nexport class AggregateNode extends DataFlowNode {\n  public clone() {\n    return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));\n  }\n\n  /**\n   * @param dimensions string set for dimensions\n   * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n   */\n  constructor(parent: DataFlowNode, private dimensions: Set<string>, private measures: Measures) {\n    super(parent);\n  }\n\n  get groupBy() {\n    return this.dimensions;\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: UnitModel): AggregateNode {\n    let isAggregate = false;\n    model.forEachFieldDef(fd => {\n      if (fd.aggregate) {\n        isAggregate = true;\n      }\n    });\n\n    const meas: Measures = {};\n    const dims = new Set<string>();\n\n    if (!isAggregate) {\n      // no need to create this node if the model has no aggregation\n      return null;\n    }\n\n    model.forEachFieldDef((fieldDef, channel: Channel) => {\n      const {aggregate, field} = fieldDef;\n      if (aggregate) {\n        if (aggregate === 'count') {\n          meas['*'] ??= {};\n          meas['*']['count'] = new Set([vgField(fieldDef, {forAs: true})]);\n        } else {\n          if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n            const op = isArgminDef(aggregate) ? 'argmin' : 'argmax';\n            const argField = aggregate[op];\n            meas[argField] ??= {};\n            meas[argField][op] = new Set([vgField({op, field: argField}, {forAs: true})]);\n          } else {\n            meas[field] ??= {};\n            meas[field][aggregate] = new Set([vgField(fieldDef, {forAs: true})]);\n          }\n\n          // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n          if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n            meas[field] ??= {};\n            meas[field]['min'] = new Set([vgField({field, aggregate: 'min'}, {forAs: true})]);\n            meas[field]['max'] = new Set([vgField({field, aggregate: 'max'}, {forAs: true})]);\n          }\n        }\n      } else {\n        addDimension(dims, channel, fieldDef, model);\n      }\n    });\n\n    if (dims.size + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, t: AggregateTransform): AggregateNode {\n    const dims = new Set<string>();\n    const meas: Measures = {};\n\n    for (const s of t.aggregate) {\n      const {op, field, as} = s;\n      if (op) {\n        if (op === 'count') {\n          meas['*'] ??= {};\n          meas['*']['count'] = new Set([as ? as : vgField(s, {forAs: true})]);\n        } else {\n          meas[field] ??= {};\n          meas[field][op] = new Set([as ? as : vgField(s, {forAs: true})]);\n        }\n      }\n    }\n\n    for (const s of t.groupby ?? []) {\n      dims.add(s);\n    }\n\n    if (dims.size + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  public merge(other: AggregateNode): boolean {\n    if (setEqual(this.dimensions, other.dimensions)) {\n      mergeMeasures(this.measures, other.measures);\n      return true;\n    }\n    log.debug('different dimensions, cannot merge');\n    return false;\n  }\n\n  public addDimensions(fields: readonly string[]) {\n    fields.forEach(this.dimensions.add, this.dimensions);\n  }\n\n  public dependentFields() {\n    return new Set([...this.dimensions, ...keys(this.measures)]);\n  }\n\n  public producedFields() {\n    const out = new Set<string>();\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        const m = this.measures[field][op];\n        if (m.size === 0) {\n          out.add(`${op}_${field}`);\n        } else {\n          m.forEach(out.add, out);\n        }\n      }\n    }\n\n    return out;\n  }\n\n  public hash() {\n    return `Aggregate ${hash({dimensions: this.dimensions, measures: this.measures})}`;\n  }\n\n  public assemble(): VgAggregateTransform {\n    const ops: AggregateOp[] = [];\n    const fields: string[] = [];\n    const as: string[] = [];\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        for (const alias of this.measures[field][op]) {\n          as.push(alias);\n          ops.push(op);\n          fields.push(field === '*' ? null : replacePathInField(field));\n        }\n      }\n    }\n\n    const result: VgAggregateTransform = {\n      type: 'aggregate',\n      groupby: [...this.dimensions].map(replacePathInField),\n      ops,\n      fields,\n      as\n    };\n\n    return result;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}