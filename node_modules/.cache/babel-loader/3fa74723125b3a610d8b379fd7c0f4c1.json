{"ast":null,"code":"export function isLogicalOr(op) {\n  return !!op.or;\n}\nexport function isLogicalAnd(op) {\n  return !!op.and;\n}\nexport function isLogicalNot(op) {\n  return !!op.not;\n}\nexport function forEachLeaf(op, fn) {\n  if (isLogicalNot(op)) {\n    forEachLeaf(op.not, fn);\n  } else if (isLogicalAnd(op)) {\n    for (const subop of op.and) {\n      forEachLeaf(subop, fn);\n    }\n  } else if (isLogicalOr(op)) {\n    for (const subop of op.or) {\n      forEachLeaf(subop, fn);\n    }\n  } else {\n    fn(op);\n  }\n}\nexport function normalizeLogicalComposition(op, normalizer) {\n  if (isLogicalNot(op)) {\n    return {\n      not: normalizeLogicalComposition(op.not, normalizer)\n    };\n  } else if (isLogicalAnd(op)) {\n    return {\n      and: op.and.map(o => normalizeLogicalComposition(o, normalizer))\n    };\n  } else if (isLogicalOr(op)) {\n    return {\n      or: op.or.map(o => normalizeLogicalComposition(o, normalizer))\n    };\n  } else {\n    return normalizer(op);\n  }\n}","map":{"version":3,"mappings":"AAcA,OAAM,SAAUA,WAAV,CAAsBC,EAAtB,EAAiD;EACrD,OAAO,CAAC,CAACA,EAAE,CAACC,EAAZ;AACD;AAED,OAAM,SAAUC,YAAV,CAAuBF,EAAvB,EAAkD;EACtD,OAAO,CAAC,CAACA,EAAE,CAACG,GAAZ;AACD;AAED,OAAM,SAAUC,YAAV,CAAuBJ,EAAvB,EAAkD;EACtD,OAAO,CAAC,CAACA,EAAE,CAACK,GAAZ;AACD;AAED,OAAM,SAAUC,WAAV,CAAyBN,EAAzB,EAAoDO,EAApD,EAAuE;EAC3E,IAAIH,YAAY,CAACJ,EAAD,CAAhB,EAAsB;IACpBM,WAAW,CAACN,EAAE,CAACK,GAAJ,EAASE,EAAT,CAAX;EACD,CAFD,MAEO,IAAIL,YAAY,CAACF,EAAD,CAAhB,EAAsB;IAC3B,KAAK,MAAMQ,KAAX,IAAoBR,EAAE,CAACG,GAAvB,EAA4B;MAC1BG,WAAW,CAACE,KAAD,EAAQD,EAAR,CAAX;IACD;EACF,CAJM,MAIA,IAAIR,WAAW,CAACC,EAAD,CAAf,EAAqB;IAC1B,KAAK,MAAMQ,KAAX,IAAoBR,EAAE,CAACC,EAAvB,EAA2B;MACzBK,WAAW,CAACE,KAAD,EAAQD,EAAR,CAAX;IACD;EACF,CAJM,MAIA;IACLA,EAAE,CAACP,EAAD,CAAF;EACD;AACF;AAED,OAAM,SAAUS,2BAAV,CACJT,EADI,EAEJU,UAFI,EAEmB;EAEvB,IAAIN,YAAY,CAACJ,EAAD,CAAhB,EAAsB;IACpB,OAAO;MAACK,GAAG,EAAEI,2BAA2B,CAACT,EAAE,CAACK,GAAJ,EAASK,UAAT;IAAjC,CAAP;EACD,CAFD,MAEO,IAAIR,YAAY,CAACF,EAAD,CAAhB,EAAsB;IAC3B,OAAO;MAACG,GAAG,EAAEH,EAAE,CAACG,GAAH,CAAOQ,GAAP,CAAWC,CAAC,IAAIH,2BAA2B,CAACG,CAAD,EAAIF,UAAJ,CAA3C;IAAN,CAAP;EACD,CAFM,MAEA,IAAIX,WAAW,CAACC,EAAD,CAAf,EAAqB;IAC1B,OAAO;MAACC,EAAE,EAAED,EAAE,CAACC,EAAH,CAAMU,GAAN,CAAUC,CAAC,IAAIH,2BAA2B,CAACG,CAAD,EAAIF,UAAJ,CAA1C;IAAL,CAAP;EACD,CAFM,MAEA;IACL,OAAOA,UAAU,CAACV,EAAD,CAAjB;EACD;AACF","names":["isLogicalOr","op","or","isLogicalAnd","and","isLogicalNot","not","forEachLeaf","fn","subop","normalizeLogicalComposition","normalizer","map","o"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/logical.ts"],"sourcesContent":["export type LogicalComposition<T> = LogicalNot<T> | LogicalAnd<T> | LogicalOr<T> | T;\n\nexport interface LogicalOr<T> {\n  or: LogicalComposition<T>[];\n}\n\nexport interface LogicalAnd<T> {\n  and: LogicalComposition<T>[];\n}\n\nexport interface LogicalNot<T> {\n  not: LogicalComposition<T>;\n}\n\nexport function isLogicalOr(op: LogicalComposition<any>): op is LogicalOr<any> {\n  return !!op.or;\n}\n\nexport function isLogicalAnd(op: LogicalComposition<any>): op is LogicalAnd<any> {\n  return !!op.and;\n}\n\nexport function isLogicalNot(op: LogicalComposition<any>): op is LogicalNot<any> {\n  return !!op.not;\n}\n\nexport function forEachLeaf<T>(op: LogicalComposition<T>, fn: (op: T) => void) {\n  if (isLogicalNot(op)) {\n    forEachLeaf(op.not, fn);\n  } else if (isLogicalAnd(op)) {\n    for (const subop of op.and) {\n      forEachLeaf(subop, fn);\n    }\n  } else if (isLogicalOr(op)) {\n    for (const subop of op.or) {\n      forEachLeaf(subop, fn);\n    }\n  } else {\n    fn(op);\n  }\n}\n\nexport function normalizeLogicalComposition<T>(\n  op: LogicalComposition<T>,\n  normalizer: (o: T) => T\n): LogicalComposition<T> {\n  if (isLogicalNot(op)) {\n    return {not: normalizeLogicalComposition(op.not, normalizer)};\n  } else if (isLogicalAnd(op)) {\n    return {and: op.and.map(o => normalizeLogicalComposition(o, normalizer))};\n  } else if (isLogicalOr(op)) {\n    return {or: op.or.map(o => normalizeLogicalComposition(o, normalizer))};\n  } else {\n    return normalizer(op);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}