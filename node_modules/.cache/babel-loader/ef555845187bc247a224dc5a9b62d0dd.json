{"ast":null,"code":"import { array } from 'vega-util';\nimport * as log from '../log';\nimport { isLayerSpec, isUnitSpec } from '../spec';\nimport { keys } from '../util';\nimport { assembleAxisSignals } from './axis/assemble';\nimport { parseLayerAxes } from './axis/parse';\nimport { parseData } from './data/parse';\nimport { assembleLayoutSignals } from './layoutsize/assemble';\nimport { parseLayerLayoutSize } from './layoutsize/parse';\nimport { assembleLegends } from './legend/assemble';\nimport { Model } from './model';\nimport { assembleLayerSelectionMarks } from './selection/assemble';\nimport { UnitModel } from './unit';\nexport class LayerModel extends Model {\n  constructor(spec, parent, parentGivenName, parentGivenSize, config) {\n    super(spec, 'layer', parent, parentGivenName, config, spec.resolve, spec.view);\n    const layoutSize = Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? {\n      width: spec.width\n    } : {}), spec.height ? {\n      height: spec.height\n    } : {});\n    this.children = spec.layer.map((layer, i) => {\n      if (isLayerSpec(layer)) {\n        return new LayerModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);\n      } else if (isUnitSpec(layer)) {\n        return new UnitModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);\n      }\n\n      throw new Error(log.message.invalidSpec(layer));\n    });\n  }\n\n  parseData() {\n    this.component.data = parseData(this);\n\n    for (const child of this.children) {\n      child.parseData();\n    }\n  }\n\n  parseLayoutSize() {\n    parseLayerLayoutSize(this);\n  }\n\n  parseSelections() {\n    // Merge selections up the hierarchy so that they may be referenced\n    // across unit specs. Persist their definitions within each child\n    // to assemble signals which remain within output Vega unit groups.\n    this.component.selection = {};\n\n    for (const child of this.children) {\n      child.parseSelections();\n\n      for (const key of keys(child.component.selection)) {\n        this.component.selection[key] = child.component.selection[key];\n      }\n    }\n  }\n\n  parseMarkGroup() {\n    for (const child of this.children) {\n      child.parseMarkGroup();\n    }\n  }\n\n  parseAxesAndHeaders() {\n    parseLayerAxes(this);\n  }\n\n  assembleSelectionTopLevelSignals(signals) {\n    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);\n  } // TODO: Support same named selections across children.\n\n\n  assembleSignals() {\n    return this.children.reduce((signals, child) => {\n      return signals.concat(child.assembleSignals());\n    }, assembleAxisSignals(this));\n  }\n\n  assembleLayoutSignals() {\n    return this.children.reduce((signals, child) => {\n      return signals.concat(child.assembleLayoutSignals());\n    }, assembleLayoutSignals(this));\n  }\n\n  assembleSelectionData(data) {\n    return this.children.reduce((db, child) => child.assembleSelectionData(db), data);\n  }\n\n  assembleGroupStyle() {\n    const uniqueStyles = new Set();\n\n    for (const child of this.children) {\n      for (const style of array(child.assembleGroupStyle())) {\n        uniqueStyles.add(style);\n      }\n    }\n\n    const styles = Array.from(uniqueStyles);\n    return styles.length > 1 ? styles : styles.length === 1 ? styles[0] : undefined;\n  }\n\n  assembleTitle() {\n    let title = super.assembleTitle();\n\n    if (title) {\n      return title;\n    } // If title does not provide layer, look into children\n\n\n    for (const child of this.children) {\n      title = child.assembleTitle();\n\n      if (title) {\n        return title;\n      }\n    }\n\n    return undefined;\n  }\n\n  assembleLayout() {\n    return null;\n  }\n\n  assembleMarks() {\n    return assembleLayerSelectionMarks(this, this.children.flatMap(child => {\n      return child.assembleMarks();\n    }));\n  }\n\n  assembleLegends() {\n    return this.children.reduce((legends, child) => {\n      return legends.concat(child.assembleLegends());\n    }, assembleLegends(this));\n  }\n\n}","map":{"version":3,"mappings":"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","names":["array","log","isLayerSpec","isUnitSpec","keys","assembleAxisSignals","parseLayerAxes","parseData","assembleLayoutSignals","parseLayerLayoutSize","assembleLegends","Model","assembleLayerSelectionMarks","UnitModel","LayerModel","constructor","spec","parent","parentGivenName","parentGivenSize","config","resolve","view","layoutSize","width","height","children","layer","map","i","getName","Error","message","invalidSpec","component","data","child","parseLayoutSize","parseSelections","selection","key","parseMarkGroup","parseAxesAndHeaders","assembleSelectionTopLevelSignals","signals","reduce","sg","assembleSignals","concat","assembleSelectionData","db","assembleGroupStyle","uniqueStyles","Set","style","add","styles","Array","from","length","undefined","assembleTitle","title","assembleLayout","assembleMarks","flatMap","legends"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/layer.ts"],"sourcesContent":["import {Legend as VgLegend, NewSignal, SignalRef, Title as VgTitle} from 'vega';\nimport {array} from 'vega-util';\nimport {Config} from '../config';\nimport * as log from '../log';\nimport {isLayerSpec, isUnitSpec, LayoutSizeMixins, NormalizedLayerSpec} from '../spec';\nimport {keys} from '../util';\nimport {VgData, VgLayout} from '../vega.schema';\nimport {assembleAxisSignals} from './axis/assemble';\nimport {parseLayerAxes} from './axis/parse';\nimport {parseData} from './data/parse';\nimport {assembleLayoutSignals} from './layoutsize/assemble';\nimport {parseLayerLayoutSize} from './layoutsize/parse';\nimport {assembleLegends} from './legend/assemble';\nimport {Model} from './model';\nimport {assembleLayerSelectionMarks} from './selection/assemble';\nimport {UnitModel} from './unit';\n\nexport class LayerModel extends Model {\n  // HACK: This should be (LayerModel | UnitModel)[], but setting the correct type leads to weird error.\n  // So I'm just putting generic Model for now\n  public readonly children: Model[];\n\n  constructor(\n    spec: NormalizedLayerSpec,\n    parent: Model,\n    parentGivenName: string,\n    parentGivenSize: LayoutSizeMixins,\n    config: Config<SignalRef>\n  ) {\n    super(spec, 'layer', parent, parentGivenName, config, spec.resolve, spec.view);\n\n    const layoutSize = {\n      ...parentGivenSize,\n      ...(spec.width ? {width: spec.width} : {}),\n      ...(spec.height ? {height: spec.height} : {})\n    };\n\n    this.children = spec.layer.map((layer, i) => {\n      if (isLayerSpec(layer)) {\n        return new LayerModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);\n      } else if (isUnitSpec(layer)) {\n        return new UnitModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);\n      }\n\n      throw new Error(log.message.invalidSpec(layer));\n    });\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n    for (const child of this.children) {\n      child.parseData();\n    }\n  }\n\n  public parseLayoutSize() {\n    parseLayerLayoutSize(this);\n  }\n\n  public parseSelections() {\n    // Merge selections up the hierarchy so that they may be referenced\n    // across unit specs. Persist their definitions within each child\n    // to assemble signals which remain within output Vega unit groups.\n    this.component.selection = {};\n    for (const child of this.children) {\n      child.parseSelections();\n      for (const key of keys(child.component.selection)) {\n        this.component.selection[key] = child.component.selection[key];\n      }\n    }\n  }\n\n  public parseMarkGroup() {\n    for (const child of this.children) {\n      child.parseMarkGroup();\n    }\n  }\n\n  public parseAxesAndHeaders() {\n    parseLayerAxes(this);\n  }\n\n  public assembleSelectionTopLevelSignals(signals: NewSignal[]): NewSignal[] {\n    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);\n  }\n\n  // TODO: Support same named selections across children.\n  public assembleSignals(): NewSignal[] {\n    return this.children.reduce((signals, child) => {\n      return signals.concat(child.assembleSignals());\n    }, assembleAxisSignals(this));\n  }\n\n  public assembleLayoutSignals(): NewSignal[] {\n    return this.children.reduce((signals, child) => {\n      return signals.concat(child.assembleLayoutSignals());\n    }, assembleLayoutSignals(this));\n  }\n\n  public assembleSelectionData(data: readonly VgData[]): readonly VgData[] {\n    return this.children.reduce((db, child) => child.assembleSelectionData(db), data);\n  }\n\n  public assembleGroupStyle(): string | string[] {\n    const uniqueStyles = new Set<string>();\n    for (const child of this.children) {\n      for (const style of array(child.assembleGroupStyle())) {\n        uniqueStyles.add(style);\n      }\n    }\n    const styles = Array.from(uniqueStyles);\n    return styles.length > 1 ? styles : styles.length === 1 ? styles[0] : undefined;\n  }\n\n  public assembleTitle(): VgTitle {\n    let title = super.assembleTitle();\n    if (title) {\n      return title;\n    }\n    // If title does not provide layer, look into children\n    for (const child of this.children) {\n      title = child.assembleTitle();\n      if (title) {\n        return title;\n      }\n    }\n    return undefined;\n  }\n\n  public assembleLayout(): VgLayout {\n    return null;\n  }\n\n  public assembleMarks(): any[] {\n    return assembleLayerSelectionMarks(\n      this,\n      this.children.flatMap(child => {\n        return child.assembleMarks();\n      })\n    );\n  }\n\n  public assembleLegends(): VgLegend[] {\n    return this.children.reduce((legends, child) => {\n      return legends.concat(child.assembleLegends());\n    }, assembleLegends(this));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}