{"ast":null,"code":"/**\n * Utility for generating row / column headers\n */\nimport { isArray } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { vgField } from '../../channeldef';\nimport { HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP } from '../../header';\nimport { isSortField } from '../../sort';\nimport { isFacetMapping } from '../../spec/facet';\nimport { contains, isEmpty, normalizeAngle, replaceAll } from '../../util';\nimport { defaultLabelAlign, defaultLabelBaseline } from '../axis/properties';\nimport { sortArrayIndexField } from '../data/calculate';\nimport { formatSignalRef } from '../format';\nimport { isFacetModel } from '../model';\nimport { getHeaderChannel, getHeaderProperties, getHeaderProperty } from './common';\nimport { HEADER_TYPES } from './component'; // TODO: rename to assembleHeaderTitleGroup\n\nexport function assembleTitleGroup(model, channel) {\n  const title = model.component.layoutHeaders[channel].title;\n  const config = model.config ? model.config : undefined;\n  const facetFieldDef = model.component.layoutHeaders[channel].facetFieldDef ? model.component.layoutHeaders[channel].facetFieldDef : undefined;\n  const {\n    titleAnchor,\n    titleAngle: ta,\n    titleOrient\n  } = getHeaderProperties(['titleAnchor', 'titleAngle', 'titleOrient'], facetFieldDef.header, config, channel);\n  const headerChannel = getHeaderChannel(channel, titleOrient);\n  const titleAngle = normalizeAngle(ta);\n  return {\n    name: `${channel}-title`,\n    type: 'group',\n    role: `${headerChannel}-title`,\n    title: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n      text: title\n    }, channel === 'row' ? {\n      orient: 'left'\n    } : {}), {\n      style: 'guide-title'\n    }), defaultHeaderGuideBaseline(titleAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, titleAngle, titleAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP))\n  };\n}\nexport function defaultHeaderGuideAlign(headerChannel, angle) {\n  let anchor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'middle';\n\n  switch (anchor) {\n    case 'start':\n      return {\n        align: 'left'\n      };\n\n    case 'end':\n      return {\n        align: 'right'\n      };\n  }\n\n  const align = defaultLabelAlign(angle, headerChannel === 'row' ? 'left' : 'top', headerChannel === 'row' ? 'y' : 'x');\n  return align ? {\n    align\n  } : {};\n}\nexport function defaultHeaderGuideBaseline(angle, channel) {\n  const baseline = defaultLabelBaseline(angle, channel === 'row' ? 'left' : 'top', channel === 'row' ? 'y' : 'x', true);\n  return baseline ? {\n    baseline\n  } : {};\n}\nexport function assembleHeaderGroups(model, channel) {\n  const layoutHeader = model.component.layoutHeaders[channel];\n  const groups = [];\n\n  for (const headerType of HEADER_TYPES) {\n    if (layoutHeader[headerType]) {\n      for (const headerComponent of layoutHeader[headerType]) {\n        const group = assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent);\n\n        if (group != null) {\n          groups.push(group);\n        }\n      }\n    }\n  }\n\n  return groups;\n}\n\nfunction getSort(facetFieldDef, channel) {\n  var _a;\n\n  const {\n    sort\n  } = facetFieldDef;\n\n  if (isSortField(sort)) {\n    return {\n      field: vgField(sort, {\n        expr: 'datum'\n      }),\n      order: (_a = sort.order) !== null && _a !== void 0 ? _a : 'ascending'\n    };\n  } else if (isArray(sort)) {\n    return {\n      field: sortArrayIndexField(facetFieldDef, channel, {\n        expr: 'datum'\n      }),\n      order: 'ascending'\n    };\n  } else {\n    return {\n      field: vgField(facetFieldDef, {\n        expr: 'datum'\n      }),\n      order: sort !== null && sort !== void 0 ? sort : 'ascending'\n    };\n  }\n}\n\nexport function assembleLabelTitle(facetFieldDef, channel, config) {\n  const {\n    format,\n    formatType,\n    labelAngle,\n    labelAnchor,\n    labelOrient,\n    labelExpr\n  } = getHeaderProperties(['format', 'formatType', 'labelAngle', 'labelAnchor', 'labelOrient', 'labelExpr'], facetFieldDef.header, config, channel);\n  const titleTextExpr = formatSignalRef({\n    fieldOrDatumDef: facetFieldDef,\n    format,\n    formatType,\n    expr: 'parent',\n    config\n  }).signal;\n  const headerChannel = getHeaderChannel(channel, labelOrient);\n  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n    text: {\n      signal: labelExpr ? replaceAll(replaceAll(labelExpr, 'datum.label', titleTextExpr), 'datum.value', vgField(facetFieldDef, {\n        expr: 'parent'\n      })) : titleTextExpr\n    }\n  }, channel === 'row' ? {\n    orient: 'left'\n  } : {}), {\n    style: 'guide-label',\n    frame: 'group'\n  }), defaultHeaderGuideBaseline(labelAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, labelAngle, labelAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP));\n}\nexport function assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent) {\n  if (headerComponent) {\n    let title = null;\n    const {\n      facetFieldDef\n    } = layoutHeader;\n    const config = model.config ? model.config : undefined;\n\n    if (facetFieldDef && headerComponent.labels) {\n      const {\n        labelOrient\n      } = getHeaderProperties(['labelOrient'], facetFieldDef.header, config, channel); // Include label title in the header if orient aligns with the channel\n\n      if (channel === 'row' && !contains(['top', 'bottom'], labelOrient) || channel === 'column' && !contains(['left', 'right'], labelOrient)) {\n        title = assembleLabelTitle(facetFieldDef, channel, config);\n      }\n    }\n\n    const isFacetWithoutRowCol = isFacetModel(model) && !isFacetMapping(model.facet);\n    const axes = headerComponent.axes;\n    const hasAxes = (axes === null || axes === void 0 ? void 0 : axes.length) > 0;\n\n    if (title || hasAxes) {\n      const sizeChannel = channel === 'row' ? 'height' : 'width';\n      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n        name: model.getName(`${channel}_${headerType}`),\n        type: 'group',\n        role: `${channel}-${headerType}`\n      }, layoutHeader.facetFieldDef ? {\n        from: {\n          data: model.getName(`${channel}_domain`)\n        },\n        sort: getSort(facetFieldDef, channel)\n      } : {}), hasAxes && isFacetWithoutRowCol ? {\n        from: {\n          data: model.getName(`facet_domain_${channel}`)\n        }\n      } : {}), title ? {\n        title\n      } : {}), headerComponent.sizeSignal ? {\n        encode: {\n          update: {\n            [sizeChannel]: headerComponent.sizeSignal\n          }\n        }\n      } : {}), hasAxes ? {\n        axes\n      } : {});\n    }\n  }\n\n  return null;\n}\nconst LAYOUT_TITLE_BAND = {\n  column: {\n    start: 0,\n    end: 1\n  },\n  row: {\n    start: 1,\n    end: 0\n  }\n};\nexport function getLayoutTitleBand(titleAnchor, headerChannel) {\n  return LAYOUT_TITLE_BAND[headerChannel][titleAnchor];\n}\nexport function assembleLayoutTitleBand(headerComponentIndex, config) {\n  const titleBand = {};\n\n  for (const channel of FACET_CHANNELS) {\n    const headerComponent = headerComponentIndex[channel];\n\n    if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent.facetFieldDef) {\n      const {\n        titleAnchor,\n        titleOrient\n      } = getHeaderProperties(['titleAnchor', 'titleOrient'], headerComponent.facetFieldDef.header, config, channel);\n      const headerChannel = getHeaderChannel(channel, titleOrient);\n      const band = getLayoutTitleBand(titleAnchor, headerChannel);\n\n      if (band !== undefined) {\n        titleBand[headerChannel] = band;\n      }\n    }\n  }\n\n  return isEmpty(titleBand) ? undefined : titleBand;\n}\nexport function assembleHeaderProperties(config, facetFieldDef, channel, properties, propertiesMap) {\n  const props = {};\n\n  for (const prop of properties) {\n    if (!propertiesMap[prop]) {\n      continue;\n    }\n\n    const value = getHeaderProperty(prop, facetFieldDef === null || facetFieldDef === void 0 ? void 0 : facetFieldDef.header, config, channel);\n\n    if (value !== undefined) {\n      props[propertiesMap[prop]] = value;\n    }\n  }\n\n  return props;\n}","map":{"version":3,"mappings":"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","names":["isArray","FACET_CHANNELS","vgField","HEADER_LABEL_PROPERTIES","HEADER_LABEL_PROPERTIES_MAP","HEADER_TITLE_PROPERTIES","HEADER_TITLE_PROPERTIES_MAP","isSortField","isFacetMapping","contains","isEmpty","normalizeAngle","replaceAll","defaultLabelAlign","defaultLabelBaseline","sortArrayIndexField","formatSignalRef","isFacetModel","getHeaderChannel","getHeaderProperties","getHeaderProperty","HEADER_TYPES","assembleTitleGroup","model","channel","title","component","layoutHeaders","config","undefined","facetFieldDef","titleAnchor","titleAngle","ta","titleOrient","header","headerChannel","name","type","role","text","orient","style","defaultHeaderGuideBaseline","defaultHeaderGuideAlign","assembleHeaderProperties","angle","anchor","align","baseline","assembleHeaderGroups","layoutHeader","groups","headerType","headerComponent","group","assembleHeaderGroup","push","getSort","sort","field","expr","order","_a","assembleLabelTitle","format","formatType","labelAngle","labelAnchor","labelOrient","labelExpr","titleTextExpr","fieldOrDatumDef","signal","frame","labels","isFacetWithoutRowCol","facet","axes","hasAxes","length","sizeChannel","getName","from","data","sizeSignal","encode","update","LAYOUT_TITLE_BAND","column","start","end","row","getLayoutTitleBand","assembleLayoutTitleBand","headerComponentIndex","titleBand","band","properties","propertiesMap","props","prop","value"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/header/assemble.ts"],"sourcesContent":["/**\n * Utility for generating row / column headers\n */\n\nimport {SignalRef, TitleAnchor, TitleConfig} from 'vega';\nimport {isArray} from 'vega-util';\nimport {FacetChannel, FACET_CHANNELS} from '../../channel';\nimport {vgField} from '../../channeldef';\nimport {Config} from '../../config';\nimport {\n  CoreHeader,\n  HEADER_LABEL_PROPERTIES,\n  HEADER_LABEL_PROPERTIES_MAP,\n  HEADER_TITLE_PROPERTIES,\n  HEADER_TITLE_PROPERTIES_MAP\n} from '../../header';\nimport {isSortField} from '../../sort';\nimport {FacetFieldDef, isFacetMapping} from '../../spec/facet';\nimport {contains, isEmpty, normalizeAngle, replaceAll} from '../../util';\nimport {RowCol, VgComparator, VgMarkGroup, VgTitle} from '../../vega.schema';\nimport {defaultLabelAlign, defaultLabelBaseline} from '../axis/properties';\nimport {sortArrayIndexField} from '../data/calculate';\nimport {formatSignalRef} from '../format';\nimport {isFacetModel, Model} from '../model';\nimport {getHeaderChannel, getHeaderProperties, getHeaderProperty} from './common';\nimport {\n  HeaderChannel,\n  HeaderComponent,\n  HeaderType,\n  HEADER_TYPES,\n  LayoutHeaderComponent,\n  LayoutHeaderComponentIndex\n} from './component';\n\n// TODO: rename to assembleHeaderTitleGroup\nexport function assembleTitleGroup(model: Model, channel: FacetChannel) {\n  const title = model.component.layoutHeaders[channel].title;\n  const config = model.config ? model.config : undefined;\n  const facetFieldDef = model.component.layoutHeaders[channel].facetFieldDef\n    ? model.component.layoutHeaders[channel].facetFieldDef\n    : undefined;\n\n  const {\n    titleAnchor,\n    titleAngle: ta,\n    titleOrient\n  } = getHeaderProperties(['titleAnchor', 'titleAngle', 'titleOrient'], facetFieldDef.header, config, channel);\n  const headerChannel = getHeaderChannel(channel, titleOrient);\n\n  const titleAngle = normalizeAngle(ta);\n\n  return {\n    name: `${channel}-title`,\n    type: 'group',\n    role: `${headerChannel}-title`,\n    title: {\n      text: title,\n      ...(channel === 'row' ? {orient: 'left'} : {}),\n      style: 'guide-title',\n      ...defaultHeaderGuideBaseline(titleAngle, headerChannel),\n      ...defaultHeaderGuideAlign(headerChannel, titleAngle, titleAnchor),\n      ...assembleHeaderProperties(config, facetFieldDef, channel, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP)\n    }\n  };\n}\n\nexport function defaultHeaderGuideAlign(headerChannel: HeaderChannel, angle: number, anchor: TitleAnchor = 'middle') {\n  switch (anchor) {\n    case 'start':\n      return {align: 'left'};\n    case 'end':\n      return {align: 'right'};\n  }\n\n  const align = defaultLabelAlign(angle, headerChannel === 'row' ? 'left' : 'top', headerChannel === 'row' ? 'y' : 'x');\n  return align ? {align} : {};\n}\n\nexport function defaultHeaderGuideBaseline(angle: number, channel: FacetChannel) {\n  const baseline = defaultLabelBaseline(angle, channel === 'row' ? 'left' : 'top', channel === 'row' ? 'y' : 'x', true);\n  return baseline ? {baseline} : {};\n}\n\nexport function assembleHeaderGroups(model: Model, channel: HeaderChannel): VgMarkGroup[] {\n  const layoutHeader = model.component.layoutHeaders[channel];\n  const groups = [];\n  for (const headerType of HEADER_TYPES) {\n    if (layoutHeader[headerType]) {\n      for (const headerComponent of layoutHeader[headerType]) {\n        const group = assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent);\n        if (group != null) {\n          groups.push(group);\n        }\n      }\n    }\n  }\n  return groups;\n}\n\nfunction getSort(facetFieldDef: FacetFieldDef<string>, channel: HeaderChannel): VgComparator {\n  const {sort} = facetFieldDef;\n  if (isSortField(sort)) {\n    return {\n      field: vgField(sort, {expr: 'datum'}),\n      order: sort.order ?? 'ascending'\n    };\n  } else if (isArray(sort)) {\n    return {\n      field: sortArrayIndexField(facetFieldDef, channel, {expr: 'datum'}),\n      order: 'ascending'\n    };\n  } else {\n    return {\n      field: vgField(facetFieldDef, {expr: 'datum'}),\n      order: sort ?? 'ascending'\n    };\n  }\n}\n\nexport function assembleLabelTitle(\n  facetFieldDef: FacetFieldDef<string, SignalRef>,\n  channel: FacetChannel,\n  config: Config<SignalRef>\n) {\n  const {format, formatType, labelAngle, labelAnchor, labelOrient, labelExpr} = getHeaderProperties(\n    ['format', 'formatType', 'labelAngle', 'labelAnchor', 'labelOrient', 'labelExpr'],\n    facetFieldDef.header,\n    config,\n    channel\n  );\n\n  const titleTextExpr = formatSignalRef({\n    fieldOrDatumDef: facetFieldDef,\n    format,\n    formatType,\n    expr: 'parent',\n    config\n  }).signal;\n  const headerChannel = getHeaderChannel(channel, labelOrient);\n\n  return {\n    text: {\n      signal: labelExpr\n        ? replaceAll(\n            replaceAll(labelExpr, 'datum.label', titleTextExpr),\n            'datum.value',\n            vgField(facetFieldDef, {expr: 'parent'})\n          )\n        : titleTextExpr\n    },\n    ...(channel === 'row' ? {orient: 'left'} : {}),\n    style: 'guide-label',\n    frame: 'group',\n    ...defaultHeaderGuideBaseline(labelAngle, headerChannel),\n    ...defaultHeaderGuideAlign(headerChannel, labelAngle, labelAnchor),\n    ...assembleHeaderProperties(config, facetFieldDef, channel, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP)\n  };\n}\n\nexport function assembleHeaderGroup(\n  model: Model,\n  channel: HeaderChannel,\n  headerType: HeaderType,\n  layoutHeader: LayoutHeaderComponent,\n  headerComponent: HeaderComponent\n) {\n  if (headerComponent) {\n    let title = null;\n    const {facetFieldDef} = layoutHeader;\n    const config = model.config ? model.config : undefined;\n    if (facetFieldDef && headerComponent.labels) {\n      const {labelOrient} = getHeaderProperties(['labelOrient'], facetFieldDef.header, config, channel);\n\n      // Include label title in the header if orient aligns with the channel\n      if (\n        (channel === 'row' && !contains(['top', 'bottom'], labelOrient)) ||\n        (channel === 'column' && !contains(['left', 'right'], labelOrient))\n      ) {\n        title = assembleLabelTitle(facetFieldDef, channel, config);\n      }\n    }\n\n    const isFacetWithoutRowCol = isFacetModel(model) && !isFacetMapping(model.facet);\n\n    const axes = headerComponent.axes;\n\n    const hasAxes = axes?.length > 0;\n    if (title || hasAxes) {\n      const sizeChannel = channel === 'row' ? 'height' : 'width';\n\n      return {\n        name: model.getName(`${channel}_${headerType}`),\n        type: 'group',\n        role: `${channel}-${headerType}`,\n\n        ...(layoutHeader.facetFieldDef\n          ? {\n              from: {data: model.getName(`${channel}_domain`)},\n              sort: getSort(facetFieldDef, channel)\n            }\n          : {}),\n        ...(hasAxes && isFacetWithoutRowCol\n          ? {\n              from: {data: model.getName(`facet_domain_${channel}`)}\n            }\n          : {}),\n\n        ...(title ? {title} : {}),\n        ...(headerComponent.sizeSignal\n          ? {\n              encode: {\n                update: {\n                  [sizeChannel]: headerComponent.sizeSignal\n                }\n              }\n            }\n          : {}),\n        ...(hasAxes ? {axes} : {})\n      };\n    }\n  }\n  return null;\n}\n\nconst LAYOUT_TITLE_BAND = {\n  column: {\n    start: 0,\n    end: 1\n  },\n  row: {\n    start: 1,\n    end: 0\n  }\n};\n\nexport function getLayoutTitleBand(titleAnchor: TitleAnchor, headerChannel: HeaderChannel) {\n  return LAYOUT_TITLE_BAND[headerChannel][titleAnchor];\n}\n\nexport function assembleLayoutTitleBand(\n  headerComponentIndex: LayoutHeaderComponentIndex,\n  config: Config<SignalRef>\n): RowCol<number> {\n  const titleBand = {};\n\n  for (const channel of FACET_CHANNELS) {\n    const headerComponent = headerComponentIndex[channel];\n    if (headerComponent?.facetFieldDef) {\n      const {titleAnchor, titleOrient} = getHeaderProperties(\n        ['titleAnchor', 'titleOrient'],\n        headerComponent.facetFieldDef.header,\n        config,\n        channel\n      );\n\n      const headerChannel = getHeaderChannel(channel, titleOrient);\n      const band = getLayoutTitleBand(titleAnchor, headerChannel);\n      if (band !== undefined) {\n        titleBand[headerChannel] = band;\n      }\n    }\n  }\n\n  return isEmpty(titleBand) ? undefined : titleBand;\n}\n\nexport function assembleHeaderProperties(\n  config: Config<SignalRef>,\n  facetFieldDef: FacetFieldDef<string, SignalRef>,\n  channel: FacetChannel,\n  properties: (keyof CoreHeader<SignalRef>)[],\n  propertiesMap: Partial<Record<keyof CoreHeader<SignalRef>, keyof TitleConfig>>\n): Partial<VgTitle> {\n  const props = {};\n  for (const prop of properties) {\n    if (!propertiesMap[prop]) {\n      continue;\n    }\n\n    const value = getHeaderProperty(prop, facetFieldDef?.header, config, channel);\n    if (value !== undefined) {\n      props[propertiesMap[prop]] = value;\n    }\n  }\n  return props;\n}\n"]},"metadata":{},"sourceType":"module"}