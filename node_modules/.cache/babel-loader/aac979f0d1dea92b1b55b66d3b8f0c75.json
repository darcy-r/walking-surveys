{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { vgField } from '../../channeldef';\nimport { getTimeUnitParts, normalizeTimeUnit } from '../../timeunit';\nimport { duplicate, entries, hash, isEmpty, replacePathInField, vals } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class TimeUnitNode extends DataFlowNode {\n  constructor(parent, formula) {\n    super(parent);\n    this.formula = formula;\n  }\n\n  clone() {\n    return new TimeUnitNode(null, duplicate(this.formula));\n  }\n\n  static makeFromEncoding(parent, model) {\n    const formula = model.reduceFieldDef((timeUnitComponent, fieldDef) => {\n      const {\n        field,\n        timeUnit\n      } = fieldDef;\n\n      if (timeUnit) {\n        const as = vgField(fieldDef, {\n          forAs: true\n        });\n        timeUnitComponent[hash({\n          as,\n          field,\n          timeUnit\n        })] = {\n          as,\n          field,\n          timeUnit\n        };\n      }\n\n      return timeUnitComponent;\n    }, {});\n\n    if (isEmpty(formula)) {\n      return null;\n    }\n\n    return new TimeUnitNode(parent, formula);\n  }\n\n  static makeFromTransform(parent, t) {\n    const _a = Object.assign({}, t),\n          {\n      timeUnit\n    } = _a,\n          other = __rest(_a, [\"timeUnit\"]);\n\n    const normalizedTimeUnit = normalizeTimeUnit(timeUnit);\n    const component = Object.assign(Object.assign({}, other), {\n      timeUnit: normalizedTimeUnit\n    });\n    return new TimeUnitNode(parent, {\n      [hash(component)]: component\n    });\n  }\n  /**\n   * Merge together TimeUnitNodes assigning the children of `other` to `this`\n   * and removing `other`.\n   */\n\n\n  merge(other) {\n    this.formula = Object.assign({}, this.formula); // if the same hash happen twice, merge\n\n    for (const key in other.formula) {\n      if (!this.formula[key]) {\n        // copy if it's not a duplicate\n        this.formula[key] = other.formula[key];\n      }\n    }\n\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n\n    other.remove();\n  }\n  /**\n   * Remove time units coming from the other node.\n   */\n\n\n  removeFormulas(fields) {\n    const newFormula = {};\n\n    for (const [key, timeUnit] of entries(this.formula)) {\n      if (!fields.has(timeUnit.as)) {\n        newFormula[key] = timeUnit;\n      }\n    }\n\n    this.formula = newFormula;\n  }\n\n  producedFields() {\n    return new Set(vals(this.formula).map(f => f.as));\n  }\n\n  dependentFields() {\n    return new Set(vals(this.formula).map(f => f.field));\n  }\n\n  hash() {\n    return `TimeUnit ${hash(this.formula)}`;\n  }\n\n  assemble() {\n    const transforms = [];\n\n    for (const f of vals(this.formula)) {\n      const {\n        field,\n        as,\n        timeUnit\n      } = f;\n\n      const _a = normalizeTimeUnit(timeUnit),\n            {\n        unit,\n        utc\n      } = _a,\n            params = __rest(_a, [\"unit\", \"utc\"]);\n\n      transforms.push(Object.assign(Object.assign(Object.assign(Object.assign({\n        field: replacePathInField(field),\n        type: 'timeunit'\n      }, unit ? {\n        units: getTimeUnitParts(unit)\n      } : {}), utc ? {\n        timezone: 'utc'\n      } : {}), params), {\n        as: [as, `${as}_end`]\n      }));\n    }\n\n    return transforms;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["vgField","getTimeUnitParts","normalizeTimeUnit","duplicate","entries","hash","isEmpty","replacePathInField","vals","DataFlowNode","TimeUnitNode","constructor","parent","formula","clone","makeFromEncoding","model","reduceFieldDef","timeUnitComponent","fieldDef","field","timeUnit","as","forAs","makeFromTransform","t","_a","other","normalizedTimeUnit","component","merge","Object","key","child","children","removeChild","remove","removeFormulas","fields","newFormula","has","producedFields","Set","map","f","dependentFields","assemble","transforms","unit","utc","params","push","type","units","timezone"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/data/timeunit.ts"],"sourcesContent":["import {TimeUnitTransform as VgTimeUnitTransform} from 'vega';\nimport {vgField} from '../../channeldef';\nimport {getTimeUnitParts, normalizeTimeUnit} from '../../timeunit';\nimport {TimeUnitTransform} from '../../transform';\nimport {Dict, duplicate, entries, hash, isEmpty, replacePathInField, vals} from '../../util';\nimport {ModelWithField} from '../model';\nimport {DataFlowNode} from './dataflow';\n\nexport type TimeUnitComponent = TimeUnitTransform;\n\nexport class TimeUnitNode extends DataFlowNode {\n  public clone() {\n    return new TimeUnitNode(null, duplicate(this.formula));\n  }\n\n  constructor(parent: DataFlowNode, private formula: Dict<TimeUnitComponent>) {\n    super(parent);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: ModelWithField) {\n    const formula = model.reduceFieldDef((timeUnitComponent: TimeUnitComponent, fieldDef) => {\n      const {field, timeUnit} = fieldDef;\n\n      if (timeUnit) {\n        const as = vgField(fieldDef, {forAs: true});\n        timeUnitComponent[\n          hash({\n            as,\n            field,\n            timeUnit\n          })\n        ] = {\n          as,\n          field,\n          timeUnit\n        };\n      }\n      return timeUnitComponent;\n    }, {} as Dict<TimeUnitComponent>);\n\n    if (isEmpty(formula)) {\n      return null;\n    }\n\n    return new TimeUnitNode(parent, formula);\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, t: TimeUnitTransform) {\n    const {timeUnit, ...other} = {...t};\n\n    const normalizedTimeUnit = normalizeTimeUnit(timeUnit);\n\n    const component = {\n      ...other,\n      timeUnit: normalizedTimeUnit\n    };\n\n    return new TimeUnitNode(parent, {\n      [hash(component)]: component\n    });\n  }\n\n  /**\n   * Merge together TimeUnitNodes assigning the children of `other` to `this`\n   * and removing `other`.\n   */\n  public merge(other: TimeUnitNode) {\n    this.formula = {...this.formula};\n\n    // if the same hash happen twice, merge\n    for (const key in other.formula) {\n      if (!this.formula[key]) {\n        // copy if it's not a duplicate\n        this.formula[key] = other.formula[key];\n      }\n    }\n\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n\n    other.remove();\n  }\n\n  /**\n   * Remove time units coming from the other node.\n   */\n  public removeFormulas(fields: Set<string>) {\n    const newFormula = {};\n\n    for (const [key, timeUnit] of entries(this.formula)) {\n      if (!fields.has(timeUnit.as)) {\n        newFormula[key] = timeUnit;\n      }\n    }\n\n    this.formula = newFormula;\n  }\n\n  public producedFields() {\n    return new Set(vals(this.formula).map(f => f.as));\n  }\n\n  public dependentFields() {\n    return new Set(vals(this.formula).map(f => f.field));\n  }\n\n  public hash() {\n    return `TimeUnit ${hash(this.formula)}`;\n  }\n\n  public assemble() {\n    const transforms: VgTimeUnitTransform[] = [];\n\n    for (const f of vals(this.formula)) {\n      const {field, as, timeUnit} = f;\n      const {unit, utc, ...params} = normalizeTimeUnit(timeUnit);\n\n      transforms.push({\n        field: replacePathInField(field),\n        type: 'timeunit',\n        ...(unit ? {units: getTimeUnitParts(unit)} : {}),\n        ...(utc ? {timezone: 'utc'} : {}),\n        ...params,\n        as: [as, `${as}_end`]\n      });\n    }\n\n    return transforms;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}