{"ast":null,"code":"import { parseSelector } from 'vega-event-selector';\nimport { X, Y } from '../../channel';\nimport { BRUSH as INTERVAL_BRUSH } from './interval';\nimport scalesCompiler, { domain } from './scales';\nconst ANCHOR = '_translate_anchor';\nconst DELTA = '_translate_delta';\nconst translate = {\n  defined: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.translate;\n  },\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const hasScales = scalesCompiler.defined(selCmpt);\n    const anchor = name + ANCHOR;\n    const {\n      x,\n      y\n    } = selCmpt.project.hasChannel;\n    let events = parseSelector(selCmpt.translate, 'scope');\n\n    if (!hasScales) {\n      events = events.map(e => (e.between[0].markname = name + INTERVAL_BRUSH, e));\n    }\n\n    signals.push({\n      name: anchor,\n      value: {},\n      on: [{\n        events: events.map(e => e.between[0]),\n        update: '{x: x(unit), y: y(unit)' + (x !== undefined ? `, extent_x: ${hasScales ? domain(model, X) : `slice(${x.signals.visual})`}` : '') + (y !== undefined ? `, extent_y: ${hasScales ? domain(model, Y) : `slice(${y.signals.visual})`}` : '') + '}'\n      }]\n    }, {\n      name: name + DELTA,\n      value: {},\n      on: [{\n        events,\n        update: `{x: ${anchor}.x - x(unit), y: ${anchor}.y - y(unit)}`\n      }]\n    });\n\n    if (x !== undefined) {\n      onDelta(model, selCmpt, x, 'width', signals);\n    }\n\n    if (y !== undefined) {\n      onDelta(model, selCmpt, y, 'height', signals);\n    }\n\n    return signals;\n  }\n};\nexport default translate;\n\nfunction onDelta(model, selCmpt, proj, size, signals) {\n  var _a, _b;\n\n  const name = selCmpt.name;\n  const anchor = name + ANCHOR;\n  const delta = name + DELTA;\n  const channel = proj.channel;\n  const hasScales = scalesCompiler.defined(selCmpt);\n  const signal = signals.filter(s => s.name === proj.signals[hasScales ? 'data' : 'visual'])[0];\n  const sizeSg = model.getSizeSignalRef(size).signal;\n  const scaleCmpt = model.getScaleComponent(channel);\n  const scaleType = scaleCmpt.get('type');\n  const reversed = scaleCmpt.get('reverse'); // scale parsing sets this flag for fieldDef.sort\n\n  const sign = !hasScales ? '' : channel === X ? reversed ? '' : '-' : reversed ? '-' : '';\n  const extent = `${anchor}.extent_${channel}`;\n  const offset = `${sign}${delta}.${channel} / ${hasScales ? `${sizeSg}` : `span(${extent})`}`;\n  const panFn = !hasScales ? 'panLinear' : scaleType === 'log' ? 'panLog' : scaleType === 'symlog' ? 'panSymlog' : scaleType === 'pow' ? 'panPow' : 'panLinear';\n  const arg = !hasScales ? '' : scaleType === 'pow' ? `, ${(_a = scaleCmpt.get('exponent')) !== null && _a !== void 0 ? _a : 1}` : scaleType === 'symlog' ? `, ${(_b = scaleCmpt.get('constant')) !== null && _b !== void 0 ? _b : 1}` : '';\n  const update = `${panFn}(${extent}, ${offset}${arg})`;\n  signal.on.push({\n    events: {\n      signal: delta\n    },\n    update: hasScales ? update : `clampRange(${update}, 0, ${sizeSg})`\n  });\n}","map":{"version":3,"mappings":"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","names":["parseSelector","X","Y","BRUSH","INTERVAL_BRUSH","scalesCompiler","domain","ANCHOR","DELTA","translate","defined","selCmpt","type","signals","model","name","hasScales","anchor","x","y","project","hasChannel","events","map","e","between","markname","push","value","on","update","undefined","visual","onDelta","proj","size","delta","channel","signal","filter","s","sizeSg","getSizeSignalRef","scaleCmpt","getScaleComponent","scaleType","get","reversed","sign","extent","offset","panFn","arg","_a","_b"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/selection/translate.ts"],"sourcesContent":["import {NewSignal} from 'vega';\nimport {parseSelector} from 'vega-event-selector';\nimport {SelectionComponent} from '.';\nimport {ScaleChannel, X, Y} from '../../channel';\nimport {UnitModel} from '../unit';\nimport {BRUSH as INTERVAL_BRUSH} from './interval';\nimport {SelectionProjection} from './project';\nimport scalesCompiler, {domain} from './scales';\nimport {SelectionCompiler} from '.';\n\nconst ANCHOR = '_translate_anchor';\nconst DELTA = '_translate_delta';\n\nconst translate: SelectionCompiler<'interval'> = {\n  defined: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.translate;\n  },\n\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const hasScales = scalesCompiler.defined(selCmpt);\n    const anchor = name + ANCHOR;\n    const {x, y} = selCmpt.project.hasChannel;\n    let events = parseSelector(selCmpt.translate, 'scope');\n\n    if (!hasScales) {\n      events = events.map(e => ((e.between[0].markname = name + INTERVAL_BRUSH), e));\n    }\n\n    signals.push(\n      {\n        name: anchor,\n        value: {},\n        on: [\n          {\n            events: events.map(e => e.between[0]),\n            update:\n              '{x: x(unit), y: y(unit)' +\n              (x !== undefined ? `, extent_x: ${hasScales ? domain(model, X) : `slice(${x.signals.visual})`}` : '') +\n              (y !== undefined ? `, extent_y: ${hasScales ? domain(model, Y) : `slice(${y.signals.visual})`}` : '') +\n              '}'\n          }\n        ]\n      },\n      {\n        name: name + DELTA,\n        value: {},\n        on: [\n          {\n            events,\n            update: `{x: ${anchor}.x - x(unit), y: ${anchor}.y - y(unit)}`\n          }\n        ]\n      }\n    );\n\n    if (x !== undefined) {\n      onDelta(model, selCmpt, x, 'width', signals);\n    }\n\n    if (y !== undefined) {\n      onDelta(model, selCmpt, y, 'height', signals);\n    }\n\n    return signals;\n  }\n};\n\nexport default translate;\n\nfunction onDelta(\n  model: UnitModel,\n  selCmpt: SelectionComponent,\n  proj: SelectionProjection,\n  size: 'width' | 'height',\n  signals: NewSignal[]\n) {\n  const name = selCmpt.name;\n  const anchor = name + ANCHOR;\n  const delta = name + DELTA;\n  const channel = proj.channel as ScaleChannel;\n  const hasScales = scalesCompiler.defined(selCmpt);\n  const signal = signals.filter(s => s.name === proj.signals[hasScales ? 'data' : 'visual'])[0];\n  const sizeSg = model.getSizeSignalRef(size).signal;\n  const scaleCmpt = model.getScaleComponent(channel);\n  const scaleType = scaleCmpt.get('type');\n  const reversed = scaleCmpt.get('reverse'); // scale parsing sets this flag for fieldDef.sort\n  const sign = !hasScales ? '' : channel === X ? (reversed ? '' : '-') : reversed ? '-' : '';\n  const extent = `${anchor}.extent_${channel}`;\n  const offset = `${sign}${delta}.${channel} / ${hasScales ? `${sizeSg}` : `span(${extent})`}`;\n  const panFn = !hasScales\n    ? 'panLinear'\n    : scaleType === 'log'\n    ? 'panLog'\n    : scaleType === 'symlog'\n    ? 'panSymlog'\n    : scaleType === 'pow'\n    ? 'panPow'\n    : 'panLinear';\n  const arg = !hasScales\n    ? ''\n    : scaleType === 'pow'\n    ? `, ${scaleCmpt.get('exponent') ?? 1}`\n    : scaleType === 'symlog'\n    ? `, ${scaleCmpt.get('constant') ?? 1}`\n    : '';\n  const update = `${panFn}(${extent}, ${offset}${arg})`;\n\n  signal.on.push({\n    events: {signal: delta},\n    update: hasScales ? update : `clampRange(${update}, 0, ${sizeSg})`\n  });\n}\n"]},"metadata":{},"sourceType":"module"}