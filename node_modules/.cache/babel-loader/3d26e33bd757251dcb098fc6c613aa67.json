{"ast":null,"code":"import { array, isBoolean } from 'vega-util';\nimport { SUM_OPS } from './aggregate';\nimport { getSecondaryRangeChannel, NONPOSITION_CHANNELS } from './channel';\nimport { channelDefType, getFieldDef, isFieldDef, isFieldOrDatumDef, vgField } from './channeldef';\nimport { channelHasField, isAggregate } from './encoding';\nimport * as log from './log';\nimport { ARC, AREA, BAR, CIRCLE, isMarkDef, isPathMark, LINE, POINT, RULE, SQUARE, TEXT, TICK } from './mark';\nimport { ScaleType } from './scale';\nconst STACK_OFFSET_INDEX = {\n  zero: 1,\n  center: 1,\n  normalize: 1\n};\nexport function isStackOffset(s) {\n  return s in STACK_OFFSET_INDEX;\n}\nexport const STACKABLE_MARKS = new Set([ARC, BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK]);\nexport const STACK_BY_DEFAULT_MARKS = new Set([BAR, AREA, ARC]);\n\nfunction isUnbinnedQuantitative(channelDef) {\n  return isFieldDef(channelDef) && channelDefType(channelDef) === 'quantitative' && !channelDef.bin;\n}\n\nfunction potentialStackedChannel(encoding, x) {\n  var _a, _b;\n\n  const y = x === 'x' ? 'y' : 'radius';\n  const xDef = encoding[x];\n  const yDef = encoding[y];\n\n  if (isFieldDef(xDef) && isFieldDef(yDef)) {\n    if (isUnbinnedQuantitative(xDef) && isUnbinnedQuantitative(yDef)) {\n      if (xDef.stack) {\n        return x;\n      } else if (yDef.stack) {\n        return y;\n      }\n\n      const xAggregate = isFieldDef(xDef) && !!xDef.aggregate;\n      const yAggregate = isFieldDef(yDef) && !!yDef.aggregate; // if there is no explicit stacking, only apply stack if there is only one aggregate for x or y\n\n      if (xAggregate !== yAggregate) {\n        return xAggregate ? x : y;\n      } else {\n        const xScale = (_a = xDef.scale) === null || _a === void 0 ? void 0 : _a.type;\n        const yScale = (_b = yDef.scale) === null || _b === void 0 ? void 0 : _b.type;\n\n        if (xScale && xScale !== 'linear') {\n          return y;\n        } else if (yScale && yScale !== 'linear') {\n          return x;\n        }\n      }\n    } else if (isUnbinnedQuantitative(xDef)) {\n      return x;\n    } else if (isUnbinnedQuantitative(yDef)) {\n      return y;\n    }\n  } else if (isUnbinnedQuantitative(xDef)) {\n    return x;\n  } else if (isUnbinnedQuantitative(yDef)) {\n    return y;\n  }\n\n  return undefined;\n}\n\nfunction getDimensionChannel(channel) {\n  switch (channel) {\n    case 'x':\n      return 'y';\n\n    case 'y':\n      return 'x';\n\n    case 'theta':\n      return 'radius';\n\n    case 'radius':\n      return 'theta';\n  }\n} // Note: CompassQL uses this method and only pass in required properties of each argument object.\n// If required properties change, make sure to update CompassQL.\n\n\nexport function stack(m, encoding) {\n  let opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a, _b;\n\n  const mark = isMarkDef(m) ? m.type : m; // Should have stackable mark\n\n  if (!STACKABLE_MARKS.has(mark)) {\n    return null;\n  } // Run potential stacked twice, one for Cartesian and another for Polar,\n  // so text marks can be stacked in any of the coordinates.\n  // Note: The logic here is not perfectly correct.  If we want to support stacked dot plots where each dot is a pie chart with label, we have to change the stack logic here to separate Cartesian stacking for polar stacking.\n  // However, since we probably never want to do that, let's just note the limitation here.\n\n\n  const fieldChannel = potentialStackedChannel(encoding, 'x') || potentialStackedChannel(encoding, 'theta');\n\n  if (!fieldChannel) {\n    return null;\n  }\n\n  const stackedFieldDef = encoding[fieldChannel];\n  const stackedField = isFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : undefined;\n  const dimensionChannel = getDimensionChannel(fieldChannel);\n  const groupbyChannels = [];\n  const groupbyFields = new Set();\n\n  if (encoding[dimensionChannel]) {\n    const dimensionDef = encoding[dimensionChannel];\n    const dimensionField = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : undefined;\n\n    if (dimensionField && dimensionField !== stackedField) {\n      // avoid grouping by the stacked field\n      groupbyChannels.push(dimensionChannel);\n      groupbyFields.add(dimensionField);\n    }\n\n    const dimensionOffsetChannel = dimensionChannel === 'x' ? 'xOffset' : 'yOffset';\n    const dimensionOffsetDef = encoding[dimensionOffsetChannel];\n    const dimensionOffsetField = isFieldDef(dimensionOffsetDef) ? vgField(dimensionOffsetDef, {}) : undefined;\n\n    if (dimensionOffsetField && dimensionOffsetField !== stackedField) {\n      // avoid grouping by the stacked field\n      groupbyChannels.push(dimensionOffsetChannel);\n      groupbyFields.add(dimensionOffsetField);\n    }\n  } // If the dimension has offset, don't stack anymore\n  // Should have grouping level of detail that is different from the dimension field\n\n\n  const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {\n    // Ignore tooltip in stackBy (https://github.com/vega/vega-lite/issues/4001)\n    if (channel !== 'tooltip' && channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n\n      for (const cDef of array(channelDef)) {\n        const fieldDef = getFieldDef(cDef);\n\n        if (fieldDef.aggregate) {\n          continue;\n        } // Check whether the channel's field is identical to x/y's field or if the channel is a repeat\n\n\n        const f = vgField(fieldDef, {});\n\n        if ( // if fielddef is a repeat, just include it in the stack by\n        !f || // otherwise, the field must be different from the groupBy fields.\n        !groupbyFields.has(f)) {\n          sc.push({\n            channel,\n            fieldDef\n          });\n        }\n      }\n    }\n\n    return sc;\n  }, []); // Automatically determine offset\n\n  let offset;\n\n  if (stackedFieldDef.stack !== undefined) {\n    if (isBoolean(stackedFieldDef.stack)) {\n      offset = stackedFieldDef.stack ? 'zero' : null;\n    } else {\n      offset = stackedFieldDef.stack;\n    }\n  } else if (STACK_BY_DEFAULT_MARKS.has(mark)) {\n    offset = 'zero';\n  }\n\n  if (!offset || !isStackOffset(offset)) {\n    return null;\n  }\n\n  if (isAggregate(encoding) && stackBy.length === 0) {\n    return null;\n  } // warn when stacking non-linear\n\n\n  if (((_a = stackedFieldDef === null || stackedFieldDef === void 0 ? void 0 : stackedFieldDef.scale) === null || _a === void 0 ? void 0 : _a.type) && ((_b = stackedFieldDef === null || stackedFieldDef === void 0 ? void 0 : stackedFieldDef.scale) === null || _b === void 0 ? void 0 : _b.type) !== ScaleType.LINEAR) {\n    if (opt.disallowNonLinearStack) {\n      return null;\n    } else {\n      log.warn(log.message.cannotStackNonLinearScale(stackedFieldDef.scale.type));\n    }\n  } // Check if it is a ranged mark\n\n\n  if (isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)])) {\n    if (stackedFieldDef.stack !== undefined) {\n      log.warn(log.message.cannotStackRangedMark(fieldChannel));\n    }\n\n    return null;\n  } // Warn if stacking non-summative aggregate\n\n\n  if (isFieldDef(stackedFieldDef) && stackedFieldDef.aggregate && !SUM_OPS.has(stackedFieldDef.aggregate)) {\n    log.warn(log.message.stackNonSummativeAggregate(stackedFieldDef.aggregate));\n  }\n\n  return {\n    groupbyChannels,\n    groupbyFields,\n    fieldChannel,\n    impute: stackedFieldDef.impute === null ? false : isPathMark(mark),\n    stackBy,\n    offset\n  };\n}","map":{"version":3,"mappings":"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","names":["array","isBoolean","SUM_OPS","getSecondaryRangeChannel","NONPOSITION_CHANNELS","channelDefType","getFieldDef","isFieldDef","isFieldOrDatumDef","vgField","channelHasField","isAggregate","log","ARC","AREA","BAR","CIRCLE","isMarkDef","isPathMark","LINE","POINT","RULE","SQUARE","TEXT","TICK","ScaleType","STACK_OFFSET_INDEX","zero","center","normalize","isStackOffset","s","STACKABLE_MARKS","Set","STACK_BY_DEFAULT_MARKS","isUnbinnedQuantitative","channelDef","bin","potentialStackedChannel","encoding","x","y","xDef","yDef","stack","xAggregate","aggregate","yAggregate","xScale","scale","_a","type","yScale","_b","undefined","getDimensionChannel","channel","m","opt","mark","has","fieldChannel","stackedFieldDef","stackedField","dimensionChannel","groupbyChannels","groupbyFields","dimensionDef","dimensionField","push","add","dimensionOffsetChannel","dimensionOffsetDef","dimensionOffsetField","stackBy","reduce","sc","cDef","fieldDef","f","offset","length","LINEAR","disallowNonLinearStack","warn","message","cannotStackNonLinearScale","cannotStackRangedMark","stackNonSummativeAggregate","impute"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/stack.ts"],"sourcesContent":["import {array, isBoolean} from 'vega-util';\nimport {Aggregate, SUM_OPS} from './aggregate';\nimport {getSecondaryRangeChannel, NonPositionChannel, NONPOSITION_CHANNELS} from './channel';\nimport {\n  channelDefType,\n  FieldName,\n  getFieldDef,\n  isFieldDef,\n  isFieldOrDatumDef,\n  PositionDatumDef,\n  PositionDef,\n  PositionFieldDef,\n  TypedFieldDef,\n  vgField\n} from './channeldef';\nimport {CompositeAggregate} from './compositemark';\nimport {channelHasField, Encoding, isAggregate} from './encoding';\nimport * as log from './log';\nimport {\n  ARC,\n  AREA,\n  BAR,\n  CIRCLE,\n  isMarkDef,\n  isPathMark,\n  LINE,\n  Mark,\n  MarkDef,\n  POINT,\n  RULE,\n  SQUARE,\n  TEXT,\n  TICK\n} from './mark';\nimport {ScaleType} from './scale';\n\nconst STACK_OFFSET_INDEX = {\n  zero: 1,\n  center: 1,\n  normalize: 1\n} as const;\n\nexport type StackOffset = keyof typeof STACK_OFFSET_INDEX;\n\nexport function isStackOffset(s: string): s is StackOffset {\n  return s in STACK_OFFSET_INDEX;\n}\n\nexport interface StackProperties {\n  /** Dimension axis of the stack. */\n  groupbyChannels: ('x' | 'y' | 'theta' | 'radius' | 'xOffset' | 'yOffset')[];\n\n  /** Field for groupbyChannel. */\n  groupbyFields: Set<FieldName>;\n\n  /** Measure axis of the stack. */\n  fieldChannel: 'x' | 'y' | 'theta' | 'radius';\n\n  /** Stack-by fields e.g., color, detail */\n  stackBy: {\n    fieldDef: TypedFieldDef<string>;\n    channel: NonPositionChannel;\n  }[];\n\n  /**\n   * See `stack` property of Position Field Def.\n   */\n  offset: StackOffset;\n\n  /**\n   * Whether this stack will produce impute transform\n   */\n  impute: boolean;\n}\n\nexport const STACKABLE_MARKS = new Set<Mark>([ARC, BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK]);\nexport const STACK_BY_DEFAULT_MARKS = new Set<Mark>([BAR, AREA, ARC]);\n\nfunction isUnbinnedQuantitative(channelDef: PositionDef<string>) {\n  return isFieldDef(channelDef) && channelDefType(channelDef) === 'quantitative' && !channelDef.bin;\n}\n\nfunction potentialStackedChannel(\n  encoding: Encoding<string>,\n  x: 'x' | 'theta'\n): 'x' | 'y' | 'theta' | 'radius' | undefined {\n  const y = x === 'x' ? 'y' : 'radius';\n\n  const xDef = encoding[x];\n  const yDef = encoding[y];\n\n  if (isFieldDef(xDef) && isFieldDef(yDef)) {\n    if (isUnbinnedQuantitative(xDef) && isUnbinnedQuantitative(yDef)) {\n      if (xDef.stack) {\n        return x;\n      } else if (yDef.stack) {\n        return y;\n      }\n      const xAggregate = isFieldDef(xDef) && !!xDef.aggregate;\n      const yAggregate = isFieldDef(yDef) && !!yDef.aggregate;\n      // if there is no explicit stacking, only apply stack if there is only one aggregate for x or y\n      if (xAggregate !== yAggregate) {\n        return xAggregate ? x : y;\n      } else {\n        const xScale = xDef.scale?.type;\n        const yScale = yDef.scale?.type;\n\n        if (xScale && xScale !== 'linear') {\n          return y;\n        } else if (yScale && yScale !== 'linear') {\n          return x;\n        }\n      }\n    } else if (isUnbinnedQuantitative(xDef)) {\n      return x;\n    } else if (isUnbinnedQuantitative(yDef)) {\n      return y;\n    }\n  } else if (isUnbinnedQuantitative(xDef)) {\n    return x;\n  } else if (isUnbinnedQuantitative(yDef)) {\n    return y;\n  }\n  return undefined;\n}\n\nfunction getDimensionChannel(channel: 'x' | 'y' | 'theta' | 'radius') {\n  switch (channel) {\n    case 'x':\n      return 'y';\n    case 'y':\n      return 'x';\n    case 'theta':\n      return 'radius';\n    case 'radius':\n      return 'theta';\n  }\n}\n\n// Note: CompassQL uses this method and only pass in required properties of each argument object.\n// If required properties change, make sure to update CompassQL.\nexport function stack(\n  m: Mark | MarkDef,\n  encoding: Encoding<string>,\n  opt: {\n    disallowNonLinearStack?: boolean; // This option is for CompassQL\n  } = {}\n): StackProperties {\n  const mark = isMarkDef(m) ? m.type : m;\n  // Should have stackable mark\n  if (!STACKABLE_MARKS.has(mark)) {\n    return null;\n  }\n\n  // Run potential stacked twice, one for Cartesian and another for Polar,\n  // so text marks can be stacked in any of the coordinates.\n\n  // Note: The logic here is not perfectly correct.  If we want to support stacked dot plots where each dot is a pie chart with label, we have to change the stack logic here to separate Cartesian stacking for polar stacking.\n  // However, since we probably never want to do that, let's just note the limitation here.\n  const fieldChannel = potentialStackedChannel(encoding, 'x') || potentialStackedChannel(encoding, 'theta');\n\n  if (!fieldChannel) {\n    return null;\n  }\n\n  const stackedFieldDef = encoding[fieldChannel] as PositionFieldDef<string> | PositionDatumDef<string>;\n  const stackedField = isFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : undefined;\n\n  const dimensionChannel: 'x' | 'y' | 'theta' | 'radius' = getDimensionChannel(fieldChannel);\n  const groupbyChannels: StackProperties['groupbyChannels'] = [];\n  const groupbyFields: Set<FieldName> = new Set();\n\n  if (encoding[dimensionChannel]) {\n    const dimensionDef = encoding[dimensionChannel];\n    const dimensionField = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : undefined;\n\n    if (dimensionField && dimensionField !== stackedField) {\n      // avoid grouping by the stacked field\n      groupbyChannels.push(dimensionChannel);\n      groupbyFields.add(dimensionField);\n    }\n\n    const dimensionOffsetChannel = dimensionChannel === 'x' ? 'xOffset' : 'yOffset';\n    const dimensionOffsetDef = encoding[dimensionOffsetChannel];\n    const dimensionOffsetField = isFieldDef(dimensionOffsetDef) ? vgField(dimensionOffsetDef, {}) : undefined;\n\n    if (dimensionOffsetField && dimensionOffsetField !== stackedField) {\n      // avoid grouping by the stacked field\n      groupbyChannels.push(dimensionOffsetChannel);\n      groupbyFields.add(dimensionOffsetField);\n    }\n  }\n\n  // If the dimension has offset, don't stack anymore\n\n  // Should have grouping level of detail that is different from the dimension field\n  const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {\n    // Ignore tooltip in stackBy (https://github.com/vega/vega-lite/issues/4001)\n    if (channel !== 'tooltip' && channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      for (const cDef of array(channelDef)) {\n        const fieldDef = getFieldDef(cDef);\n        if (fieldDef.aggregate) {\n          continue;\n        }\n\n        // Check whether the channel's field is identical to x/y's field or if the channel is a repeat\n        const f = vgField(fieldDef, {});\n        if (\n          // if fielddef is a repeat, just include it in the stack by\n          !f ||\n          // otherwise, the field must be different from the groupBy fields.\n          !groupbyFields.has(f)\n        ) {\n          sc.push({channel, fieldDef});\n        }\n      }\n    }\n    return sc;\n  }, []);\n\n  // Automatically determine offset\n  let offset: StackOffset;\n  if (stackedFieldDef.stack !== undefined) {\n    if (isBoolean(stackedFieldDef.stack)) {\n      offset = stackedFieldDef.stack ? 'zero' : null;\n    } else {\n      offset = stackedFieldDef.stack;\n    }\n  } else if (STACK_BY_DEFAULT_MARKS.has(mark)) {\n    offset = 'zero';\n  }\n\n  if (!offset || !isStackOffset(offset)) {\n    return null;\n  }\n\n  if (isAggregate(encoding) && stackBy.length === 0) {\n    return null;\n  }\n\n  // warn when stacking non-linear\n  if (stackedFieldDef?.scale?.type && stackedFieldDef?.scale?.type !== ScaleType.LINEAR) {\n    if (opt.disallowNonLinearStack) {\n      return null;\n    } else {\n      log.warn(log.message.cannotStackNonLinearScale(stackedFieldDef.scale.type));\n    }\n  }\n\n  // Check if it is a ranged mark\n  if (isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)])) {\n    if (stackedFieldDef.stack !== undefined) {\n      log.warn(log.message.cannotStackRangedMark(fieldChannel));\n    }\n    return null;\n  }\n\n  // Warn if stacking non-summative aggregate\n  if (\n    isFieldDef(stackedFieldDef) &&\n    stackedFieldDef.aggregate &&\n    !(SUM_OPS as Set<Aggregate | CompositeAggregate>).has(stackedFieldDef.aggregate)\n  ) {\n    log.warn(log.message.stackNonSummativeAggregate(stackedFieldDef.aggregate));\n  }\n\n  return {\n    groupbyChannels,\n    groupbyFields,\n    fieldChannel,\n    impute: stackedFieldDef.impute === null ? false : isPathMark(mark),\n    stackBy,\n    offset\n  };\n}\n"]},"metadata":{},"sourceType":"module"}