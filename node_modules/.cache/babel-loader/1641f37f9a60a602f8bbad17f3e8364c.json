{"ast":null,"code":"import { isUrlData } from '../../data';\nimport { AggregateNode } from './aggregate';\nimport { BinNode } from './bin';\nimport { CalculateNode } from './calculate';\nimport { OutputNode } from './dataflow';\nimport { DensityTransformNode } from './density';\nimport { FacetNode } from './facet';\nimport { FilterNode } from './filter';\nimport { FilterInvalidNode } from './filterinvalid';\nimport { FlattenTransformNode } from './flatten';\nimport { FoldTransformNode } from './fold';\nimport { ParseNode } from './formatparse';\nimport { GeoJSONNode } from './geojson';\nimport { GeoPointNode } from './geopoint';\nimport { GraticuleNode } from './graticule';\nimport { IdentifierNode } from './identifier';\nimport { ImputeNode } from './impute';\nimport { JoinAggregateTransformNode } from './joinaggregate';\nimport { LoessTransformNode } from './loess';\nimport { LookupNode } from './lookup';\nimport { QuantileTransformNode } from './quantile';\nimport { RegressionTransformNode } from './regression';\nimport { PivotTransformNode } from './pivot';\nimport { SampleTransformNode } from './sample';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\nimport { StackNode } from './stack';\nimport { TimeUnitNode } from './timeunit';\nimport { WindowTransformNode } from './window';\n\nfunction makeWalkTree(data) {\n  // to name datasources\n  let datasetIndex = 0;\n  /**\n   * Recursively walk down the tree.\n   */\n\n  function walkTree(node, dataSource) {\n    var _a;\n\n    if (node instanceof SourceNode) {\n      // If the source is a named data source or a data source with values, we need\n      // to put it in a different data source. Otherwise, Vega may override the data.\n      if (!node.isGenerator && !isUrlData(node.data)) {\n        data.push(dataSource);\n        const newData = {\n          name: null,\n          source: dataSource.name,\n          transform: []\n        };\n        dataSource = newData;\n      }\n    }\n\n    if (node instanceof ParseNode) {\n      if (node.parent instanceof SourceNode && !dataSource.source) {\n        // If node's parent is a root source and the data source does not refer to another data source, use normal format parse\n        dataSource.format = Object.assign(Object.assign({}, (_a = dataSource.format) !== null && _a !== void 0 ? _a : {}), {\n          parse: node.assembleFormatParse()\n        }); // add calculates for all nested fields\n\n        dataSource.transform.push(...node.assembleTransforms(true));\n      } else {\n        // Otherwise use Vega expression to parse\n        dataSource.transform.push(...node.assembleTransforms());\n      }\n    }\n\n    if (node instanceof FacetNode) {\n      if (!dataSource.name) {\n        dataSource.name = `data_${datasetIndex++}`;\n      }\n\n      if (!dataSource.source || dataSource.transform.length > 0) {\n        data.push(dataSource);\n        node.data = dataSource.name;\n      } else {\n        node.data = dataSource.source;\n      }\n\n      data.push(...node.assemble()); // break here because the rest of the tree has to be taken care of by the facet.\n\n      return;\n    }\n\n    if (node instanceof GraticuleNode || node instanceof SequenceNode || node instanceof FilterInvalidNode || node instanceof FilterNode || node instanceof CalculateNode || node instanceof GeoPointNode || node instanceof AggregateNode || node instanceof LookupNode || node instanceof WindowTransformNode || node instanceof JoinAggregateTransformNode || node instanceof FoldTransformNode || node instanceof FlattenTransformNode || node instanceof DensityTransformNode || node instanceof LoessTransformNode || node instanceof QuantileTransformNode || node instanceof RegressionTransformNode || node instanceof IdentifierNode || node instanceof SampleTransformNode || node instanceof PivotTransformNode) {\n      dataSource.transform.push(node.assemble());\n    }\n\n    if (node instanceof BinNode || node instanceof TimeUnitNode || node instanceof ImputeNode || node instanceof StackNode || node instanceof GeoJSONNode) {\n      dataSource.transform.push(...node.assemble());\n    }\n\n    if (node instanceof OutputNode) {\n      if (dataSource.source && dataSource.transform.length === 0) {\n        node.setSource(dataSource.source);\n      } else if (node.parent instanceof OutputNode) {\n        // Note that an output node may be required but we still do not assemble a\n        // separate data source for it.\n        node.setSource(dataSource.name);\n      } else {\n        if (!dataSource.name) {\n          dataSource.name = `data_${datasetIndex++}`;\n        } // Here we set the name of the datasource we generated. From now on\n        // other assemblers can use it.\n\n\n        node.setSource(dataSource.name); // if this node has more than one child, we will add a datasource automatically\n\n        if (node.numChildren() === 1) {\n          data.push(dataSource);\n          const newData = {\n            name: null,\n            source: dataSource.name,\n            transform: []\n          };\n          dataSource = newData;\n        }\n      }\n    }\n\n    switch (node.numChildren()) {\n      case 0:\n        // done\n        if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {\n          // do not push empty datasources that are simply references\n          data.push(dataSource);\n        }\n\n        break;\n\n      case 1:\n        walkTree(node.children[0], dataSource);\n        break;\n\n      default:\n        {\n          if (!dataSource.name) {\n            dataSource.name = `data_${datasetIndex++}`;\n          }\n\n          let source = dataSource.name;\n\n          if (!dataSource.source || dataSource.transform.length > 0) {\n            data.push(dataSource);\n          } else {\n            source = dataSource.source;\n          }\n\n          for (const child of node.children) {\n            const newData = {\n              name: null,\n              source,\n              transform: []\n            };\n            walkTree(child, newData);\n          }\n\n          break;\n        }\n    }\n  }\n\n  return walkTree;\n}\n/**\n * Assemble data sources that are derived from faceted data.\n */\n\n\nexport function assembleFacetData(root) {\n  const data = [];\n  const walkTree = makeWalkTree(data);\n\n  for (const child of root.children) {\n    walkTree(child, {\n      source: root.name,\n      name: null,\n      transform: []\n    });\n  }\n\n  return data;\n}\n/**\n * Create Vega data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\n\nexport function assembleRootData(dataComponent, datasets) {\n  var _a, _b;\n\n  const data = []; // dataComponent.sources.forEach(debug);\n  // draw(dataComponent.sources);\n\n  const walkTree = makeWalkTree(data);\n  let sourceIndex = 0;\n\n  for (const root of dataComponent.sources) {\n    // assign a name if the source does not have a name yet\n    if (!root.hasName()) {\n      root.dataName = `source_${sourceIndex++}`;\n    }\n\n    const newData = root.assemble();\n    walkTree(root, newData);\n  } // remove empty transform arrays for cleaner output\n\n\n  for (const d of data) {\n    if (d.transform.length === 0) {\n      delete d.transform;\n    }\n  } // move sources without transforms (the ones that are potentially used in lookups) to the beginning\n\n\n  let whereTo = 0;\n\n  for (const [i, d] of data.entries()) {\n    if (((_a = d.transform) !== null && _a !== void 0 ? _a : []).length === 0 && !d.source) {\n      data.splice(whereTo++, 0, data.splice(i, 1)[0]);\n    }\n  } // now fix the from references in lookup transforms\n\n\n  for (const d of data) {\n    for (const t of (_b = d.transform) !== null && _b !== void 0 ? _b : []) {\n      if (t.type === 'lookup') {\n        t.from = dataComponent.outputNodes[t.from].getSource();\n      }\n    }\n  } // inline values for datasets that are in the datastore\n\n\n  for (const d of data) {\n    if (d.name in datasets) {\n      d.values = datasets[d.name];\n    }\n  }\n\n  return data;\n}","map":{"version":3,"mappings":"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","names":["isUrlData","AggregateNode","BinNode","CalculateNode","OutputNode","DensityTransformNode","FacetNode","FilterNode","FilterInvalidNode","FlattenTransformNode","FoldTransformNode","ParseNode","GeoJSONNode","GeoPointNode","GraticuleNode","IdentifierNode","ImputeNode","JoinAggregateTransformNode","LoessTransformNode","LookupNode","QuantileTransformNode","RegressionTransformNode","PivotTransformNode","SampleTransformNode","SequenceNode","SourceNode","StackNode","TimeUnitNode","WindowTransformNode","makeWalkTree","data","datasetIndex","walkTree","node","dataSource","isGenerator","push","newData","name","source","transform","parent","format","Object","_a","parse","assembleFormatParse","assembleTransforms","length","assemble","setSource","numChildren","children","child","assembleFacetData","root","assembleRootData","dataComponent","datasets","sourceIndex","sources","hasName","dataName","d","whereTo","i","entries","splice","t","_b","type","from","outputNodes","getSource","values"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/data/assemble.ts"],"sourcesContent":["import {InlineDataset, isUrlData} from '../../data';\nimport {Dict} from '../../util';\nimport {VgData} from '../../vega.schema';\nimport {DataComponent} from './';\nimport {AggregateNode} from './aggregate';\nimport {BinNode} from './bin';\nimport {CalculateNode} from './calculate';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {DensityTransformNode} from './density';\nimport {FacetNode} from './facet';\nimport {FilterNode} from './filter';\nimport {FilterInvalidNode} from './filterinvalid';\nimport {FlattenTransformNode} from './flatten';\nimport {FoldTransformNode} from './fold';\nimport {ParseNode} from './formatparse';\nimport {GeoJSONNode} from './geojson';\nimport {GeoPointNode} from './geopoint';\nimport {GraticuleNode} from './graticule';\nimport {IdentifierNode} from './identifier';\nimport {ImputeNode} from './impute';\nimport {JoinAggregateTransformNode} from './joinaggregate';\nimport {LoessTransformNode} from './loess';\nimport {LookupNode} from './lookup';\nimport {QuantileTransformNode} from './quantile';\nimport {RegressionTransformNode} from './regression';\nimport {PivotTransformNode} from './pivot';\nimport {SampleTransformNode} from './sample';\nimport {SequenceNode} from './sequence';\nimport {SourceNode} from './source';\nimport {StackNode} from './stack';\nimport {TimeUnitNode} from './timeunit';\nimport {WindowTransformNode} from './window';\n\nfunction makeWalkTree(data: VgData[]) {\n  // to name datasources\n  let datasetIndex = 0;\n\n  /**\n   * Recursively walk down the tree.\n   */\n  function walkTree(node: DataFlowNode, dataSource: VgData) {\n    if (node instanceof SourceNode) {\n      // If the source is a named data source or a data source with values, we need\n      // to put it in a different data source. Otherwise, Vega may override the data.\n      if (!node.isGenerator && !isUrlData(node.data)) {\n        data.push(dataSource);\n        const newData: VgData = {\n          name: null,\n          source: dataSource.name,\n          transform: []\n        };\n        dataSource = newData;\n      }\n    }\n\n    if (node instanceof ParseNode) {\n      if (node.parent instanceof SourceNode && !dataSource.source) {\n        // If node's parent is a root source and the data source does not refer to another data source, use normal format parse\n        dataSource.format = {\n          ...(dataSource.format ?? {}),\n          parse: node.assembleFormatParse()\n        };\n\n        // add calculates for all nested fields\n        dataSource.transform.push(...node.assembleTransforms(true));\n      } else {\n        // Otherwise use Vega expression to parse\n        dataSource.transform.push(...node.assembleTransforms());\n      }\n    }\n\n    if (node instanceof FacetNode) {\n      if (!dataSource.name) {\n        dataSource.name = `data_${datasetIndex++}`;\n      }\n\n      if (!dataSource.source || dataSource.transform.length > 0) {\n        data.push(dataSource);\n        node.data = dataSource.name;\n      } else {\n        node.data = dataSource.source;\n      }\n\n      data.push(...node.assemble());\n\n      // break here because the rest of the tree has to be taken care of by the facet.\n      return;\n    }\n\n    if (\n      node instanceof GraticuleNode ||\n      node instanceof SequenceNode ||\n      node instanceof FilterInvalidNode ||\n      node instanceof FilterNode ||\n      node instanceof CalculateNode ||\n      node instanceof GeoPointNode ||\n      node instanceof AggregateNode ||\n      node instanceof LookupNode ||\n      node instanceof WindowTransformNode ||\n      node instanceof JoinAggregateTransformNode ||\n      node instanceof FoldTransformNode ||\n      node instanceof FlattenTransformNode ||\n      node instanceof DensityTransformNode ||\n      node instanceof LoessTransformNode ||\n      node instanceof QuantileTransformNode ||\n      node instanceof RegressionTransformNode ||\n      node instanceof IdentifierNode ||\n      node instanceof SampleTransformNode ||\n      node instanceof PivotTransformNode\n    ) {\n      dataSource.transform.push(node.assemble());\n    }\n\n    if (\n      node instanceof BinNode ||\n      node instanceof TimeUnitNode ||\n      node instanceof ImputeNode ||\n      node instanceof StackNode ||\n      node instanceof GeoJSONNode\n    ) {\n      dataSource.transform.push(...node.assemble());\n    }\n\n    if (node instanceof OutputNode) {\n      if (dataSource.source && dataSource.transform.length === 0) {\n        node.setSource(dataSource.source);\n      } else if (node.parent instanceof OutputNode) {\n        // Note that an output node may be required but we still do not assemble a\n        // separate data source for it.\n        node.setSource(dataSource.name);\n      } else {\n        if (!dataSource.name) {\n          dataSource.name = `data_${datasetIndex++}`;\n        }\n\n        // Here we set the name of the datasource we generated. From now on\n        // other assemblers can use it.\n        node.setSource(dataSource.name);\n\n        // if this node has more than one child, we will add a datasource automatically\n        if (node.numChildren() === 1) {\n          data.push(dataSource);\n          const newData: VgData = {\n            name: null,\n            source: dataSource.name,\n            transform: []\n          };\n          dataSource = newData;\n        }\n      }\n    }\n\n    switch (node.numChildren()) {\n      case 0:\n        // done\n        if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {\n          // do not push empty datasources that are simply references\n          data.push(dataSource);\n        }\n        break;\n      case 1:\n        walkTree(node.children[0], dataSource);\n        break;\n      default: {\n        if (!dataSource.name) {\n          dataSource.name = `data_${datasetIndex++}`;\n        }\n\n        let source = dataSource.name;\n        if (!dataSource.source || dataSource.transform.length > 0) {\n          data.push(dataSource);\n        } else {\n          source = dataSource.source;\n        }\n\n        for (const child of node.children) {\n          const newData: VgData = {\n            name: null,\n            source,\n            transform: []\n          };\n          walkTree(child, newData);\n        }\n        break;\n      }\n    }\n  }\n\n  return walkTree;\n}\n\n/**\n * Assemble data sources that are derived from faceted data.\n */\nexport function assembleFacetData(root: FacetNode): VgData[] {\n  const data: VgData[] = [];\n  const walkTree = makeWalkTree(data);\n\n  for (const child of root.children) {\n    walkTree(child, {\n      source: root.name,\n      name: null,\n      transform: []\n    });\n  }\n\n  return data;\n}\n\n/**\n * Create Vega data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\nexport function assembleRootData(dataComponent: DataComponent, datasets: Dict<InlineDataset>): VgData[] {\n  const data: VgData[] = [];\n\n  // dataComponent.sources.forEach(debug);\n  // draw(dataComponent.sources);\n\n  const walkTree = makeWalkTree(data);\n\n  let sourceIndex = 0;\n\n  for (const root of dataComponent.sources) {\n    // assign a name if the source does not have a name yet\n    if (!root.hasName()) {\n      root.dataName = `source_${sourceIndex++}`;\n    }\n\n    const newData: VgData = root.assemble();\n\n    walkTree(root, newData);\n  }\n\n  // remove empty transform arrays for cleaner output\n  for (const d of data) {\n    if (d.transform.length === 0) {\n      delete d.transform;\n    }\n  }\n\n  // move sources without transforms (the ones that are potentially used in lookups) to the beginning\n  let whereTo = 0;\n  for (const [i, d] of data.entries()) {\n    if ((d.transform ?? []).length === 0 && !d.source) {\n      data.splice(whereTo++, 0, data.splice(i, 1)[0]);\n    }\n  }\n\n  // now fix the from references in lookup transforms\n  for (const d of data) {\n    for (const t of d.transform ?? []) {\n      if (t.type === 'lookup') {\n        t.from = dataComponent.outputNodes[t.from].getSource();\n      }\n    }\n  }\n\n  // inline values for datasets that are in the datastore\n  for (const d of data) {\n    if (d.name in datasets) {\n      d.values = datasets[d.name];\n    }\n  }\n\n  return data;\n}\n"]},"metadata":{},"sourceType":"module"}