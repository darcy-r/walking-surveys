{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isConditionalAxisValue } from '../axis';\nimport { GEOPOSITION_CHANNELS, NONPOSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, SCALE_CHANNELS, supportLegend, X, Y } from '../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldOrDatumDef, isTypedFieldDef } from '../channeldef';\nimport { isGraticuleGenerator } from '../data';\nimport * as vlEncoding from '../encoding';\nimport { initEncoding } from '../encoding';\nimport { replaceExprRef } from '../expr';\nimport { GEOSHAPE, isMarkDef } from '../mark';\nimport { isSelectionParameter } from '../selection';\nimport { isFrameMixins } from '../spec/base';\nimport { stack } from '../stack';\nimport { keys } from '../util';\nimport { assembleAxisSignals } from './axis/assemble';\nimport { parseUnitAxes } from './axis/parse';\nimport { signalOrValueRefWithCondition, signalRefOrValue } from './common';\nimport { parseData } from './data/parse';\nimport { assembleLayoutSignals } from './layoutsize/assemble';\nimport { initLayoutSize } from './layoutsize/init';\nimport { parseUnitLayoutSize } from './layoutsize/parse';\nimport { defaultFilled, initMarkdef } from './mark/init';\nimport { parseMarkGroups } from './mark/mark';\nimport { isLayerModel, ModelWithField } from './model';\nimport { assembleTopLevelSignals, assembleUnitSelectionData, assembleUnitSelectionMarks, assembleUnitSelectionSignals } from './selection/assemble';\nimport { parseUnitSelection } from './selection/parse';\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\n\nexport class UnitModel extends ModelWithField {\n  constructor(spec, parent, parentGivenName) {\n    let parentGivenSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let config = arguments.length > 4 ? arguments[4] : undefined;\n\n    var _a;\n\n    super(spec, 'unit', parent, parentGivenName, config, undefined, isFrameMixins(spec) ? spec.view : undefined);\n    this.specifiedScales = {};\n    this.specifiedAxes = {};\n    this.specifiedLegends = {};\n    this.specifiedProjection = {};\n    this.selection = [];\n    this.children = [];\n    const markDef = isMarkDef(spec.mark) ? Object.assign({}, spec.mark) : {\n      type: spec.mark\n    };\n    const mark = markDef.type; // Need to init filled before other mark properties because encoding depends on filled but other mark properties depend on types inside encoding\n\n    if (markDef.filled === undefined) {\n      markDef.filled = defaultFilled(markDef, config, {\n        graticule: spec.data && isGraticuleGenerator(spec.data)\n      });\n    }\n\n    const encoding = this.encoding = initEncoding(spec.encoding || {}, mark, markDef.filled, config);\n    this.markDef = initMarkdef(markDef, encoding, config);\n    this.size = initLayoutSize({\n      encoding,\n      size: isFrameMixins(spec) ? Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? {\n        width: spec.width\n      } : {}), spec.height ? {\n        height: spec.height\n      } : {}) : parentGivenSize\n    }); // calculate stack properties\n\n    this.stack = stack(mark, encoding);\n    this.specifiedScales = this.initScales(mark, encoding);\n    this.specifiedAxes = this.initAxes(encoding);\n    this.specifiedLegends = this.initLegends(encoding);\n    this.specifiedProjection = spec.projection; // Selections will be initialized upon parse.\n\n    this.selection = ((_a = spec.params) !== null && _a !== void 0 ? _a : []).filter(p => isSelectionParameter(p));\n  }\n\n  get hasProjection() {\n    const {\n      encoding\n    } = this;\n    const isGeoShapeMark = this.mark === GEOSHAPE;\n    const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(channel => isFieldOrDatumDef(encoding[channel]));\n    return isGeoShapeMark || hasGeoPosition;\n  }\n  /**\n   * Return specified Vega-Lite scale domain for a particular channel\n   * @param channel\n   */\n\n\n  scaleDomain(channel) {\n    const scale = this.specifiedScales[channel];\n    return scale ? scale.domain : undefined;\n  }\n\n  axis(channel) {\n    return this.specifiedAxes[channel];\n  }\n\n  legend(channel) {\n    return this.specifiedLegends[channel];\n  }\n\n  initScales(mark, encoding) {\n    return SCALE_CHANNELS.reduce((scales, channel) => {\n      var _a;\n\n      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n\n      if (fieldOrDatumDef) {\n        scales[channel] = this.initScale((_a = fieldOrDatumDef.scale) !== null && _a !== void 0 ? _a : {});\n      }\n\n      return scales;\n    }, {});\n  }\n\n  initScale(scale) {\n    const {\n      domain,\n      range\n    } = scale; // TODO: we could simplify this function if we had a recursive replace function\n\n    const scaleInternal = replaceExprRef(scale);\n\n    if (isArray(domain)) {\n      scaleInternal.domain = domain.map(signalRefOrValue);\n    }\n\n    if (isArray(range)) {\n      scaleInternal.range = range.map(signalRefOrValue);\n    }\n\n    return scaleInternal;\n  }\n\n  initAxes(encoding) {\n    return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {\n      // Position Axis\n      // TODO: handle ConditionFieldDef\n      const channelDef = encoding[channel];\n\n      if (isFieldOrDatumDef(channelDef) || channel === X && isFieldOrDatumDef(encoding.x2) || channel === Y && isFieldOrDatumDef(encoding.y2)) {\n        const axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : undefined;\n        _axis[channel] = axisSpec ? this.initAxis(Object.assign({}, axisSpec)) // convert truthy value to object\n        : axisSpec;\n      }\n\n      return _axis;\n    }, {});\n  }\n\n  initAxis(axis) {\n    const props = keys(axis);\n    const axisInternal = {};\n\n    for (const prop of props) {\n      const val = axis[prop];\n      axisInternal[prop] = isConditionalAxisValue(val) ? signalOrValueRefWithCondition(val) : signalRefOrValue(val);\n    }\n\n    return axisInternal;\n  }\n\n  initLegends(encoding) {\n    return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {\n      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n\n      if (fieldOrDatumDef && supportLegend(channel)) {\n        const legend = fieldOrDatumDef.legend;\n        _legend[channel] = legend ? replaceExprRef(legend) // convert truthy value to object\n        : legend;\n      }\n\n      return _legend;\n    }, {});\n  }\n\n  parseData() {\n    this.component.data = parseData(this);\n  }\n\n  parseLayoutSize() {\n    parseUnitLayoutSize(this);\n  }\n\n  parseSelections() {\n    this.component.selection = parseUnitSelection(this, this.selection);\n  }\n\n  parseMarkGroup() {\n    this.component.mark = parseMarkGroups(this);\n  }\n\n  parseAxesAndHeaders() {\n    this.component.axes = parseUnitAxes(this);\n  }\n\n  assembleSelectionTopLevelSignals(signals) {\n    return assembleTopLevelSignals(this, signals);\n  }\n\n  assembleSignals() {\n    return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];\n  }\n\n  assembleSelectionData(data) {\n    return assembleUnitSelectionData(this, data);\n  }\n\n  assembleLayout() {\n    return null;\n  }\n\n  assembleLayoutSignals() {\n    return assembleLayoutSignals(this);\n  }\n\n  assembleMarks() {\n    var _a;\n\n    let marks = (_a = this.component.mark) !== null && _a !== void 0 ? _a : []; // If this unit is part of a layer, selections should augment\n    // all in concert rather than each unit individually. This\n    // ensures correct interleaving of clipping and brushed marks.\n\n    if (!this.parent || !isLayerModel(this.parent)) {\n      marks = assembleUnitSelectionMarks(this, marks);\n    }\n\n    return marks.map(this.correctDataNames);\n  }\n\n  assembleGroupStyle() {\n    const {\n      style\n    } = this.view || {};\n\n    if (style !== undefined) {\n      return style;\n    }\n\n    if (this.encoding.x || this.encoding.y) {\n      return 'cell';\n    } else {\n      return undefined;\n    }\n  }\n\n  getMapping() {\n    return this.encoding;\n  }\n\n  get mark() {\n    return this.markDef.type;\n  }\n\n  channelHasField(channel) {\n    return vlEncoding.channelHasField(this.encoding, channel);\n  }\n\n  fieldDef(channel) {\n    const channelDef = this.encoding[channel];\n    return getFieldDef(channelDef);\n  }\n\n  typedFieldDef(channel) {\n    const fieldDef = this.fieldDef(channel);\n\n    if (isTypedFieldDef(fieldDef)) {\n      return fieldDef;\n    }\n\n    return null;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["isArray","isConditionalAxisValue","GEOPOSITION_CHANNELS","NONPOSITION_SCALE_CHANNELS","POSITION_SCALE_CHANNELS","SCALE_CHANNELS","supportLegend","X","Y","getFieldDef","getFieldOrDatumDef","isFieldOrDatumDef","isTypedFieldDef","isGraticuleGenerator","vlEncoding","initEncoding","replaceExprRef","GEOSHAPE","isMarkDef","isSelectionParameter","isFrameMixins","stack","keys","assembleAxisSignals","parseUnitAxes","signalOrValueRefWithCondition","signalRefOrValue","parseData","assembleLayoutSignals","initLayoutSize","parseUnitLayoutSize","defaultFilled","initMarkdef","parseMarkGroups","isLayerModel","ModelWithField","assembleTopLevelSignals","assembleUnitSelectionData","assembleUnitSelectionMarks","assembleUnitSelectionSignals","parseUnitSelection","UnitModel","constructor","spec","parent","parentGivenName","parentGivenSize","config","undefined","view","markDef","mark","Object","type","filled","graticule","data","encoding","size","width","height","specifiedScales","initScales","specifiedAxes","initAxes","specifiedLegends","initLegends","specifiedProjection","projection","selection","params","_a","filter","p","hasProjection","isGeoShapeMark","hasGeoPosition","some","channel","scaleDomain","scale","domain","axis","legend","reduce","scales","fieldOrDatumDef","initScale","range","scaleInternal","map","_axis","channelDef","x2","y2","axisSpec","initAxis","props","axisInternal","prop","val","_legend","component","parseLayoutSize","parseSelections","parseMarkGroup","parseAxesAndHeaders","axes","assembleSelectionTopLevelSignals","signals","assembleSignals","assembleSelectionData","assembleLayout","assembleMarks","marks","correctDataNames","assembleGroupStyle","style","x","y","getMapping","channelHasField","fieldDef","typedFieldDef"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/unit.ts"],"sourcesContent":["import {NewSignal, SignalRef} from 'vega';\nimport {isArray} from 'vega-util';\nimport {Axis, AxisInternal, isConditionalAxisValue} from '../axis';\nimport {\n  Channel,\n  GEOPOSITION_CHANNELS,\n  NonPositionScaleChannel,\n  NONPOSITION_SCALE_CHANNELS,\n  PositionChannel,\n  POSITION_SCALE_CHANNELS,\n  ScaleChannel,\n  SCALE_CHANNELS,\n  SingleDefChannel,\n  supportLegend,\n  X,\n  Y\n} from '../channel';\nimport {\n  getFieldDef,\n  getFieldOrDatumDef,\n  isFieldOrDatumDef,\n  isTypedFieldDef,\n  MarkPropFieldOrDatumDef,\n  PositionFieldDef\n} from '../channeldef';\nimport {Config} from '../config';\nimport {isGraticuleGenerator} from '../data';\nimport * as vlEncoding from '../encoding';\nimport {Encoding, initEncoding} from '../encoding';\nimport {ExprRef, replaceExprRef} from '../expr';\nimport {LegendInternal} from '../legend';\nimport {GEOSHAPE, isMarkDef, Mark, MarkDef} from '../mark';\nimport {Projection} from '../projection';\nimport {Domain, Scale} from '../scale';\nimport {isSelectionParameter, SelectionParameter} from '../selection';\nimport {LayoutSizeMixins, NormalizedUnitSpec} from '../spec';\nimport {isFrameMixins} from '../spec/base';\nimport {stack, StackProperties} from '../stack';\nimport {keys} from '../util';\nimport {VgData, VgLayout} from '../vega.schema';\nimport {assembleAxisSignals} from './axis/assemble';\nimport {AxisInternalIndex} from './axis/component';\nimport {parseUnitAxes} from './axis/parse';\nimport {signalOrValueRefWithCondition, signalRefOrValue} from './common';\nimport {parseData} from './data/parse';\nimport {assembleLayoutSignals} from './layoutsize/assemble';\nimport {initLayoutSize} from './layoutsize/init';\nimport {parseUnitLayoutSize} from './layoutsize/parse';\nimport {LegendInternalIndex} from './legend/component';\nimport {defaultFilled, initMarkdef} from './mark/init';\nimport {parseMarkGroups} from './mark/mark';\nimport {isLayerModel, Model, ModelWithField} from './model';\nimport {ScaleIndex} from './scale/component';\nimport {\n  assembleTopLevelSignals,\n  assembleUnitSelectionData,\n  assembleUnitSelectionMarks,\n  assembleUnitSelectionSignals\n} from './selection/assemble';\nimport {parseUnitSelection} from './selection/parse';\n\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\nexport class UnitModel extends ModelWithField {\n  public readonly markDef: MarkDef<Mark, SignalRef>;\n  public readonly encoding: Encoding<string>;\n\n  public readonly specifiedScales: ScaleIndex = {};\n\n  public readonly stack: StackProperties;\n\n  protected specifiedAxes: AxisInternalIndex = {};\n\n  protected specifiedLegends: LegendInternalIndex = {};\n\n  public specifiedProjection: Projection<ExprRef | SignalRef> = {};\n\n  public readonly selection: SelectionParameter[] = [];\n  public children: Model[] = [];\n\n  constructor(\n    spec: NormalizedUnitSpec,\n    parent: Model,\n    parentGivenName: string,\n    parentGivenSize: LayoutSizeMixins = {},\n    config: Config<SignalRef>\n  ) {\n    super(spec, 'unit', parent, parentGivenName, config, undefined, isFrameMixins(spec) ? spec.view : undefined);\n\n    const markDef = isMarkDef(spec.mark) ? {...spec.mark} : {type: spec.mark};\n    const mark = markDef.type;\n\n    // Need to init filled before other mark properties because encoding depends on filled but other mark properties depend on types inside encoding\n    if (markDef.filled === undefined) {\n      markDef.filled = defaultFilled(markDef, config, {\n        graticule: spec.data && isGraticuleGenerator(spec.data)\n      });\n    }\n\n    const encoding = (this.encoding = initEncoding(spec.encoding || {}, mark, markDef.filled, config));\n    this.markDef = initMarkdef(markDef, encoding, config);\n\n    this.size = initLayoutSize({\n      encoding,\n      size: isFrameMixins(spec)\n        ? {\n            ...parentGivenSize,\n            ...(spec.width ? {width: spec.width} : {}),\n            ...(spec.height ? {height: spec.height} : {})\n          }\n        : parentGivenSize\n    });\n\n    // calculate stack properties\n    this.stack = stack(mark, encoding);\n    this.specifiedScales = this.initScales(mark, encoding);\n\n    this.specifiedAxes = this.initAxes(encoding);\n    this.specifiedLegends = this.initLegends(encoding);\n    this.specifiedProjection = spec.projection;\n\n    // Selections will be initialized upon parse.\n    this.selection = (spec.params ?? []).filter(p => isSelectionParameter(p)) as SelectionParameter[];\n  }\n\n  public get hasProjection(): boolean {\n    const {encoding} = this;\n    const isGeoShapeMark = this.mark === GEOSHAPE;\n    const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(channel => isFieldOrDatumDef(encoding[channel]));\n    return isGeoShapeMark || hasGeoPosition;\n  }\n\n  /**\n   * Return specified Vega-Lite scale domain for a particular channel\n   * @param channel\n   */\n  public scaleDomain(channel: ScaleChannel): Domain {\n    const scale = this.specifiedScales[channel];\n    return scale ? scale.domain : undefined;\n  }\n\n  public axis(channel: PositionChannel): AxisInternal {\n    return this.specifiedAxes[channel];\n  }\n\n  public legend(channel: NonPositionScaleChannel): LegendInternal {\n    return this.specifiedLegends[channel];\n  }\n\n  private initScales(mark: Mark, encoding: Encoding<string>): ScaleIndex {\n    return SCALE_CHANNELS.reduce((scales, channel) => {\n      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) as\n        | PositionFieldDef<string>\n        | MarkPropFieldOrDatumDef<string>;\n      if (fieldOrDatumDef) {\n        scales[channel] = this.initScale(fieldOrDatumDef.scale ?? {});\n      }\n      return scales;\n    }, {} as ScaleIndex);\n  }\n\n  private initScale(scale: Scale<ExprRef | SignalRef>): Scale<SignalRef> {\n    const {domain, range} = scale;\n    // TODO: we could simplify this function if we had a recursive replace function\n    const scaleInternal = replaceExprRef(scale);\n    if (isArray(domain)) {\n      scaleInternal.domain = domain.map(signalRefOrValue);\n    }\n    if (isArray(range)) {\n      scaleInternal.range = range.map(signalRefOrValue);\n    }\n    return scaleInternal as Scale<SignalRef>;\n  }\n\n  private initAxes(encoding: Encoding<string>): AxisInternalIndex {\n    return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {\n      // Position Axis\n\n      // TODO: handle ConditionFieldDef\n      const channelDef = encoding[channel];\n      if (\n        isFieldOrDatumDef(channelDef) ||\n        (channel === X && isFieldOrDatumDef(encoding.x2)) ||\n        (channel === Y && isFieldOrDatumDef(encoding.y2))\n      ) {\n        const axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : undefined;\n\n        _axis[channel] = axisSpec\n          ? this.initAxis({...axisSpec}) // convert truthy value to object\n          : axisSpec;\n      }\n      return _axis;\n    }, {});\n  }\n\n  private initAxis(axis: Axis<ExprRef | SignalRef>): Axis<SignalRef> {\n    const props = keys(axis);\n    const axisInternal = {};\n    for (const prop of props) {\n      const val = axis[prop];\n      axisInternal[prop as any] = isConditionalAxisValue<any, ExprRef | SignalRef>(val)\n        ? signalOrValueRefWithCondition<any>(val)\n        : signalRefOrValue(val);\n    }\n    return axisInternal;\n  }\n\n  private initLegends(encoding: Encoding<string>): LegendInternalIndex {\n    return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {\n      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) as MarkPropFieldOrDatumDef<string>;\n\n      if (fieldOrDatumDef && supportLegend(channel)) {\n        const legend = fieldOrDatumDef.legend;\n        _legend[channel] = legend\n          ? replaceExprRef(legend) // convert truthy value to object\n          : legend;\n      }\n\n      return _legend;\n    }, {});\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n  }\n\n  public parseLayoutSize() {\n    parseUnitLayoutSize(this);\n  }\n\n  public parseSelections() {\n    this.component.selection = parseUnitSelection(this, this.selection);\n  }\n\n  public parseMarkGroup() {\n    this.component.mark = parseMarkGroups(this);\n  }\n\n  public parseAxesAndHeaders() {\n    this.component.axes = parseUnitAxes(this);\n  }\n\n  public assembleSelectionTopLevelSignals(signals: any[]): NewSignal[] {\n    return assembleTopLevelSignals(this, signals);\n  }\n\n  public assembleSignals(): NewSignal[] {\n    return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];\n  }\n\n  public assembleSelectionData(data: readonly VgData[]): VgData[] {\n    return assembleUnitSelectionData(this, data);\n  }\n\n  public assembleLayout(): VgLayout {\n    return null;\n  }\n\n  public assembleLayoutSignals(): NewSignal[] {\n    return assembleLayoutSignals(this);\n  }\n\n  public assembleMarks() {\n    let marks = this.component.mark ?? [];\n\n    // If this unit is part of a layer, selections should augment\n    // all in concert rather than each unit individually. This\n    // ensures correct interleaving of clipping and brushed marks.\n    if (!this.parent || !isLayerModel(this.parent)) {\n      marks = assembleUnitSelectionMarks(this, marks);\n    }\n\n    return marks.map(this.correctDataNames);\n  }\n  public assembleGroupStyle(): string | string[] {\n    const {style} = this.view || {};\n    if (style !== undefined) {\n      return style;\n    }\n    if (this.encoding.x || this.encoding.y) {\n      return 'cell';\n    } else {\n      return undefined;\n    }\n  }\n\n  protected getMapping() {\n    return this.encoding;\n  }\n\n  public get mark(): Mark {\n    return this.markDef.type;\n  }\n\n  public channelHasField(channel: Channel) {\n    return vlEncoding.channelHasField(this.encoding, channel);\n  }\n\n  public fieldDef(channel: SingleDefChannel) {\n    const channelDef = this.encoding[channel];\n    return getFieldDef<string>(channelDef);\n  }\n\n  public typedFieldDef(channel: SingleDefChannel) {\n    const fieldDef = this.fieldDef(channel);\n    if (isTypedFieldDef(fieldDef)) {\n      return fieldDef;\n    }\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}