{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW } from '../../channel';\nimport { vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { hasDiscreteDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../../sort';\nimport { hash } from '../../util';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { HEADER_CHANNELS, HEADER_TYPES } from '../header/component';\nimport { assembleDomain, getFieldFromDomain } from '../scale/domain';\nimport { sortArrayIndexField } from './calculate';\nimport { DataFlowNode } from './dataflow';\n/**\n * A node that helps us track what fields we are faceting by.\n */\n\nexport class FacetNode extends DataFlowNode {\n  /**\n   * @param model The facet model.\n   * @param name The name that this facet source will have.\n   * @param data The source data for this facet data.\n   */\n  constructor(parent, model, name, data) {\n    super(parent);\n    this.model = model;\n    this.name = name;\n    this.data = data;\n\n    for (const channel of FACET_CHANNELS) {\n      const fieldDef = model.facet[channel];\n\n      if (fieldDef) {\n        const {\n          bin,\n          sort\n        } = fieldDef;\n        this[channel] = Object.assign({\n          name: model.getName(`${channel}_domain`),\n          fields: [vgField(fieldDef), ...(isBinning(bin) ? [vgField(fieldDef, {\n            binSuffix: 'end'\n          })] : [])]\n        }, isSortField(sort) ? {\n          sortField: sort\n        } : isArray(sort) ? {\n          sortIndexField: sortArrayIndexField(fieldDef, channel)\n        } : {});\n      }\n    }\n\n    this.childModel = model.child;\n  }\n\n  hash() {\n    let out = `Facet`;\n\n    for (const channel of FACET_CHANNELS) {\n      if (this[channel]) {\n        out += ` ${channel.charAt(0)}:${hash(this[channel])}`;\n      }\n    }\n\n    return out;\n  }\n\n  get fields() {\n    var _a;\n\n    const f = [];\n\n    for (const channel of FACET_CHANNELS) {\n      if ((_a = this[channel]) === null || _a === void 0 ? void 0 : _a.fields) {\n        f.push(...this[channel].fields);\n      }\n    }\n\n    return f;\n  }\n\n  dependentFields() {\n    const depFields = new Set(this.fields);\n\n    for (const channel of FACET_CHANNELS) {\n      if (this[channel]) {\n        if (this[channel].sortField) {\n          depFields.add(this[channel].sortField.field);\n        }\n\n        if (this[channel].sortIndexField) {\n          depFields.add(this[channel].sortIndexField);\n        }\n      }\n    }\n\n    return depFields;\n  }\n\n  producedFields() {\n    return new Set(); // facet does not produce any new fields\n  }\n  /**\n   * The name to reference this source is its name.\n   */\n\n\n  getSource() {\n    return this.name;\n  }\n\n  getChildIndependentFieldsWithStep() {\n    const childIndependentFieldsWithStep = {};\n\n    for (const channel of POSITION_SCALE_CHANNELS) {\n      const childScaleComponent = this.childModel.component.scales[channel];\n\n      if (childScaleComponent && !childScaleComponent.merged) {\n        // independent scale\n        const type = childScaleComponent.get('type');\n        const range = childScaleComponent.get('range');\n\n        if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n          const domain = assembleDomain(this.childModel, channel);\n          const field = getFieldFromDomain(domain);\n\n          if (field) {\n            childIndependentFieldsWithStep[channel] = field;\n          } else {\n            log.warn(log.message.unknownField(channel));\n          }\n        }\n      }\n    }\n\n    return childIndependentFieldsWithStep;\n  }\n\n  assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {\n    const childChannel = {\n      row: 'y',\n      column: 'x',\n      facet: undefined\n    }[channel];\n    const fields = [];\n    const ops = [];\n    const as = [];\n\n    if (childChannel && childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {\n      if (crossedDataName) {\n        // If there is a crossed data, calculate max\n        fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n        ops.push('max');\n      } else {\n        // If there is no crossed data, just calculate distinct\n        fields.push(childIndependentFieldsWithStep[childChannel]);\n        ops.push('distinct');\n      } // Although it is technically a max, just name it distinct so it's easier to refer to it\n\n\n      as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n    }\n\n    const {\n      sortField,\n      sortIndexField\n    } = this[channel];\n\n    if (sortField) {\n      const {\n        op = DEFAULT_SORT_OP,\n        field\n      } = sortField;\n      fields.push(field);\n      ops.push(op);\n      as.push(vgField(sortField, {\n        forAs: true\n      }));\n    } else if (sortIndexField) {\n      fields.push(sortIndexField);\n      ops.push('max');\n      as.push(sortIndexField);\n    }\n\n    return {\n      name: this[channel].name,\n      // Use data from the crossed one if it exist\n      source: crossedDataName !== null && crossedDataName !== void 0 ? crossedDataName : this.data,\n      transform: [Object.assign({\n        type: 'aggregate',\n        groupby: this[channel].fields\n      }, fields.length ? {\n        fields,\n        ops,\n        as\n      } : {})]\n    };\n  }\n\n  assembleFacetHeaderData(childIndependentFieldsWithStep) {\n    var _a, _b;\n\n    const {\n      columns\n    } = this.model.layout;\n    const {\n      layoutHeaders\n    } = this.model.component;\n    const data = [];\n    const hasSharedAxis = {};\n\n    for (const headerChannel of HEADER_CHANNELS) {\n      for (const headerType of HEADER_TYPES) {\n        const headers = (_a = layoutHeaders[headerChannel] && layoutHeaders[headerChannel][headerType]) !== null && _a !== void 0 ? _a : [];\n\n        for (const header of headers) {\n          if (((_b = header.axes) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n            hasSharedAxis[headerChannel] = true;\n            break;\n          }\n        }\n      }\n\n      if (hasSharedAxis[headerChannel]) {\n        const cardinality = `length(data(\"${this.facet.name}\"))`;\n        const stop = headerChannel === 'row' ? columns ? {\n          signal: `ceil(${cardinality} / ${columns})`\n        } : 1 : columns ? {\n          signal: `min(${cardinality}, ${columns})`\n        } : {\n          signal: cardinality\n        };\n        data.push({\n          name: `${this.facet.name}_${headerChannel}`,\n          transform: [{\n            type: 'sequence',\n            start: 0,\n            stop\n          }]\n        });\n      }\n    }\n\n    const {\n      row,\n      column\n    } = hasSharedAxis;\n\n    if (row || column) {\n      data.unshift(this.assembleRowColumnHeaderData('facet', null, childIndependentFieldsWithStep));\n    }\n\n    return data;\n  }\n\n  assemble() {\n    var _a, _b;\n\n    const data = [];\n    let crossedDataName = null;\n    const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();\n    const {\n      column,\n      row,\n      facet\n    } = this;\n\n    if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {\n      // Need to create a cross dataset to correctly calculate cardinality\n      crossedDataName = `cross_${this.column.name}_${this.row.name}`;\n      const fields = [].concat((_a = childIndependentFieldsWithStep.x) !== null && _a !== void 0 ? _a : [], (_b = childIndependentFieldsWithStep.y) !== null && _b !== void 0 ? _b : []);\n      const ops = fields.map(() => 'distinct');\n      data.push({\n        name: crossedDataName,\n        source: this.data,\n        transform: [{\n          type: 'aggregate',\n          groupby: this.fields,\n          fields,\n          ops\n        }]\n      });\n    }\n\n    for (const channel of [COLUMN, ROW]) {\n      if (this[channel]) {\n        data.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));\n      }\n    }\n\n    if (facet) {\n      const facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);\n\n      if (facetData) {\n        data.push(...facetData);\n      }\n    }\n\n    return data;\n  }\n\n}","map":{"version":3,"mappings":"AACA,SAAQA,OAAR,QAAsB,WAAtB;AACA,SAAQC,SAAR,QAAwB,WAAxB;AACA,SAAQC,MAAR,EAAgBC,cAAhB,EAAgCC,uBAAhC,EAAyDC,GAAzD,QAAmE,eAAnE;AACA,SAAQC,OAAR,QAAsB,kBAAtB;AACA,OAAO,KAAKC,GAAZ,MAAqB,WAArB;AACA,SAAQC,iBAAR,QAAgC,aAAhC;AACA,SAAQC,eAAR,EAA4CC,WAA5C,QAA8D,YAA9D;AACA,SAAQC,IAAR,QAAmB,YAAnB;AACA,SAAQC,aAAR,QAAoC,mBAApC;AAEA,SAAQC,eAAR,EAAyBC,YAAzB,QAA4C,qBAA5C;AAEA,SAAQC,cAAR,EAAwBC,kBAAxB,QAAiD,iBAAjD;AACA,SAAQC,mBAAR,QAAkC,aAAlC;AACA,SAAQC,YAAR,QAA2B,YAA3B;AAeA;;;;AAGA,OAAM,MAAOC,SAAP,SAAyBD,YAAzB,CAAqC;EASzC;;;;;EAKAE,YACEC,MADF,EAEkBC,KAFlB,EAGkBC,IAHlB,EAISC,IAJT,EAIqB;IAEnB,MAAMH,MAAN;IAJgB;IACA;IACT;;IAIP,KAAK,MAAMI,OAAX,IAAsBtB,cAAtB,EAAsC;MACpC,MAAMuB,QAAQ,GAAGJ,KAAK,CAACK,KAAN,CAAYF,OAAZ,CAAjB;;MACA,IAAIC,QAAJ,EAAc;QACZ,MAAM;UAACE,GAAD;UAAMC;QAAN,IAAcH,QAApB;QACA,KAAKD,OAAL,IAAaK;UACXP,IAAI,EAAED,KAAK,CAACS,OAAN,CAAc,GAAGN,OAAO,SAAxB,CADK;UAEXO,MAAM,EAAE,CAAC1B,OAAO,CAACoB,QAAD,CAAR,EAAoB,IAAIzB,SAAS,CAAC2B,GAAD,CAAT,GAAiB,CAACtB,OAAO,CAACoB,QAAD,EAAW;YAACO,SAAS,EAAE;UAAZ,CAAX,CAAR,CAAjB,GAA2D,EAA/D,CAApB;QAFG,GAGPvB,WAAW,CAACmB,IAAD,CAAX,GACA;UAACK,SAAS,EAAEL;QAAZ,CADA,GAEA7B,OAAO,CAAC6B,IAAD,CAAP,GACA;UAACM,cAAc,EAAElB,mBAAmB,CAACS,QAAD,EAAWD,OAAX;QAApC,CADA,GAEA,EAPO,CAAb;MASD;IACF;;IACD,KAAKW,UAAL,GAAkBd,KAAK,CAACe,KAAxB;EACD;;EAEM1B,IAAI;IACT,IAAI2B,GAAG,GAAG,OAAV;;IAEA,KAAK,MAAMb,OAAX,IAAsBtB,cAAtB,EAAsC;MACpC,IAAI,KAAKsB,OAAL,CAAJ,EAAmB;QACjBa,GAAG,IAAI,IAAIb,OAAO,CAACc,MAAR,CAAe,CAAf,CAAiB,IAAI5B,IAAI,CAAC,KAAKc,OAAL,CAAD,CAAe,EAAnD;MACD;IACF;;IAED,OAAOa,GAAP;EACD;;EAES,IAANN,MAAM;;;IACR,MAAMQ,CAAC,GAAa,EAApB;;IAEA,KAAK,MAAMf,OAAX,IAAsBtB,cAAtB,EAAsC;MACpC,IAAI,WAAKsB,OAAL,OAAa,IAAb,IAAagB,aAAb,GAAa,MAAb,GAAaA,GAAET,MAAnB,EAA2B;QACzBQ,CAAC,CAACE,IAAF,CAAO,GAAG,KAAKjB,OAAL,EAAcO,MAAxB;MACD;IACF;;IACD,OAAOQ,CAAP;EACD;;EAEMG,eAAe;IACpB,MAAMC,SAAS,GAAG,IAAIC,GAAJ,CAAgB,KAAKb,MAArB,CAAlB;;IAEA,KAAK,MAAMP,OAAX,IAAsBtB,cAAtB,EAAsC;MACpC,IAAI,KAAKsB,OAAL,CAAJ,EAAmB;QACjB,IAAI,KAAKA,OAAL,EAAcS,SAAlB,EAA6B;UAC3BU,SAAS,CAACE,GAAV,CAAc,KAAKrB,OAAL,EAAcS,SAAd,CAAwBa,KAAtC;QACD;;QACD,IAAI,KAAKtB,OAAL,EAAcU,cAAlB,EAAkC;UAChCS,SAAS,CAACE,GAAV,CAAc,KAAKrB,OAAL,EAAcU,cAA5B;QACD;MACF;IACF;;IAED,OAAOS,SAAP;EACD;;EAEMI,cAAc;IACnB,OAAO,IAAIH,GAAJ,EAAP,CADmB,CACO;EAC3B;EAED;;;;;EAGOI,SAAS;IACd,OAAO,KAAK1B,IAAZ;EACD;;EAEO2B,iCAAiC;IACvC,MAAMC,8BAA8B,GAAmC,EAAvE;;IAEA,KAAK,MAAM1B,OAAX,IAAsBrB,uBAAtB,EAA+C;MAC7C,MAAMgD,mBAAmB,GAAG,KAAKhB,UAAL,CAAgBiB,SAAhB,CAA0BC,MAA1B,CAAiC7B,OAAjC,CAA5B;;MACA,IAAI2B,mBAAmB,IAAI,CAACA,mBAAmB,CAACG,MAAhD,EAAwD;QACtD;QACA,MAAMC,IAAI,GAAGJ,mBAAmB,CAACK,GAApB,CAAwB,MAAxB,CAAb;QACA,MAAMC,KAAK,GAAGN,mBAAmB,CAACK,GAApB,CAAwB,OAAxB,CAAd;;QAEA,IAAIjD,iBAAiB,CAACgD,IAAD,CAAjB,IAA2B5C,aAAa,CAAC8C,KAAD,CAA5C,EAAqD;UACnD,MAAMC,MAAM,GAAG5C,cAAc,CAAC,KAAKqB,UAAN,EAAkBX,OAAlB,CAA7B;UACA,MAAMsB,KAAK,GAAG/B,kBAAkB,CAAC2C,MAAD,CAAhC;;UACA,IAAIZ,KAAJ,EAAW;YACTI,8BAA8B,CAAC1B,OAAD,CAA9B,GAA0CsB,KAA1C;UACD,CAFD,MAEO;YACLxC,GAAG,CAACqD,IAAJ,CAASrD,GAAG,CAACsD,OAAJ,CAAYC,YAAZ,CAAyBrC,OAAzB,CAAT;UACD;QACF;MACF;IACF;;IAED,OAAO0B,8BAAP;EACD;;EAEOY,2BAA2B,CACjCtC,OADiC,EAEjCuC,eAFiC,EAGjCb,8BAHiC,EAG6B;IAE9D,MAAMc,YAAY,GAAG;MAACC,GAAG,EAAE,GAAN;MAAWC,MAAM,EAAE,GAAnB;MAAwBxC,KAAK,EAAEyC;IAA/B,EAA0C3C,OAA1C,CAArB;IAEA,MAAMO,MAAM,GAAa,EAAzB;IACA,MAAMqC,GAAG,GAAkB,EAA3B;IACA,MAAMC,EAAE,GAAa,EAArB;;IAEA,IAAIL,YAAY,IAAId,8BAAhB,IAAkDA,8BAA8B,CAACc,YAAD,CAApF,EAAoG;MAClG,IAAID,eAAJ,EAAqB;QACnB;QACAhC,MAAM,CAACU,IAAP,CAAY,YAAYS,8BAA8B,CAACc,YAAD,CAAc,EAApE;QAEAI,GAAG,CAAC3B,IAAJ,CAAS,KAAT;MACD,CALD,MAKO;QACL;QACAV,MAAM,CAACU,IAAP,CAAYS,8BAA8B,CAACc,YAAD,CAA1C;QACAI,GAAG,CAAC3B,IAAJ,CAAS,UAAT;MACD,CAViG,CAWlG;;;MACA4B,EAAE,CAAC5B,IAAH,CAAQ,YAAYS,8BAA8B,CAACc,YAAD,CAAc,EAAhE;IACD;;IAED,MAAM;MAAC/B,SAAD;MAAYC;IAAZ,IAA8B,KAAKV,OAAL,CAApC;;IACA,IAAIS,SAAJ,EAAe;MACb,MAAM;QAACqC,EAAE,GAAG9D,eAAN;QAAuBsC;MAAvB,IAAgCb,SAAtC;MACAF,MAAM,CAACU,IAAP,CAAYK,KAAZ;MACAsB,GAAG,CAAC3B,IAAJ,CAAS6B,EAAT;MACAD,EAAE,CAAC5B,IAAH,CAAQpC,OAAO,CAAC4B,SAAD,EAAY;QAACsC,KAAK,EAAE;MAAR,CAAZ,CAAf;IACD,CALD,MAKO,IAAIrC,cAAJ,EAAoB;MACzBH,MAAM,CAACU,IAAP,CAAYP,cAAZ;MACAkC,GAAG,CAAC3B,IAAJ,CAAS,KAAT;MACA4B,EAAE,CAAC5B,IAAH,CAAQP,cAAR;IACD;;IAED,OAAO;MACLZ,IAAI,EAAE,KAAKE,OAAL,EAAcF,IADf;MAEL;MACAkD,MAAM,EAAET,eAAe,SAAf,mBAAe,WAAf,qBAAmB,KAAKxC,IAH3B;MAILkD,SAAS,EAAE;QAEPlB,IAAI,EAAE;QACNmB,OAAO,EAAE,KAAKlD,OAAL,EAAcO;SACnBA,MAAM,CAAC4C,MAAP,GACA;QACE5C,MADF;QAEEqC,GAFF;QAGEC;MAHF,CADA,GAMA,GAVG;IAJN,CAAP;EAkBD;;EAEOO,uBAAuB,CAAC1B,8BAAD,EAA+D;;;IAC5F,MAAM;MAAC2B;IAAD,IAAY,KAAKxD,KAAL,CAAWyD,MAA7B;IACA,MAAM;MAACC;IAAD,IAAkB,KAAK1D,KAAL,CAAW+B,SAAnC;IACA,MAAM7B,IAAI,GAAa,EAAvB;IAEA,MAAMyD,aAAa,GAAgC,EAAnD;;IACA,KAAK,MAAMC,aAAX,IAA4BrE,eAA5B,EAA6C;MAC3C,KAAK,MAAMsE,UAAX,IAAyBrE,YAAzB,EAAuC;QACrC,MAAMsE,OAAO,GAAG,MAACJ,aAAa,CAACE,aAAD,CAAb,IAAgCF,aAAa,CAACE,aAAD,CAAb,CAA6BC,UAA7B,CAAjC,MAA0E,IAA1E,IAA0E1C,aAA1E,GAA0EA,EAA1E,GAA8E,EAA9F;;QACA,KAAK,MAAM4C,MAAX,IAAqBD,OAArB,EAA8B;UAC5B,IAAI,aAAM,CAACE,IAAP,MAAW,IAAX,IAAWC,aAAX,GAAW,MAAX,GAAWA,GAAEX,MAAb,IAAsB,CAA1B,EAA6B;YAC3BK,aAAa,CAACC,aAAD,CAAb,GAA+B,IAA/B;YACA;UACD;QACF;MACF;;MAED,IAAID,aAAa,CAACC,aAAD,CAAjB,EAAkC;QAChC,MAAMM,WAAW,GAAG,gBAAgB,KAAK7D,KAAL,CAAWJ,IAAI,KAAnD;QAEA,MAAMkE,IAAI,GACRP,aAAa,KAAK,KAAlB,GACIJ,OAAO,GACL;UAACY,MAAM,EAAE,QAAQF,WAAW,MAAMV,OAAO;QAAzC,CADK,GAEL,CAHN,GAIIA,OAAO,GACP;UAACY,MAAM,EAAE,OAAOF,WAAW,KAAKV,OAAO;QAAvC,CADO,GAEP;UAACY,MAAM,EAAEF;QAAT,CAPN;QASAhE,IAAI,CAACkB,IAAL,CAAU;UACRnB,IAAI,EAAE,GAAG,KAAKI,KAAL,CAAWJ,IAAI,IAAI2D,aAAa,EADjC;UAERR,SAAS,EAAE,CACT;YACElB,IAAI,EAAE,UADR;YAEEmC,KAAK,EAAE,CAFT;YAGEF;UAHF,CADS;QAFH,CAAV;MAUD;IACF;;IAED,MAAM;MAACvB,GAAD;MAAMC;IAAN,IAAgBc,aAAtB;;IAEA,IAAIf,GAAG,IAAIC,MAAX,EAAmB;MACjB3C,IAAI,CAACoE,OAAL,CAAa,KAAK7B,2BAAL,CAAiC,OAAjC,EAA0C,IAA1C,EAAgDZ,8BAAhD,CAAb;IACD;;IAED,OAAO3B,IAAP;EACD;;EAEMqE,QAAQ;;;IACb,MAAMrE,IAAI,GAAa,EAAvB;IACA,IAAIwC,eAAe,GAAG,IAAtB;IACA,MAAMb,8BAA8B,GAAG,KAAKD,iCAAL,EAAvC;IAEA,MAAM;MAACiB,MAAD;MAASD,GAAT;MAAcvC;IAAd,IAAuB,IAA7B;;IAEA,IAAIwC,MAAM,IAAID,GAAV,KAAkBf,8BAA8B,CAAC2C,CAA/B,IAAoC3C,8BAA8B,CAAC4C,CAArF,CAAJ,EAA6F;MAC3F;MACA/B,eAAe,GAAG,SAAS,KAAKG,MAAL,CAAY5C,IAAI,IAAI,KAAK2C,GAAL,CAAS3C,IAAI,EAA5D;MAEA,MAAMS,MAAM,GAAa,GAAGgE,MAAH,CACvB,oCAA8B,CAACF,CAA/B,MAAgC,IAAhC,IAAgCrD,aAAhC,GAAgCA,EAAhC,GAAoC,EADb,EAEvB,oCAA8B,CAACsD,CAA/B,MAAgC,IAAhC,IAAgCR,aAAhC,GAAgCA,EAAhC,GAAoC,EAFb,CAAzB;MAIA,MAAMlB,GAAG,GAAGrC,MAAM,CAACiE,GAAP,CAAW,MAAmB,UAA9B,CAAZ;MAEAzE,IAAI,CAACkB,IAAL,CAAU;QACRnB,IAAI,EAAEyC,eADE;QAERS,MAAM,EAAE,KAAKjD,IAFL;QAGRkD,SAAS,EAAE,CACT;UACElB,IAAI,EAAE,WADR;UAEEmB,OAAO,EAAE,KAAK3C,MAFhB;UAGEA,MAHF;UAIEqC;QAJF,CADS;MAHH,CAAV;IAYD;;IAED,KAAK,MAAM5C,OAAX,IAAsB,CAACvB,MAAD,EAASG,GAAT,CAAtB,EAAqC;MACnC,IAAI,KAAKoB,OAAL,CAAJ,EAAmB;QACjBD,IAAI,CAACkB,IAAL,CAAU,KAAKqB,2BAAL,CAAiCtC,OAAjC,EAA0CuC,eAA1C,EAA2Db,8BAA3D,CAAV;MACD;IACF;;IAED,IAAIxB,KAAJ,EAAW;MACT,MAAMuE,SAAS,GAAG,KAAKrB,uBAAL,CAA6B1B,8BAA7B,CAAlB;;MACA,IAAI+C,SAAJ,EAAe;QACb1E,IAAI,CAACkB,IAAL,CAAU,GAAGwD,SAAb;MACD;IACF;;IAED,OAAO1E,IAAP;EACD;;AA9QwC","names":["isArray","isBinning","COLUMN","FACET_CHANNELS","POSITION_SCALE_CHANNELS","ROW","vgField","log","hasDiscreteDomain","DEFAULT_SORT_OP","isSortField","hash","isVgRangeStep","HEADER_CHANNELS","HEADER_TYPES","assembleDomain","getFieldFromDomain","sortArrayIndexField","DataFlowNode","FacetNode","constructor","parent","model","name","data","channel","fieldDef","facet","bin","sort","Object","getName","fields","binSuffix","sortField","sortIndexField","childModel","child","out","charAt","f","_a","push","dependentFields","depFields","Set","add","field","producedFields","getSource","getChildIndependentFieldsWithStep","childIndependentFieldsWithStep","childScaleComponent","component","scales","merged","type","get","range","domain","warn","message","unknownField","assembleRowColumnHeaderData","crossedDataName","childChannel","row","column","undefined","ops","as","op","forAs","source","transform","groupby","length","assembleFacetHeaderData","columns","layout","layoutHeaders","hasSharedAxis","headerChannel","headerType","headers","header","axes","_b","cardinality","stop","signal","start","unshift","assemble","x","y","concat","map","facetData"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/data/facet.ts"],"sourcesContent":["import {AggregateOp} from 'vega';\nimport {isArray} from 'vega-util';\nimport {isBinning} from '../../bin';\nimport {COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW} from '../../channel';\nimport {vgField} from '../../channeldef';\nimport * as log from '../../log';\nimport {hasDiscreteDomain} from '../../scale';\nimport {DEFAULT_SORT_OP, EncodingSortField, isSortField} from '../../sort';\nimport {hash} from '../../util';\nimport {isVgRangeStep, VgData} from '../../vega.schema';\nimport {FacetModel} from '../facet';\nimport {HEADER_CHANNELS, HEADER_TYPES} from '../header/component';\nimport {Model} from '../model';\nimport {assembleDomain, getFieldFromDomain} from '../scale/domain';\nimport {sortArrayIndexField} from './calculate';\nimport {DataFlowNode} from './dataflow';\n\ninterface ChildIndependentFieldsWithStep {\n  x?: string;\n  y?: string;\n}\n\ninterface FacetChannelInfo {\n  name: string;\n  fields: string[];\n  sortField?: EncodingSortField<string>;\n\n  sortIndexField?: string;\n}\n\n/**\n * A node that helps us track what fields we are faceting by.\n */\nexport class FacetNode extends DataFlowNode {\n  private readonly column: FacetChannelInfo;\n\n  private readonly row: FacetChannelInfo;\n\n  private readonly facet: FacetChannelInfo;\n\n  private readonly childModel: Model;\n\n  /**\n   * @param model The facet model.\n   * @param name The name that this facet source will have.\n   * @param data The source data for this facet data.\n   */\n  public constructor(\n    parent: DataFlowNode,\n    public readonly model: FacetModel,\n    public readonly name: string,\n    public data: string\n  ) {\n    super(parent);\n\n    for (const channel of FACET_CHANNELS) {\n      const fieldDef = model.facet[channel];\n      if (fieldDef) {\n        const {bin, sort} = fieldDef;\n        this[channel] = {\n          name: model.getName(`${channel}_domain`),\n          fields: [vgField(fieldDef), ...(isBinning(bin) ? [vgField(fieldDef, {binSuffix: 'end'})] : [])],\n          ...(isSortField(sort)\n            ? {sortField: sort}\n            : isArray(sort)\n            ? {sortIndexField: sortArrayIndexField(fieldDef, channel)}\n            : {})\n        };\n      }\n    }\n    this.childModel = model.child;\n  }\n\n  public hash() {\n    let out = `Facet`;\n\n    for (const channel of FACET_CHANNELS) {\n      if (this[channel]) {\n        out += ` ${channel.charAt(0)}:${hash(this[channel])}`;\n      }\n    }\n\n    return out;\n  }\n\n  get fields() {\n    const f: string[] = [];\n\n    for (const channel of FACET_CHANNELS) {\n      if (this[channel]?.fields) {\n        f.push(...this[channel].fields);\n      }\n    }\n    return f;\n  }\n\n  public dependentFields() {\n    const depFields = new Set<string>(this.fields);\n\n    for (const channel of FACET_CHANNELS) {\n      if (this[channel]) {\n        if (this[channel].sortField) {\n          depFields.add(this[channel].sortField.field);\n        }\n        if (this[channel].sortIndexField) {\n          depFields.add(this[channel].sortIndexField);\n        }\n      }\n    }\n\n    return depFields;\n  }\n\n  public producedFields() {\n    return new Set<string>(); // facet does not produce any new fields\n  }\n\n  /**\n   * The name to reference this source is its name.\n   */\n  public getSource() {\n    return this.name;\n  }\n\n  private getChildIndependentFieldsWithStep() {\n    const childIndependentFieldsWithStep: ChildIndependentFieldsWithStep = {};\n\n    for (const channel of POSITION_SCALE_CHANNELS) {\n      const childScaleComponent = this.childModel.component.scales[channel];\n      if (childScaleComponent && !childScaleComponent.merged) {\n        // independent scale\n        const type = childScaleComponent.get('type');\n        const range = childScaleComponent.get('range');\n\n        if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n          const domain = assembleDomain(this.childModel, channel);\n          const field = getFieldFromDomain(domain);\n          if (field) {\n            childIndependentFieldsWithStep[channel] = field;\n          } else {\n            log.warn(log.message.unknownField(channel));\n          }\n        }\n      }\n    }\n\n    return childIndependentFieldsWithStep;\n  }\n\n  private assembleRowColumnHeaderData(\n    channel: 'row' | 'column' | 'facet',\n    crossedDataName: string,\n    childIndependentFieldsWithStep: ChildIndependentFieldsWithStep\n  ): VgData {\n    const childChannel = {row: 'y', column: 'x', facet: undefined}[channel];\n\n    const fields: string[] = [];\n    const ops: AggregateOp[] = [];\n    const as: string[] = [];\n\n    if (childChannel && childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {\n      if (crossedDataName) {\n        // If there is a crossed data, calculate max\n        fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n\n        ops.push('max');\n      } else {\n        // If there is no crossed data, just calculate distinct\n        fields.push(childIndependentFieldsWithStep[childChannel]);\n        ops.push('distinct');\n      }\n      // Although it is technically a max, just name it distinct so it's easier to refer to it\n      as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n    }\n\n    const {sortField, sortIndexField} = this[channel];\n    if (sortField) {\n      const {op = DEFAULT_SORT_OP, field} = sortField;\n      fields.push(field);\n      ops.push(op);\n      as.push(vgField(sortField, {forAs: true}));\n    } else if (sortIndexField) {\n      fields.push(sortIndexField);\n      ops.push('max');\n      as.push(sortIndexField);\n    }\n\n    return {\n      name: this[channel].name,\n      // Use data from the crossed one if it exist\n      source: crossedDataName ?? this.data,\n      transform: [\n        {\n          type: 'aggregate',\n          groupby: this[channel].fields,\n          ...(fields.length\n            ? {\n                fields,\n                ops,\n                as\n              }\n            : {})\n        }\n      ]\n    };\n  }\n\n  private assembleFacetHeaderData(childIndependentFieldsWithStep: ChildIndependentFieldsWithStep) {\n    const {columns} = this.model.layout;\n    const {layoutHeaders} = this.model.component;\n    const data: VgData[] = [];\n\n    const hasSharedAxis: {row?: true; column?: true} = {};\n    for (const headerChannel of HEADER_CHANNELS) {\n      for (const headerType of HEADER_TYPES) {\n        const headers = (layoutHeaders[headerChannel] && layoutHeaders[headerChannel][headerType]) ?? [];\n        for (const header of headers) {\n          if (header.axes?.length > 0) {\n            hasSharedAxis[headerChannel] = true;\n            break;\n          }\n        }\n      }\n\n      if (hasSharedAxis[headerChannel]) {\n        const cardinality = `length(data(\"${this.facet.name}\"))`;\n\n        const stop =\n          headerChannel === 'row'\n            ? columns\n              ? {signal: `ceil(${cardinality} / ${columns})`}\n              : 1\n            : columns\n            ? {signal: `min(${cardinality}, ${columns})`}\n            : {signal: cardinality};\n\n        data.push({\n          name: `${this.facet.name}_${headerChannel}`,\n          transform: [\n            {\n              type: 'sequence',\n              start: 0,\n              stop\n            }\n          ]\n        });\n      }\n    }\n\n    const {row, column} = hasSharedAxis;\n\n    if (row || column) {\n      data.unshift(this.assembleRowColumnHeaderData('facet', null, childIndependentFieldsWithStep));\n    }\n\n    return data;\n  }\n\n  public assemble() {\n    const data: VgData[] = [];\n    let crossedDataName = null;\n    const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();\n\n    const {column, row, facet} = this;\n\n    if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {\n      // Need to create a cross dataset to correctly calculate cardinality\n      crossedDataName = `cross_${this.column.name}_${this.row.name}`;\n\n      const fields: string[] = [].concat(\n        childIndependentFieldsWithStep.x ?? [],\n        childIndependentFieldsWithStep.y ?? []\n      );\n      const ops = fields.map((): AggregateOp => 'distinct');\n\n      data.push({\n        name: crossedDataName,\n        source: this.data,\n        transform: [\n          {\n            type: 'aggregate',\n            groupby: this.fields,\n            fields,\n            ops\n          }\n        ]\n      });\n    }\n\n    for (const channel of [COLUMN, ROW]) {\n      if (this[channel]) {\n        data.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));\n      }\n    }\n\n    if (facet) {\n      const facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);\n      if (facetData) {\n        data.push(...facetData);\n      }\n    }\n\n    return data;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}