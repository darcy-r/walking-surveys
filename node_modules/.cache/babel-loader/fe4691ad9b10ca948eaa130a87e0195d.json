{"ast":null,"code":"import { isString } from 'vega';\nimport { stringValue } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { SELECTION_ID } from '../../selection';\nimport { vals } from '../../util';\nimport { isFacetModel } from '../model';\nimport interval from './interval';\nimport point from './point';\nimport clear from './clear';\nimport inputs from './inputs';\nimport nearest from './nearest';\nimport project from './project';\nimport scales from './scales';\nimport legends from './legends';\nimport toggle from './toggle';\nimport translate from './translate';\nimport zoom from './zoom';\nexport const STORE = '_store';\nexport const TUPLE = '_tuple';\nexport const MODIFY = '_modify';\nexport const SELECTION_DOMAIN = '_selection_domain_';\nexport const VL_SELECTION_RESOLVE = 'vlSelectionResolve'; // Order matters for parsing and assembly.\n\nexport const selectionCompilers = [point, interval, project, toggle, // Bindings may disable direct manipulation.\ninputs, scales, legends, clear, translate, zoom, nearest];\n\nfunction getFacetModel(model) {\n  let parent = model.parent;\n\n  while (parent) {\n    if (isFacetModel(parent)) break;\n    parent = parent.parent;\n  }\n\n  return parent;\n}\n\nexport function unitName(model) {\n  let {\n    escape\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    escape: true\n  };\n  let name = escape ? stringValue(model.name) : model.name;\n  const facetModel = getFacetModel(model);\n\n  if (facetModel) {\n    const {\n      facet\n    } = facetModel;\n\n    for (const channel of FACET_CHANNELS) {\n      if (facet[channel]) {\n        name += ` + '__facet_${channel}_' + (facet[${stringValue(facetModel.vgField(channel))}])`;\n      }\n    }\n  }\n\n  return name;\n}\nexport function requiresSelectionId(model) {\n  var _a;\n\n  return vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {}).reduce((identifier, selCmpt) => {\n    return identifier || selCmpt.project.items.some(proj => proj.field === SELECTION_ID);\n  }, false);\n} // Binding a point selection to query widgets or legends disables default direct manipulation interaction.\n// A user can choose to re-enable it by explicitly specifying triggering input events.\n\nexport function disableDirectManipulation(selCmpt, selDef) {\n  if (isString(selDef.select) || !selDef.select.on) delete selCmpt.events;\n  if (isString(selDef.select) || !selDef.select.clear) delete selCmpt.clear;\n  if (isString(selDef.select) || !selDef.select.toggle) delete selCmpt.toggle;\n}","map":{"version":3,"mappings":"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","names":["isString","stringValue","FACET_CHANNELS","SELECTION_ID","vals","isFacetModel","interval","point","clear","inputs","nearest","project","scales","legends","toggle","translate","zoom","STORE","TUPLE","MODIFY","SELECTION_DOMAIN","VL_SELECTION_RESOLVE","selectionCompilers","getFacetModel","model","parent","unitName","escape","name","facetModel","facet","channel","vgField","requiresSelectionId","component","selection","_a","reduce","identifier","selCmpt","items","some","proj","field","disableDirectManipulation","selDef","select","on","events"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/selection/index.ts"],"sourcesContent":["import {Binding, isString, NewSignal, Signal, Stream} from 'vega';\nimport {stringValue} from 'vega-util';\nimport {FACET_CHANNELS} from '../../channel';\nimport {\n  BrushConfig,\n  LegendBinding,\n  SelectionInit,\n  SelectionInitInterval,\n  SelectionResolution,\n  SelectionType,\n  SELECTION_ID\n} from '../../selection';\nimport {Dict, vals} from '../../util';\nimport {OutputNode} from '../data/dataflow';\nimport {FacetModel} from '../facet';\nimport {isFacetModel, Model} from '../model';\nimport {UnitModel} from '../unit';\nimport interval from './interval';\nimport point from './point';\nimport {SelectionProjection, SelectionProjectionComponent} from './project';\nimport {SelectionParameter} from '../../selection';\nimport clear from './clear';\nimport inputs from './inputs';\nimport nearest from './nearest';\nimport project from './project';\nimport scales from './scales';\nimport legends from './legends';\nimport toggle from './toggle';\nimport translate from './translate';\nimport zoom from './zoom';\nimport {ParameterName} from '../../parameter';\n\nexport const STORE = '_store';\nexport const TUPLE = '_tuple';\nexport const MODIFY = '_modify';\nexport const SELECTION_DOMAIN = '_selection_domain_';\nexport const VL_SELECTION_RESOLVE = 'vlSelectionResolve';\n\nexport interface SelectionComponent<T extends SelectionType = SelectionType> {\n  name: ParameterName;\n  type: T;\n  // Use conditional types for stricter type of init (as the type of init depends on selection type).\n  init?: (T extends 'interval' ? SelectionInitInterval : T extends 'point' ? SelectionInit : never)[][];\n  events: Stream[];\n  materialized: OutputNode;\n  bind?: 'scales' | Binding | Dict<Binding> | LegendBinding;\n  resolve: SelectionResolution;\n  mark?: BrushConfig;\n\n  // Transforms\n  project: SelectionProjectionComponent;\n  scales?: SelectionProjection[];\n  toggle?: string;\n  translate?: any;\n  zoom?: any;\n  nearest?: any;\n  clear?: any;\n}\n\nexport interface SelectionCompiler<T extends SelectionType = SelectionType> {\n  defined: (selCmpt: SelectionComponent) => boolean;\n  parse?: (model: UnitModel, selCmpt: SelectionComponent<T>, def: SelectionParameter<T>) => void;\n  signals?: (model: UnitModel, selCmpt: SelectionComponent<T>, signals: NewSignal[]) => Signal[]; // the output can be a new or a push signal\n  topLevelSignals?: (model: Model, selCmpt: SelectionComponent<T>, signals: NewSignal[]) => NewSignal[];\n  modifyExpr?: (model: UnitModel, selCmpt: SelectionComponent<T>, expr: string) => string;\n  marks?: (model: UnitModel, selCmpt: SelectionComponent<T>, marks: any[]) => any[];\n}\n\n// Order matters for parsing and assembly.\nexport const selectionCompilers: SelectionCompiler[] = [\n  point,\n  interval,\n  project,\n  toggle,\n\n  // Bindings may disable direct manipulation.\n  inputs,\n  scales,\n  legends,\n\n  clear,\n  translate,\n  zoom,\n  nearest\n];\n\nfunction getFacetModel(model: Model): FacetModel {\n  let parent = model.parent;\n  while (parent) {\n    if (isFacetModel(parent)) break;\n    parent = parent.parent;\n  }\n\n  return parent as FacetModel;\n}\n\nexport function unitName(model: Model, {escape} = {escape: true}) {\n  let name = escape ? stringValue(model.name) : model.name;\n  const facetModel = getFacetModel(model);\n  if (facetModel) {\n    const {facet} = facetModel;\n    for (const channel of FACET_CHANNELS) {\n      if (facet[channel]) {\n        name += ` + '__facet_${channel}_' + (facet[${stringValue(facetModel.vgField(channel))}])`;\n      }\n    }\n  }\n  return name;\n}\n\nexport function requiresSelectionId(model: Model) {\n  return vals(model.component.selection ?? {}).reduce((identifier, selCmpt) => {\n    return identifier || selCmpt.project.items.some(proj => proj.field === SELECTION_ID);\n  }, false);\n}\n\n// Binding a point selection to query widgets or legends disables default direct manipulation interaction.\n// A user can choose to re-enable it by explicitly specifying triggering input events.\nexport function disableDirectManipulation(selCmpt: SelectionComponent, selDef: SelectionParameter<'point'>) {\n  if (isString(selDef.select) || !selDef.select.on) delete selCmpt.events;\n  if (isString(selDef.select) || !selDef.select.clear) delete selCmpt.clear;\n  if (isString(selDef.select) || !selDef.select.toggle) delete selCmpt.toggle;\n}\n"]},"metadata":{},"sourceType":"module"}