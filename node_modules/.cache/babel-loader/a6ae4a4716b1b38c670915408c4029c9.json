{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { valueExpr, vgField } from './channeldef';\nimport { fieldExpr as timeUnitFieldExpr, normalizeTimeUnit } from './timeunit';\nimport { stringify } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function isSelectionPredicate(predicate) {\n  return predicate === null || predicate === void 0 ? void 0 : predicate['param'];\n}\nexport function isFieldEqualPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.equal !== undefined;\n}\nexport function isFieldLTPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.lt !== undefined;\n}\nexport function isFieldLTEPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.lte !== undefined;\n}\nexport function isFieldGTPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.gt !== undefined;\n}\nexport function isFieldGTEPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.gte !== undefined;\n}\nexport function isFieldRangePredicate(predicate) {\n  if (predicate === null || predicate === void 0 ? void 0 : predicate.field) {\n    if (isArray(predicate.range) && predicate.range.length === 2) {\n      return true;\n    } else if (isSignalRef(predicate.range)) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexport function isFieldOneOfPredicate(predicate) {\n  return predicate && !!predicate.field && (isArray(predicate.oneOf) || isArray(predicate.in)) // backward compatibility\n  ;\n}\nexport function isFieldValidPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.valid !== undefined;\n}\nexport function isFieldPredicate(predicate) {\n  return isFieldOneOfPredicate(predicate) || isFieldEqualPredicate(predicate) || isFieldRangePredicate(predicate) || isFieldLTPredicate(predicate) || isFieldGTPredicate(predicate) || isFieldLTEPredicate(predicate) || isFieldGTEPredicate(predicate);\n}\n\nfunction predicateValueExpr(v, timeUnit) {\n  return valueExpr(v, {\n    timeUnit,\n    wrapTime: true\n  });\n}\n\nfunction predicateValuesExpr(vals, timeUnit) {\n  return vals.map(v => predicateValueExpr(v, timeUnit));\n} // This method is used by Voyager. Do not change its behavior without changing Voyager.\n\n\nexport function fieldFilterExpression(predicate) {\n  let useInRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  var _a;\n\n  const {\n    field\n  } = predicate;\n  const timeUnit = (_a = normalizeTimeUnit(predicate.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;\n  const fieldExpr = timeUnit ? // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.\n  // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline\n  // TODO: support utc\n  `time(${timeUnitFieldExpr(timeUnit, field)})` : vgField(predicate, {\n    expr: 'datum'\n  });\n\n  if (isFieldEqualPredicate(predicate)) {\n    return `${fieldExpr}===${predicateValueExpr(predicate.equal, timeUnit)}`;\n  } else if (isFieldLTPredicate(predicate)) {\n    const upper = predicate.lt;\n    return `${fieldExpr}<${predicateValueExpr(upper, timeUnit)}`;\n  } else if (isFieldGTPredicate(predicate)) {\n    const lower = predicate.gt;\n    return `${fieldExpr}>${predicateValueExpr(lower, timeUnit)}`;\n  } else if (isFieldLTEPredicate(predicate)) {\n    const upper = predicate.lte;\n    return `${fieldExpr}<=${predicateValueExpr(upper, timeUnit)}`;\n  } else if (isFieldGTEPredicate(predicate)) {\n    const lower = predicate.gte;\n    return `${fieldExpr}>=${predicateValueExpr(lower, timeUnit)}`;\n  } else if (isFieldOneOfPredicate(predicate)) {\n    return `indexof([${predicateValuesExpr(predicate.oneOf, timeUnit).join(',')}], ${fieldExpr}) !== -1`;\n  } else if (isFieldValidPredicate(predicate)) {\n    return fieldValidPredicate(fieldExpr, predicate.valid);\n  } else if (isFieldRangePredicate(predicate)) {\n    const {\n      range\n    } = predicate;\n    const lower = isSignalRef(range) ? {\n      signal: `${range.signal}[0]`\n    } : range[0];\n    const upper = isSignalRef(range) ? {\n      signal: `${range.signal}[1]`\n    } : range[1];\n\n    if (lower !== null && upper !== null && useInRange) {\n      return 'inrange(' + fieldExpr + ', [' + predicateValueExpr(lower, timeUnit) + ', ' + predicateValueExpr(upper, timeUnit) + '])';\n    }\n\n    const exprs = [];\n\n    if (lower !== null) {\n      exprs.push(`${fieldExpr} >= ${predicateValueExpr(lower, timeUnit)}`);\n    }\n\n    if (upper !== null) {\n      exprs.push(`${fieldExpr} <= ${predicateValueExpr(upper, timeUnit)}`);\n    }\n\n    return exprs.length > 0 ? exprs.join(' && ') : 'true';\n  }\n  /* istanbul ignore next: it should never reach here */\n\n\n  throw new Error(`Invalid field predicate: ${stringify(predicate)}`);\n}\nexport function fieldValidPredicate(fieldExpr) {\n  let valid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (valid) {\n    return `isValid(${fieldExpr}) && isFinite(+${fieldExpr})`;\n  } else {\n    return `!isValid(${fieldExpr}) || !isFinite(+${fieldExpr})`;\n  }\n}\nexport function normalizePredicate(f) {\n  var _a;\n\n  if (isFieldPredicate(f) && f.timeUnit) {\n    return Object.assign(Object.assign({}, f), {\n      timeUnit: (_a = normalizeTimeUnit(f.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit\n    });\n  }\n\n  return f;\n}","map":{"version":3,"mappings":"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","names":["isArray","valueExpr","vgField","fieldExpr","timeUnitFieldExpr","normalizeTimeUnit","stringify","isSignalRef","isSelectionPredicate","predicate","isFieldEqualPredicate","field","equal","undefined","isFieldLTPredicate","lt","isFieldLTEPredicate","lte","isFieldGTPredicate","gt","isFieldGTEPredicate","gte","isFieldRangePredicate","range","length","isFieldOneOfPredicate","oneOf","in","isFieldValidPredicate","valid","isFieldPredicate","predicateValueExpr","v","timeUnit","wrapTime","predicateValuesExpr","vals","map","fieldFilterExpression","useInRange","_a","unit","expr","upper","lower","join","fieldValidPredicate","signal","exprs","push","Error","normalizePredicate","f"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/predicate.ts"],"sourcesContent":["import {SignalRef} from 'vega';\nimport {isArray} from 'vega-util';\nimport {FieldName, valueExpr, vgField} from './channeldef';\nimport {DateTime} from './datetime';\nimport {ExprRef} from './expr';\nimport {LogicalComposition} from './logical';\nimport {ParameterName} from './parameter';\nimport {fieldExpr as timeUnitFieldExpr, normalizeTimeUnit, TimeUnit, TimeUnitParams} from './timeunit';\nimport {stringify} from './util';\nimport {isSignalRef} from './vega.schema';\n\nexport type Predicate =\n  // a) FieldPredicate (but we don't type FieldFilter here so the schema has no nesting\n  // and thus the documentation shows all of the types clearly)\n  | FieldEqualPredicate\n  | FieldRangePredicate\n  | FieldOneOfPredicate\n  | FieldLTPredicate\n  | FieldGTPredicate\n  | FieldLTEPredicate\n  | FieldGTEPredicate\n  | FieldValidPredicate\n  // b) Selection Predicate\n  | ParameterPredicate\n  // c) Vega Expression string\n  | string;\n\nexport type FieldPredicate =\n  | FieldEqualPredicate\n  | FieldLTPredicate\n  | FieldGTPredicate\n  | FieldLTEPredicate\n  | FieldGTEPredicate\n  | FieldRangePredicate\n  | FieldOneOfPredicate\n  | FieldValidPredicate;\n\nexport interface ParameterPredicate {\n  /**\n   * Filter using a parameter name.\n   */\n  param: ParameterName;\n  /**\n   * For selection parameters, the predicate of empty selections returns true by default.\n   * Override this behavior, by setting this property `empty: false`.\n   */\n  empty?: boolean;\n}\n\nexport function isSelectionPredicate(predicate: LogicalComposition<Predicate>): predicate is ParameterPredicate {\n  return predicate?.['param'];\n}\n\nexport interface FieldPredicateBase {\n  // TODO: support aggregate\n\n  /**\n   * Time unit for the field to be tested.\n   */\n  timeUnit?: TimeUnit | TimeUnitParams;\n\n  /**\n   * Field to be tested.\n   */\n  field: FieldName;\n}\n\nexport interface FieldEqualPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be equal to.\n   */\n  equal: string | number | boolean | DateTime | ExprRef | SignalRef;\n}\n\nexport function isFieldEqualPredicate(predicate: any): predicate is FieldEqualPredicate {\n  return predicate && !!predicate.field && predicate.equal !== undefined;\n}\n\nexport interface FieldLTPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be less than.\n   */\n  lt: string | number | DateTime | ExprRef | SignalRef;\n}\n\nexport function isFieldLTPredicate(predicate: any): predicate is FieldLTPredicate {\n  return predicate && !!predicate.field && predicate.lt !== undefined;\n}\n\nexport interface FieldLTEPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be less than or equals to.\n   */\n  lte: string | number | DateTime | ExprRef | SignalRef;\n}\n\nexport function isFieldLTEPredicate(predicate: any): predicate is FieldLTEPredicate {\n  return predicate && !!predicate.field && predicate.lte !== undefined;\n}\n\nexport interface FieldGTPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be greater than.\n   */\n  gt: string | number | DateTime | ExprRef | SignalRef;\n}\n\nexport function isFieldGTPredicate(predicate: any): predicate is FieldGTPredicate {\n  return predicate && !!predicate.field && predicate.gt !== undefined;\n}\n\nexport interface FieldGTEPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be greater than or equals to.\n   */\n  gte: string | number | DateTime | ExprRef | SignalRef;\n}\n\nexport function isFieldGTEPredicate(predicate: any): predicate is FieldGTEPredicate {\n  return predicate && !!predicate.field && predicate.gte !== undefined;\n}\n\nexport interface FieldRangePredicate extends FieldPredicateBase {\n  /**\n   * An array of inclusive minimum and maximum values\n   * for a field value of a data item to be included in the filtered data.\n   * @maxItems 2\n   * @minItems 2\n   */\n  range: (number | DateTime | null | ExprRef | SignalRef)[] | ExprRef | SignalRef;\n}\n\nexport function isFieldRangePredicate(predicate: any): predicate is FieldRangePredicate {\n  if (predicate?.field) {\n    if (isArray(predicate.range) && predicate.range.length === 2) {\n      return true;\n    } else if (isSignalRef(predicate.range)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport interface FieldOneOfPredicate extends FieldPredicateBase {\n  /**\n   * A set of values that the `field`'s value should be a member of,\n   * for a data item included in the filtered data.\n   */\n  oneOf: string[] | number[] | boolean[] | DateTime[];\n}\n\nexport interface FieldValidPredicate extends FieldPredicateBase {\n  /**\n   * If set to true the field's value has to be valid, meaning both not `null` and not [`NaN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN).\n   */\n  valid: boolean;\n}\n\nexport function isFieldOneOfPredicate(predicate: any): predicate is FieldOneOfPredicate {\n  return (\n    predicate && !!predicate.field && (isArray(predicate.oneOf) || isArray(predicate.in)) // backward compatibility\n  );\n}\n\nexport function isFieldValidPredicate(predicate: any): predicate is FieldValidPredicate {\n  return predicate && !!predicate.field && predicate.valid !== undefined;\n}\n\nexport function isFieldPredicate(\n  predicate: Predicate\n): predicate is\n  | FieldOneOfPredicate\n  | FieldEqualPredicate\n  | FieldRangePredicate\n  | FieldLTPredicate\n  | FieldGTPredicate\n  | FieldLTEPredicate\n  | FieldGTEPredicate {\n  return (\n    isFieldOneOfPredicate(predicate) ||\n    isFieldEqualPredicate(predicate) ||\n    isFieldRangePredicate(predicate) ||\n    isFieldLTPredicate(predicate) ||\n    isFieldGTPredicate(predicate) ||\n    isFieldLTEPredicate(predicate) ||\n    isFieldGTEPredicate(predicate)\n  );\n}\n\nfunction predicateValueExpr(v: number | string | boolean | DateTime | ExprRef | SignalRef, timeUnit: TimeUnit) {\n  return valueExpr(v, {timeUnit, wrapTime: true});\n}\n\nfunction predicateValuesExpr(vals: (number | string | boolean | DateTime)[], timeUnit: TimeUnit) {\n  return vals.map(v => predicateValueExpr(v, timeUnit));\n}\n\n// This method is used by Voyager. Do not change its behavior without changing Voyager.\nexport function fieldFilterExpression(predicate: FieldPredicate, useInRange = true) {\n  const {field} = predicate;\n  const timeUnit = normalizeTimeUnit(predicate.timeUnit)?.unit;\n  const fieldExpr = timeUnit\n    ? // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.\n      // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline\n      // TODO: support utc\n      `time(${timeUnitFieldExpr(timeUnit, field)})`\n    : vgField(predicate, {expr: 'datum'});\n\n  if (isFieldEqualPredicate(predicate)) {\n    return `${fieldExpr}===${predicateValueExpr(predicate.equal, timeUnit)}`;\n  } else if (isFieldLTPredicate(predicate)) {\n    const upper = predicate.lt;\n    return `${fieldExpr}<${predicateValueExpr(upper, timeUnit)}`;\n  } else if (isFieldGTPredicate(predicate)) {\n    const lower = predicate.gt;\n    return `${fieldExpr}>${predicateValueExpr(lower, timeUnit)}`;\n  } else if (isFieldLTEPredicate(predicate)) {\n    const upper = predicate.lte;\n    return `${fieldExpr}<=${predicateValueExpr(upper, timeUnit)}`;\n  } else if (isFieldGTEPredicate(predicate)) {\n    const lower = predicate.gte;\n    return `${fieldExpr}>=${predicateValueExpr(lower, timeUnit)}`;\n  } else if (isFieldOneOfPredicate(predicate)) {\n    return `indexof([${predicateValuesExpr(predicate.oneOf, timeUnit).join(',')}], ${fieldExpr}) !== -1`;\n  } else if (isFieldValidPredicate(predicate)) {\n    return fieldValidPredicate(fieldExpr, predicate.valid);\n  } else if (isFieldRangePredicate(predicate)) {\n    const {range} = predicate;\n    const lower = isSignalRef(range) ? {signal: `${range.signal}[0]`} : range[0];\n    const upper = isSignalRef(range) ? {signal: `${range.signal}[1]`} : range[1];\n\n    if (lower !== null && upper !== null && useInRange) {\n      return (\n        'inrange(' +\n        fieldExpr +\n        ', [' +\n        predicateValueExpr(lower, timeUnit) +\n        ', ' +\n        predicateValueExpr(upper, timeUnit) +\n        '])'\n      );\n    }\n\n    const exprs = [];\n    if (lower !== null) {\n      exprs.push(`${fieldExpr} >= ${predicateValueExpr(lower, timeUnit)}`);\n    }\n    if (upper !== null) {\n      exprs.push(`${fieldExpr} <= ${predicateValueExpr(upper, timeUnit)}`);\n    }\n\n    return exprs.length > 0 ? exprs.join(' && ') : 'true';\n  }\n\n  /* istanbul ignore next: it should never reach here */\n  throw new Error(`Invalid field predicate: ${stringify(predicate)}`);\n}\n\nexport function fieldValidPredicate(fieldExpr: string, valid = true) {\n  if (valid) {\n    return `isValid(${fieldExpr}) && isFinite(+${fieldExpr})`;\n  } else {\n    return `!isValid(${fieldExpr}) || !isFinite(+${fieldExpr})`;\n  }\n}\n\nexport function normalizePredicate(f: Predicate): Predicate {\n  if (isFieldPredicate(f) && f.timeUnit) {\n    return {\n      ...f,\n      timeUnit: normalizeTimeUnit(f.timeUnit)?.unit\n    };\n  }\n  return f;\n}\n"]},"metadata":{},"sourceType":"module"}