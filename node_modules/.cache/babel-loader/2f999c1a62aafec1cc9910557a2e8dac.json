{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isString } from 'vega-util';\nimport { binToString, isBinning, isParameterExtent } from '../../bin';\nimport { binRequiresRange, isTypedFieldDef, normalizeBin, vgField } from '../../channeldef';\nimport { duplicate, hash, isEmpty, keys, replacePathInField, unique, vals } from '../../util';\nimport { binFormatExpression } from '../format';\nimport { isUnitModel } from '../model';\nimport { parseSelectionExtent } from '../selection/parse';\nimport { DataFlowNode } from './dataflow';\n\nfunction rangeFormula(model, fieldDef, channel, config) {\n  var _a, _b;\n\n  if (binRequiresRange(fieldDef, channel)) {\n    // read format from axis or legend, if there is no format then use config.numberFormat\n    const guide = isUnitModel(model) ? (_b = (_a = model.axis(channel)) !== null && _a !== void 0 ? _a : model.legend(channel)) !== null && _b !== void 0 ? _b : {} : {};\n    const startField = vgField(fieldDef, {\n      expr: 'datum'\n    });\n    const endField = vgField(fieldDef, {\n      expr: 'datum',\n      binSuffix: 'end'\n    });\n    return {\n      formulaAs: vgField(fieldDef, {\n        binSuffix: 'range',\n        forAs: true\n      }),\n      formula: binFormatExpression(startField, endField, guide.format, guide.formatType, config)\n    };\n  }\n\n  return {};\n}\n\nfunction binKey(bin, field) {\n  return `${binToString(bin)}_${field}`;\n}\n\nfunction getSignalsFromModel(model, key) {\n  return {\n    signal: model.getName(`${key}_bins`),\n    extentSignal: model.getName(`${key}_extent`)\n  };\n}\n\nexport function getBinSignalName(model, field, bin) {\n  var _a;\n\n  const normalizedBin = (_a = normalizeBin(bin, undefined)) !== null && _a !== void 0 ? _a : {};\n  const key = binKey(normalizedBin, field);\n  return model.getName(`${key}_bins`);\n}\n\nfunction isBinTransform(t) {\n  return 'as' in t;\n}\n\nfunction createBinComponent(t, bin, model) {\n  let as;\n  let span;\n\n  if (isBinTransform(t)) {\n    as = isString(t.as) ? [t.as, `${t.as}_end`] : [t.as[0], t.as[1]];\n  } else {\n    as = [vgField(t, {\n      forAs: true\n    }), vgField(t, {\n      binSuffix: 'end',\n      forAs: true\n    })];\n  }\n\n  const normalizedBin = Object.assign({}, normalizeBin(bin, undefined));\n  const key = binKey(normalizedBin, t.field);\n  const {\n    signal,\n    extentSignal\n  } = getSignalsFromModel(model, key);\n\n  if (isParameterExtent(normalizedBin.extent)) {\n    const ext = normalizedBin.extent;\n    span = parseSelectionExtent(model, ext.param, ext);\n    delete normalizedBin.extent; // Vega-Lite selection extent map to Vega's span property.\n  }\n\n  const binComponent = Object.assign(Object.assign(Object.assign({\n    bin: normalizedBin,\n    field: t.field,\n    as: [as]\n  }, signal ? {\n    signal\n  } : {}), extentSignal ? {\n    extentSignal\n  } : {}), span ? {\n    span\n  } : {});\n  return {\n    key,\n    binComponent\n  };\n}\n\nexport class BinNode extends DataFlowNode {\n  constructor(parent, bins) {\n    super(parent);\n    this.bins = bins;\n  }\n\n  clone() {\n    return new BinNode(null, duplicate(this.bins));\n  }\n\n  static makeFromEncoding(parent, model) {\n    const bins = model.reduceFieldDef((binComponentIndex, fieldDef, channel) => {\n      if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n        const {\n          key,\n          binComponent\n        } = createBinComponent(fieldDef, fieldDef.bin, model);\n        binComponentIndex[key] = Object.assign(Object.assign(Object.assign({}, binComponent), binComponentIndex[key]), rangeFormula(model, fieldDef, channel, model.config));\n      }\n\n      return binComponentIndex;\n    }, {});\n\n    if (isEmpty(bins)) {\n      return null;\n    }\n\n    return new BinNode(parent, bins);\n  }\n  /**\n   * Creates a bin node from BinTransform.\n   * The optional parameter should provide\n   */\n\n\n  static makeFromTransform(parent, t, model) {\n    const {\n      key,\n      binComponent\n    } = createBinComponent(t, t.bin, model);\n    return new BinNode(parent, {\n      [key]: binComponent\n    });\n  }\n  /**\n   * Merge bin nodes. This method either integrates the bin config from the other node\n   * or if this node already has a bin config, renames the corresponding signal in the model.\n   */\n\n\n  merge(other, renameSignal) {\n    for (const key of keys(other.bins)) {\n      if (key in this.bins) {\n        renameSignal(other.bins[key].signal, this.bins[key].signal); // Ensure that we don't have duplicate names for signal pairs\n\n        this.bins[key].as = unique([...this.bins[key].as, ...other.bins[key].as], hash);\n      } else {\n        this.bins[key] = other.bins[key];\n      }\n    }\n\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n\n    other.remove();\n  }\n\n  producedFields() {\n    return new Set(vals(this.bins).map(c => c.as).flat(2));\n  }\n\n  dependentFields() {\n    return new Set(vals(this.bins).map(c => c.field));\n  }\n\n  hash() {\n    return `Bin ${hash(this.bins)}`;\n  }\n\n  assemble() {\n    return vals(this.bins).flatMap(bin => {\n      const transform = [];\n      const [binAs, ...remainingAs] = bin.as;\n\n      const _a = bin.bin,\n            {\n        extent\n      } = _a,\n            params = __rest(_a, [\"extent\"]);\n\n      const binTrans = Object.assign(Object.assign(Object.assign({\n        type: 'bin',\n        field: replacePathInField(bin.field),\n        as: binAs,\n        signal: bin.signal\n      }, !isParameterExtent(extent) ? {\n        extent\n      } : {\n        extent: null\n      }), bin.span ? {\n        span: {\n          signal: `span(${bin.span})`\n        }\n      } : {}), params);\n\n      if (!extent && bin.extentSignal) {\n        transform.push({\n          type: 'extent',\n          field: replacePathInField(bin.field),\n          signal: bin.extentSignal\n        });\n        binTrans.extent = {\n          signal: bin.extentSignal\n        };\n      }\n\n      transform.push(binTrans);\n\n      for (const as of remainingAs) {\n        for (let i = 0; i < 2; i++) {\n          transform.push({\n            type: 'formula',\n            expr: vgField({\n              field: binAs[i]\n            }, {\n              expr: 'datum'\n            }),\n            as: as[i]\n          });\n        }\n      }\n\n      if (bin.formula) {\n        transform.push({\n          type: 'formula',\n          expr: bin.formula,\n          as: bin.formulaAs\n        });\n      }\n\n      return transform;\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["isString","binToString","isBinning","isParameterExtent","binRequiresRange","isTypedFieldDef","normalizeBin","vgField","duplicate","hash","isEmpty","keys","replacePathInField","unique","vals","binFormatExpression","isUnitModel","parseSelectionExtent","DataFlowNode","rangeFormula","model","fieldDef","channel","config","guide","axis","_a","legend","_b","startField","expr","endField","binSuffix","formulaAs","forAs","formula","format","formatType","binKey","bin","field","getSignalsFromModel","key","signal","getName","extentSignal","getBinSignalName","normalizedBin","undefined","isBinTransform","t","createBinComponent","as","span","extent","ext","param","binComponent","BinNode","constructor","parent","bins","clone","makeFromEncoding","reduceFieldDef","binComponentIndex","Object","makeFromTransform","merge","other","renameSignal","child","children","removeChild","remove","producedFields","Set","map","c","flat","dependentFields","assemble","flatMap","transform","binAs","remainingAs","params","binTrans","type","push","i"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/data/bin.ts"],"sourcesContent":["import {BinTransform as VgBinTransform, Transforms as VgTransform} from 'vega';\nimport {isString} from 'vega-util';\nimport {BinParams, binToString, isBinning, isParameterExtent} from '../../bin';\nimport {Channel} from '../../channel';\nimport {binRequiresRange, FieldName, isTypedFieldDef, normalizeBin, TypedFieldDef, vgField} from '../../channeldef';\nimport {Config} from '../../config';\nimport {BinTransform} from '../../transform';\nimport {Dict, duplicate, hash, isEmpty, keys, replacePathInField, unique, vals} from '../../util';\nimport {binFormatExpression} from '../format';\nimport {isUnitModel, Model, ModelWithField} from '../model';\nimport {parseSelectionExtent} from '../selection/parse';\nimport {NonPositionScaleChannel, PositionChannel} from './../../channel';\nimport {DataFlowNode} from './dataflow';\n\nfunction rangeFormula(model: ModelWithField, fieldDef: TypedFieldDef<string>, channel: Channel, config: Config) {\n  if (binRequiresRange(fieldDef, channel)) {\n    // read format from axis or legend, if there is no format then use config.numberFormat\n\n    const guide = isUnitModel(model)\n      ? model.axis(channel as PositionChannel) ?? model.legend(channel as NonPositionScaleChannel) ?? {}\n      : {};\n\n    const startField = vgField(fieldDef, {expr: 'datum'});\n    const endField = vgField(fieldDef, {expr: 'datum', binSuffix: 'end'});\n\n    return {\n      formulaAs: vgField(fieldDef, {binSuffix: 'range', forAs: true}),\n      formula: binFormatExpression(startField, endField, guide.format, guide.formatType, config)\n    };\n  }\n  return {};\n}\n\nfunction binKey(bin: BinParams, field: string) {\n  return `${binToString(bin)}_${field}`;\n}\n\nfunction getSignalsFromModel(model: Model, key: string) {\n  return {\n    signal: model.getName(`${key}_bins`),\n    extentSignal: model.getName(`${key}_extent`)\n  };\n}\n\nexport function getBinSignalName(model: Model, field: string, bin: boolean | BinParams) {\n  const normalizedBin = normalizeBin(bin, undefined) ?? {};\n  const key = binKey(normalizedBin, field);\n  return model.getName(`${key}_bins`);\n}\n\nfunction isBinTransform(t: TypedFieldDef<string> | BinTransform): t is BinTransform {\n  return 'as' in t;\n}\n\nfunction createBinComponent(t: TypedFieldDef<string> | BinTransform, bin: boolean | BinParams, model: Model) {\n  let as: [string, string];\n  let span: string;\n\n  if (isBinTransform(t)) {\n    as = isString(t.as) ? [t.as, `${t.as}_end`] : [t.as[0], t.as[1]];\n  } else {\n    as = [vgField(t, {forAs: true}), vgField(t, {binSuffix: 'end', forAs: true})];\n  }\n\n  const normalizedBin = {...normalizeBin(bin, undefined)};\n  const key = binKey(normalizedBin, t.field);\n  const {signal, extentSignal} = getSignalsFromModel(model, key);\n\n  if (isParameterExtent(normalizedBin.extent)) {\n    const ext = normalizedBin.extent;\n    span = parseSelectionExtent(model, ext.param, ext);\n    delete normalizedBin.extent; // Vega-Lite selection extent map to Vega's span property.\n  }\n\n  const binComponent: BinComponent = {\n    bin: normalizedBin,\n    field: t.field,\n    as: [as],\n    ...(signal ? {signal} : {}),\n    ...(extentSignal ? {extentSignal} : {}),\n    ...(span ? {span} : {})\n  };\n\n  return {key, binComponent};\n}\n\nexport interface BinComponent {\n  bin: BinParams;\n  field: FieldName;\n  extentSignal?: string;\n  signal?: string;\n  span?: string;\n\n  /** Pairs of strings of the names of start and end signals */\n  as: [string, string][];\n\n  // Range Formula\n\n  formula?: string;\n  formulaAs?: string;\n}\n\nexport class BinNode extends DataFlowNode {\n  public clone() {\n    return new BinNode(null, duplicate(this.bins));\n  }\n\n  constructor(parent: DataFlowNode, private bins: Dict<BinComponent>) {\n    super(parent);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: ModelWithField) {\n    const bins = model.reduceFieldDef((binComponentIndex: Dict<BinComponent>, fieldDef, channel) => {\n      if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n        const {key, binComponent} = createBinComponent(fieldDef, fieldDef.bin, model);\n        binComponentIndex[key] = {\n          ...binComponent,\n          ...binComponentIndex[key],\n          ...rangeFormula(model, fieldDef, channel, model.config)\n        };\n      }\n      return binComponentIndex;\n    }, {} as Dict<BinComponent>);\n\n    if (isEmpty(bins)) {\n      return null;\n    }\n\n    return new BinNode(parent, bins);\n  }\n\n  /**\n   * Creates a bin node from BinTransform.\n   * The optional parameter should provide\n   */\n  public static makeFromTransform(parent: DataFlowNode, t: BinTransform, model: Model) {\n    const {key, binComponent} = createBinComponent(t, t.bin, model);\n    return new BinNode(parent, {\n      [key]: binComponent\n    });\n  }\n\n  /**\n   * Merge bin nodes. This method either integrates the bin config from the other node\n   * or if this node already has a bin config, renames the corresponding signal in the model.\n   */\n  public merge(other: BinNode, renameSignal: (s1: string, s2: string) => void) {\n    for (const key of keys(other.bins)) {\n      if (key in this.bins) {\n        renameSignal(other.bins[key].signal, this.bins[key].signal);\n        // Ensure that we don't have duplicate names for signal pairs\n        this.bins[key].as = unique([...this.bins[key].as, ...other.bins[key].as], hash);\n      } else {\n        this.bins[key] = other.bins[key];\n      }\n    }\n\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n    other.remove();\n  }\n\n  public producedFields() {\n    return new Set(\n      vals(this.bins)\n        .map(c => c.as)\n        .flat(2)\n    );\n  }\n\n  public dependentFields() {\n    return new Set(vals(this.bins).map(c => c.field));\n  }\n\n  public hash() {\n    return `Bin ${hash(this.bins)}`;\n  }\n\n  public assemble(): VgTransform[] {\n    return vals(this.bins).flatMap(bin => {\n      const transform: VgTransform[] = [];\n\n      const [binAs, ...remainingAs] = bin.as;\n      const {extent, ...params} = bin.bin;\n      const binTrans: VgBinTransform = {\n        type: 'bin',\n        field: replacePathInField(bin.field),\n        as: binAs,\n        signal: bin.signal,\n        ...(!isParameterExtent(extent) ? {extent} : {extent: null}),\n        ...(bin.span ? {span: {signal: `span(${bin.span})`}} : {}),\n        ...params\n      };\n\n      if (!extent && bin.extentSignal) {\n        transform.push({\n          type: 'extent',\n          field: replacePathInField(bin.field),\n          signal: bin.extentSignal\n        });\n        binTrans.extent = {signal: bin.extentSignal};\n      }\n\n      transform.push(binTrans);\n\n      for (const as of remainingAs) {\n        for (let i = 0; i < 2; i++) {\n          transform.push({\n            type: 'formula',\n            expr: vgField({field: binAs[i]}, {expr: 'datum'}),\n            as: as[i]\n          });\n        }\n      }\n\n      if (bin.formula) {\n        transform.push({\n          type: 'formula',\n          expr: bin.formula,\n          as: bin.formulaAs\n        });\n      }\n      return transform;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}