{"ast":null,"code":"import { parseSelector } from 'vega-event-selector';\nimport { stringValue } from 'vega-util';\nimport { X, Y } from '../../channel';\nimport { BRUSH as INTERVAL_BRUSH } from './interval';\nimport { default as scalesCompiler, domain } from './scales';\nconst ANCHOR = '_zoom_anchor';\nconst DELTA = '_zoom_delta';\nconst zoom = {\n  defined: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.zoom;\n  },\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const hasScales = scalesCompiler.defined(selCmpt);\n    const delta = name + DELTA;\n    const {\n      x,\n      y\n    } = selCmpt.project.hasChannel;\n    const sx = stringValue(model.scaleName(X));\n    const sy = stringValue(model.scaleName(Y));\n    let events = parseSelector(selCmpt.zoom, 'scope');\n\n    if (!hasScales) {\n      events = events.map(e => (e.markname = name + INTERVAL_BRUSH, e));\n    }\n\n    signals.push({\n      name: name + ANCHOR,\n      on: [{\n        events,\n        update: !hasScales ? `{x: x(unit), y: y(unit)}` : '{' + [sx ? `x: invert(${sx}, x(unit))` : '', sy ? `y: invert(${sy}, y(unit))` : ''].filter(expr => !!expr).join(', ') + '}'\n      }]\n    }, {\n      name: delta,\n      on: [{\n        events,\n        force: true,\n        update: 'pow(1.001, event.deltaY * pow(16, event.deltaMode))'\n      }]\n    });\n\n    if (x !== undefined) {\n      onDelta(model, selCmpt, x, 'width', signals);\n    }\n\n    if (y !== undefined) {\n      onDelta(model, selCmpt, y, 'height', signals);\n    }\n\n    return signals;\n  }\n};\nexport default zoom;\n\nfunction onDelta(model, selCmpt, proj, size, signals) {\n  var _a, _b;\n\n  const name = selCmpt.name;\n  const channel = proj.channel;\n  const hasScales = scalesCompiler.defined(selCmpt);\n  const signal = signals.filter(s => s.name === proj.signals[hasScales ? 'data' : 'visual'])[0];\n  const sizeSg = model.getSizeSignalRef(size).signal;\n  const scaleCmpt = model.getScaleComponent(channel);\n  const scaleType = scaleCmpt.get('type');\n  const base = hasScales ? domain(model, channel) : signal.name;\n  const delta = name + DELTA;\n  const anchor = `${name}${ANCHOR}.${channel}`;\n  const zoomFn = !hasScales ? 'zoomLinear' : scaleType === 'log' ? 'zoomLog' : scaleType === 'symlog' ? 'zoomSymlog' : scaleType === 'pow' ? 'zoomPow' : 'zoomLinear';\n  const arg = !hasScales ? '' : scaleType === 'pow' ? `, ${(_a = scaleCmpt.get('exponent')) !== null && _a !== void 0 ? _a : 1}` : scaleType === 'symlog' ? `, ${(_b = scaleCmpt.get('constant')) !== null && _b !== void 0 ? _b : 1}` : '';\n  const update = `${zoomFn}(${base}, ${anchor}, ${delta}${arg})`;\n  signal.on.push({\n    events: {\n      signal: delta\n    },\n    update: hasScales ? update : `clampRange(${update}, 0, ${sizeSg})`\n  });\n}","map":{"version":3,"mappings":"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","names":["parseSelector","stringValue","X","Y","BRUSH","INTERVAL_BRUSH","default","scalesCompiler","domain","ANCHOR","DELTA","zoom","defined","selCmpt","type","signals","model","name","hasScales","delta","x","y","project","hasChannel","sx","scaleName","sy","events","map","e","markname","push","on","update","filter","expr","join","force","undefined","onDelta","proj","size","channel","signal","s","sizeSg","getSizeSignalRef","scaleCmpt","getScaleComponent","scaleType","get","base","anchor","zoomFn","arg","_a","_b"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/selection/zoom.ts"],"sourcesContent":["import {NewSignal} from 'vega';\nimport {parseSelector} from 'vega-event-selector';\nimport {stringValue} from 'vega-util';\nimport {SelectionComponent} from '.';\nimport {ScaleChannel, X, Y} from '../../channel';\nimport {UnitModel} from '../unit';\nimport {BRUSH as INTERVAL_BRUSH} from './interval';\nimport {SelectionProjection} from './project';\nimport {default as scalesCompiler, domain} from './scales';\nimport {SelectionCompiler} from '.';\n\nconst ANCHOR = '_zoom_anchor';\nconst DELTA = '_zoom_delta';\n\nconst zoom: SelectionCompiler<'interval'> = {\n  defined: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.zoom;\n  },\n\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const hasScales = scalesCompiler.defined(selCmpt);\n    const delta = name + DELTA;\n    const {x, y} = selCmpt.project.hasChannel;\n    const sx = stringValue(model.scaleName(X));\n    const sy = stringValue(model.scaleName(Y));\n    let events = parseSelector(selCmpt.zoom, 'scope');\n\n    if (!hasScales) {\n      events = events.map(e => ((e.markname = name + INTERVAL_BRUSH), e));\n    }\n\n    signals.push(\n      {\n        name: name + ANCHOR,\n        on: [\n          {\n            events,\n            update: !hasScales\n              ? `{x: x(unit), y: y(unit)}`\n              : '{' +\n                [sx ? `x: invert(${sx}, x(unit))` : '', sy ? `y: invert(${sy}, y(unit))` : '']\n                  .filter(expr => !!expr)\n                  .join(', ') +\n                '}'\n          }\n        ]\n      },\n      {\n        name: delta,\n        on: [\n          {\n            events,\n            force: true,\n            update: 'pow(1.001, event.deltaY * pow(16, event.deltaMode))'\n          }\n        ]\n      }\n    );\n\n    if (x !== undefined) {\n      onDelta(model, selCmpt, x, 'width', signals);\n    }\n\n    if (y !== undefined) {\n      onDelta(model, selCmpt, y, 'height', signals);\n    }\n\n    return signals;\n  }\n};\n\nexport default zoom;\n\nfunction onDelta(\n  model: UnitModel,\n  selCmpt: SelectionComponent,\n  proj: SelectionProjection,\n  size: 'width' | 'height',\n  signals: NewSignal[]\n) {\n  const name = selCmpt.name;\n  const channel = proj.channel as ScaleChannel;\n  const hasScales = scalesCompiler.defined(selCmpt);\n  const signal = signals.filter(s => s.name === proj.signals[hasScales ? 'data' : 'visual'])[0];\n  const sizeSg = model.getSizeSignalRef(size).signal;\n  const scaleCmpt = model.getScaleComponent(channel);\n  const scaleType = scaleCmpt.get('type');\n  const base = hasScales ? domain(model, channel) : signal.name;\n  const delta = name + DELTA;\n  const anchor = `${name}${ANCHOR}.${channel}`;\n  const zoomFn = !hasScales\n    ? 'zoomLinear'\n    : scaleType === 'log'\n    ? 'zoomLog'\n    : scaleType === 'symlog'\n    ? 'zoomSymlog'\n    : scaleType === 'pow'\n    ? 'zoomPow'\n    : 'zoomLinear';\n  const arg = !hasScales\n    ? ''\n    : scaleType === 'pow'\n    ? `, ${scaleCmpt.get('exponent') ?? 1}`\n    : scaleType === 'symlog'\n    ? `, ${scaleCmpt.get('constant') ?? 1}`\n    : '';\n  const update = `${zoomFn}(${base}, ${anchor}, ${delta}${arg})`;\n\n  signal.on.push({\n    events: {signal: delta},\n    update: hasScales ? update : `clampRange(${update}, 0, ${sizeSg})`\n  });\n}\n"]},"metadata":{},"sourceType":"module"}