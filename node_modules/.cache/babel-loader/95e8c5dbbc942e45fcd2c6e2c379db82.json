{"ast":null,"code":"import { getSizeChannel } from '../channel';\nimport { stringify } from '../util';\nexport function invalidSpec(spec) {\n  return `Invalid specification ${stringify(spec)}. Make sure the specification includes at least one of the following properties: \"mark\", \"layer\", \"facet\", \"hconcat\", \"vconcat\", \"concat\", or \"repeat\".`;\n} // FIT\n\nexport const FIT_NON_SINGLE = 'Autosize \"fit\" only works for single views and layered views.';\nexport function containerSizeNonSingle(name) {\n  const uName = name == 'width' ? 'Width' : 'Height';\n  return `${uName} \"container\" only works for single views and layered views.`;\n}\nexport function containerSizeNotCompatibleWithAutosize(name) {\n  const uName = name == 'width' ? 'Width' : 'Height';\n  const fitDirection = name == 'width' ? 'x' : 'y';\n  return `${uName} \"container\" only works well with autosize \"fit\" or \"fit-${fitDirection}\".`;\n}\nexport function droppingFit(channel) {\n  return channel ? `Dropping \"fit-${channel}\" because spec has discrete ${getSizeChannel(channel)}.` : `Dropping \"fit\" because spec has discrete size.`;\n} // VIEW SIZE\n\nexport function unknownField(channel) {\n  return `Unknown field for ${channel}. Cannot calculate view size.`;\n} // SELECTION\n\nexport function cannotProjectOnChannelWithoutField(channel) {\n  return `Cannot project a selection on encoding channel \"${channel}\", which has no field.`;\n}\nexport function cannotProjectAggregate(channel, aggregate) {\n  return `Cannot project a selection on encoding channel \"${channel}\" as it uses an aggregate function (\"${aggregate}\").`;\n}\nexport function nearestNotSupportForContinuous(mark) {\n  return `The \"nearest\" transform is not supported for ${mark} marks.`;\n}\nexport function selectionNotSupported(mark) {\n  return `Selection not supported for ${mark} yet.`;\n}\nexport function selectionNotFound(name) {\n  return `Cannot find a selection named \"${name}\".`;\n}\nexport const SCALE_BINDINGS_CONTINUOUS = 'Scale bindings are currently only supported for scales with unbinned, continuous domains.';\nexport const LEGEND_BINDINGS_MUST_HAVE_PROJECTION = 'Legend bindings are only supported for selections over an individual field or encoding channel.';\nexport function cannotLookupVariableParameter(name) {\n  return `Lookups can only be performed on selection parameters. \"${name}\" is a variable parameter.`;\n}\nexport function noSameUnitLookup(name) {\n  return `Cannot define and lookup the \"${name}\" selection in the same view. ` + `Try moving the lookup into a second, layered view?`;\n}\nexport const NEEDS_SAME_SELECTION = 'The same selection must be used to override scale domains in a layered view.';\nexport const INTERVAL_INITIALIZED_WITH_X_Y = 'Interval selections should be initialized using \"x\" and/or \"y\" keys.'; // REPEAT\n\nexport function noSuchRepeatedValue(field) {\n  return `Unknown repeated value \"${field}\".`;\n}\nexport function columnsNotSupportByRowCol(type) {\n  return `The \"columns\" property cannot be used when \"${type}\" has nested row/column.`;\n} // CONCAT / REPEAT\n\nexport const CONCAT_CANNOT_SHARE_AXIS = 'Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).'; // DATA\n\nexport function unrecognizedParse(p) {\n  return `Unrecognized parse \"${p}\".`;\n}\nexport function differentParse(field, local, ancestor) {\n  return `An ancestor parsed field \"${field}\" as ${ancestor} but a child wants to parse the field as ${local}.`;\n}\nexport const ADD_SAME_CHILD_TWICE = 'Attempt to add the same child twice.'; // TRANSFORMS\n\nexport function invalidTransformIgnored(transform) {\n  return `Ignoring an invalid transform: ${stringify(transform)}.`;\n}\nexport const NO_FIELDS_NEEDS_AS = 'If \"from.fields\" is not specified, \"as\" has to be a string that specifies the key to be used for the data from the secondary source.'; // ENCODING & FACET\n\nexport function customFormatTypeNotAllowed(channel) {\n  return `Config.customFormatTypes is not true, thus custom format type and format for channel ${channel} are dropped.`;\n}\nexport function projectionOverridden(opt) {\n  const {\n    parentProjection,\n    projection\n  } = opt;\n  return `Layer's shared projection ${stringify(parentProjection)} is overridden by a child projection ${stringify(projection)}.`;\n}\nexport const REPLACE_ANGLE_WITH_THETA = 'Arc marks uses theta channel rather than angle, replacing angle with theta.';\nexport function offsetNestedInsideContinuousPositionScaleDropped(mainChannel) {\n  return `${mainChannel}Offset dropped because ${mainChannel} is continuous`;\n}\nexport function replaceOffsetWithMainChannel(mainChannel) {\n  return `There is no ${mainChannel} encoding. Replacing ${mainChannel}Offset encoding as ${mainChannel}.`;\n}\nexport function primitiveChannelDef(channel, type, value) {\n  return `Channel ${channel} is a ${type}. Converted to {value: ${stringify(value)}}.`;\n}\nexport function invalidFieldType(type) {\n  return `Invalid field type \"${type}\".`;\n}\nexport function invalidFieldTypeForCountAggregate(type, aggregate) {\n  return `Invalid field type \"${type}\" for aggregate: \"${aggregate}\", using \"quantitative\" instead.`;\n}\nexport function invalidAggregate(aggregate) {\n  return `Invalid aggregation operator \"${aggregate}\".`;\n}\nexport function missingFieldType(channel, newType) {\n  return `Missing type for channel \"${channel}\", using \"${newType}\" instead.`;\n}\nexport function droppingColor(type, opt) {\n  const {\n    fill,\n    stroke\n  } = opt;\n  return `Dropping color ${type} as the plot also has ${fill && stroke ? 'fill and stroke' : fill ? 'fill' : 'stroke'}.`;\n}\nexport function relativeBandSizeNotSupported(sizeChannel) {\n  return `Position range does not support relative band size for ${sizeChannel}.`;\n}\nexport function emptyFieldDef(fieldDef, channel) {\n  return `Dropping ${stringify(fieldDef)} from channel \"${channel}\" since it does not contain any data field, datum, value, or signal.`;\n}\nexport const LINE_WITH_VARYING_SIZE = 'Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.';\nexport function incompatibleChannel(channel, markOrFacet, when) {\n  return `${channel} dropped as it is incompatible with \"${markOrFacet}\"${when ? ` when ${when}` : ''}.`;\n}\nexport function offsetEncodingScaleIgnored(channel) {\n  return `${channel} encoding has no scale, so specified scale is ignored.`;\n}\nexport function invalidEncodingChannel(channel) {\n  return `${channel}-encoding is dropped as ${channel} is not a valid encoding channel.`;\n}\nexport function channelShouldBeDiscrete(channel) {\n  return `${channel} encoding should be discrete (ordinal / nominal / binned).`;\n}\nexport function channelShouldBeDiscreteOrDiscretizing(channel) {\n  return `${channel} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`;\n}\nexport function facetChannelDropped(channels) {\n  return `Facet encoding dropped as ${channels.join(' and ')} ${channels.length > 1 ? 'are' : 'is'} also specified.`;\n}\nexport function discreteChannelCannotEncode(channel, type) {\n  return `Using discrete channel \"${channel}\" to encode \"${type}\" field can be misleading as it does not encode ${type === 'ordinal' ? 'order' : 'magnitude'}.`;\n} // MARK\n\nexport function rangeMarkAlignmentCannotBeExpression(align) {\n  return `The ${align} for range marks cannot be an expression`;\n}\nexport function lineWithRange(hasX2, hasY2) {\n  const channels = hasX2 && hasY2 ? 'x2 and y2' : hasX2 ? 'x2' : 'y2';\n  return `Line mark is for continuous lines and thus cannot be used with ${channels}. We will use the rule mark (line segments) instead.`;\n}\nexport function orientOverridden(original, actual) {\n  return `Specified orient \"${original}\" overridden with \"${actual}\".`;\n} // SCALE\n\nexport const CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN = 'Custom domain scale cannot be unioned with default field-based domain.';\nexport function cannotUseScalePropertyWithNonColor(prop) {\n  return `Cannot use the scale property \"${prop}\" with non-color channel.`;\n}\nexport function cannotUseRelativeBandSizeWithNonBandScale(scaleType) {\n  return `Cannot use the relative band size with ${scaleType} scale.`;\n}\nexport function unaggregateDomainHasNoEffectForRawField(fieldDef) {\n  return `Using unaggregated domain with raw field has no effect (${stringify(fieldDef)}).`;\n}\nexport function unaggregateDomainWithNonSharedDomainOp(aggregate) {\n  return `Unaggregated domain not applicable for \"${aggregate}\" since it produces values outside the origin domain of the source data.`;\n}\nexport function unaggregatedDomainWithLogScale(fieldDef) {\n  return `Unaggregated domain is currently unsupported for log scale (${stringify(fieldDef)}).`;\n}\nexport function cannotApplySizeToNonOrientedMark(mark) {\n  return `Cannot apply size to non-oriented mark \"${mark}\".`;\n}\nexport function scaleTypeNotWorkWithChannel(channel, scaleType, defaultScaleType) {\n  return `Channel \"${channel}\" does not work with \"${scaleType}\" scale. We are using \"${defaultScaleType}\" scale instead.`;\n}\nexport function scaleTypeNotWorkWithFieldDef(scaleType, defaultScaleType) {\n  return `FieldDef does not work with \"${scaleType}\" scale. We are using \"${defaultScaleType}\" scale instead.`;\n}\nexport function scalePropertyNotWorkWithScaleType(scaleType, propName, channel) {\n  return `${channel}-scale's \"${propName}\" is dropped as it does not work with ${scaleType} scale.`;\n}\nexport function scaleTypeNotWorkWithMark(mark, scaleType) {\n  return `Scale type \"${scaleType}\" does not work with mark \"${mark}\".`;\n}\nexport function stepDropped(channel) {\n  return `The step for \"${channel}\" is dropped because the ${channel === 'width' ? 'x' : 'y'} is continuous.`;\n}\nexport function mergeConflictingProperty(property, propertyOf, v1, v2) {\n  return `Conflicting ${propertyOf.toString()} property \"${property.toString()}\" (${stringify(v1)} and ${stringify(v2)}). Using ${stringify(v1)}.`;\n}\nexport function mergeConflictingDomainProperty(property, propertyOf, v1, v2) {\n  return `Conflicting ${propertyOf.toString()} property \"${property.toString()}\" (${stringify(v1)} and ${stringify(v2)}). Using the union of the two domains.`;\n}\nexport function independentScaleMeansIndependentGuide(channel) {\n  return `Setting the scale to be independent for \"${channel}\" means we also have to set the guide (axis or legend) to be independent.`;\n}\nexport function domainSortDropped(sort) {\n  return `Dropping sort property ${stringify(sort)} as unioned domains only support boolean or op \"count\", \"min\", and \"max\".`;\n}\nexport const MORE_THAN_ONE_SORT = 'Domains that should be unioned has conflicting sort properties. Sort will be set to true.';\nexport const FACETED_INDEPENDENT_DIFFERENT_SOURCES = 'Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.';\nexport const FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES = 'Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.';\nexport const FACETED_INDEPENDENT_SAME_SOURCE = 'Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.'; // AXIS\n\nexport const INVALID_CHANNEL_FOR_AXIS = 'Invalid channel for axis.'; // STACK\n\nexport function cannotStackRangedMark(channel) {\n  return `Cannot stack \"${channel}\" if there is already \"${channel}2\".`;\n}\nexport function cannotStackNonLinearScale(scaleType) {\n  return `Cannot stack non-linear scale (${scaleType}).`;\n}\nexport function stackNonSummativeAggregate(aggregate) {\n  return `Stacking is applied even though the aggregate function is non-summative (\"${aggregate}\").`;\n} // TIMEUNIT\n\nexport function invalidTimeUnit(unitName, value) {\n  return `Invalid ${unitName}: ${stringify(value)}.`;\n}\nexport function droppedDay(d) {\n  return `Dropping day from datetime ${stringify(d)} as day cannot be combined with other units.`;\n}\nexport function errorBarCenterAndExtentAreNotNeeded(center, extent) {\n  return `${extent ? 'extent ' : ''}${extent && center ? 'and ' : ''}${center ? 'center ' : ''}${extent && center ? 'are ' : 'is '}not needed when data are aggregated.`;\n}\nexport function errorBarCenterIsUsedWithWrongExtent(center, extent, mark) {\n  return `${center} is not usually used with ${extent} for ${mark}.`;\n}\nexport function errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark) {\n  return `Continuous axis should not have customized aggregation function ${aggregate}; ${compositeMark} already agregates the axis.`;\n}\nexport function errorBand1DNotSupport(property) {\n  return `1D error band does not support ${property}.`;\n} // CHANNEL\n\nexport function channelRequiredForBinned(channel) {\n  return `Channel ${channel} is required for \"binned\" bin.`;\n}\nexport function channelShouldNotBeUsedForBinned(channel) {\n  return `Channel ${channel} should not be used with \"binned\" bin.`;\n}\nexport function domainRequiredForThresholdScale(channel) {\n  return `Domain for ${channel} is required for threshold scale.`;\n}","map":{"version":3,"mappings":"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","names":["getSizeChannel","stringify","invalidSpec","spec","FIT_NON_SINGLE","containerSizeNonSingle","name","uName","containerSizeNotCompatibleWithAutosize","fitDirection","droppingFit","channel","unknownField","cannotProjectOnChannelWithoutField","cannotProjectAggregate","aggregate","nearestNotSupportForContinuous","mark","selectionNotSupported","selectionNotFound","SCALE_BINDINGS_CONTINUOUS","LEGEND_BINDINGS_MUST_HAVE_PROJECTION","cannotLookupVariableParameter","noSameUnitLookup","NEEDS_SAME_SELECTION","INTERVAL_INITIALIZED_WITH_X_Y","noSuchRepeatedValue","field","columnsNotSupportByRowCol","type","CONCAT_CANNOT_SHARE_AXIS","unrecognizedParse","p","differentParse","local","ancestor","ADD_SAME_CHILD_TWICE","invalidTransformIgnored","transform","NO_FIELDS_NEEDS_AS","customFormatTypeNotAllowed","projectionOverridden","opt","parentProjection","projection","REPLACE_ANGLE_WITH_THETA","offsetNestedInsideContinuousPositionScaleDropped","mainChannel","replaceOffsetWithMainChannel","primitiveChannelDef","value","invalidFieldType","invalidFieldTypeForCountAggregate","invalidAggregate","missingFieldType","newType","droppingColor","fill","stroke","relativeBandSizeNotSupported","sizeChannel","emptyFieldDef","fieldDef","LINE_WITH_VARYING_SIZE","incompatibleChannel","markOrFacet","when","offsetEncodingScaleIgnored","invalidEncodingChannel","channelShouldBeDiscrete","channelShouldBeDiscreteOrDiscretizing","facetChannelDropped","channels","join","length","discreteChannelCannotEncode","rangeMarkAlignmentCannotBeExpression","align","lineWithRange","hasX2","hasY2","orientOverridden","original","actual","CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN","cannotUseScalePropertyWithNonColor","prop","cannotUseRelativeBandSizeWithNonBandScale","scaleType","unaggregateDomainHasNoEffectForRawField","unaggregateDomainWithNonSharedDomainOp","unaggregatedDomainWithLogScale","cannotApplySizeToNonOrientedMark","scaleTypeNotWorkWithChannel","defaultScaleType","scaleTypeNotWorkWithFieldDef","scalePropertyNotWorkWithScaleType","propName","scaleTypeNotWorkWithMark","stepDropped","mergeConflictingProperty","property","propertyOf","v1","v2","toString","mergeConflictingDomainProperty","independentScaleMeansIndependentGuide","domainSortDropped","sort","MORE_THAN_ONE_SORT","FACETED_INDEPENDENT_DIFFERENT_SOURCES","FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES","FACETED_INDEPENDENT_SAME_SOURCE","INVALID_CHANNEL_FOR_AXIS","cannotStackRangedMark","cannotStackNonLinearScale","stackNonSummativeAggregate","invalidTimeUnit","unitName","droppedDay","d","errorBarCenterAndExtentAreNotNeeded","center","extent","errorBarCenterIsUsedWithWrongExtent","errorBarContinuousAxisHasCustomizedAggregate","compositeMark","errorBand1DNotSupport","channelRequiredForBinned","channelShouldNotBeUsedForBinned","domainRequiredForThresholdScale"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/log/message.ts"],"sourcesContent":["/**\n * Collection of all Vega-Lite Error Messages\n */\nimport {AggregateOp, SignalRef} from 'vega';\nimport {Aggregate} from '../aggregate';\nimport {\n  Channel,\n  ExtendedChannel,\n  FacetChannel,\n  getSizeChannel,\n  OffsetScaleChannel,\n  PositionScaleChannel,\n  ScaleChannel\n} from '../channel';\nimport {HiddenCompositeAggregate, TypedFieldDef, Value} from '../channeldef';\nimport {SplitParentProperty} from '../compile/split';\nimport {CompositeMark} from '../compositemark';\nimport {ErrorBarCenter, ErrorBarExtent} from '../compositemark/errorbar';\nimport {DateTime, DateTimeExpr} from '../datetime';\nimport {ExprRef} from '../expr';\nimport {Mark} from '../mark';\nimport {Projection} from '../projection';\nimport {ScaleType} from '../scale';\nimport {GenericSpec} from '../spec';\nimport {Type} from '../type';\nimport {stringify} from '../util';\nimport {VgSortField} from '../vega.schema';\n\nexport function invalidSpec(spec: GenericSpec<any, any, any, any>) {\n  return `Invalid specification ${stringify(\n    spec\n  )}. Make sure the specification includes at least one of the following properties: \"mark\", \"layer\", \"facet\", \"hconcat\", \"vconcat\", \"concat\", or \"repeat\".`;\n}\n\n// FIT\nexport const FIT_NON_SINGLE = 'Autosize \"fit\" only works for single views and layered views.';\n\nexport function containerSizeNonSingle(name: 'width' | 'height') {\n  const uName = name == 'width' ? 'Width' : 'Height';\n  return `${uName} \"container\" only works for single views and layered views.`;\n}\n\nexport function containerSizeNotCompatibleWithAutosize(name: 'width' | 'height') {\n  const uName = name == 'width' ? 'Width' : 'Height';\n  const fitDirection = name == 'width' ? 'x' : 'y';\n  return `${uName} \"container\" only works well with autosize \"fit\" or \"fit-${fitDirection}\".`;\n}\n\nexport function droppingFit(channel?: PositionScaleChannel) {\n  return channel\n    ? `Dropping \"fit-${channel}\" because spec has discrete ${getSizeChannel(channel)}.`\n    : `Dropping \"fit\" because spec has discrete size.`;\n}\n\n// VIEW SIZE\n\nexport function unknownField(channel: Channel) {\n  return `Unknown field for ${channel}. Cannot calculate view size.`;\n}\n\n// SELECTION\nexport function cannotProjectOnChannelWithoutField(channel: Channel) {\n  return `Cannot project a selection on encoding channel \"${channel}\", which has no field.`;\n}\n\nexport function cannotProjectAggregate(channel: Channel, aggregate: Aggregate | HiddenCompositeAggregate) {\n  return `Cannot project a selection on encoding channel \"${channel}\" as it uses an aggregate function (\"${aggregate}\").`;\n}\n\nexport function nearestNotSupportForContinuous(mark: string) {\n  return `The \"nearest\" transform is not supported for ${mark} marks.`;\n}\n\nexport function selectionNotSupported(mark: CompositeMark) {\n  return `Selection not supported for ${mark} yet.`;\n}\n\nexport function selectionNotFound(name: string) {\n  return `Cannot find a selection named \"${name}\".`;\n}\n\nexport const SCALE_BINDINGS_CONTINUOUS =\n  'Scale bindings are currently only supported for scales with unbinned, continuous domains.';\n\nexport const LEGEND_BINDINGS_MUST_HAVE_PROJECTION =\n  'Legend bindings are only supported for selections over an individual field or encoding channel.';\nexport function cannotLookupVariableParameter(name: string) {\n  return `Lookups can only be performed on selection parameters. \"${name}\" is a variable parameter.`;\n}\n\nexport function noSameUnitLookup(name: string) {\n  return (\n    `Cannot define and lookup the \"${name}\" selection in the same view. ` +\n    `Try moving the lookup into a second, layered view?`\n  );\n}\n\nexport const NEEDS_SAME_SELECTION = 'The same selection must be used to override scale domains in a layered view.';\n\nexport const INTERVAL_INITIALIZED_WITH_X_Y = 'Interval selections should be initialized using \"x\" and/or \"y\" keys.';\n\n// REPEAT\nexport function noSuchRepeatedValue(field: string) {\n  return `Unknown repeated value \"${field}\".`;\n}\n\nexport function columnsNotSupportByRowCol(type: 'facet' | 'repeat') {\n  return `The \"columns\" property cannot be used when \"${type}\" has nested row/column.`;\n}\n\n// CONCAT / REPEAT\nexport const CONCAT_CANNOT_SHARE_AXIS =\n  'Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).';\n\n// DATA\nexport function unrecognizedParse(p: string) {\n  return `Unrecognized parse \"${p}\".`;\n}\n\nexport function differentParse(field: string, local: string, ancestor: string) {\n  return `An ancestor parsed field \"${field}\" as ${ancestor} but a child wants to parse the field as ${local}.`;\n}\n\nexport const ADD_SAME_CHILD_TWICE = 'Attempt to add the same child twice.';\n\n// TRANSFORMS\nexport function invalidTransformIgnored(transform: any) {\n  return `Ignoring an invalid transform: ${stringify(transform)}.`;\n}\n\nexport const NO_FIELDS_NEEDS_AS =\n  'If \"from.fields\" is not specified, \"as\" has to be a string that specifies the key to be used for the data from the secondary source.';\n\n// ENCODING & FACET\n\nexport function customFormatTypeNotAllowed(channel: ExtendedChannel) {\n  return `Config.customFormatTypes is not true, thus custom format type and format for channel ${channel} are dropped.`;\n}\n\nexport function projectionOverridden<ES extends ExprRef | SignalRef>(opt: {\n  parentProjection: Projection<ES>;\n  projection: Projection<ES>;\n}) {\n  const {parentProjection, projection} = opt;\n  return `Layer's shared projection ${stringify(parentProjection)} is overridden by a child projection ${stringify(\n    projection\n  )}.`;\n}\n\nexport const REPLACE_ANGLE_WITH_THETA = 'Arc marks uses theta channel rather than angle, replacing angle with theta.';\n\nexport function offsetNestedInsideContinuousPositionScaleDropped(mainChannel: PositionScaleChannel) {\n  return `${mainChannel}Offset dropped because ${mainChannel} is continuous`;\n}\n\nexport function replaceOffsetWithMainChannel(mainChannel: PositionScaleChannel) {\n  return `There is no ${mainChannel} encoding. Replacing ${mainChannel}Offset encoding as ${mainChannel}.`;\n}\n\nexport function primitiveChannelDef(\n  channel: ExtendedChannel,\n  type: 'string' | 'number' | 'boolean',\n  value: Exclude<Value, null>\n) {\n  return `Channel ${channel} is a ${type}. Converted to {value: ${stringify(value)}}.`;\n}\n\nexport function invalidFieldType(type: Type) {\n  return `Invalid field type \"${type}\".`;\n}\n\nexport function invalidFieldTypeForCountAggregate(type: Type, aggregate: Aggregate | string) {\n  return `Invalid field type \"${type}\" for aggregate: \"${aggregate}\", using \"quantitative\" instead.`;\n}\n\nexport function invalidAggregate(aggregate: AggregateOp | string) {\n  return `Invalid aggregation operator \"${aggregate}\".`;\n}\n\nexport function missingFieldType(channel: Channel, newType: Type) {\n  return `Missing type for channel \"${channel}\", using \"${newType}\" instead.`;\n}\nexport function droppingColor(type: 'encoding' | 'property', opt: {fill?: boolean; stroke?: boolean}) {\n  const {fill, stroke} = opt;\n  return `Dropping color ${type} as the plot also has ${\n    fill && stroke ? 'fill and stroke' : fill ? 'fill' : 'stroke'\n  }.`;\n}\n\nexport function relativeBandSizeNotSupported(sizeChannel: 'width' | 'height') {\n  return `Position range does not support relative band size for ${sizeChannel}.`;\n}\n\nexport function emptyFieldDef(fieldDef: unknown, channel: ExtendedChannel) {\n  return `Dropping ${stringify(\n    fieldDef\n  )} from channel \"${channel}\" since it does not contain any data field, datum, value, or signal.`;\n}\n\nexport const LINE_WITH_VARYING_SIZE =\n  'Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.';\n\nexport function incompatibleChannel(\n  channel: ExtendedChannel,\n  markOrFacet: Mark | 'facet' | CompositeMark,\n  when?: string\n) {\n  return `${channel} dropped as it is incompatible with \"${markOrFacet}\"${when ? ` when ${when}` : ''}.`;\n}\n\nexport function offsetEncodingScaleIgnored(channel: OffsetScaleChannel) {\n  return `${channel} encoding has no scale, so specified scale is ignored.`;\n}\n\nexport function invalidEncodingChannel(channel: ExtendedChannel) {\n  return `${channel}-encoding is dropped as ${channel} is not a valid encoding channel.`;\n}\n\nexport function channelShouldBeDiscrete(channel: ExtendedChannel) {\n  return `${channel} encoding should be discrete (ordinal / nominal / binned).`;\n}\n\nexport function channelShouldBeDiscreteOrDiscretizing(channel: ExtendedChannel) {\n  return `${channel} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`;\n}\n\nexport function facetChannelDropped(channels: FacetChannel[]) {\n  return `Facet encoding dropped as ${channels.join(' and ')} ${channels.length > 1 ? 'are' : 'is'} also specified.`;\n}\n\nexport function discreteChannelCannotEncode(channel: Channel, type: Type) {\n  return `Using discrete channel \"${channel}\" to encode \"${type}\" field can be misleading as it does not encode ${\n    type === 'ordinal' ? 'order' : 'magnitude'\n  }.`;\n}\n\n// MARK\n\nexport function rangeMarkAlignmentCannotBeExpression(align: 'align' | 'baseline') {\n  return `The ${align} for range marks cannot be an expression`;\n}\n\nexport function lineWithRange(hasX2: boolean, hasY2: boolean) {\n  const channels = hasX2 && hasY2 ? 'x2 and y2' : hasX2 ? 'x2' : 'y2';\n  return `Line mark is for continuous lines and thus cannot be used with ${channels}. We will use the rule mark (line segments) instead.`;\n}\n\nexport function orientOverridden(original: string, actual: string) {\n  return `Specified orient \"${original}\" overridden with \"${actual}\".`;\n}\n\n// SCALE\nexport const CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN =\n  'Custom domain scale cannot be unioned with default field-based domain.';\n\nexport function cannotUseScalePropertyWithNonColor(prop: string) {\n  return `Cannot use the scale property \"${prop}\" with non-color channel.`;\n}\n\nexport function cannotUseRelativeBandSizeWithNonBandScale(scaleType: ScaleType) {\n  return `Cannot use the relative band size with ${scaleType} scale.`;\n}\n\nexport function unaggregateDomainHasNoEffectForRawField(fieldDef: TypedFieldDef<string>) {\n  return `Using unaggregated domain with raw field has no effect (${stringify(fieldDef)}).`;\n}\n\nexport function unaggregateDomainWithNonSharedDomainOp(aggregate: Aggregate | string) {\n  return `Unaggregated domain not applicable for \"${aggregate}\" since it produces values outside the origin domain of the source data.`;\n}\n\nexport function unaggregatedDomainWithLogScale(fieldDef: TypedFieldDef<string>) {\n  return `Unaggregated domain is currently unsupported for log scale (${stringify(fieldDef)}).`;\n}\n\nexport function cannotApplySizeToNonOrientedMark(mark: Mark) {\n  return `Cannot apply size to non-oriented mark \"${mark}\".`;\n}\n\nexport function scaleTypeNotWorkWithChannel(channel: Channel, scaleType: ScaleType, defaultScaleType: ScaleType) {\n  return `Channel \"${channel}\" does not work with \"${scaleType}\" scale. We are using \"${defaultScaleType}\" scale instead.`;\n}\n\nexport function scaleTypeNotWorkWithFieldDef(scaleType: ScaleType, defaultScaleType: ScaleType) {\n  return `FieldDef does not work with \"${scaleType}\" scale. We are using \"${defaultScaleType}\" scale instead.`;\n}\n\nexport function scalePropertyNotWorkWithScaleType(scaleType: ScaleType, propName: string, channel: Channel) {\n  return `${channel}-scale's \"${propName}\" is dropped as it does not work with ${scaleType} scale.`;\n}\n\nexport function scaleTypeNotWorkWithMark(mark: Mark, scaleType: ScaleType) {\n  return `Scale type \"${scaleType}\" does not work with mark \"${mark}\".`;\n}\n\nexport function stepDropped(channel: 'width' | 'height') {\n  return `The step for \"${channel}\" is dropped because the ${channel === 'width' ? 'x' : 'y'} is continuous.`;\n}\n\nexport function mergeConflictingProperty<T>(\n  property: string | number | symbol,\n  propertyOf: SplitParentProperty,\n  v1: T,\n  v2: T\n) {\n  return `Conflicting ${propertyOf.toString()} property \"${property.toString()}\" (${stringify(v1)} and ${stringify(\n    v2\n  )}). Using ${stringify(v1)}.`;\n}\n\nexport function mergeConflictingDomainProperty<T>(property: 'domains', propertyOf: SplitParentProperty, v1: T, v2: T) {\n  return `Conflicting ${propertyOf.toString()} property \"${property.toString()}\" (${stringify(v1)} and ${stringify(\n    v2\n  )}). Using the union of the two domains.`;\n}\n\nexport function independentScaleMeansIndependentGuide(channel: Channel) {\n  return `Setting the scale to be independent for \"${channel}\" means we also have to set the guide (axis or legend) to be independent.`;\n}\n\nexport function domainSortDropped(sort: VgSortField) {\n  return `Dropping sort property ${stringify(\n    sort\n  )} as unioned domains only support boolean or op \"count\", \"min\", and \"max\".`;\n}\n\nexport const MORE_THAN_ONE_SORT =\n  'Domains that should be unioned has conflicting sort properties. Sort will be set to true.';\n\nexport const FACETED_INDEPENDENT_DIFFERENT_SOURCES =\n  'Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.';\n\nexport const FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES =\n  'Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.';\n\nexport const FACETED_INDEPENDENT_SAME_SOURCE =\n  'Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.';\n\n// AXIS\nexport const INVALID_CHANNEL_FOR_AXIS = 'Invalid channel for axis.';\n\n// STACK\nexport function cannotStackRangedMark(channel: Channel) {\n  return `Cannot stack \"${channel}\" if there is already \"${channel}2\".`;\n}\n\nexport function cannotStackNonLinearScale(scaleType: ScaleType) {\n  return `Cannot stack non-linear scale (${scaleType}).`;\n}\n\nexport function stackNonSummativeAggregate(aggregate: Aggregate | string) {\n  return `Stacking is applied even though the aggregate function is non-summative (\"${aggregate}\").`;\n}\n\n// TIMEUNIT\nexport function invalidTimeUnit(unitName: string, value: string | number) {\n  return `Invalid ${unitName}: ${stringify(value)}.`;\n}\n\nexport function droppedDay(d: DateTime | DateTimeExpr) {\n  return `Dropping day from datetime ${stringify(d)} as day cannot be combined with other units.`;\n}\n\nexport function errorBarCenterAndExtentAreNotNeeded(center: ErrorBarCenter, extent: ErrorBarExtent) {\n  return `${extent ? 'extent ' : ''}${extent && center ? 'and ' : ''}${center ? 'center ' : ''}${\n    extent && center ? 'are ' : 'is '\n  }not needed when data are aggregated.`;\n}\n\nexport function errorBarCenterIsUsedWithWrongExtent(\n  center: ErrorBarCenter,\n  extent: ErrorBarExtent,\n  mark: 'errorbar' | 'errorband'\n) {\n  return `${center} is not usually used with ${extent} for ${mark}.`;\n}\n\nexport function errorBarContinuousAxisHasCustomizedAggregate(\n  aggregate: Aggregate | string,\n  compositeMark: CompositeMark\n) {\n  return `Continuous axis should not have customized aggregation function ${aggregate}; ${compositeMark} already agregates the axis.`;\n}\n\nexport function errorBand1DNotSupport(property: 'interpolate' | 'tension') {\n  return `1D error band does not support ${property}.`;\n}\n\n// CHANNEL\nexport function channelRequiredForBinned(channel: Channel) {\n  return `Channel ${channel} is required for \"binned\" bin.`;\n}\n\nexport function channelShouldNotBeUsedForBinned(channel: ExtendedChannel) {\n  return `Channel ${channel} should not be used with \"binned\" bin.`;\n}\n\nexport function domainRequiredForThresholdScale(channel: ScaleChannel) {\n  return `Domain for ${channel} is required for threshold scale.`;\n}\n"]},"metadata":{},"sourceType":"module"}