{"ast":null,"code":"import { isGenerator, isInlineData, isNamedData, isSphereGenerator, isUrlData } from '../../data';\nimport { contains, isEmpty, omit } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class SourceNode extends DataFlowNode {\n  constructor(data) {\n    super(null); // source cannot have parent\n\n    data !== null && data !== void 0 ? data : data = {\n      name: 'source'\n    };\n    let format;\n\n    if (!isGenerator(data)) {\n      format = data.format ? Object.assign({}, omit(data.format, ['parse'])) : {};\n    }\n\n    if (isInlineData(data)) {\n      this._data = {\n        values: data.values\n      };\n    } else if (isUrlData(data)) {\n      this._data = {\n        url: data.url\n      };\n\n      if (!format.type) {\n        // Extract extension from URL using snippet from\n        // http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript\n        let defaultExtension = /(?:\\.([^.]+))?$/.exec(data.url)[1];\n\n        if (!contains(['json', 'csv', 'tsv', 'dsv', 'topojson'], defaultExtension)) {\n          defaultExtension = 'json';\n        } // defaultExtension has type string but we ensure that it is DataFormatType above\n\n\n        format.type = defaultExtension;\n      }\n    } else if (isSphereGenerator(data)) {\n      // hardwire GeoJSON sphere data into output specification\n      this._data = {\n        values: [{\n          type: 'Sphere'\n        }]\n      };\n    } else if (isNamedData(data) || isGenerator(data)) {\n      this._data = {};\n    } // set flag to check if generator\n\n\n    this._generator = isGenerator(data); // any dataset can be named\n\n    if (data.name) {\n      this._name = data.name;\n    }\n\n    if (format && !isEmpty(format)) {\n      this._data.format = format;\n    }\n  }\n\n  dependentFields() {\n    return new Set();\n  }\n\n  producedFields() {\n    return undefined; // we don't know what this source produces\n  }\n\n  get data() {\n    return this._data;\n  }\n\n  hasName() {\n    return !!this._name;\n  }\n\n  get isGenerator() {\n    return this._generator;\n  }\n\n  get dataName() {\n    return this._name;\n  }\n\n  set dataName(name) {\n    this._name = name;\n  }\n\n  set parent(parent) {\n    throw new Error('Source nodes have to be roots.');\n  }\n\n  remove() {\n    throw new Error('Source nodes are roots and cannot be removed.');\n  }\n\n  hash() {\n    throw new Error('Cannot hash sources');\n  }\n\n  assemble() {\n    return Object.assign(Object.assign({\n      name: this._name\n    }, this._data), {\n      transform: []\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["isGenerator","isInlineData","isNamedData","isSphereGenerator","isUrlData","contains","isEmpty","omit","DataFlowNode","SourceNode","constructor","data","name","format","Object","_data","values","url","type","defaultExtension","exec","_generator","_name","dependentFields","Set","producedFields","undefined","hasName","dataName","parent","Error","remove","hash","assemble","transform"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/data/source.ts"],"sourcesContent":["import {\n  Data,\n  DataFormat,\n  DataFormatType,\n  isGenerator,\n  isInlineData,\n  isNamedData,\n  isSphereGenerator,\n  isUrlData\n} from '../../data';\nimport {contains, isEmpty, omit} from '../../util';\nimport {VgData} from '../../vega.schema';\nimport {DataFlowNode} from './dataflow';\n\nexport class SourceNode extends DataFlowNode {\n  private _data: Partial<VgData>;\n\n  private _name: string;\n\n  private _generator: boolean;\n\n  constructor(data: Data) {\n    super(null); // source cannot have parent\n\n    data ??= {name: 'source'};\n    let format;\n\n    if (!isGenerator(data)) {\n      format = data.format ? {...omit(data.format, ['parse'])} : ({} as DataFormat);\n    }\n\n    if (isInlineData(data)) {\n      this._data = {values: data.values};\n    } else if (isUrlData(data)) {\n      this._data = {url: data.url};\n\n      if (!format.type) {\n        // Extract extension from URL using snippet from\n        // http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript\n        let defaultExtension = /(?:\\.([^.]+))?$/.exec(data.url)[1];\n        if (!contains(['json', 'csv', 'tsv', 'dsv', 'topojson'], defaultExtension)) {\n          defaultExtension = 'json';\n        }\n\n        // defaultExtension has type string but we ensure that it is DataFormatType above\n        format.type = defaultExtension as DataFormatType;\n      }\n    } else if (isSphereGenerator(data)) {\n      // hardwire GeoJSON sphere data into output specification\n      this._data = {values: [{type: 'Sphere'}]};\n    } else if (isNamedData(data) || isGenerator(data)) {\n      this._data = {};\n    }\n\n    // set flag to check if generator\n    this._generator = isGenerator(data);\n\n    // any dataset can be named\n    if (data.name) {\n      this._name = data.name;\n    }\n\n    if (format && !isEmpty(format)) {\n      this._data.format = format;\n    }\n  }\n\n  public dependentFields() {\n    return new Set<string>();\n  }\n\n  public producedFields(): undefined {\n    return undefined; // we don't know what this source produces\n  }\n\n  get data() {\n    return this._data;\n  }\n\n  public hasName(): boolean {\n    return !!this._name;\n  }\n\n  get isGenerator() {\n    return this._generator;\n  }\n\n  get dataName() {\n    return this._name;\n  }\n\n  set dataName(name: string) {\n    this._name = name;\n  }\n\n  set parent(parent: DataFlowNode) {\n    throw new Error('Source nodes have to be roots.');\n  }\n\n  public remove() {\n    throw new Error('Source nodes are roots and cannot be removed.');\n  }\n\n  public hash(): string | number {\n    throw new Error('Cannot hash sources');\n  }\n\n  public assemble(): VgData {\n    return {\n      name: this._name,\n      ...this._data,\n      transform: []\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}