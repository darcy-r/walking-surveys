{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isFieldDef, isValueDef, vgField } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport { isAggregate, pathGroupingFields } from '../../encoding';\nimport { AREA, BAR, isPathMark, LINE, TRAIL } from '../../mark';\nimport { isSortByEncoding, isSortField } from '../../sort';\nimport { contains, getFirstDefined, isNullOrFalse, keys, omit, pick } from '../../util';\nimport { VG_CORNERRADIUS_CHANNELS } from '../../vega.schema';\nimport { getMarkConfig, getMarkPropOrConfig, getStyles, signalOrValueRef, sortParams } from '../common';\nimport { arc } from './arc';\nimport { area } from './area';\nimport { bar } from './bar';\nimport { geoshape } from './geoshape';\nimport { image } from './image';\nimport { line, trail } from './line';\nimport { circle, point, square } from './point';\nimport { rect } from './rect';\nimport { rule } from './rule';\nimport { text } from './text';\nimport { tick } from './tick';\nconst markCompiler = {\n  arc,\n  area,\n  bar,\n  circle,\n  geoshape,\n  image,\n  line,\n  point,\n  rect,\n  rule,\n  square,\n  text,\n  tick,\n  trail\n};\nexport function parseMarkGroups(model) {\n  if (contains([LINE, AREA, TRAIL], model.mark)) {\n    const details = pathGroupingFields(model.mark, model.encoding);\n\n    if (details.length > 0) {\n      return getPathGroups(model, details);\n    } // otherwise use standard mark groups\n\n  } else if (model.mark === BAR) {\n    const hasCornerRadius = VG_CORNERRADIUS_CHANNELS.some(prop => getMarkPropOrConfig(prop, model.markDef, model.config));\n\n    if (model.stack && !model.fieldDef('size') && hasCornerRadius) {\n      return getGroupsForStackedBarWithCornerRadius(model);\n    }\n  }\n\n  return getMarkGroup(model);\n}\nconst FACETED_PATH_PREFIX = 'faceted_path_';\n\nfunction getPathGroups(model, details) {\n  // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n  return [{\n    name: model.getName('pathgroup'),\n    type: 'group',\n    from: {\n      facet: {\n        name: FACETED_PATH_PREFIX + model.requestDataName(DataSourceType.Main),\n        data: model.requestDataName(DataSourceType.Main),\n        groupby: details\n      }\n    },\n    encode: {\n      update: {\n        width: {\n          field: {\n            group: 'width'\n          }\n        },\n        height: {\n          field: {\n            group: 'height'\n          }\n        }\n      }\n    },\n    // With subfacet for line/area group, need to use faceted data from above.\n    marks: getMarkGroup(model, {\n      fromPrefix: FACETED_PATH_PREFIX\n    })\n  }];\n}\n\nconst STACK_GROUP_PREFIX = 'stack_group_';\n/**\n * We need to put stacked bars into groups in order to enable cornerRadius for stacks.\n * If stack is used and the model doesn't have size encoding, we put the mark into groups,\n * and apply cornerRadius properties at the group.\n */\n\nfunction getGroupsForStackedBarWithCornerRadius(model) {\n  var _a; // Generate the mark\n\n\n  const [mark] = getMarkGroup(model, {\n    fromPrefix: STACK_GROUP_PREFIX\n  }); // Get the scale for the stacked field\n\n  const fieldScale = model.scaleName(model.stack.fieldChannel);\n\n  const stackField = function () {\n    let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return model.vgField(model.stack.fieldChannel, opt);\n  }; // Find the min/max of the pixel value on the stacked direction\n\n\n  const stackFieldGroup = (func, expr) => {\n    const vgFieldMinMax = [stackField({\n      prefix: 'min',\n      suffix: 'start',\n      expr\n    }), stackField({\n      prefix: 'max',\n      suffix: 'start',\n      expr\n    }), stackField({\n      prefix: 'min',\n      suffix: 'end',\n      expr\n    }), stackField({\n      prefix: 'max',\n      suffix: 'end',\n      expr\n    })];\n    return `${func}(${vgFieldMinMax.map(field => `scale('${fieldScale}',${field})`).join(',')})`;\n  };\n\n  let groupUpdate;\n  let innerGroupUpdate; // Build the encoding for group and an inner group\n\n  if (model.stack.fieldChannel === 'x') {\n    // Move cornerRadius, y/yc/y2/height properties to group\n    // Group x/x2 should be the min/max of the marks within\n    groupUpdate = Object.assign(Object.assign({}, pick(mark.encode.update, ['y', 'yc', 'y2', 'height', ...VG_CORNERRADIUS_CHANNELS])), {\n      x: {\n        signal: stackFieldGroup('min', 'datum')\n      },\n      x2: {\n        signal: stackFieldGroup('max', 'datum')\n      },\n      clip: {\n        value: true\n      }\n    }); // Inner group should revert the x translation, and pass height through\n\n    innerGroupUpdate = {\n      x: {\n        field: {\n          group: 'x'\n        },\n        mult: -1\n      },\n      height: {\n        field: {\n          group: 'height'\n        }\n      }\n    }; // The marks should use the same height as group, without y/yc/y2 properties (because it's already done by group)\n    // This is why size encoding is not supported yet\n\n    mark.encode.update = Object.assign(Object.assign({}, omit(mark.encode.update, ['y', 'yc', 'y2'])), {\n      height: {\n        field: {\n          group: 'height'\n        }\n      }\n    });\n  } else {\n    groupUpdate = Object.assign(Object.assign({}, pick(mark.encode.update, ['x', 'xc', 'x2', 'width'])), {\n      y: {\n        signal: stackFieldGroup('min', 'datum')\n      },\n      y2: {\n        signal: stackFieldGroup('max', 'datum')\n      },\n      clip: {\n        value: true\n      }\n    });\n    innerGroupUpdate = {\n      y: {\n        field: {\n          group: 'y'\n        },\n        mult: -1\n      },\n      width: {\n        field: {\n          group: 'width'\n        }\n      }\n    };\n    mark.encode.update = Object.assign(Object.assign({}, omit(mark.encode.update, ['x', 'xc', 'x2'])), {\n      width: {\n        field: {\n          group: 'width'\n        }\n      }\n    });\n  } // Deal with cornerRadius properties\n\n\n  for (const key of VG_CORNERRADIUS_CHANNELS) {\n    const configValue = getMarkConfig(key, model.markDef, model.config); // Move from mark to group\n\n    if (mark.encode.update[key]) {\n      groupUpdate[key] = mark.encode.update[key];\n      delete mark.encode.update[key];\n    } else if (configValue) {\n      groupUpdate[key] = signalOrValueRef(configValue);\n    } // Overwrite any cornerRadius on mark set by config --- they are already moved to the group\n\n\n    if (configValue) {\n      mark.encode.update[key] = {\n        value: 0\n      };\n    }\n  }\n\n  const groupby = [];\n\n  if (((_a = model.stack.groupbyChannels) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n    for (const groupbyChannel of model.stack.groupbyChannels) {\n      // For bin and time unit, we have to add bin/timeunit -end channels.\n      const groupByField = model.fieldDef(groupbyChannel);\n      const field = vgField(groupByField);\n\n      if (field) {\n        groupby.push(field);\n      }\n\n      if ((groupByField === null || groupByField === void 0 ? void 0 : groupByField.bin) || (groupByField === null || groupByField === void 0 ? void 0 : groupByField.timeUnit)) {\n        groupby.push(vgField(groupByField, {\n          binSuffix: 'end'\n        }));\n      }\n    }\n  }\n\n  const strokeProperties = ['stroke', 'strokeWidth', 'strokeJoin', 'strokeCap', 'strokeDash', 'strokeDashOffset', 'strokeMiterLimit', 'strokeOpacity']; // Generate stroke properties for the group\n\n  groupUpdate = strokeProperties.reduce((encode, prop) => {\n    if (mark.encode.update[prop]) {\n      return Object.assign(Object.assign({}, encode), {\n        [prop]: mark.encode.update[prop]\n      });\n    } else {\n      const configValue = getMarkConfig(prop, model.markDef, model.config);\n\n      if (configValue !== undefined) {\n        return Object.assign(Object.assign({}, encode), {\n          [prop]: signalOrValueRef(configValue)\n        });\n      } else {\n        return encode;\n      }\n    }\n  }, groupUpdate); // Apply strokeForeground and strokeOffset if stroke is used\n\n  if (groupUpdate.stroke) {\n    groupUpdate.strokeForeground = {\n      value: true\n    };\n    groupUpdate.strokeOffset = {\n      value: 0\n    };\n  }\n\n  return [{\n    type: 'group',\n    from: {\n      facet: {\n        data: model.requestDataName(DataSourceType.Main),\n        name: STACK_GROUP_PREFIX + model.requestDataName(DataSourceType.Main),\n        groupby,\n        aggregate: {\n          fields: [stackField({\n            suffix: 'start'\n          }), stackField({\n            suffix: 'start'\n          }), stackField({\n            suffix: 'end'\n          }), stackField({\n            suffix: 'end'\n          })],\n          ops: ['min', 'max', 'min', 'max']\n        }\n      }\n    },\n    encode: {\n      update: groupUpdate\n    },\n    marks: [{\n      type: 'group',\n      encode: {\n        update: innerGroupUpdate\n      },\n      marks: [mark]\n    }]\n  }];\n}\n\nexport function getSort(model) {\n  var _a;\n\n  const {\n    encoding,\n    stack,\n    mark,\n    markDef,\n    config\n  } = model;\n  const order = encoding.order;\n\n  if (!isArray(order) && isValueDef(order) && isNullOrFalse(order.value) || !order && isNullOrFalse(getMarkPropOrConfig('order', markDef, config))) {\n    return undefined;\n  } else if ((isArray(order) || isFieldDef(order)) && !stack) {\n    // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n    return sortParams(order, {\n      expr: 'datum'\n    });\n  } else if (isPathMark(mark)) {\n    // For both line and area, we sort values based on dimension by default\n    const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n    const dimensionChannelDef = encoding[dimensionChannel];\n\n    if (isFieldDef(dimensionChannelDef)) {\n      const s = dimensionChannelDef.sort;\n\n      if (isArray(s)) {\n        return {\n          field: vgField(dimensionChannelDef, {\n            prefix: dimensionChannel,\n            suffix: 'sort_index',\n            expr: 'datum'\n          })\n        };\n      } else if (isSortField(s)) {\n        return {\n          field: vgField({\n            // FIXME: this op might not already exist?\n            // FIXME: what if dimensionChannel (x or y) contains custom domain?\n            aggregate: isAggregate(model.encoding) ? s.op : undefined,\n            field: s.field\n          }, {\n            expr: 'datum'\n          })\n        };\n      } else if (isSortByEncoding(s)) {\n        const fieldDefToSort = model.fieldDef(s.encoding);\n        return {\n          field: vgField(fieldDefToSort, {\n            expr: 'datum'\n          }),\n          order: s.order\n        };\n      } else if (s === null) {\n        return undefined;\n      } else {\n        return {\n          field: vgField(dimensionChannelDef, {\n            // For stack with imputation, we only have bin_mid\n            binSuffix: ((_a = model.stack) === null || _a === void 0 ? void 0 : _a.impute) ? 'mid' : undefined,\n            expr: 'datum'\n          })\n        };\n      }\n    }\n\n    return undefined;\n  }\n\n  return undefined;\n}\n\nfunction getMarkGroup(model) {\n  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    fromPrefix: ''\n  };\n  const {\n    mark,\n    markDef,\n    encoding,\n    config\n  } = model;\n  const clip = getFirstDefined(markDef.clip, scaleClip(model), projectionClip(model));\n  const style = getStyles(markDef);\n  const key = encoding.key;\n  const sort = getSort(model);\n  const interactive = interactiveFlag(model);\n  const aria = getMarkPropOrConfig('aria', markDef, config);\n  const postEncodingTransform = markCompiler[mark].postEncodingTransform ? markCompiler[mark].postEncodingTransform(model) : null;\n  return [Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n    name: model.getName('marks'),\n    type: markCompiler[mark].vgMark\n  }, clip ? {\n    clip: true\n  } : {}), style ? {\n    style\n  } : {}), key ? {\n    key: key.field\n  } : {}), sort ? {\n    sort\n  } : {}), interactive ? interactive : {}), aria === false ? {\n    aria\n  } : {}), {\n    from: {\n      data: opt.fromPrefix + model.requestDataName(DataSourceType.Main)\n    },\n    encode: {\n      update: markCompiler[mark].encodeEntry(model)\n    }\n  }), postEncodingTransform ? {\n    transform: postEncodingTransform\n  } : {})];\n}\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the selectionExtent property, which gets added during scale parsing.\n */\n\n\nfunction scaleClip(model) {\n  const xScale = model.getScaleComponent('x');\n  const yScale = model.getScaleComponent('y');\n  return (xScale === null || xScale === void 0 ? void 0 : xScale.get('selectionExtent')) || (yScale === null || yScale === void 0 ? void 0 : yScale.get('selectionExtent')) ? true : undefined;\n}\n/**\n * If we use a custom projection with auto-fitting to the geodata extent,\n * we need to clip to ensure the chart size doesn't explode.\n */\n\n\nfunction projectionClip(model) {\n  const projection = model.component.projection;\n  return projection && !projection.isFit ? true : undefined;\n}\n/**\n * Only output interactive flags if we have selections defined somewhere in our model hierarchy.\n */\n\n\nfunction interactiveFlag(model) {\n  if (!model.component.selection) return null;\n  const unitCount = keys(model.component.selection).length;\n  let parentCount = unitCount;\n  let parent = model.parent;\n\n  while (parent && parentCount === 0) {\n    parentCount = keys(parent.component.selection).length;\n    parent = parent.parent;\n  }\n\n  return parentCount ? {\n    interactive: unitCount > 0 || !!model.encoding.tooltip\n  } : null;\n}","map":{"version":3,"mappings":"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","names":["isArray","isFieldDef","isValueDef","vgField","DataSourceType","isAggregate","pathGroupingFields","AREA","BAR","isPathMark","LINE","TRAIL","isSortByEncoding","isSortField","contains","getFirstDefined","isNullOrFalse","keys","omit","pick","VG_CORNERRADIUS_CHANNELS","getMarkConfig","getMarkPropOrConfig","getStyles","signalOrValueRef","sortParams","arc","area","bar","geoshape","image","line","trail","circle","point","square","rect","rule","text","tick","markCompiler","parseMarkGroups","model","mark","details","encoding","length","getPathGroups","hasCornerRadius","some","prop","markDef","config","stack","fieldDef","getGroupsForStackedBarWithCornerRadius","getMarkGroup","FACETED_PATH_PREFIX","name","getName","type","from","facet","requestDataName","Main","data","groupby","encode","update","width","field","group","height","marks","fromPrefix","STACK_GROUP_PREFIX","fieldScale","scaleName","fieldChannel","stackField","opt","stackFieldGroup","func","expr","vgFieldMinMax","prefix","suffix","map","join","groupUpdate","innerGroupUpdate","x","signal","x2","clip","value","mult","Object","y","y2","key","configValue","groupbyChannels","_a","groupbyChannel","groupByField","push","bin","timeUnit","binSuffix","strokeProperties","reduce","undefined","stroke","strokeForeground","strokeOffset","aggregate","fields","ops","getSort","order","dimensionChannel","orient","dimensionChannelDef","s","sort","op","fieldDefToSort","impute","scaleClip","projectionClip","style","interactive","interactiveFlag","aria","postEncodingTransform","vgMark","encodeEntry","transform","xScale","getScaleComponent","yScale","get","projection","component","isFit","selection","unitCount","parentCount","parent","tooltip"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compile/mark/mark.ts"],"sourcesContent":["import {isArray} from 'vega-util';\nimport {FieldRefOption, isFieldDef, isValueDef, vgField} from '../../channeldef';\nimport {DataSourceType} from '../../data';\nimport {isAggregate, pathGroupingFields} from '../../encoding';\nimport {AREA, BAR, isPathMark, LINE, Mark, TRAIL} from '../../mark';\nimport {isSortByEncoding, isSortField} from '../../sort';\nimport {contains, getFirstDefined, isNullOrFalse, keys, omit, pick} from '../../util';\nimport {VgCompare, VgEncodeEntry, VG_CORNERRADIUS_CHANNELS} from '../../vega.schema';\nimport {getMarkConfig, getMarkPropOrConfig, getStyles, signalOrValueRef, sortParams} from '../common';\nimport {UnitModel} from '../unit';\nimport {arc} from './arc';\nimport {area} from './area';\nimport {bar} from './bar';\nimport {MarkCompiler} from './base';\nimport {geoshape} from './geoshape';\nimport {image} from './image';\nimport {line, trail} from './line';\nimport {circle, point, square} from './point';\nimport {rect} from './rect';\nimport {rule} from './rule';\nimport {text} from './text';\nimport {tick} from './tick';\n\nconst markCompiler: Record<Mark, MarkCompiler> = {\n  arc,\n  area,\n  bar,\n  circle,\n  geoshape,\n  image,\n  line,\n  point,\n  rect,\n  rule,\n  square,\n  text,\n  tick,\n  trail\n};\n\nexport function parseMarkGroups(model: UnitModel): any[] {\n  if (contains([LINE, AREA, TRAIL], model.mark)) {\n    const details = pathGroupingFields(model.mark, model.encoding);\n    if (details.length > 0) {\n      return getPathGroups(model, details);\n    }\n    // otherwise use standard mark groups\n  } else if (model.mark === BAR) {\n    const hasCornerRadius = VG_CORNERRADIUS_CHANNELS.some(prop =>\n      getMarkPropOrConfig(prop, model.markDef, model.config)\n    );\n    if (model.stack && !model.fieldDef('size') && hasCornerRadius) {\n      return getGroupsForStackedBarWithCornerRadius(model);\n    }\n  }\n\n  return getMarkGroup(model);\n}\n\nconst FACETED_PATH_PREFIX = 'faceted_path_';\n\nfunction getPathGroups(model: UnitModel, details: string[]) {\n  // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n\n  return [\n    {\n      name: model.getName('pathgroup'),\n      type: 'group',\n      from: {\n        facet: {\n          name: FACETED_PATH_PREFIX + model.requestDataName(DataSourceType.Main),\n          data: model.requestDataName(DataSourceType.Main),\n          groupby: details\n        }\n      },\n      encode: {\n        update: {\n          width: {field: {group: 'width'}},\n          height: {field: {group: 'height'}}\n        }\n      },\n      // With subfacet for line/area group, need to use faceted data from above.\n      marks: getMarkGroup(model, {fromPrefix: FACETED_PATH_PREFIX})\n    }\n  ];\n}\n\nconst STACK_GROUP_PREFIX = 'stack_group_';\n\n/**\n * We need to put stacked bars into groups in order to enable cornerRadius for stacks.\n * If stack is used and the model doesn't have size encoding, we put the mark into groups,\n * and apply cornerRadius properties at the group.\n */\nfunction getGroupsForStackedBarWithCornerRadius(model: UnitModel) {\n  // Generate the mark\n  const [mark] = getMarkGroup(model, {fromPrefix: STACK_GROUP_PREFIX});\n\n  // Get the scale for the stacked field\n  const fieldScale = model.scaleName(model.stack.fieldChannel);\n  const stackField = (opt: FieldRefOption = {}) => model.vgField(model.stack.fieldChannel, opt);\n  // Find the min/max of the pixel value on the stacked direction\n  const stackFieldGroup = (func: 'min' | 'max', expr: 'datum' | 'parent') => {\n    const vgFieldMinMax = [\n      stackField({prefix: 'min', suffix: 'start', expr}),\n      stackField({prefix: 'max', suffix: 'start', expr}),\n      stackField({prefix: 'min', suffix: 'end', expr}),\n      stackField({prefix: 'max', suffix: 'end', expr})\n    ];\n    return `${func}(${vgFieldMinMax.map(field => `scale('${fieldScale}',${field})`).join(',')})`;\n  };\n\n  let groupUpdate: VgEncodeEntry;\n  let innerGroupUpdate: VgEncodeEntry;\n\n  // Build the encoding for group and an inner group\n  if (model.stack.fieldChannel === 'x') {\n    // Move cornerRadius, y/yc/y2/height properties to group\n    // Group x/x2 should be the min/max of the marks within\n    groupUpdate = {\n      ...pick(mark.encode.update, ['y', 'yc', 'y2', 'height', ...VG_CORNERRADIUS_CHANNELS]),\n      x: {signal: stackFieldGroup('min', 'datum')},\n      x2: {signal: stackFieldGroup('max', 'datum')},\n      clip: {value: true}\n    };\n    // Inner group should revert the x translation, and pass height through\n    innerGroupUpdate = {\n      x: {field: {group: 'x'}, mult: -1},\n      height: {field: {group: 'height'}}\n    };\n    // The marks should use the same height as group, without y/yc/y2 properties (because it's already done by group)\n    // This is why size encoding is not supported yet\n    mark.encode.update = {\n      ...omit(mark.encode.update, ['y', 'yc', 'y2']),\n      height: {field: {group: 'height'}}\n    };\n  } else {\n    groupUpdate = {\n      ...pick(mark.encode.update, ['x', 'xc', 'x2', 'width']),\n      y: {signal: stackFieldGroup('min', 'datum')},\n      y2: {signal: stackFieldGroup('max', 'datum')},\n      clip: {value: true}\n    };\n    innerGroupUpdate = {\n      y: {field: {group: 'y'}, mult: -1},\n      width: {field: {group: 'width'}}\n    };\n    mark.encode.update = {\n      ...omit(mark.encode.update, ['x', 'xc', 'x2']),\n      width: {field: {group: 'width'}}\n    };\n  }\n\n  // Deal with cornerRadius properties\n  for (const key of VG_CORNERRADIUS_CHANNELS) {\n    const configValue = getMarkConfig(key, model.markDef, model.config);\n    // Move from mark to group\n    if (mark.encode.update[key]) {\n      groupUpdate[key] = mark.encode.update[key];\n      delete mark.encode.update[key];\n    } else if (configValue) {\n      groupUpdate[key] = signalOrValueRef(configValue);\n    }\n    // Overwrite any cornerRadius on mark set by config --- they are already moved to the group\n    if (configValue) {\n      mark.encode.update[key] = {value: 0};\n    }\n  }\n\n  const groupby: string[] = [];\n\n  if (model.stack.groupbyChannels?.length > 0) {\n    for (const groupbyChannel of model.stack.groupbyChannels) {\n      // For bin and time unit, we have to add bin/timeunit -end channels.\n      const groupByField = model.fieldDef(groupbyChannel);\n      const field = vgField(groupByField);\n      if (field) {\n        groupby.push(field);\n      }\n\n      if (groupByField?.bin || groupByField?.timeUnit) {\n        groupby.push(vgField(groupByField, {binSuffix: 'end'}));\n      }\n    }\n  }\n\n  const strokeProperties = [\n    'stroke',\n    'strokeWidth',\n    'strokeJoin',\n    'strokeCap',\n    'strokeDash',\n    'strokeDashOffset',\n    'strokeMiterLimit',\n    'strokeOpacity'\n  ] as const;\n\n  // Generate stroke properties for the group\n  groupUpdate = strokeProperties.reduce((encode, prop) => {\n    if (mark.encode.update[prop]) {\n      return {...encode, [prop]: mark.encode.update[prop]};\n    } else {\n      const configValue = getMarkConfig(prop, model.markDef, model.config);\n      if (configValue !== undefined) {\n        return {...encode, [prop]: signalOrValueRef(configValue)};\n      } else {\n        return encode;\n      }\n    }\n  }, groupUpdate);\n\n  // Apply strokeForeground and strokeOffset if stroke is used\n  if (groupUpdate.stroke) {\n    groupUpdate.strokeForeground = {value: true};\n    groupUpdate.strokeOffset = {value: 0};\n  }\n\n  return [\n    {\n      type: 'group',\n      from: {\n        facet: {\n          data: model.requestDataName(DataSourceType.Main),\n          name: STACK_GROUP_PREFIX + model.requestDataName(DataSourceType.Main),\n          groupby,\n          aggregate: {\n            fields: [\n              stackField({suffix: 'start'}),\n              stackField({suffix: 'start'}),\n              stackField({suffix: 'end'}),\n              stackField({suffix: 'end'})\n            ],\n            ops: ['min', 'max', 'min', 'max']\n          }\n        }\n      },\n      encode: {\n        update: groupUpdate\n      },\n      marks: [\n        {\n          type: 'group',\n          encode: {update: innerGroupUpdate},\n          marks: [mark]\n        }\n      ]\n    }\n  ];\n}\n\nexport function getSort(model: UnitModel): VgCompare {\n  const {encoding, stack, mark, markDef, config} = model;\n  const order = encoding.order;\n  if (\n    (!isArray(order) && isValueDef(order) && isNullOrFalse(order.value)) ||\n    (!order && isNullOrFalse(getMarkPropOrConfig('order', markDef, config)))\n  ) {\n    return undefined;\n  } else if ((isArray(order) || isFieldDef(order)) && !stack) {\n    // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n    return sortParams(order, {expr: 'datum'});\n  } else if (isPathMark(mark)) {\n    // For both line and area, we sort values based on dimension by default\n    const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n    const dimensionChannelDef = encoding[dimensionChannel];\n    if (isFieldDef(dimensionChannelDef)) {\n      const s = dimensionChannelDef.sort;\n\n      if (isArray(s)) {\n        return {\n          field: vgField(dimensionChannelDef, {prefix: dimensionChannel, suffix: 'sort_index', expr: 'datum'})\n        };\n      } else if (isSortField(s)) {\n        return {\n          field: vgField(\n            {\n              // FIXME: this op might not already exist?\n              // FIXME: what if dimensionChannel (x or y) contains custom domain?\n              aggregate: isAggregate(model.encoding) ? s.op : undefined,\n              field: s.field\n            },\n            {expr: 'datum'}\n          )\n        };\n      } else if (isSortByEncoding(s)) {\n        const fieldDefToSort = model.fieldDef(s.encoding);\n        return {\n          field: vgField(fieldDefToSort, {expr: 'datum'}),\n          order: s.order\n        };\n      } else if (s === null) {\n        return undefined;\n      } else {\n        return {\n          field: vgField(dimensionChannelDef, {\n            // For stack with imputation, we only have bin_mid\n            binSuffix: model.stack?.impute ? 'mid' : undefined,\n            expr: 'datum'\n          })\n        };\n      }\n    }\n    return undefined;\n  }\n  return undefined;\n}\n\nfunction getMarkGroup(model: UnitModel, opt: {fromPrefix: string} = {fromPrefix: ''}) {\n  const {mark, markDef, encoding, config} = model;\n\n  const clip = getFirstDefined(markDef.clip, scaleClip(model), projectionClip(model));\n  const style = getStyles(markDef);\n  const key = encoding.key;\n  const sort = getSort(model);\n  const interactive = interactiveFlag(model);\n  const aria = getMarkPropOrConfig('aria', markDef, config);\n\n  const postEncodingTransform = markCompiler[mark].postEncodingTransform\n    ? markCompiler[mark].postEncodingTransform(model)\n    : null;\n\n  return [\n    {\n      name: model.getName('marks'),\n      type: markCompiler[mark].vgMark,\n      ...(clip ? {clip: true} : {}),\n      ...(style ? {style} : {}),\n      ...(key ? {key: key.field} : {}),\n      ...(sort ? {sort} : {}),\n      ...(interactive ? interactive : {}),\n      ...(aria === false ? {aria} : {}),\n      from: {data: opt.fromPrefix + model.requestDataName(DataSourceType.Main)},\n      encode: {\n        update: markCompiler[mark].encodeEntry(model)\n      },\n      ...(postEncodingTransform\n        ? {\n            transform: postEncodingTransform\n          }\n        : {})\n    }\n  ];\n}\n\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the selectionExtent property, which gets added during scale parsing.\n */\nfunction scaleClip(model: UnitModel) {\n  const xScale = model.getScaleComponent('x');\n  const yScale = model.getScaleComponent('y');\n  return xScale?.get('selectionExtent') || yScale?.get('selectionExtent') ? true : undefined;\n}\n\n/**\n * If we use a custom projection with auto-fitting to the geodata extent,\n * we need to clip to ensure the chart size doesn't explode.\n */\nfunction projectionClip(model: UnitModel) {\n  const projection = model.component.projection;\n  return projection && !projection.isFit ? true : undefined;\n}\n\n/**\n * Only output interactive flags if we have selections defined somewhere in our model hierarchy.\n */\nfunction interactiveFlag(model: UnitModel) {\n  if (!model.component.selection) return null;\n  const unitCount = keys(model.component.selection).length;\n  let parentCount = unitCount;\n  let parent = model.parent;\n  while (parent && parentCount === 0) {\n    parentCount = keys(parent.component.selection).length;\n    parent = parent.parent;\n  }\n  return parentCount\n    ? {\n        interactive: unitCount > 0 || !!model.encoding.tooltip\n      }\n    : null;\n}\n"]},"metadata":{},"sourceType":"module"}