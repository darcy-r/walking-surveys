{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { isContinuousFieldOrDatumDef, isFieldOrDatumDef, title } from '../channeldef';\nimport { extractTransformsFromEncoding, normalizeEncoding } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { replaceAll, titleCase } from '../util';\nimport { CompositeMarkNormalizer } from './base';\nimport { compositeMarkContinuousAxis, compositeMarkOrient, getCompositeMarkTooltip, makeCompositeAggregatePartFactory } from './common';\nexport const ERRORBAR = 'errorbar';\nexport const ERRORBAR_PARTS = ['ticks', 'rule'];\nexport const errorBarNormalizer = new CompositeMarkNormalizer(ERRORBAR, normalizeErrorBar);\nexport function normalizeErrorBar(spec, _ref) {\n  let {\n    config\n  } = _ref;\n  // Need to initEncoding first so we can infer type\n  spec = Object.assign(Object.assign({}, spec), {\n    encoding: normalizeEncoding(spec.encoding, config)\n  });\n  const {\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    ticksOrient,\n    markDef,\n    outerSpec,\n    tooltipEncoding\n  } = errorBarParams(spec, ERRORBAR, config);\n  delete encodingWithoutContinuousAxis['size'];\n  const makeErrorBarPart = makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorbar);\n  const thickness = markDef.thickness;\n  const size = markDef.size;\n  const tick = Object.assign(Object.assign({\n    type: 'tick',\n    orient: ticksOrient,\n    aria: false\n  }, thickness !== undefined ? {\n    thickness\n  } : {}), size !== undefined ? {\n    size\n  } : {});\n  const layer = [...makeErrorBarPart({\n    partName: 'ticks',\n    mark: tick,\n    positionPrefix: 'lower',\n    extraEncoding: tooltipEncoding\n  }), ...makeErrorBarPart({\n    partName: 'ticks',\n    mark: tick,\n    positionPrefix: 'upper',\n    extraEncoding: tooltipEncoding\n  }), ...makeErrorBarPart({\n    partName: 'rule',\n    mark: Object.assign({\n      type: 'rule',\n      ariaRoleDescription: 'errorbar'\n    }, thickness !== undefined ? {\n      size: thickness\n    } : {}),\n    positionPrefix: 'lower',\n    endPositionPrefix: 'upper',\n    extraEncoding: tooltipEncoding\n  })];\n  return Object.assign(Object.assign(Object.assign({}, outerSpec), {\n    transform\n  }), layer.length > 1 ? {\n    layer\n  } : Object.assign({}, layer[0]));\n}\n\nfunction errorBarOrientAndInputType(spec, compositeMark) {\n  const {\n    encoding\n  } = spec;\n\n  if (errorBarIsInputTypeRaw(encoding)) {\n    return {\n      orient: compositeMarkOrient(spec, compositeMark),\n      inputType: 'raw'\n    };\n  }\n\n  const isTypeAggregatedUpperLower = errorBarIsInputTypeAggregatedUpperLower(encoding);\n  const isTypeAggregatedError = errorBarIsInputTypeAggregatedError(encoding);\n  const x = encoding.x;\n  const y = encoding.y;\n\n  if (isTypeAggregatedUpperLower) {\n    // type is aggregated-upper-lower\n    if (isTypeAggregatedError) {\n      throw new Error(`${compositeMark} cannot be both type aggregated-upper-lower and aggregated-error`);\n    }\n\n    const x2 = encoding.x2;\n    const y2 = encoding.y2;\n\n    if (isFieldOrDatumDef(x2) && isFieldOrDatumDef(y2)) {\n      // having both x, x2 and y, y2\n      throw new Error(`${compositeMark} cannot have both x2 and y2`);\n    } else if (isFieldOrDatumDef(x2)) {\n      if (isContinuousFieldOrDatumDef(x)) {\n        // having x, x2 quantitative and field y, y2 are not specified\n        return {\n          orient: 'horizontal',\n          inputType: 'aggregated-upper-lower'\n        };\n      } else {\n        // having x, x2 that are not both quantitative\n        throw new Error(`Both x and x2 have to be quantitative in ${compositeMark}`);\n      }\n    } else if (isFieldOrDatumDef(y2)) {\n      // y2 is a FieldDef\n      if (isContinuousFieldOrDatumDef(y)) {\n        // having y, y2 quantitative and field x, x2 are not specified\n        return {\n          orient: 'vertical',\n          inputType: 'aggregated-upper-lower'\n        };\n      } else {\n        // having y, y2 that are not both quantitative\n        throw new Error(`Both y and y2 have to be quantitative in ${compositeMark}`);\n      }\n    }\n\n    throw new Error('No ranged axis');\n  } else {\n    // type is aggregated-error\n    const xError = encoding.xError;\n    const xError2 = encoding.xError2;\n    const yError = encoding.yError;\n    const yError2 = encoding.yError2;\n\n    if (isFieldOrDatumDef(xError2) && !isFieldOrDatumDef(xError)) {\n      // having xError2 without xError\n      throw new Error(`${compositeMark} cannot have xError2 without xError`);\n    }\n\n    if (isFieldOrDatumDef(yError2) && !isFieldOrDatumDef(yError)) {\n      // having yError2 without yError\n      throw new Error(`${compositeMark} cannot have yError2 without yError`);\n    }\n\n    if (isFieldOrDatumDef(xError) && isFieldOrDatumDef(yError)) {\n      // having both xError and yError\n      throw new Error(`${compositeMark} cannot have both xError and yError with both are quantiative`);\n    } else if (isFieldOrDatumDef(xError)) {\n      if (isContinuousFieldOrDatumDef(x)) {\n        // having x and xError that are all quantitative\n        return {\n          orient: 'horizontal',\n          inputType: 'aggregated-error'\n        };\n      } else {\n        // having x, xError, and xError2 that are not all quantitative\n        throw new Error('All x, xError, and xError2 (if exist) have to be quantitative');\n      }\n    } else if (isFieldOrDatumDef(yError)) {\n      if (isContinuousFieldOrDatumDef(y)) {\n        // having y and yError that are all quantitative\n        return {\n          orient: 'vertical',\n          inputType: 'aggregated-error'\n        };\n      } else {\n        // having y, yError, and yError2 that are not all quantitative\n        throw new Error('All y, yError, and yError2 (if exist) have to be quantitative');\n      }\n    }\n\n    throw new Error('No ranged axis');\n  }\n}\n\nfunction errorBarIsInputTypeRaw(encoding) {\n  return (isFieldOrDatumDef(encoding.x) || isFieldOrDatumDef(encoding.y)) && !isFieldOrDatumDef(encoding.x2) && !isFieldOrDatumDef(encoding.y2) && !isFieldOrDatumDef(encoding.xError) && !isFieldOrDatumDef(encoding.xError2) && !isFieldOrDatumDef(encoding.yError) && !isFieldOrDatumDef(encoding.yError2);\n}\n\nfunction errorBarIsInputTypeAggregatedUpperLower(encoding) {\n  return isFieldOrDatumDef(encoding.x2) || isFieldOrDatumDef(encoding.y2);\n}\n\nfunction errorBarIsInputTypeAggregatedError(encoding) {\n  return isFieldOrDatumDef(encoding.xError) || isFieldOrDatumDef(encoding.xError2) || isFieldOrDatumDef(encoding.yError) || isFieldOrDatumDef(encoding.yError2);\n}\n\nexport function errorBarParams(spec, compositeMark, config) {\n  var _a; // TODO: use selection\n\n\n  const {\n    mark,\n    encoding,\n    params,\n    projection: _p\n  } = spec,\n        outerSpec = __rest(spec, [\"mark\", \"encoding\", \"params\", \"projection\"]);\n\n  const markDef = isMarkDef(mark) ? mark : {\n    type: mark\n  }; // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n\n  if (params) {\n    log.warn(log.message.selectionNotSupported(compositeMark));\n  }\n\n  const {\n    orient,\n    inputType\n  } = errorBarOrientAndInputType(spec, compositeMark);\n  const {\n    continuousAxisChannelDef,\n    continuousAxisChannelDef2,\n    continuousAxisChannelDefError,\n    continuousAxisChannelDefError2,\n    continuousAxis\n  } = compositeMarkContinuousAxis(spec, orient, compositeMark);\n  const {\n    errorBarSpecificAggregate,\n    postAggregateCalculates,\n    tooltipSummary,\n    tooltipTitleWithFieldName\n  } = errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config);\n\n  const _b = encoding,\n        _c = continuousAxis,\n        oldContinuousAxisChannelDef = _b[_c],\n        _d = continuousAxis === 'x' ? 'x2' : 'y2',\n        oldContinuousAxisChannelDef2 = _b[_d],\n        _e = continuousAxis === 'x' ? 'xError' : 'yError',\n        oldContinuousAxisChannelDefError = _b[_e],\n        _f = continuousAxis === 'x' ? 'xError2' : 'yError2',\n        oldContinuousAxisChannelDefError2 = _b[_f],\n        oldEncodingWithoutContinuousAxis = __rest(_b, [typeof _c === \"symbol\" ? _c : _c + \"\", typeof _d === \"symbol\" ? _d : _d + \"\", typeof _e === \"symbol\" ? _e : _e + \"\", typeof _f === \"symbol\" ? _f : _f + \"\"]);\n\n  const {\n    bins,\n    timeUnits,\n    aggregate: oldAggregate,\n    groupby: oldGroupBy,\n    encoding: encodingWithoutContinuousAxis\n  } = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config);\n  const aggregate = [...oldAggregate, ...errorBarSpecificAggregate];\n  const groupby = inputType !== 'raw' ? [] : oldGroupBy;\n  const tooltipEncoding = getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, tooltipTitleWithFieldName);\n  return {\n    transform: [...((_a = outerSpec.transform) !== null && _a !== void 0 ? _a : []), ...bins, ...timeUnits, ...(aggregate.length === 0 ? [] : [{\n      aggregate,\n      groupby\n    }]), ...postAggregateCalculates],\n    groupby,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    ticksOrient: orient === 'vertical' ? 'horizontal' : 'vertical',\n    markDef,\n    outerSpec,\n    tooltipEncoding\n  };\n}\n\nfunction errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config) {\n  let errorBarSpecificAggregate = [];\n  let postAggregateCalculates = [];\n  const continuousFieldName = continuousAxisChannelDef.field;\n  let tooltipSummary;\n  let tooltipTitleWithFieldName = false;\n\n  if (inputType === 'raw') {\n    const center = markDef.center ? markDef.center : markDef.extent ? markDef.extent === 'iqr' ? 'median' : 'mean' : config.errorbar.center;\n    const extent = markDef.extent ? markDef.extent : center === 'mean' ? 'stderr' : 'iqr';\n\n    if (center === 'median' !== (extent === 'iqr')) {\n      log.warn(log.message.errorBarCenterIsUsedWithWrongExtent(center, extent, compositeMark));\n    }\n\n    if (extent === 'stderr' || extent === 'stdev') {\n      errorBarSpecificAggregate = [{\n        op: extent,\n        field: continuousFieldName,\n        as: `extent_${continuousFieldName}`\n      }, {\n        op: center,\n        field: continuousFieldName,\n        as: `center_${continuousFieldName}`\n      }];\n      postAggregateCalculates = [{\n        calculate: `datum[\"center_${continuousFieldName}\"] + datum[\"extent_${continuousFieldName}\"]`,\n        as: `upper_${continuousFieldName}`\n      }, {\n        calculate: `datum[\"center_${continuousFieldName}\"] - datum[\"extent_${continuousFieldName}\"]`,\n        as: `lower_${continuousFieldName}`\n      }];\n      tooltipSummary = [{\n        fieldPrefix: 'center_',\n        titlePrefix: titleCase(center)\n      }, {\n        fieldPrefix: 'upper_',\n        titlePrefix: getTitlePrefix(center, extent, '+')\n      }, {\n        fieldPrefix: 'lower_',\n        titlePrefix: getTitlePrefix(center, extent, '-')\n      }];\n      tooltipTitleWithFieldName = true;\n    } else {\n      let centerOp;\n      let lowerExtentOp;\n      let upperExtentOp;\n\n      if (extent === 'ci') {\n        centerOp = 'mean';\n        lowerExtentOp = 'ci0';\n        upperExtentOp = 'ci1';\n      } else {\n        centerOp = 'median';\n        lowerExtentOp = 'q1';\n        upperExtentOp = 'q3';\n      }\n\n      errorBarSpecificAggregate = [{\n        op: lowerExtentOp,\n        field: continuousFieldName,\n        as: `lower_${continuousFieldName}`\n      }, {\n        op: upperExtentOp,\n        field: continuousFieldName,\n        as: `upper_${continuousFieldName}`\n      }, {\n        op: centerOp,\n        field: continuousFieldName,\n        as: `center_${continuousFieldName}`\n      }];\n      tooltipSummary = [{\n        fieldPrefix: 'upper_',\n        titlePrefix: title({\n          field: continuousFieldName,\n          aggregate: upperExtentOp,\n          type: 'quantitative'\n        }, config, {\n          allowDisabling: false\n        })\n      }, {\n        fieldPrefix: 'lower_',\n        titlePrefix: title({\n          field: continuousFieldName,\n          aggregate: lowerExtentOp,\n          type: 'quantitative'\n        }, config, {\n          allowDisabling: false\n        })\n      }, {\n        fieldPrefix: 'center_',\n        titlePrefix: title({\n          field: continuousFieldName,\n          aggregate: centerOp,\n          type: 'quantitative'\n        }, config, {\n          allowDisabling: false\n        })\n      }];\n    }\n  } else {\n    if (markDef.center || markDef.extent) {\n      log.warn(log.message.errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));\n    }\n\n    if (inputType === 'aggregated-upper-lower') {\n      tooltipSummary = [];\n      postAggregateCalculates = [{\n        calculate: `datum[\"${continuousAxisChannelDef2.field}\"]`,\n        as: `upper_${continuousFieldName}`\n      }, {\n        calculate: `datum[\"${continuousFieldName}\"]`,\n        as: `lower_${continuousFieldName}`\n      }];\n    } else if (inputType === 'aggregated-error') {\n      tooltipSummary = [{\n        fieldPrefix: '',\n        titlePrefix: continuousFieldName\n      }];\n      postAggregateCalculates = [{\n        calculate: `datum[\"${continuousFieldName}\"] + datum[\"${continuousAxisChannelDefError.field}\"]`,\n        as: `upper_${continuousFieldName}`\n      }];\n\n      if (continuousAxisChannelDefError2) {\n        postAggregateCalculates.push({\n          calculate: `datum[\"${continuousFieldName}\"] + datum[\"${continuousAxisChannelDefError2.field}\"]`,\n          as: `lower_${continuousFieldName}`\n        });\n      } else {\n        postAggregateCalculates.push({\n          calculate: `datum[\"${continuousFieldName}\"] - datum[\"${continuousAxisChannelDefError.field}\"]`,\n          as: `lower_${continuousFieldName}`\n        });\n      }\n    }\n\n    for (const postAggregateCalculate of postAggregateCalculates) {\n      tooltipSummary.push({\n        fieldPrefix: postAggregateCalculate.as.substring(0, 6),\n        titlePrefix: replaceAll(replaceAll(postAggregateCalculate.calculate, 'datum[\"', ''), '\"]', '')\n      });\n    }\n  }\n\n  return {\n    postAggregateCalculates,\n    errorBarSpecificAggregate,\n    tooltipSummary,\n    tooltipTitleWithFieldName\n  };\n}\n\nfunction getTitlePrefix(center, extent, operation) {\n  return `${titleCase(center)} ${operation} ${extent}`;\n}","map":{"version":3,"mappings":"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","names":["isContinuousFieldOrDatumDef","isFieldOrDatumDef","title","extractTransformsFromEncoding","normalizeEncoding","log","isMarkDef","replaceAll","titleCase","CompositeMarkNormalizer","compositeMarkContinuousAxis","compositeMarkOrient","getCompositeMarkTooltip","makeCompositeAggregatePartFactory","ERRORBAR","ERRORBAR_PARTS","errorBarNormalizer","normalizeErrorBar","spec","config","encoding","transform","continuousAxisChannelDef","continuousAxis","encodingWithoutContinuousAxis","ticksOrient","markDef","outerSpec","tooltipEncoding","errorBarParams","makeErrorBarPart","errorbar","thickness","size","tick","type","orient","aria","undefined","layer","partName","mark","positionPrefix","extraEncoding","ariaRoleDescription","endPositionPrefix","length","Object","errorBarOrientAndInputType","compositeMark","errorBarIsInputTypeRaw","inputType","isTypeAggregatedUpperLower","errorBarIsInputTypeAggregatedUpperLower","isTypeAggregatedError","errorBarIsInputTypeAggregatedError","x","y","Error","x2","y2","xError","xError2","yError","yError2","params","projection","_p","warn","message","selectionNotSupported","continuousAxisChannelDef2","continuousAxisChannelDefError","continuousAxisChannelDefError2","errorBarSpecificAggregate","postAggregateCalculates","tooltipSummary","tooltipTitleWithFieldName","errorBarAggregationAndCalculation","_b","_c","oldContinuousAxisChannelDef","_d","oldContinuousAxisChannelDef2","_e","oldContinuousAxisChannelDefError","_f","oldContinuousAxisChannelDefError2","oldEncodingWithoutContinuousAxis","bins","timeUnits","aggregate","oldAggregate","groupby","oldGroupBy","_a","continuousFieldName","field","center","extent","errorBarCenterIsUsedWithWrongExtent","op","as","calculate","fieldPrefix","titlePrefix","getTitlePrefix","centerOp","lowerExtentOp","upperExtentOp","allowDisabling","errorBarCenterAndExtentAreNotNeeded","push","postAggregateCalculate","substring","operation"],"sources":["/Users/darcyroche/Documents/cathracha is tíreolaíocht/public life observations/plo-viz-app/node_modules/vega-lite/src/compositemark/errorbar.ts"],"sourcesContent":["import {AggregateOp, Orientation, SignalRef, Text} from 'vega';\nimport {PositionChannel} from '../channel';\nimport {\n  Field,\n  isContinuousFieldOrDatumDef,\n  isFieldOrDatumDef,\n  PositionFieldDef,\n  SecondaryFieldDef,\n  title,\n  ValueDef\n} from '../channeldef';\nimport {Config} from '../config';\nimport {Data} from '../data';\nimport {Encoding, extractTransformsFromEncoding, normalizeEncoding} from '../encoding';\nimport {ExprRef} from '../expr';\nimport * as log from '../log';\nimport {isMarkDef, MarkDef} from '../mark';\nimport {NormalizerParams} from '../normalize';\nimport {GenericUnitSpec, NormalizedLayerSpec} from '../spec';\nimport {Step} from '../spec/base';\nimport {NormalizedUnitSpec} from '../spec/unit';\nimport {TitleParams} from '../title';\nimport {AggregatedFieldDef, CalculateTransform, Transform} from '../transform';\nimport {replaceAll, titleCase} from '../util';\nimport {CompositeMarkNormalizer} from './base';\nimport {\n  compositeMarkContinuousAxis,\n  compositeMarkOrient,\n  CompositeMarkTooltipSummary,\n  GenericCompositeMarkDef,\n  getCompositeMarkTooltip,\n  makeCompositeAggregatePartFactory,\n  PartsMixins\n} from './common';\nimport {ErrorBand, ErrorBandDef} from './errorband';\n\nexport const ERRORBAR = 'errorbar' as const;\nexport type ErrorBar = typeof ERRORBAR;\n\nexport type ErrorBarExtent = 'ci' | 'iqr' | 'stderr' | 'stdev';\nexport type ErrorBarCenter = 'mean' | 'median';\n\nexport type ErrorInputType = 'raw' | 'aggregated-upper-lower' | 'aggregated-error';\n\nexport const ERRORBAR_PARTS = ['ticks', 'rule'] as const;\n\nexport type ErrorBarPart = typeof ERRORBAR_PARTS[number];\n\nexport interface ErrorExtraEncoding<F extends Field> {\n  /**\n   * Error value of x coordinates for error specified `\"errorbar\"` and `\"errorband\"`.\n   */\n  xError?: SecondaryFieldDef<F> | ValueDef<number>;\n\n  /**\n   * Secondary error value of x coordinates for error specified `\"errorbar\"` and `\"errorband\"`.\n   */\n  // `xError2` cannot have type as it should have the same type as `xError`\n  xError2?: SecondaryFieldDef<F> | ValueDef<number>;\n\n  /**\n   * Error value of y coordinates for error specified `\"errorbar\"` and `\"errorband\"`.\n   */\n  yError?: SecondaryFieldDef<F> | ValueDef<number>;\n\n  /**\n   * Secondary error value of y coordinates for error specified `\"errorbar\"` and `\"errorband\"`.\n   */\n  // `yError2` cannot have type as it should have the same type as `yError`\n  yError2?: SecondaryFieldDef<F> | ValueDef<number>;\n}\n\nexport type ErrorEncoding<F extends Field> = Pick<Encoding<F>, PositionChannel | 'color' | 'detail' | 'opacity'> &\n  ErrorExtraEncoding<F>;\n\nexport type ErrorBarPartsMixins = PartsMixins<ErrorBarPart>;\n\nexport interface ErrorBarConfig extends ErrorBarPartsMixins {\n  /** Size of the ticks of an error bar */\n  size?: number;\n\n  /** Thickness of the ticks and the bar of an error bar */\n  thickness?: number;\n\n  /**\n   * The center of the errorbar. Available options include:\n   * - `\"mean\"`: the mean of the data points.\n   * - `\"median\"`: the median of the data points.\n   *\n   * __Default value:__ `\"mean\"`.\n   * @hidden\n   */\n\n  // center is not needed right now but will be added back to the schema if future features require it.\n  center?: ErrorBarCenter;\n\n  /**\n   * The extent of the rule. Available options include:\n   * - `\"ci\"`: Extend the rule to the confidence interval of the mean.\n   * - `\"stderr\"`: The size of rule are set to the value of standard error, extending from the mean.\n   * - `\"stdev\"`: The size of rule are set to the value of standard deviation, extending from the mean.\n   * - `\"iqr\"`: Extend the rule to the q1 and q3.\n   *\n   * __Default value:__ `\"stderr\"`.\n   */\n  extent?: ErrorBarExtent;\n}\n\nexport type ErrorBarDef = GenericCompositeMarkDef<ErrorBar> &\n  ErrorBarConfig & {\n    /**\n     * Orientation of the error bar. This is normally automatically determined, but can be specified when the orientation is ambiguous and cannot be automatically determined.\n     */\n    orient?: Orientation;\n  };\n\nexport interface ErrorBarConfigMixins {\n  /**\n   * ErrorBar Config\n   */\n  errorbar?: ErrorBarConfig;\n}\n\nexport const errorBarNormalizer = new CompositeMarkNormalizer(ERRORBAR, normalizeErrorBar);\n\nexport function normalizeErrorBar(\n  spec: GenericUnitSpec<ErrorEncoding<string>, ErrorBar | ErrorBarDef>,\n  {config}: NormalizerParams\n): NormalizedLayerSpec | NormalizedUnitSpec {\n  // Need to initEncoding first so we can infer type\n  spec = {\n    ...spec,\n    encoding: normalizeEncoding(spec.encoding, config)\n  };\n\n  const {\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    ticksOrient,\n    markDef,\n    outerSpec,\n    tooltipEncoding\n  } = errorBarParams(spec, ERRORBAR, config);\n  delete encodingWithoutContinuousAxis['size'];\n\n  const makeErrorBarPart = makeCompositeAggregatePartFactory<ErrorBarPartsMixins>(\n    markDef,\n    continuousAxis,\n    continuousAxisChannelDef,\n    encodingWithoutContinuousAxis,\n    config.errorbar\n  );\n\n  const thickness = markDef.thickness;\n  const size = markDef.size;\n  const tick: MarkDef = {\n    type: 'tick',\n    orient: ticksOrient,\n    aria: false,\n    ...(thickness !== undefined ? {thickness} : {}),\n    ...(size !== undefined ? {size} : {})\n  };\n\n  const layer = [\n    ...makeErrorBarPart({\n      partName: 'ticks',\n      mark: tick,\n      positionPrefix: 'lower',\n      extraEncoding: tooltipEncoding\n    }),\n    ...makeErrorBarPart({\n      partName: 'ticks',\n      mark: tick,\n      positionPrefix: 'upper',\n      extraEncoding: tooltipEncoding\n    }),\n    ...makeErrorBarPart({\n      partName: 'rule',\n      mark: {\n        type: 'rule',\n        ariaRoleDescription: 'errorbar',\n        ...(thickness !== undefined ? {size: thickness} : {})\n      },\n      positionPrefix: 'lower',\n      endPositionPrefix: 'upper',\n      extraEncoding: tooltipEncoding\n    })\n  ];\n\n  return {\n    ...outerSpec,\n    transform,\n    ...(layer.length > 1 ? {layer} : {...layer[0]})\n  };\n}\n\nfunction errorBarOrientAndInputType(\n  spec: GenericUnitSpec<ErrorEncoding<string>, ErrorBar | ErrorBand | ErrorBarDef | ErrorBandDef>,\n  compositeMark: ErrorBar | ErrorBand\n): {\n  orient: Orientation;\n  inputType: ErrorInputType;\n} {\n  const {encoding} = spec;\n\n  if (errorBarIsInputTypeRaw(encoding)) {\n    return {\n      orient: compositeMarkOrient(spec, compositeMark),\n      inputType: 'raw'\n    };\n  }\n\n  const isTypeAggregatedUpperLower: boolean = errorBarIsInputTypeAggregatedUpperLower(encoding);\n  const isTypeAggregatedError: boolean = errorBarIsInputTypeAggregatedError(encoding);\n  const x = encoding.x;\n  const y = encoding.y;\n\n  if (isTypeAggregatedUpperLower) {\n    // type is aggregated-upper-lower\n\n    if (isTypeAggregatedError) {\n      throw new Error(`${compositeMark} cannot be both type aggregated-upper-lower and aggregated-error`);\n    }\n\n    const x2 = encoding.x2;\n    const y2 = encoding.y2;\n\n    if (isFieldOrDatumDef(x2) && isFieldOrDatumDef(y2)) {\n      // having both x, x2 and y, y2\n      throw new Error(`${compositeMark} cannot have both x2 and y2`);\n    } else if (isFieldOrDatumDef(x2)) {\n      if (isContinuousFieldOrDatumDef(x)) {\n        // having x, x2 quantitative and field y, y2 are not specified\n        return {orient: 'horizontal', inputType: 'aggregated-upper-lower'};\n      } else {\n        // having x, x2 that are not both quantitative\n        throw new Error(`Both x and x2 have to be quantitative in ${compositeMark}`);\n      }\n    } else if (isFieldOrDatumDef(y2)) {\n      // y2 is a FieldDef\n      if (isContinuousFieldOrDatumDef(y)) {\n        // having y, y2 quantitative and field x, x2 are not specified\n        return {orient: 'vertical', inputType: 'aggregated-upper-lower'};\n      } else {\n        // having y, y2 that are not both quantitative\n        throw new Error(`Both y and y2 have to be quantitative in ${compositeMark}`);\n      }\n    }\n    throw new Error('No ranged axis');\n  } else {\n    // type is aggregated-error\n\n    const xError = encoding.xError;\n    const xError2 = encoding.xError2;\n    const yError = encoding.yError;\n    const yError2 = encoding.yError2;\n\n    if (isFieldOrDatumDef(xError2) && !isFieldOrDatumDef(xError)) {\n      // having xError2 without xError\n      throw new Error(`${compositeMark} cannot have xError2 without xError`);\n    }\n\n    if (isFieldOrDatumDef(yError2) && !isFieldOrDatumDef(yError)) {\n      // having yError2 without yError\n      throw new Error(`${compositeMark} cannot have yError2 without yError`);\n    }\n\n    if (isFieldOrDatumDef(xError) && isFieldOrDatumDef(yError)) {\n      // having both xError and yError\n      throw new Error(`${compositeMark} cannot have both xError and yError with both are quantiative`);\n    } else if (isFieldOrDatumDef(xError)) {\n      if (isContinuousFieldOrDatumDef(x)) {\n        // having x and xError that are all quantitative\n        return {orient: 'horizontal', inputType: 'aggregated-error'};\n      } else {\n        // having x, xError, and xError2 that are not all quantitative\n        throw new Error('All x, xError, and xError2 (if exist) have to be quantitative');\n      }\n    } else if (isFieldOrDatumDef(yError)) {\n      if (isContinuousFieldOrDatumDef(y)) {\n        // having y and yError that are all quantitative\n        return {orient: 'vertical', inputType: 'aggregated-error'};\n      } else {\n        // having y, yError, and yError2 that are not all quantitative\n        throw new Error('All y, yError, and yError2 (if exist) have to be quantitative');\n      }\n    }\n    throw new Error('No ranged axis');\n  }\n}\n\nfunction errorBarIsInputTypeRaw(encoding: ErrorEncoding<string>): boolean {\n  return (\n    (isFieldOrDatumDef(encoding.x) || isFieldOrDatumDef(encoding.y)) &&\n    !isFieldOrDatumDef(encoding.x2) &&\n    !isFieldOrDatumDef(encoding.y2) &&\n    !isFieldOrDatumDef(encoding.xError) &&\n    !isFieldOrDatumDef(encoding.xError2) &&\n    !isFieldOrDatumDef(encoding.yError) &&\n    !isFieldOrDatumDef(encoding.yError2)\n  );\n}\n\nfunction errorBarIsInputTypeAggregatedUpperLower(encoding: ErrorEncoding<string>): boolean {\n  return isFieldOrDatumDef(encoding.x2) || isFieldOrDatumDef(encoding.y2);\n}\n\nfunction errorBarIsInputTypeAggregatedError(encoding: ErrorEncoding<string>): boolean {\n  return (\n    isFieldOrDatumDef(encoding.xError) ||\n    isFieldOrDatumDef(encoding.xError2) ||\n    isFieldOrDatumDef(encoding.yError) ||\n    isFieldOrDatumDef(encoding.yError2)\n  );\n}\n\nexport function errorBarParams<\n  M extends ErrorBar | ErrorBand,\n  MD extends GenericCompositeMarkDef<M> & (ErrorBarDef | ErrorBandDef)\n>(\n  spec: GenericUnitSpec<ErrorEncoding<string>, M | MD>,\n  compositeMark: M,\n  config: Config\n): {\n  transform: Transform[];\n  groupby: string[];\n  continuousAxisChannelDef: PositionFieldDef<string>;\n  continuousAxis: 'x' | 'y';\n  encodingWithoutContinuousAxis: ErrorEncoding<string>;\n  ticksOrient: Orientation;\n  markDef: MD;\n  outerSpec: {\n    data?: Data;\n    title?: Text | TitleParams<ExprRef | SignalRef>;\n    name?: string;\n    description?: string;\n    transform?: Transform[];\n    width?: number | 'container' | Step;\n    height?: number | 'container' | Step;\n  };\n  tooltipEncoding: ErrorEncoding<string>;\n} {\n  // TODO: use selection\n  const {mark, encoding, params, projection: _p, ...outerSpec} = spec;\n  const markDef: MD = isMarkDef(mark) ? mark : ({type: mark} as MD);\n\n  // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n  if (params) {\n    log.warn(log.message.selectionNotSupported(compositeMark));\n  }\n\n  const {orient, inputType} = errorBarOrientAndInputType(spec, compositeMark);\n  const {\n    continuousAxisChannelDef,\n    continuousAxisChannelDef2,\n    continuousAxisChannelDefError,\n    continuousAxisChannelDefError2,\n    continuousAxis\n  } = compositeMarkContinuousAxis(spec, orient, compositeMark);\n\n  const {errorBarSpecificAggregate, postAggregateCalculates, tooltipSummary, tooltipTitleWithFieldName} =\n    errorBarAggregationAndCalculation(\n      markDef,\n      continuousAxisChannelDef,\n      continuousAxisChannelDef2,\n      continuousAxisChannelDefError,\n      continuousAxisChannelDefError2,\n      inputType,\n      compositeMark,\n      config\n    );\n\n  const {\n    [continuousAxis]: oldContinuousAxisChannelDef,\n    [continuousAxis === 'x' ? 'x2' : 'y2']: oldContinuousAxisChannelDef2,\n    [continuousAxis === 'x' ? 'xError' : 'yError']: oldContinuousAxisChannelDefError,\n    [continuousAxis === 'x' ? 'xError2' : 'yError2']: oldContinuousAxisChannelDefError2,\n    ...oldEncodingWithoutContinuousAxis\n  } = encoding;\n\n  const {\n    bins,\n    timeUnits,\n    aggregate: oldAggregate,\n    groupby: oldGroupBy,\n    encoding: encodingWithoutContinuousAxis\n  } = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config);\n\n  const aggregate: AggregatedFieldDef[] = [...oldAggregate, ...errorBarSpecificAggregate];\n  const groupby: string[] = inputType !== 'raw' ? [] : oldGroupBy;\n\n  const tooltipEncoding: ErrorEncoding<string> = getCompositeMarkTooltip(\n    tooltipSummary,\n    continuousAxisChannelDef,\n    encodingWithoutContinuousAxis,\n    tooltipTitleWithFieldName\n  );\n\n  return {\n    transform: [\n      ...(outerSpec.transform ?? []),\n      ...bins,\n      ...timeUnits,\n      ...(aggregate.length === 0 ? [] : [{aggregate, groupby}]),\n      ...postAggregateCalculates\n    ],\n    groupby,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    ticksOrient: orient === 'vertical' ? 'horizontal' : 'vertical',\n    markDef,\n    outerSpec,\n    tooltipEncoding\n  };\n}\n\nfunction errorBarAggregationAndCalculation<\n  M extends ErrorBar | ErrorBand,\n  MD extends GenericCompositeMarkDef<M> & (ErrorBarDef | ErrorBandDef)\n>(\n  markDef: MD,\n  continuousAxisChannelDef: PositionFieldDef<string>,\n  continuousAxisChannelDef2: SecondaryFieldDef<string>,\n  continuousAxisChannelDefError: SecondaryFieldDef<string>,\n  continuousAxisChannelDefError2: SecondaryFieldDef<string>,\n  inputType: ErrorInputType,\n  compositeMark: M,\n  config: Config\n): {\n  postAggregateCalculates: CalculateTransform[];\n  errorBarSpecificAggregate: AggregatedFieldDef[];\n  tooltipSummary: CompositeMarkTooltipSummary[];\n  tooltipTitleWithFieldName: boolean;\n} {\n  let errorBarSpecificAggregate: AggregatedFieldDef[] = [];\n  let postAggregateCalculates: CalculateTransform[] = [];\n  const continuousFieldName: string = continuousAxisChannelDef.field;\n\n  let tooltipSummary: CompositeMarkTooltipSummary[];\n  let tooltipTitleWithFieldName = false;\n\n  if (inputType === 'raw') {\n    const center: ErrorBarCenter = markDef.center\n      ? markDef.center\n      : markDef.extent\n      ? markDef.extent === 'iqr'\n        ? 'median'\n        : 'mean'\n      : config.errorbar.center;\n    const extent: ErrorBarExtent = markDef.extent ? markDef.extent : center === 'mean' ? 'stderr' : 'iqr';\n\n    if ((center === 'median') !== (extent === 'iqr')) {\n      log.warn(log.message.errorBarCenterIsUsedWithWrongExtent(center, extent, compositeMark));\n    }\n\n    if (extent === 'stderr' || extent === 'stdev') {\n      errorBarSpecificAggregate = [\n        {op: extent, field: continuousFieldName, as: `extent_${continuousFieldName}`},\n        {op: center, field: continuousFieldName, as: `center_${continuousFieldName}`}\n      ];\n\n      postAggregateCalculates = [\n        {\n          calculate: `datum[\"center_${continuousFieldName}\"] + datum[\"extent_${continuousFieldName}\"]`,\n          as: `upper_${continuousFieldName}`\n        },\n        {\n          calculate: `datum[\"center_${continuousFieldName}\"] - datum[\"extent_${continuousFieldName}\"]`,\n          as: `lower_${continuousFieldName}`\n        }\n      ];\n\n      tooltipSummary = [\n        {fieldPrefix: 'center_', titlePrefix: titleCase(center)},\n        {fieldPrefix: 'upper_', titlePrefix: getTitlePrefix(center, extent, '+')},\n        {fieldPrefix: 'lower_', titlePrefix: getTitlePrefix(center, extent, '-')}\n      ];\n      tooltipTitleWithFieldName = true;\n    } else {\n      let centerOp: AggregateOp;\n      let lowerExtentOp: AggregateOp;\n      let upperExtentOp: AggregateOp;\n      if (extent === 'ci') {\n        centerOp = 'mean';\n        lowerExtentOp = 'ci0';\n        upperExtentOp = 'ci1';\n      } else {\n        centerOp = 'median';\n        lowerExtentOp = 'q1';\n        upperExtentOp = 'q3';\n      }\n\n      errorBarSpecificAggregate = [\n        {op: lowerExtentOp, field: continuousFieldName, as: `lower_${continuousFieldName}`},\n        {op: upperExtentOp, field: continuousFieldName, as: `upper_${continuousFieldName}`},\n        {op: centerOp, field: continuousFieldName, as: `center_${continuousFieldName}`}\n      ];\n\n      tooltipSummary = [\n        {\n          fieldPrefix: 'upper_',\n          titlePrefix: title({field: continuousFieldName, aggregate: upperExtentOp, type: 'quantitative'}, config, {\n            allowDisabling: false\n          })\n        },\n        {\n          fieldPrefix: 'lower_',\n          titlePrefix: title({field: continuousFieldName, aggregate: lowerExtentOp, type: 'quantitative'}, config, {\n            allowDisabling: false\n          })\n        },\n        {\n          fieldPrefix: 'center_',\n          titlePrefix: title({field: continuousFieldName, aggregate: centerOp, type: 'quantitative'}, config, {\n            allowDisabling: false\n          })\n        }\n      ];\n    }\n  } else {\n    if (markDef.center || markDef.extent) {\n      log.warn(log.message.errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));\n    }\n\n    if (inputType === 'aggregated-upper-lower') {\n      tooltipSummary = [];\n      postAggregateCalculates = [\n        {calculate: `datum[\"${continuousAxisChannelDef2.field}\"]`, as: `upper_${continuousFieldName}`},\n        {calculate: `datum[\"${continuousFieldName}\"]`, as: `lower_${continuousFieldName}`}\n      ];\n    } else if (inputType === 'aggregated-error') {\n      tooltipSummary = [{fieldPrefix: '', titlePrefix: continuousFieldName}];\n      postAggregateCalculates = [\n        {\n          calculate: `datum[\"${continuousFieldName}\"] + datum[\"${continuousAxisChannelDefError.field}\"]`,\n          as: `upper_${continuousFieldName}`\n        }\n      ];\n\n      if (continuousAxisChannelDefError2) {\n        postAggregateCalculates.push({\n          calculate: `datum[\"${continuousFieldName}\"] + datum[\"${continuousAxisChannelDefError2.field}\"]`,\n          as: `lower_${continuousFieldName}`\n        });\n      } else {\n        postAggregateCalculates.push({\n          calculate: `datum[\"${continuousFieldName}\"] - datum[\"${continuousAxisChannelDefError.field}\"]`,\n          as: `lower_${continuousFieldName}`\n        });\n      }\n    }\n\n    for (const postAggregateCalculate of postAggregateCalculates) {\n      tooltipSummary.push({\n        fieldPrefix: postAggregateCalculate.as.substring(0, 6),\n        titlePrefix: replaceAll(replaceAll(postAggregateCalculate.calculate, 'datum[\"', ''), '\"]', '')\n      });\n    }\n  }\n  return {postAggregateCalculates, errorBarSpecificAggregate, tooltipSummary, tooltipTitleWithFieldName};\n}\n\nfunction getTitlePrefix(center: ErrorBarCenter, extent: ErrorBarExtent, operation: '+' | '-'): string {\n  return `${titleCase(center)} ${operation} ${extent}`;\n}\n"]},"metadata":{},"sourceType":"module"}